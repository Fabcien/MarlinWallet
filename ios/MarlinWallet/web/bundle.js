(()=>{var __webpack_modules__={81:g=>{"use strict";g.exports=JSON.parse('["的","一","是","在","不","了","有","和","人","這","中","大","為","上","個","國","我","以","要","他","時","來","用","們","生","到","作","地","於","出","就","分","對","成","會","可","主","發","年","動","同","工","也","能","下","過","子","說","產","種","面","而","方","後","多","定","行","學","法","所","民","得","經","十","三","之","進","著","等","部","度","家","電","力","裡","如","水","化","高","自","二","理","起","小","物","現","實","加","量","都","兩","體","制","機","當","使","點","從","業","本","去","把","性","好","應","開","它","合","還","因","由","其","些","然","前","外","天","政","四","日","那","社","義","事","平","形","相","全","表","間","樣","與","關","各","重","新","線","內","數","正","心","反","你","明","看","原","又","麼","利","比","或","但","質","氣","第","向","道","命","此","變","條","只","沒","結","解","問","意","建","月","公","無","系","軍","很","情","者","最","立","代","想","已","通","並","提","直","題","黨","程","展","五","果","料","象","員","革","位","入","常","文","總","次","品","式","活","設","及","管","特","件","長","求","老","頭","基","資","邊","流","路","級","少","圖","山","統","接","知","較","將","組","見","計","別","她","手","角","期","根","論","運","農","指","幾","九","區","強","放","決","西","被","幹","做","必","戰","先","回","則","任","取","據","處","隊","南","給","色","光","門","即","保","治","北","造","百","規","熱","領","七","海","口","東","導","器","壓","志","世","金","增","爭","濟","階","油","思","術","極","交","受","聯","什","認","六","共","權","收","證","改","清","美","再","採","轉","更","單","風","切","打","白","教","速","花","帶","安","場","身","車","例","真","務","具","萬","每","目","至","達","走","積","示","議","聲","報","鬥","完","類","八","離","華","名","確","才","科","張","信","馬","節","話","米","整","空","元","況","今","集","溫","傳","土","許","步","群","廣","石","記","需","段","研","界","拉","林","律","叫","且","究","觀","越","織","裝","影","算","低","持","音","眾","書","布","复","容","兒","須","際","商","非","驗","連","斷","深","難","近","礦","千","週","委","素","技","備","半","辦","青","省","列","習","響","約","支","般","史","感","勞","便","團","往","酸","歷","市","克","何","除","消","構","府","稱","太","準","精","值","號","率","族","維","劃","選","標","寫","存","候","毛","親","快","效","斯","院","查","江","型","眼","王","按","格","養","易","置","派","層","片","始","卻","專","狀","育","廠","京","識","適","屬","圓","包","火","住","調","滿","縣","局","照","參","紅","細","引","聽","該","鐵","價","嚴","首","底","液","官","德","隨","病","蘇","失","爾","死","講","配","女","黃","推","顯","談","罪","神","藝","呢","席","含","企","望","密","批","營","項","防","舉","球","英","氧","勢","告","李","台","落","木","幫","輪","破","亞","師","圍","注","遠","字","材","排","供","河","態","封","另","施","減","樹","溶","怎","止","案","言","士","均","武","固","葉","魚","波","視","僅","費","緊","愛","左","章","早","朝","害","續","輕","服","試","食","充","兵","源","判","護","司","足","某","練","差","致","板","田","降","黑","犯","負","擊","范","繼","興","似","餘","堅","曲","輸","修","故","城","夫","夠","送","筆","船","佔","右","財","吃","富","春","職","覺","漢","畫","功","巴","跟","雖","雜","飛","檢","吸","助","昇","陽","互","初","創","抗","考","投","壞","策","古","徑","換","未","跑","留","鋼","曾","端","責","站","簡","述","錢","副","盡","帝","射","草","衝","承","獨","令","限","阿","宣","環","雙","請","超","微","讓","控","州","良","軸","找","否","紀","益","依","優","頂","礎","載","倒","房","突","坐","粉","敵","略","客","袁","冷","勝","絕","析","塊","劑","測","絲","協","訴","念","陳","仍","羅","鹽","友","洋","錯","苦","夜","刑","移","頻","逐","靠","混","母","短","皮","終","聚","汽","村","雲","哪","既","距","衛","停","烈","央","察","燒","迅","境","若","印","洲","刻","括","激","孔","搞","甚","室","待","核","校","散","侵","吧","甲","遊","久","菜","味","舊","模","湖","貨","損","預","阻","毫","普","穩","乙","媽","植","息","擴","銀","語","揮","酒","守","拿","序","紙","醫","缺","雨","嗎","針","劉","啊","急","唱","誤","訓","願","審","附","獲","茶","鮮","糧","斤","孩","脫","硫","肥","善","龍","演","父","漸","血","歡","械","掌","歌","沙","剛","攻","謂","盾","討","晚","粒","亂","燃","矛","乎","殺","藥","寧","魯","貴","鐘","煤","讀","班","伯","香","介","迫","句","豐","培","握","蘭","擔","弦","蛋","沉","假","穿","執","答","樂","誰","順","煙","縮","徵","臉","喜","松","腳","困","異","免","背","星","福","買","染","井","概","慢","怕","磁","倍","祖","皇","促","靜","補","評","翻","肉","踐","尼","衣","寬","揚","棉","希","傷","操","垂","秋","宜","氫","套","督","振","架","亮","末","憲","慶","編","牛","觸","映","雷","銷","詩","座","居","抓","裂","胞","呼","娘","景","威","綠","晶","厚","盟","衡","雞","孫","延","危","膠","屋","鄉","臨","陸","顧","掉","呀","燈","歲","措","束","耐","劇","玉","趙","跳","哥","季","課","凱","胡","額","款","紹","卷","齊","偉","蒸","殖","永","宗","苗","川","爐","岩","弱","零","楊","奏","沿","露","桿","探","滑","鎮","飯","濃","航","懷","趕","庫","奪","伊","靈","稅","途","滅","賽","歸","召","鼓","播","盤","裁","險","康","唯","錄","菌","純","借","糖","蓋","橫","符","私","努","堂","域","槍","潤","幅","哈","竟","熟","蟲","澤","腦","壤","碳","歐","遍","側","寨","敢","徹","慮","斜","薄","庭","納","彈","飼","伸","折","麥","濕","暗","荷","瓦","塞","床","築","惡","戶","訪","塔","奇","透","梁","刀","旋","跡","卡","氯","遇","份","毒","泥","退","洗","擺","灰","彩","賣","耗","夏","擇","忙","銅","獻","硬","予","繁","圈","雪","函","亦","抽","篇","陣","陰","丁","尺","追","堆","雄","迎","泛","爸","樓","避","謀","噸","野","豬","旗","累","偏","典","館","索","秦","脂","潮","爺","豆","忽","托","驚","塑","遺","愈","朱","替","纖","粗","傾","尚","痛","楚","謝","奮","購","磨","君","池","旁","碎","骨","監","捕","弟","暴","割","貫","殊","釋","詞","亡","壁","頓","寶","午","塵","聞","揭","炮","殘","冬","橋","婦","警","綜","招","吳","付","浮","遭","徐","您","搖","谷","贊","箱","隔","訂","男","吹","園","紛","唐","敗","宋","玻","巨","耕","坦","榮","閉","灣","鍵","凡","駐","鍋","救","恩","剝","凝","鹼","齒","截","煉","麻","紡","禁","廢","盛","版","緩","淨","睛","昌","婚","涉","筒","嘴","插","岸","朗","莊","街","藏","姑","貿","腐","奴","啦","慣","乘","夥","恢","勻","紗","扎","辯","耳","彪","臣","億","璃","抵","脈","秀","薩","俄","網","舞","店","噴","縱","寸","汗","掛","洪","賀","閃","柬","爆","烯","津","稻","牆","軟","勇","像","滾","厘","蒙","芳","肯","坡","柱","盪","腿","儀","旅","尾","軋","冰","貢","登","黎","削","鑽","勒","逃","障","氨","郭","峰","幣","港","伏","軌","畝","畢","擦","莫","刺","浪","秘","援","株","健","售","股","島","甘","泡","睡","童","鑄","湯","閥","休","匯","舍","牧","繞","炸","哲","磷","績","朋","淡","尖","啟","陷","柴","呈","徒","顏","淚","稍","忘","泵","藍","拖","洞","授","鏡","辛","壯","鋒","貧","虛","彎","摩","泰","幼","廷","尊","窗","綱","弄","隸","疑","氏","宮","姐","震","瑞","怪","尤","琴","循","描","膜","違","夾","腰","緣","珠","窮","森","枝","竹","溝","催","繩","憶","邦","剩","幸","漿","欄","擁","牙","貯","禮","濾","鈉","紋","罷","拍","咱","喊","袖","埃","勤","罰","焦","潛","伍","墨","欲","縫","姓","刊","飽","仿","獎","鋁","鬼","麗","跨","默","挖","鏈","掃","喝","袋","炭","污","幕","諸","弧","勵","梅","奶","潔","災","舟","鑑","苯","訟","抱","毀","懂","寒","智","埔","寄","屆","躍","渡","挑","丹","艱","貝","碰","拔","爹","戴","碼","夢","芽","熔","赤","漁","哭","敬","顆","奔","鉛","仲","虎","稀","妹","乏","珍","申","桌","遵","允","隆","螺","倉","魏","銳","曉","氮","兼","隱","礙","赫","撥","忠","肅","缸","牽","搶","博","巧","殼","兄","杜","訊","誠","碧","祥","柯","頁","巡","矩","悲","灌","齡","倫","票","尋","桂","鋪","聖","恐","恰","鄭","趣","抬","荒","騰","貼","柔","滴","猛","闊","輛","妻","填","撤","儲","簽","鬧","擾","紫","砂","遞","戲","吊","陶","伐","餵","療","瓶","婆","撫","臂","摸","忍","蝦","蠟","鄰","胸","鞏","擠","偶","棄","槽","勁","乳","鄧","吉","仁","爛","磚","租","烏","艦","伴","瓜","淺","丙","暫","燥","橡","柳","迷","暖","牌","秧","膽","詳","簧","踏","瓷","譜","呆","賓","糊","洛","輝","憤","競","隙","怒","粘","乃","緒","肩","籍","敏","塗","熙","皆","偵","懸","掘","享","糾","醒","狂","鎖","淀","恨","牲","霸","爬","賞","逆","玩","陵","祝","秒","浙","貌","役","彼","悉","鴨","趨","鳳","晨","畜","輩","秩","卵","署","梯","炎","灘","棋","驅","篩","峽","冒","啥","壽","譯","浸","泉","帽","遲","矽","疆","貸","漏","稿","冠","嫩","脅","芯","牢","叛","蝕","奧","鳴","嶺","羊","憑","串","塘","繪","酵","融","盆","錫","廟","籌","凍","輔","攝","襲","筋","拒","僚","旱","鉀","鳥","漆","沈","眉","疏","添","棒","穗","硝","韓","逼","扭","僑","涼","挺","碗","栽","炒","杯","患","餾","勸","豪","遼","勃","鴻","旦","吏","拜","狗","埋","輥","掩","飲","搬","罵","辭","勾","扣","估","蔣","絨","霧","丈","朵","姆","擬","宇","輯","陝","雕","償","蓄","崇","剪","倡","廳","咬","駛","薯","刷","斥","番","賦","奉","佛","澆","漫","曼","扇","鈣","桃","扶","仔","返","俗","虧","腔","鞋","棱","覆","框","悄","叔","撞","騙","勘","旺","沸","孤","吐","孟","渠","屈","疾","妙","惜","仰","狠","脹","諧","拋","黴","桑","崗","嘛","衰","盜","滲","臟","賴","湧","甜","曹","閱","肌","哩","厲","烴","緯","毅","昨","偽","症","煮","嘆","釘","搭","莖","籠","酷","偷","弓","錐","恆","傑","坑","鼻","翼","綸","敘","獄","逮","罐","絡","棚","抑","膨","蔬","寺","驟","穆","冶","枯","冊","屍","凸","紳","坯","犧","焰","轟","欣","晉","瘦","禦","錠","錦","喪","旬","鍛","壟","搜","撲","邀","亭","酯","邁","舒","脆","酶","閒","憂","酚","頑","羽","漲","卸","仗","陪","闢","懲","杭","姚","肚","捉","飄","漂","昆","欺","吾","郎","烷","汁","呵","飾","蕭","雅","郵","遷","燕","撒","姻","赴","宴","煩","債","帳","斑","鈴","旨","醇","董","餅","雛","姿","拌","傅","腹","妥","揉","賢","拆","歪","葡","胺","丟","浩","徽","昂","墊","擋","覽","貪","慰","繳","汪","慌","馮","諾","姜","誼","兇","劣","誣","耀","昏","躺","盈","騎","喬","溪","叢","盧","抹","悶","諮","刮","駕","纜","悟","摘","鉺","擲","頗","幻","柄","惠","慘","佳","仇","臘","窩","滌","劍","瞧","堡","潑","蔥","罩","霍","撈","胎","蒼","濱","倆","捅","湘","砍","霞","邵","萄","瘋","淮","遂","熊","糞","烘","宿","檔","戈","駁","嫂","裕","徙","箭","捐","腸","撐","曬","辨","殿","蓮","攤","攪","醬","屏","疫","哀","蔡","堵","沫","皺","暢","疊","閣","萊","敲","轄","鉤","痕","壩","巷","餓","禍","丘","玄","溜","曰","邏","彭","嘗","卿","妨","艇","吞","韋","怨","矮","歇"]')},102:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.sha512_256 = exports.SHA512_256 = exports.sha512_224 = exports.SHA512_224 = exports.sha384 = exports.SHA384 = exports.sha512 = exports.SHA512 = void 0;\n/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n * @deprecated\n */\nconst sha2_ts_1 = __webpack_require__(7076);\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA512 = sha2_ts_1.SHA512;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha512 = sha2_ts_1.sha512;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA384 = sha2_ts_1.SHA384;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha384 = sha2_ts_1.sha384;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA512_224 = sha2_ts_1.SHA512_224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha512_224 = sha2_ts_1.sha512_224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA512_256 = sha2_ts_1.SHA512_256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha512_256 = sha2_ts_1.sha512_256;\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLElBQVc7QUFDckM7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhNTEyLmpzPzI4MWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTUxMl8yNTYgPSBleHBvcnRzLlNIQTUxMl8yNTYgPSBleHBvcnRzLnNoYTUxMl8yMjQgPSBleHBvcnRzLlNIQTUxMl8yMjQgPSBleHBvcnRzLnNoYTM4NCA9IGV4cG9ydHMuU0hBMzg0ID0gZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLlNIQTUxMiA9IHZvaWQgMDtcbi8qKlxuICogU0hBMi01MTIgYS5rLmEuIHNoYTUxMiBhbmQgc2hhMzg0LiBJdCBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cbiAqXG4gKiBDaGVjayBvdXQgW1JGQyA0NjM0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2MzQpIGFuZFxuICogW3RoZSBwYXBlciBvbiB0cnVuY2F0ZWQgU0hBNTEyLzI1Nl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqIEBtb2R1bGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IHNoYTJfdHNfMSA9IHJlcXVpcmUoXCIuL3NoYTIuanNcIik7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLlNIQTUxMiA9IHNoYTJfdHNfMS5TSEE1MTI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLnNoYTUxMiA9IHNoYTJfdHNfMS5zaGE1MTI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLlNIQTM4NCA9IHNoYTJfdHNfMS5TSEEzODQ7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLnNoYTM4NCA9IHNoYTJfdHNfMS5zaGEzODQ7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLlNIQTUxMl8yMjQgPSBzaGEyX3RzXzEuU0hBNTEyXzIyNDtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuc2hhNTEyXzIyNCA9IHNoYTJfdHNfMS5zaGE1MTJfMjI0O1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0cy5TSEE1MTJfMjU2ID0gc2hhMl90c18xLlNIQTUxMl8yNTY7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLnNoYTUxMl8yNTYgPSBzaGEyX3RzXzEuc2hhNTEyXzI1Njtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTUxMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///102\n\n}')},157:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const Utils = __webpack_require__(6886)\nconst ECLevel = __webpack_require__(9953)\nconst BitBuffer = __webpack_require__(9899)\nconst BitMatrix = __webpack_require__(8820)\nconst AlignmentPattern = __webpack_require__(6421)\nconst FinderPattern = __webpack_require__(7756)\nconst MaskPattern = __webpack_require__(1332)\nconst ECCode = __webpack_require__(7518)\nconst ReedSolomonEncoder = __webpack_require__(4764)\nconst Version = __webpack_require__(1427)\nconst FormatInfo = __webpack_require__(4565)\nconst Mode = __webpack_require__(208)\nconst Segments = __webpack_require__(9801)\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  const size = matrix.size\n  const pos = FinderPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  const size = matrix.size\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  const pos = AlignmentPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  const size = matrix.size\n  const bits = Version.getEncodedBits(version)\n  let row, col, mod\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  let i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\nfunction setupData (matrix, data) {\n  const size = matrix.size\n  let inc = -1\n  let row = size - 1\n  let bitIndex = 7\n  let byteIndex = 0\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  const rs = new ReedSolomonEncoder(ecCount)\n\n  let offset = 0\n  const dcData = new Array(ecTotalBlocks)\n  const ecData = new Array(ecTotalBlocks)\n  let maxDataSize = 0\n  const buffer = new Uint8Array(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  const data = new Uint8Array(totalCodewords)\n  let index = 0\n  let i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  let segments\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  const moduleCount = Utils.getSymbolSize(version)\n  const modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  let errorCorrectionLevel = ECLevel.M\n  let version\n  let mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9jb3JlL3FyY29kZS5qcz9hYTYzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBFQ0xldmVsID0gcmVxdWlyZSgnLi9lcnJvci1jb3JyZWN0aW9uLWxldmVsJylcbmNvbnN0IEJpdEJ1ZmZlciA9IHJlcXVpcmUoJy4vYml0LWJ1ZmZlcicpXG5jb25zdCBCaXRNYXRyaXggPSByZXF1aXJlKCcuL2JpdC1tYXRyaXgnKVxuY29uc3QgQWxpZ25tZW50UGF0dGVybiA9IHJlcXVpcmUoJy4vYWxpZ25tZW50LXBhdHRlcm4nKVxuY29uc3QgRmluZGVyUGF0dGVybiA9IHJlcXVpcmUoJy4vZmluZGVyLXBhdHRlcm4nKVxuY29uc3QgTWFza1BhdHRlcm4gPSByZXF1aXJlKCcuL21hc2stcGF0dGVybicpXG5jb25zdCBFQ0NvZGUgPSByZXF1aXJlKCcuL2Vycm9yLWNvcnJlY3Rpb24tY29kZScpXG5jb25zdCBSZWVkU29sb21vbkVuY29kZXIgPSByZXF1aXJlKCcuL3JlZWQtc29sb21vbi1lbmNvZGVyJylcbmNvbnN0IFZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKVxuY29uc3QgRm9ybWF0SW5mbyA9IHJlcXVpcmUoJy4vZm9ybWF0LWluZm8nKVxuY29uc3QgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpXG5jb25zdCBTZWdtZW50cyA9IHJlcXVpcmUoJy4vc2VnbWVudHMnKVxuXG4vKipcbiAqIFFSQ29kZSBmb3IgSmF2YVNjcmlwdFxuICpcbiAqIG1vZGlmaWVkIGJ5IFJ5YW4gRGF5IGZvciBub2RlanMgc3VwcG9ydFxuICogQ29weXJpZ2h0IChjKSAyMDExIFJ5YW4gRGF5XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBRUkNvZGUgZm9yIEphdmFTY3JpcHRcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgS2F6dWhpa28gQXJhc2Vcbi8vXG4vLyBVUkw6IGh0dHA6Ly93d3cuZC1wcm9qZWN0LmNvbS9cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4vLyAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4vL1xuLy8gVGhlIHdvcmQgXCJRUiBDb2RlXCIgaXMgcmVnaXN0ZXJlZCB0cmFkZW1hcmsgb2Zcbi8vIERFTlNPIFdBVkUgSU5DT1JQT1JBVEVEXG4vLyAgIGh0dHA6Ly93d3cuZGVuc28td2F2ZS5jb20vcXJjb2RlL2ZhcXBhdGVudC1lLmh0bWxcbi8vXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKi9cblxuLyoqXG4gKiBBZGQgZmluZGVyIHBhdHRlcm5zIGJpdHMgdG8gbWF0cml4XG4gKlxuICogQHBhcmFtICB7Qml0TWF0cml4fSBtYXRyaXggIE1vZHVsZXMgbWF0cml4XG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG4gKi9cbmZ1bmN0aW9uIHNldHVwRmluZGVyUGF0dGVybiAobWF0cml4LCB2ZXJzaW9uKSB7XG4gIGNvbnN0IHNpemUgPSBtYXRyaXguc2l6ZVxuICBjb25zdCBwb3MgPSBGaW5kZXJQYXR0ZXJuLmdldFBvc2l0aW9ucyh2ZXJzaW9uKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gcG9zW2ldWzBdXG4gICAgY29uc3QgY29sID0gcG9zW2ldWzFdXG5cbiAgICBmb3IgKGxldCByID0gLTE7IHIgPD0gNzsgcisrKSB7XG4gICAgICBpZiAocm93ICsgciA8PSAtMSB8fCBzaXplIDw9IHJvdyArIHIpIGNvbnRpbnVlXG5cbiAgICAgIGZvciAobGV0IGMgPSAtMTsgYyA8PSA3OyBjKyspIHtcbiAgICAgICAgaWYgKGNvbCArIGMgPD0gLTEgfHwgc2l6ZSA8PSBjb2wgKyBjKSBjb250aW51ZVxuXG4gICAgICAgIGlmICgociA+PSAwICYmIHIgPD0gNiAmJiAoYyA9PT0gMCB8fCBjID09PSA2KSkgfHxcbiAgICAgICAgICAoYyA+PSAwICYmIGMgPD0gNiAmJiAociA9PT0gMCB8fCByID09PSA2KSkgfHxcbiAgICAgICAgICAociA+PSAyICYmIHIgPD0gNCAmJiBjID49IDIgJiYgYyA8PSA0KSkge1xuICAgICAgICAgIG1hdHJpeC5zZXQocm93ICsgciwgY29sICsgYywgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRyaXguc2V0KHJvdyArIHIsIGNvbCArIGMsIGZhbHNlLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIHRpbWluZyBwYXR0ZXJuIGJpdHMgdG8gbWF0cml4XG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIHNldHVwQWxpZ25tZW50UGF0dGVybn1cbiAqXG4gKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCBNb2R1bGVzIG1hdHJpeFxuICovXG5mdW5jdGlvbiBzZXR1cFRpbWluZ1BhdHRlcm4gKG1hdHJpeCkge1xuICBjb25zdCBzaXplID0gbWF0cml4LnNpemVcblxuICBmb3IgKGxldCByID0gODsgciA8IHNpemUgLSA4OyByKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHIgJSAyID09PSAwXG4gICAgbWF0cml4LnNldChyLCA2LCB2YWx1ZSwgdHJ1ZSlcbiAgICBtYXRyaXguc2V0KDYsIHIsIHZhbHVlLCB0cnVlKVxuICB9XG59XG5cbi8qKlxuICogQWRkIGFsaWdubWVudCBwYXR0ZXJucyBiaXRzIHRvIG1hdHJpeFxuICpcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYWZ0ZXIge0BsaW5rIHNldHVwVGltaW5nUGF0dGVybn1cbiAqXG4gKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCAgTW9kdWxlcyBtYXRyaXhcbiAqIEBwYXJhbSAge051bWJlcn0gICAgdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gc2V0dXBBbGlnbm1lbnRQYXR0ZXJuIChtYXRyaXgsIHZlcnNpb24pIHtcbiAgY29uc3QgcG9zID0gQWxpZ25tZW50UGF0dGVybi5nZXRQb3NpdGlvbnModmVyc2lvbilcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IHBvc1tpXVswXVxuICAgIGNvbnN0IGNvbCA9IHBvc1tpXVsxXVxuXG4gICAgZm9yIChsZXQgciA9IC0yOyByIDw9IDI7IHIrKykge1xuICAgICAgZm9yIChsZXQgYyA9IC0yOyBjIDw9IDI7IGMrKykge1xuICAgICAgICBpZiAociA9PT0gLTIgfHwgciA9PT0gMiB8fCBjID09PSAtMiB8fCBjID09PSAyIHx8XG4gICAgICAgICAgKHIgPT09IDAgJiYgYyA9PT0gMCkpIHtcbiAgICAgICAgICBtYXRyaXguc2V0KHJvdyArIHIsIGNvbCArIGMsIHRydWUsIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0cml4LnNldChyb3cgKyByLCBjb2wgKyBjLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZCB2ZXJzaW9uIGluZm8gYml0cyB0byBtYXRyaXhcbiAqXG4gKiBAcGFyYW0gIHtCaXRNYXRyaXh9IG1hdHJpeCAgTW9kdWxlcyBtYXRyaXhcbiAqIEBwYXJhbSAge051bWJlcn0gICAgdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gc2V0dXBWZXJzaW9uSW5mbyAobWF0cml4LCB2ZXJzaW9uKSB7XG4gIGNvbnN0IHNpemUgPSBtYXRyaXguc2l6ZVxuICBjb25zdCBiaXRzID0gVmVyc2lvbi5nZXRFbmNvZGVkQml0cyh2ZXJzaW9uKVxuICBsZXQgcm93LCBjb2wsIG1vZFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTg7IGkrKykge1xuICAgIHJvdyA9IE1hdGguZmxvb3IoaSAvIDMpXG4gICAgY29sID0gaSAlIDMgKyBzaXplIC0gOCAtIDNcbiAgICBtb2QgPSAoKGJpdHMgPj4gaSkgJiAxKSA9PT0gMVxuXG4gICAgbWF0cml4LnNldChyb3csIGNvbCwgbW9kLCB0cnVlKVxuICAgIG1hdHJpeC5zZXQoY29sLCByb3csIG1vZCwgdHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBmb3JtYXQgaW5mbyBiaXRzIHRvIG1hdHJpeFxuICpcbiAqIEBwYXJhbSAge0JpdE1hdHJpeH0gbWF0cml4ICAgICAgICAgICAgICAgTW9kdWxlcyBtYXRyaXhcbiAqIEBwYXJhbSAge0Vycm9yQ29ycmVjdGlvbkxldmVsfSAgICBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIG1hc2tQYXR0ZXJuICAgICAgICAgIE1hc2sgcGF0dGVybiByZWZlcmVuY2UgdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0dXBGb3JtYXRJbmZvIChtYXRyaXgsIGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrUGF0dGVybikge1xuICBjb25zdCBzaXplID0gbWF0cml4LnNpemVcbiAgY29uc3QgYml0cyA9IEZvcm1hdEluZm8uZ2V0RW5jb2RlZEJpdHMoZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIG1hc2tQYXR0ZXJuKVxuICBsZXQgaSwgbW9kXG5cbiAgZm9yIChpID0gMDsgaSA8IDE1OyBpKyspIHtcbiAgICBtb2QgPSAoKGJpdHMgPj4gaSkgJiAxKSA9PT0gMVxuXG4gICAgLy8gdmVydGljYWxcbiAgICBpZiAoaSA8IDYpIHtcbiAgICAgIG1hdHJpeC5zZXQoaSwgOCwgbW9kLCB0cnVlKVxuICAgIH0gZWxzZSBpZiAoaSA8IDgpIHtcbiAgICAgIG1hdHJpeC5zZXQoaSArIDEsIDgsIG1vZCwgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0cml4LnNldChzaXplIC0gMTUgKyBpLCA4LCBtb2QsIHRydWUpXG4gICAgfVxuXG4gICAgLy8gaG9yaXpvbnRhbFxuICAgIGlmIChpIDwgOCkge1xuICAgICAgbWF0cml4LnNldCg4LCBzaXplIC0gaSAtIDEsIG1vZCwgdHJ1ZSlcbiAgICB9IGVsc2UgaWYgKGkgPCA5KSB7XG4gICAgICBtYXRyaXguc2V0KDgsIDE1IC0gaSAtIDEgKyAxLCBtb2QsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdHJpeC5zZXQoOCwgMTUgLSBpIC0gMSwgbW9kLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpeGVkIG1vZHVsZVxuICBtYXRyaXguc2V0KHNpemUgLSA4LCA4LCAxLCB0cnVlKVxufVxuXG4vKipcbiAqIEFkZCBlbmNvZGVkIGRhdGEgYml0cyB0byBtYXRyaXhcbiAqXG4gKiBAcGFyYW0gIHtCaXRNYXRyaXh9ICBtYXRyaXggTW9kdWxlcyBtYXRyaXhcbiAqIEBwYXJhbSAge1VpbnQ4QXJyYXl9IGRhdGEgICBEYXRhIGNvZGV3b3Jkc1xuICovXG5mdW5jdGlvbiBzZXR1cERhdGEgKG1hdHJpeCwgZGF0YSkge1xuICBjb25zdCBzaXplID0gbWF0cml4LnNpemVcbiAgbGV0IGluYyA9IC0xXG4gIGxldCByb3cgPSBzaXplIC0gMVxuICBsZXQgYml0SW5kZXggPSA3XG4gIGxldCBieXRlSW5kZXggPSAwXG5cbiAgZm9yIChsZXQgY29sID0gc2l6ZSAtIDE7IGNvbCA+IDA7IGNvbCAtPSAyKSB7XG4gICAgaWYgKGNvbCA9PT0gNikgY29sLS1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IDI7IGMrKykge1xuICAgICAgICBpZiAoIW1hdHJpeC5pc1Jlc2VydmVkKHJvdywgY29sIC0gYykpIHtcbiAgICAgICAgICBsZXQgZGFyayA9IGZhbHNlXG5cbiAgICAgICAgICBpZiAoYnl0ZUluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhcmsgPSAoKChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4KSAmIDEpID09PSAxKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hdHJpeC5zZXQocm93LCBjb2wgLSBjLCBkYXJrKVxuICAgICAgICAgIGJpdEluZGV4LS1cblxuICAgICAgICAgIGlmIChiaXRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJ5dGVJbmRleCsrXG4gICAgICAgICAgICBiaXRJbmRleCA9IDdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcm93ICs9IGluY1xuXG4gICAgICBpZiAocm93IDwgMCB8fCBzaXplIDw9IHJvdykge1xuICAgICAgICByb3cgLT0gaW5jXG4gICAgICAgIGluYyA9IC1pbmNcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgZW5jb2RlZCBjb2Rld29yZHMgZnJvbSBkYXRhIGlucHV0XG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgIHZlcnNpb24gICAgICAgICAgICAgIFFSIENvZGUgdmVyc2lvblxuICogQHBhcmFtICB7RXJyb3JDb3JyZWN0aW9uTGV2ZWx9ICAgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICogQHBhcmFtICB7Qnl0ZURhdGF9IGRhdGEgICAgICAgICAgICAgICAgIERhdGEgaW5wdXRcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9ICAgICAgICAgICAgICAgICAgICBCdWZmZXIgY29udGFpbmluZyBlbmNvZGVkIGNvZGV3b3Jkc1xuICovXG5mdW5jdGlvbiBjcmVhdGVEYXRhICh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgc2VnbWVudHMpIHtcbiAgLy8gUHJlcGFyZSBkYXRhIGJ1ZmZlclxuICBjb25zdCBidWZmZXIgPSBuZXcgQml0QnVmZmVyKClcblxuICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgLy8gcHJlZml4IGRhdGEgd2l0aCBtb2RlIGluZGljYXRvciAoNCBiaXRzKVxuICAgIGJ1ZmZlci5wdXQoZGF0YS5tb2RlLmJpdCwgNClcblxuICAgIC8vIFByZWZpeCBkYXRhIHdpdGggY2hhcmFjdGVyIGNvdW50IGluZGljYXRvci5cbiAgICAvLyBUaGUgY2hhcmFjdGVyIGNvdW50IGluZGljYXRvciBpcyBhIHN0cmluZyBvZiBiaXRzIHRoYXQgcmVwcmVzZW50cyB0aGVcbiAgICAvLyBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBiZWluZyBlbmNvZGVkLlxuICAgIC8vIFRoZSBjaGFyYWN0ZXIgY291bnQgaW5kaWNhdG9yIG11c3QgYmUgcGxhY2VkIGFmdGVyIHRoZSBtb2RlIGluZGljYXRvclxuICAgIC8vIGFuZCBtdXN0IGJlIGEgY2VydGFpbiBudW1iZXIgb2YgYml0cyBsb25nLCBkZXBlbmRpbmcgb24gdGhlIFFSIHZlcnNpb25cbiAgICAvLyBhbmQgZGF0YSBtb2RlXG4gICAgLy8gQHNlZSB7QGxpbmsgTW9kZS5nZXRDaGFyQ291bnRJbmRpY2F0b3J9LlxuICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgTW9kZS5nZXRDaGFyQ291bnRJbmRpY2F0b3IoZGF0YS5tb2RlLCB2ZXJzaW9uKSlcblxuICAgIC8vIGFkZCBiaW5hcnkgZGF0YSBzZXF1ZW5jZSB0byBidWZmZXJcbiAgICBkYXRhLndyaXRlKGJ1ZmZlcilcbiAgfSlcblxuICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgbnVtYmVyIG9mIGJpdHNcbiAgY29uc3QgdG90YWxDb2Rld29yZHMgPSBVdGlscy5nZXRTeW1ib2xUb3RhbENvZGV3b3Jkcyh2ZXJzaW9uKVxuICBjb25zdCBlY1RvdGFsQ29kZXdvcmRzID0gRUNDb2RlLmdldFRvdGFsQ29kZXdvcmRzQ291bnQodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpXG4gIGNvbnN0IGRhdGFUb3RhbENvZGV3b3Jkc0JpdHMgPSAodG90YWxDb2Rld29yZHMgLSBlY1RvdGFsQ29kZXdvcmRzKSAqIDhcblxuICAvLyBBZGQgYSB0ZXJtaW5hdG9yLlxuICAvLyBJZiB0aGUgYml0IHN0cmluZyBpcyBzaG9ydGVyIHRoYW4gdGhlIHRvdGFsIG51bWJlciBvZiByZXF1aXJlZCBiaXRzLFxuICAvLyBhIHRlcm1pbmF0b3Igb2YgdXAgdG8gZm91ciAwcyBtdXN0IGJlIGFkZGVkIHRvIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzdHJpbmcuXG4gIC8vIElmIHRoZSBiaXQgc3RyaW5nIGlzIG1vcmUgdGhhbiBmb3VyIGJpdHMgc2hvcnRlciB0aGFuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgYml0cyxcbiAgLy8gYWRkIGZvdXIgMHMgdG8gdGhlIGVuZC5cbiAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSArIDQgPD0gZGF0YVRvdGFsQ29kZXdvcmRzQml0cykge1xuICAgIGJ1ZmZlci5wdXQoMCwgNClcbiAgfVxuXG4gIC8vIElmIHRoZSBiaXQgc3RyaW5nIGlzIGZld2VyIHRoYW4gZm91ciBiaXRzIHNob3J0ZXIsIGFkZCBvbmx5IHRoZSBudW1iZXIgb2YgMHMgdGhhdFxuICAvLyBhcmUgbmVlZGVkIHRvIHJlYWNoIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgYml0cy5cblxuICAvLyBBZnRlciBhZGRpbmcgdGhlIHRlcm1pbmF0b3IsIGlmIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgc3RyaW5nIGlzIG5vdCBhIG11bHRpcGxlIG9mIDgsXG4gIC8vIHBhZCB0aGUgc3RyaW5nIG9uIHRoZSByaWdodCB3aXRoIDBzIHRvIG1ha2UgdGhlIHN0cmluZydzIGxlbmd0aCBhIG11bHRpcGxlIG9mIDguXG4gIHdoaWxlIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgJSA4ICE9PSAwKSB7XG4gICAgYnVmZmVyLnB1dEJpdCgwKVxuICB9XG5cbiAgLy8gQWRkIHBhZCBieXRlcyBpZiB0aGUgc3RyaW5nIGlzIHN0aWxsIHNob3J0ZXIgdGhhbiB0aGUgdG90YWwgbnVtYmVyIG9mIHJlcXVpcmVkIGJpdHMuXG4gIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHRvIGZpbGwgdGhlIGRhdGEgY2FwYWNpdHkgb2YgdGhlIHN5bWJvbCBjb3JyZXNwb25kaW5nIHRvXG4gIC8vIHRoZSBWZXJzaW9uIGFuZCBFcnJvciBDb3JyZWN0aW9uIExldmVsIGJ5IGFkZGluZyB0aGUgUGFkIENvZGV3b3JkcyAxMTEwMTEwMCAoMHhFQylcbiAgLy8gYW5kIDAwMDEwMDAxICgweDExKSBhbHRlcm5hdGVseS5cbiAgY29uc3QgcmVtYWluaW5nQnl0ZSA9IChkYXRhVG90YWxDb2Rld29yZHNCaXRzIC0gYnVmZmVyLmdldExlbmd0aEluQml0cygpKSAvIDhcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1haW5pbmdCeXRlOyBpKyspIHtcbiAgICBidWZmZXIucHV0KGkgJSAyID8gMHgxMSA6IDB4RUMsIDgpXG4gIH1cblxuICByZXR1cm4gY3JlYXRlQ29kZXdvcmRzKGJ1ZmZlciwgdmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpXG59XG5cbi8qKlxuICogRW5jb2RlIGlucHV0IGRhdGEgd2l0aCBSZWVkLVNvbG9tb24gYW5kIHJldHVybiBjb2Rld29yZHMgd2l0aFxuICogcmVsYXRpdmUgZXJyb3IgY29ycmVjdGlvbiBiaXRzXG4gKlxuICogQHBhcmFtICB7Qml0QnVmZmVyfSBiaXRCdWZmZXIgICAgICAgICAgICBEYXRhIHRvIGVuY29kZVxuICogQHBhcmFtICB7TnVtYmVyfSAgICB2ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cbiAqIEBwYXJhbSAge0Vycm9yQ29ycmVjdGlvbkxldmVsfSBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlciBjb250YWluaW5nIGVuY29kZWQgY29kZXdvcmRzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvZGV3b3JkcyAoYml0QnVmZmVyLCB2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAvLyBUb3RhbCBjb2Rld29yZHMgZm9yIHRoaXMgUVIgY29kZSB2ZXJzaW9uIChEYXRhICsgRXJyb3IgY29ycmVjdGlvbilcbiAgY29uc3QgdG90YWxDb2Rld29yZHMgPSBVdGlscy5nZXRTeW1ib2xUb3RhbENvZGV3b3Jkcyh2ZXJzaW9uKVxuXG4gIC8vIFRvdGFsIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICBjb25zdCBlY1RvdGFsQ29kZXdvcmRzID0gRUNDb2RlLmdldFRvdGFsQ29kZXdvcmRzQ291bnQodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpXG5cbiAgLy8gVG90YWwgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXG4gIGNvbnN0IGRhdGFUb3RhbENvZGV3b3JkcyA9IHRvdGFsQ29kZXdvcmRzIC0gZWNUb3RhbENvZGV3b3Jkc1xuXG4gIC8vIFRvdGFsIG51bWJlciBvZiBibG9ja3NcbiAgY29uc3QgZWNUb3RhbEJsb2NrcyA9IEVDQ29kZS5nZXRCbG9ja3NDb3VudCh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbClcblxuICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgYmxvY2tzIGVhY2ggZ3JvdXAgc2hvdWxkIGNvbnRhaW5cbiAgY29uc3QgYmxvY2tzSW5Hcm91cDIgPSB0b3RhbENvZGV3b3JkcyAlIGVjVG90YWxCbG9ja3NcbiAgY29uc3QgYmxvY2tzSW5Hcm91cDEgPSBlY1RvdGFsQmxvY2tzIC0gYmxvY2tzSW5Hcm91cDJcblxuICBjb25zdCB0b3RhbENvZGV3b3Jkc0luR3JvdXAxID0gTWF0aC5mbG9vcih0b3RhbENvZGV3b3JkcyAvIGVjVG90YWxCbG9ja3MpXG5cbiAgY29uc3QgZGF0YUNvZGV3b3Jkc0luR3JvdXAxID0gTWF0aC5mbG9vcihkYXRhVG90YWxDb2Rld29yZHMgLyBlY1RvdGFsQmxvY2tzKVxuICBjb25zdCBkYXRhQ29kZXdvcmRzSW5Hcm91cDIgPSBkYXRhQ29kZXdvcmRzSW5Hcm91cDEgKyAxXG5cbiAgLy8gTnVtYmVyIG9mIEVDIGNvZGV3b3JkcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBncm91cHNcbiAgY29uc3QgZWNDb3VudCA9IHRvdGFsQ29kZXdvcmRzSW5Hcm91cDEgLSBkYXRhQ29kZXdvcmRzSW5Hcm91cDFcblxuICAvLyBJbml0aWFsaXplIGEgUmVlZC1Tb2xvbW9uIGVuY29kZXIgd2l0aCBhIGdlbmVyYXRvciBwb2x5bm9taWFsIG9mIGRlZ3JlZSBlY0NvdW50XG4gIGNvbnN0IHJzID0gbmV3IFJlZWRTb2xvbW9uRW5jb2RlcihlY0NvdW50KVxuXG4gIGxldCBvZmZzZXQgPSAwXG4gIGNvbnN0IGRjRGF0YSA9IG5ldyBBcnJheShlY1RvdGFsQmxvY2tzKVxuICBjb25zdCBlY0RhdGEgPSBuZXcgQXJyYXkoZWNUb3RhbEJsb2NrcylcbiAgbGV0IG1heERhdGFTaXplID0gMFxuICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShiaXRCdWZmZXIuYnVmZmVyKVxuXG4gIC8vIERpdmlkZSB0aGUgYnVmZmVyIGludG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBibG9ja3NcbiAgZm9yIChsZXQgYiA9IDA7IGIgPCBlY1RvdGFsQmxvY2tzOyBiKyspIHtcbiAgICBjb25zdCBkYXRhU2l6ZSA9IGIgPCBibG9ja3NJbkdyb3VwMSA/IGRhdGFDb2Rld29yZHNJbkdyb3VwMSA6IGRhdGFDb2Rld29yZHNJbkdyb3VwMlxuXG4gICAgLy8gZXh0cmFjdCBhIGJsb2NrIG9mIGRhdGEgZnJvbSBidWZmZXJcbiAgICBkY0RhdGFbYl0gPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBkYXRhU2l6ZSlcblxuICAgIC8vIENhbGN1bGF0ZSBFQyBjb2Rld29yZHMgZm9yIHRoaXMgZGF0YSBibG9ja1xuICAgIGVjRGF0YVtiXSA9IHJzLmVuY29kZShkY0RhdGFbYl0pXG5cbiAgICBvZmZzZXQgKz0gZGF0YVNpemVcbiAgICBtYXhEYXRhU2l6ZSA9IE1hdGgubWF4KG1heERhdGFTaXplLCBkYXRhU2l6ZSlcbiAgfVxuXG4gIC8vIENyZWF0ZSBmaW5hbCBkYXRhXG4gIC8vIEludGVybGVhdmUgdGhlIGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzIGZyb20gZWFjaCBibG9ja1xuICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodG90YWxDb2Rld29yZHMpXG4gIGxldCBpbmRleCA9IDBcbiAgbGV0IGksIHJcblxuICAvLyBBZGQgZGF0YSBjb2Rld29yZHNcbiAgZm9yIChpID0gMDsgaSA8IG1heERhdGFTaXplOyBpKyspIHtcbiAgICBmb3IgKHIgPSAwOyByIDwgZWNUb3RhbEJsb2NrczsgcisrKSB7XG4gICAgICBpZiAoaSA8IGRjRGF0YVtyXS5sZW5ndGgpIHtcbiAgICAgICAgZGF0YVtpbmRleCsrXSA9IGRjRGF0YVtyXVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGVkIEVDIGNvZGV3b3Jkc1xuICBmb3IgKGkgPSAwOyBpIDwgZWNDb3VudDsgaSsrKSB7XG4gICAgZm9yIChyID0gMDsgciA8IGVjVG90YWxCbG9ja3M7IHIrKykge1xuICAgICAgZGF0YVtpbmRleCsrXSA9IGVjRGF0YVtyXVtpXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhXG59XG5cbi8qKlxuICogQnVpbGQgUVIgQ29kZSBzeW1ib2xcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgICAgICAgICAgICAgICAgIElucHV0IHN0cmluZ1xuICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cbiAqIEBwYXJhbSAge0Vycm9yQ29ycmV0aW9uTGV2ZWx9IGVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yIGxldmVsXG4gKiBAcGFyYW0gIHtNYXNrUGF0dGVybn0gbWFza1BhdHRlcm4gICAgIE1hc2sgcGF0dGVyblxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBzeW1ib2wgZGF0YVxuICovXG5mdW5jdGlvbiBjcmVhdGVTeW1ib2wgKGRhdGEsIHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrUGF0dGVybikge1xuICBsZXQgc2VnbWVudHNcblxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHNlZ21lbnRzID0gU2VnbWVudHMuZnJvbUFycmF5KGRhdGEpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgbGV0IGVzdGltYXRlZFZlcnNpb24gPSB2ZXJzaW9uXG5cbiAgICBpZiAoIWVzdGltYXRlZFZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHJhd1NlZ21lbnRzID0gU2VnbWVudHMucmF3U3BsaXQoZGF0YSlcblxuICAgICAgLy8gRXN0aW1hdGUgYmVzdCB2ZXJzaW9uIHRoYXQgY2FuIGNvbnRhaW4gcmF3IHNwbGl0dGVkIHNlZ21lbnRzXG4gICAgICBlc3RpbWF0ZWRWZXJzaW9uID0gVmVyc2lvbi5nZXRCZXN0VmVyc2lvbkZvckRhdGEocmF3U2VnbWVudHMsIGVycm9yQ29ycmVjdGlvbkxldmVsKVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIG9wdGltaXplZCBzZWdtZW50c1xuICAgIC8vIElmIGVzdGltYXRlZCB2ZXJzaW9uIGlzIHVuZGVmaW5lZCwgdHJ5IHdpdGggdGhlIGhpZ2hlc3QgdmVyc2lvblxuICAgIHNlZ21lbnRzID0gU2VnbWVudHMuZnJvbVN0cmluZyhkYXRhLCBlc3RpbWF0ZWRWZXJzaW9uIHx8IDQwKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhJylcbiAgfVxuXG4gIC8vIEdldCB0aGUgbWluIHZlcnNpb24gdGhhdCBjYW4gY29udGFpbiBkYXRhXG4gIGNvbnN0IGJlc3RWZXJzaW9uID0gVmVyc2lvbi5nZXRCZXN0VmVyc2lvbkZvckRhdGEoc2VnbWVudHMsIGVycm9yQ29ycmVjdGlvbkxldmVsKVxuXG4gIC8vIElmIG5vIHZlcnNpb24gaXMgZm91bmQsIGRhdGEgY2Fubm90IGJlIHN0b3JlZFxuICBpZiAoIWJlc3RWZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYW1vdW50IG9mIGRhdGEgaXMgdG9vIGJpZyB0byBiZSBzdG9yZWQgaW4gYSBRUiBDb2RlJylcbiAgfVxuXG4gIC8vIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBtaW4gdmVyc2lvbiBhcyBkZWZhdWx0XG4gIGlmICghdmVyc2lvbikge1xuICAgIHZlcnNpb24gPSBiZXN0VmVyc2lvblxuXG4gIC8vIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgdmVyc2lvbiBjYW4gY29udGFpbiB0aGUgZGF0YVxuICB9IGVsc2UgaWYgKHZlcnNpb24gPCBiZXN0VmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignXFxuJyArXG4gICAgICAnVGhlIGNob3NlbiBRUiBDb2RlIHZlcnNpb24gY2Fubm90IGNvbnRhaW4gdGhpcyBhbW91bnQgb2YgZGF0YS5cXG4nICtcbiAgICAgICdNaW5pbXVtIHZlcnNpb24gcmVxdWlyZWQgdG8gc3RvcmUgY3VycmVudCBkYXRhIGlzOiAnICsgYmVzdFZlcnNpb24gKyAnLlxcbidcbiAgICApXG4gIH1cblxuICBjb25zdCBkYXRhQml0cyA9IGNyZWF0ZURhdGEodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIHNlZ21lbnRzKVxuXG4gIC8vIEFsbG9jYXRlIG1hdHJpeCBidWZmZXJcbiAgY29uc3QgbW9kdWxlQ291bnQgPSBVdGlscy5nZXRTeW1ib2xTaXplKHZlcnNpb24pXG4gIGNvbnN0IG1vZHVsZXMgPSBuZXcgQml0TWF0cml4KG1vZHVsZUNvdW50KVxuXG4gIC8vIEFkZCBmdW5jdGlvbiBtb2R1bGVzXG4gIHNldHVwRmluZGVyUGF0dGVybihtb2R1bGVzLCB2ZXJzaW9uKVxuICBzZXR1cFRpbWluZ1BhdHRlcm4obW9kdWxlcylcbiAgc2V0dXBBbGlnbm1lbnRQYXR0ZXJuKG1vZHVsZXMsIHZlcnNpb24pXG5cbiAgLy8gQWRkIHRlbXBvcmFyeSBkdW1teSBiaXRzIGZvciBmb3JtYXQgaW5mbyBqdXN0IHRvIHNldCB0aGVtIGFzIHJlc2VydmVkLlxuICAvLyBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50IHRoZXNlIGJpdHMgZnJvbSBiZWluZyBtYXNrZWQgYnkge0BsaW5rIE1hc2tQYXR0ZXJuLmFwcGx5TWFza31cbiAgLy8gc2luY2UgdGhlIG1hc2tpbmcgb3BlcmF0aW9uIG11c3QgYmUgcGVyZm9ybWVkIG9ubHkgb24gdGhlIGVuY29kaW5nIHJlZ2lvbi5cbiAgLy8gVGhlc2UgYmxvY2tzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBjb3JyZWN0IHZhbHVlcyBsYXRlciBpbiBjb2RlLlxuICBzZXR1cEZvcm1hdEluZm8obW9kdWxlcywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIDApXG5cbiAgaWYgKHZlcnNpb24gPj0gNykge1xuICAgIHNldHVwVmVyc2lvbkluZm8obW9kdWxlcywgdmVyc2lvbilcbiAgfVxuXG4gIC8vIEFkZCBkYXRhIGNvZGV3b3Jkc1xuICBzZXR1cERhdGEobW9kdWxlcywgZGF0YUJpdHMpXG5cbiAgaWYgKGlzTmFOKG1hc2tQYXR0ZXJuKSkge1xuICAgIC8vIEZpbmQgYmVzdCBtYXNrIHBhdHRlcm5cbiAgICBtYXNrUGF0dGVybiA9IE1hc2tQYXR0ZXJuLmdldEJlc3RNYXNrKG1vZHVsZXMsXG4gICAgICBzZXR1cEZvcm1hdEluZm8uYmluZChudWxsLCBtb2R1bGVzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkpXG4gIH1cblxuICAvLyBBcHBseSBtYXNrIHBhdHRlcm5cbiAgTWFza1BhdHRlcm4uYXBwbHlNYXNrKG1hc2tQYXR0ZXJuLCBtb2R1bGVzKVxuXG4gIC8vIFJlcGxhY2UgZm9ybWF0IGluZm8gYml0cyB3aXRoIGNvcnJlY3QgdmFsdWVzXG4gIHNldHVwRm9ybWF0SW5mbyhtb2R1bGVzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgbWFza1BhdHRlcm4pXG5cbiAgcmV0dXJuIHtcbiAgICBtb2R1bGVzOiBtb2R1bGVzLFxuICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgZXJyb3JDb3JyZWN0aW9uTGV2ZWw6IGVycm9yQ29ycmVjdGlvbkxldmVsLFxuICAgIG1hc2tQYXR0ZXJuOiBtYXNrUGF0dGVybixcbiAgICBzZWdtZW50czogc2VnbWVudHNcbiAgfVxufVxuXG4vKipcbiAqIFFSIENvZGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBkYXRhICAgICAgICAgICAgICAgICBJbnB1dCBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICBPcHRpb25hbCBjb25maWd1cmF0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMudmVyc2lvbiAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5lcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnRvU0pJU0Z1bmMgICAgICAgICBIZWxwZXIgZnVuYyB0byBjb252ZXJ0IHV0ZjggdG8gc2ppc1xuICovXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAoZGF0YSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnIHx8IGRhdGEgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnB1dCB0ZXh0JylcbiAgfVxuXG4gIGxldCBlcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVDTGV2ZWwuTVxuICBsZXQgdmVyc2lvblxuICBsZXQgbWFza1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBVc2UgaGlnaGVyIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgYXMgZGVmYXVsdFxuICAgIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRUNMZXZlbC5mcm9tKG9wdGlvbnMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIEVDTGV2ZWwuTSlcbiAgICB2ZXJzaW9uID0gVmVyc2lvbi5mcm9tKG9wdGlvbnMudmVyc2lvbilcbiAgICBtYXNrID0gTWFza1BhdHRlcm4uZnJvbShvcHRpb25zLm1hc2tQYXR0ZXJuKVxuXG4gICAgaWYgKG9wdGlvbnMudG9TSklTRnVuYykge1xuICAgICAgVXRpbHMuc2V0VG9TSklTRnVuY3Rpb24ob3B0aW9ucy50b1NKSVNGdW5jKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjcmVhdGVTeW1ib2woZGF0YSwgdmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIG1hc2spXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///157\n\n}")},169:(module,__unused_webpack_exports,__webpack_require__)=>{eval("{// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof __webpack_require__.g !== 'undefined') {\n  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nmodule.exports = ws\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5LmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFLGdCQUFnQixxQkFBTTtBQUN4QixPQUFPLHFCQUFNLGNBQWMscUJBQU07QUFDakMsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtd3MvYnJvd3Nlci5qcz8zZmUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhvZ2Rlbi93ZWJzb2NrZXQtc3RyZWFtL2Jsb2IvNDhkYzNkZGY5NDNlNWFkYTY2OGMzMWNjZDk0ZTkxODZmMDJmYWZiZC93cy1mYWxsYmFjay5qc1xuXG52YXIgd3MgPSBudWxsXG5cbmlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IFdlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2YgTW96V2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IE1veldlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3cyA9IHdpbmRvdy5XZWJTb2NrZXQgfHwgd2luZG93Lk1veldlYlNvY2tldFxufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd3MgPSBzZWxmLldlYlNvY2tldCB8fCBzZWxmLk1veldlYlNvY2tldFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdzXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///169\n\n}")},208:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const VersionCheck = __webpack_require__(1878)\nconst Regex = __webpack_require__(7044)\n\n/**\n * Numeric mode encodes data from the decimal digit set (0 - 9)\n * (byte values 30HEX to 39HEX).\n * Normally, 3 data characters are represented by 10 bits.\n *\n * @type {Object}\n */\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n}\n\n/**\n * Alphanumeric mode encodes data from a set of 45 characters,\n * i.e. 10 numeric digits (0 - 9),\n *      26 alphabetic characters (A - Z),\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n * Normally, two input characters are represented by 11 bits.\n *\n * @type {Object}\n */\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n}\n\n/**\n * In byte mode, data is encoded at 8 bits per character.\n *\n * @type {Object}\n */\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n}\n\n/**\n * The Kanji mode efficiently encodes Kanji characters in accordance with\n * the Shift JIS system based on JIS X 0208.\n * The Shift JIS values are shifted from the JIS X 0208 values.\n * JIS X 0208 gives details of the shift coded representation.\n * Each two-byte character value is compacted to a 13-bit binary codeword.\n *\n * @type {Object}\n */\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n}\n\n/**\n * Mixed mode will contain a sequences of data in a combination of any of\n * the modes described above\n *\n * @type {Object}\n */\nexports.MIXED = {\n  bit: -1\n}\n\n/**\n * Returns the number of bits needed to store the data length\n * according to QR Code specifications.\n *\n * @param  {Mode}   mode    Data mode\n * @param  {Number} version QR Code version\n * @return {Number}         Number of bits\n */\nexports.getCharCountIndicator = function getCharCountIndicator (mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)\n\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version)\n  }\n\n  if (version >= 1 && version < 10) return mode.ccBits[0]\n  else if (version < 27) return mode.ccBits[1]\n  return mode.ccBits[2]\n}\n\n/**\n * Returns the most efficient mode to store the specified data\n *\n * @param  {String} dataStr Input data string\n * @return {Mode}           Best mode\n */\nexports.getBestModeForData = function getBestModeForData (dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC\n  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC\n  else if (Regex.testKanji(dataStr)) return exports.KANJI\n  else return exports.BYTE\n}\n\n/**\n * Return mode name as string\n *\n * @param {Mode} mode Mode object\n * @returns {String}  Mode name\n */\nexports.toString = function toString (mode) {\n  if (mode && mode.id) return mode.id\n  throw new Error('Invalid mode')\n}\n\n/**\n * Check if input param is a valid mode object\n *\n * @param   {Mode}    mode Mode object\n * @returns {Boolean} True if valid mode, false otherwise\n */\nexports.isValid = function isValid (mode) {\n  return mode && mode.bit && mode.ccBits\n}\n\n/**\n * Get mode object from its name\n *\n * @param   {String} string Mode name\n * @returns {Mode}          Mode object\n */\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC\n    case 'kanji':\n      return exports.KANJI\n    case 'byte':\n      return exports.BYTE\n    default:\n      throw new Error('Unknown mode: ' + string)\n  }\n}\n\n/**\n * Returns mode from a value.\n * If value is not a valid mode, returns defaultValue\n *\n * @param  {Mode|String} value        Encoding mode\n * @param  {Mode}        defaultValue Fallback value\n * @return {Mode}                     Encoding mode\n */\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA4LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLElBQWlCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxJQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGFBQWE7QUFDekIsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2NvcmUvbW9kZS5qcz9iYmYwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZlcnNpb25DaGVjayA9IHJlcXVpcmUoJy4vdmVyc2lvbi1jaGVjaycpXG5jb25zdCBSZWdleCA9IHJlcXVpcmUoJy4vcmVnZXgnKVxuXG4vKipcbiAqIE51bWVyaWMgbW9kZSBlbmNvZGVzIGRhdGEgZnJvbSB0aGUgZGVjaW1hbCBkaWdpdCBzZXQgKDAgLSA5KVxuICogKGJ5dGUgdmFsdWVzIDMwSEVYIHRvIDM5SEVYKS5cbiAqIE5vcm1hbGx5LCAzIGRhdGEgY2hhcmFjdGVycyBhcmUgcmVwcmVzZW50ZWQgYnkgMTAgYml0cy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLk5VTUVSSUMgPSB7XG4gIGlkOiAnTnVtZXJpYycsXG4gIGJpdDogMSA8PCAwLFxuICBjY0JpdHM6IFsxMCwgMTIsIDE0XVxufVxuXG4vKipcbiAqIEFscGhhbnVtZXJpYyBtb2RlIGVuY29kZXMgZGF0YSBmcm9tIGEgc2V0IG9mIDQ1IGNoYXJhY3RlcnMsXG4gKiBpLmUuIDEwIG51bWVyaWMgZGlnaXRzICgwIC0gOSksXG4gKiAgICAgIDI2IGFscGhhYmV0aWMgY2hhcmFjdGVycyAoQSAtIFopLFxuICogICBhbmQgOSBzeW1ib2xzIChTUCwgJCwgJSwgKiwgKywgLSwgLiwgLywgOikuXG4gKiBOb3JtYWxseSwgdHdvIGlucHV0IGNoYXJhY3RlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IDExIGJpdHMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5BTFBIQU5VTUVSSUMgPSB7XG4gIGlkOiAnQWxwaGFudW1lcmljJyxcbiAgYml0OiAxIDw8IDEsXG4gIGNjQml0czogWzksIDExLCAxM11cbn1cblxuLyoqXG4gKiBJbiBieXRlIG1vZGUsIGRhdGEgaXMgZW5jb2RlZCBhdCA4IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLkJZVEUgPSB7XG4gIGlkOiAnQnl0ZScsXG4gIGJpdDogMSA8PCAyLFxuICBjY0JpdHM6IFs4LCAxNiwgMTZdXG59XG5cbi8qKlxuICogVGhlIEthbmppIG1vZGUgZWZmaWNpZW50bHkgZW5jb2RlcyBLYW5qaSBjaGFyYWN0ZXJzIGluIGFjY29yZGFuY2Ugd2l0aFxuICogdGhlIFNoaWZ0IEpJUyBzeXN0ZW0gYmFzZWQgb24gSklTIFggMDIwOC5cbiAqIFRoZSBTaGlmdCBKSVMgdmFsdWVzIGFyZSBzaGlmdGVkIGZyb20gdGhlIEpJUyBYIDAyMDggdmFsdWVzLlxuICogSklTIFggMDIwOCBnaXZlcyBkZXRhaWxzIG9mIHRoZSBzaGlmdCBjb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqIEVhY2ggdHdvLWJ5dGUgY2hhcmFjdGVyIHZhbHVlIGlzIGNvbXBhY3RlZCB0byBhIDEzLWJpdCBiaW5hcnkgY29kZXdvcmQuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5LQU5KSSA9IHtcbiAgaWQ6ICdLYW5qaScsXG4gIGJpdDogMSA8PCAzLFxuICBjY0JpdHM6IFs4LCAxMCwgMTJdXG59XG5cbi8qKlxuICogTWl4ZWQgbW9kZSB3aWxsIGNvbnRhaW4gYSBzZXF1ZW5jZXMgb2YgZGF0YSBpbiBhIGNvbWJpbmF0aW9uIG9mIGFueSBvZlxuICogdGhlIG1vZGVzIGRlc2NyaWJlZCBhYm92ZVxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuTUlYRUQgPSB7XG4gIGJpdDogLTFcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gc3RvcmUgdGhlIGRhdGEgbGVuZ3RoXG4gKiBhY2NvcmRpbmcgdG8gUVIgQ29kZSBzcGVjaWZpY2F0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtNb2RlfSAgIG1vZGUgICAgRGF0YSBtb2RlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgTnVtYmVyIG9mIGJpdHNcbiAqL1xuZXhwb3J0cy5nZXRDaGFyQ291bnRJbmRpY2F0b3IgPSBmdW5jdGlvbiBnZXRDaGFyQ291bnRJbmRpY2F0b3IgKG1vZGUsIHZlcnNpb24pIHtcbiAgaWYgKCFtb2RlLmNjQml0cykgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGU6ICcgKyBtb2RlKVxuXG4gIGlmICghVmVyc2lvbkNoZWNrLmlzVmFsaWQodmVyc2lvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbjogJyArIHZlcnNpb24pXG4gIH1cblxuICBpZiAodmVyc2lvbiA+PSAxICYmIHZlcnNpb24gPCAxMCkgcmV0dXJuIG1vZGUuY2NCaXRzWzBdXG4gIGVsc2UgaWYgKHZlcnNpb24gPCAyNykgcmV0dXJuIG1vZGUuY2NCaXRzWzFdXG4gIHJldHVybiBtb2RlLmNjQml0c1syXVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vc3QgZWZmaWNpZW50IG1vZGUgdG8gc3RvcmUgdGhlIHNwZWNpZmllZCBkYXRhXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBkYXRhU3RyIElucHV0IGRhdGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtNb2RlfSAgICAgICAgICAgQmVzdCBtb2RlXG4gKi9cbmV4cG9ydHMuZ2V0QmVzdE1vZGVGb3JEYXRhID0gZnVuY3Rpb24gZ2V0QmVzdE1vZGVGb3JEYXRhIChkYXRhU3RyKSB7XG4gIGlmIChSZWdleC50ZXN0TnVtZXJpYyhkYXRhU3RyKSkgcmV0dXJuIGV4cG9ydHMuTlVNRVJJQ1xuICBlbHNlIGlmIChSZWdleC50ZXN0QWxwaGFudW1lcmljKGRhdGFTdHIpKSByZXR1cm4gZXhwb3J0cy5BTFBIQU5VTUVSSUNcbiAgZWxzZSBpZiAoUmVnZXgudGVzdEthbmppKGRhdGFTdHIpKSByZXR1cm4gZXhwb3J0cy5LQU5KSVxuICBlbHNlIHJldHVybiBleHBvcnRzLkJZVEVcbn1cblxuLyoqXG4gKiBSZXR1cm4gbW9kZSBuYW1lIGFzIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7TW9kZX0gbW9kZSBNb2RlIG9iamVjdFxuICogQHJldHVybnMge1N0cmluZ30gIE1vZGUgbmFtZVxuICovXG5leHBvcnRzLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKG1vZGUpIHtcbiAgaWYgKG1vZGUgJiYgbW9kZS5pZCkgcmV0dXJuIG1vZGUuaWRcbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGUnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGlucHV0IHBhcmFtIGlzIGEgdmFsaWQgbW9kZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gICB7TW9kZX0gICAgbW9kZSBNb2RlIG9iamVjdFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdmFsaWQgbW9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKG1vZGUpIHtcbiAgcmV0dXJuIG1vZGUgJiYgbW9kZS5iaXQgJiYgbW9kZS5jY0JpdHNcbn1cblxuLyoqXG4gKiBHZXQgbW9kZSBvYmplY3QgZnJvbSBpdHMgbmFtZVxuICpcbiAqIEBwYXJhbSAgIHtTdHJpbmd9IHN0cmluZyBNb2RlIG5hbWVcbiAqIEByZXR1cm5zIHtNb2RlfSAgICAgICAgICBNb2RlIG9iamVjdFxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJhbSBpcyBub3QgYSBzdHJpbmcnKVxuICB9XG5cbiAgY29uc3QgbGNTdHIgPSBzdHJpbmcudG9Mb3dlckNhc2UoKVxuXG4gIHN3aXRjaCAobGNTdHIpIHtcbiAgICBjYXNlICdudW1lcmljJzpcbiAgICAgIHJldHVybiBleHBvcnRzLk5VTUVSSUNcbiAgICBjYXNlICdhbHBoYW51bWVyaWMnOlxuICAgICAgcmV0dXJuIGV4cG9ydHMuQUxQSEFOVU1FUklDXG4gICAgY2FzZSAna2FuamknOlxuICAgICAgcmV0dXJuIGV4cG9ydHMuS0FOSklcbiAgICBjYXNlICdieXRlJzpcbiAgICAgIHJldHVybiBleHBvcnRzLkJZVEVcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGU6ICcgKyBzdHJpbmcpXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIG1vZGUgZnJvbSBhIHZhbHVlLlxuICogSWYgdmFsdWUgaXMgbm90IGEgdmFsaWQgbW9kZSwgcmV0dXJucyBkZWZhdWx0VmFsdWVcbiAqXG4gKiBAcGFyYW0gIHtNb2RlfFN0cmluZ30gdmFsdWUgICAgICAgIEVuY29kaW5nIG1vZGVcbiAqIEBwYXJhbSAge01vZGV9ICAgICAgICBkZWZhdWx0VmFsdWUgRmFsbGJhY2sgdmFsdWVcbiAqIEByZXR1cm4ge01vZGV9ICAgICAgICAgICAgICAgICAgICAgRW5jb2RpbmcgbW9kZVxuICovXG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChleHBvcnRzLmlzVmFsaWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///208\n\n}")},243:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pushNumberOp = exports.pushBytesOp = exports.writeOp = exports.readOp = exports.isPushOp = void 0;\nconst opcode_js_1 = __webpack_require__(2250);\n/** Returns true if the given object is a `PushOp` */\nfunction isPushOp(op) {\n    if (!op || typeof op !== 'object') {\n        return false;\n    }\n    // eslint-disable-next-line no-prototype-builtins\n    if (!op.hasOwnProperty('opcode') || !op.hasOwnProperty('data')) {\n        return false;\n    }\n    return typeof op.opcode === 'number' && op.data instanceof Uint8Array;\n}\nexports.isPushOp = isPushOp;\n/** Read a single Script operation from the bytes */\nfunction readOp(bytes) {\n    const opcode = bytes.readU8();\n    let numBytes;\n    switch (opcode) {\n        case opcode_js_1.OP_PUSHDATA1:\n            numBytes = bytes.readU8();\n            break;\n        case opcode_js_1.OP_PUSHDATA2:\n            numBytes = bytes.readU16();\n            break;\n        case opcode_js_1.OP_PUSHDATA4:\n            numBytes = bytes.readU32();\n            break;\n        default:\n            if (opcode < 0x01 || opcode > 0x4b) {\n                // Non-push opcode\n                return opcode;\n            }\n            numBytes = opcode;\n    }\n    const data = bytes.readBytes(numBytes);\n    return { opcode, data };\n}\nexports.readOp = readOp;\n/** Write a Script operation to the writer */\nfunction writeOp(op, writer) {\n    if (typeof op == 'number') {\n        writer.putU8(op);\n        return;\n    }\n    if (!isPushOp(op)) {\n        throw `Unexpected op: ${op}`;\n    }\n    writer.putU8(op.opcode);\n    switch (op.opcode) {\n        case opcode_js_1.OP_PUSHDATA1:\n            writer.putU8(op.data.length);\n            break;\n        case opcode_js_1.OP_PUSHDATA2:\n            writer.putU16(op.data.length);\n            break;\n        case opcode_js_1.OP_PUSHDATA4:\n            writer.putU32(op.data.length);\n            break;\n        default:\n            if (op.opcode < 0 || op.opcode > 0x4b) {\n                throw `Not a pushop opcode: 0x${op.opcode.toString(16)}`;\n            }\n            if (op.opcode != op.data.length) {\n                throw (`Inconsistent PushOp, claims to push ${op.opcode} bytes ` +\n                    `but actually has ${op.data.length} bytes attached`);\n            }\n    }\n    writer.putBytes(op.data);\n}\nexports.writeOp = writeOp;\n/** Return an Op that minimally pushes the given bytes onto the stack */\nfunction pushBytesOp(data) {\n    if (data.length == 0) {\n        return opcode_js_1.OP_0;\n    }\n    else if (data.length == 1) {\n        if (data[0] >= 1 && data[0] <= 16) {\n            return data[0] + 0x50;\n        }\n        else if (data[0] == 0x81) {\n            return opcode_js_1.OP_1NEGATE;\n        }\n    }\n    let opcode;\n    if (data.length >= 0x01 && data.length <= 0x4b) {\n        opcode = data.length;\n    }\n    else if (data.length >= 0x4c && data.length <= 0xff) {\n        opcode = opcode_js_1.OP_PUSHDATA1;\n    }\n    else if (data.length >= 0x100 && data.length <= 0xffff) {\n        opcode = opcode_js_1.OP_PUSHDATA2;\n    }\n    else if (data.length >= 0x10000 && data.length <= 0xffffffff) {\n        opcode = opcode_js_1.OP_PUSHDATA4;\n    }\n    else {\n        throw 'Bytes way too large';\n    }\n    return { opcode, data };\n}\nexports.pushBytesOp = pushBytesOp;\n/**\n * Returns an Op that pushes the minimally encoded byte representation of a\n * number to the stack. The bytes pushed to the stack can be used directly\n * without the need for OP_BIN2NUM.\n */\nfunction pushNumberOp(value) {\n    if (value == 0) {\n        return opcode_js_1.OP_0;\n    }\n    // Prepare number for encoding. The algorithm below replicates the one used\n    // in `src/script/script.h` intentionally to avoid discrepancies.\n    const auxValue = BigInt(value);\n    const bytes = [];\n    const negative = auxValue < 0;\n    let absvalue = negative ? ~auxValue + 1n : auxValue;\n    // Encode value in little endian byte order by iteratively pushing the\n    // least significant byte until shifting right 1 more byte produces 0\n    while (absvalue) {\n        bytes.push(Number(absvalue & 0xffn));\n        absvalue >>= 8n;\n    }\n    // The MSB will encode the sign which means that, if the previous encoding\n    // of the absolute value uses that bit, a new byte must be added to encode\n    // the sign. If bit is not set, then it must be set for negative numbers.\n    const last = bytes[bytes.length - 1];\n    if (last & 0x80) {\n        bytes.push(negative ? 0x80 : 0x00);\n    }\n    else if (negative) {\n        bytes[bytes.length - 1] = last | 0x80;\n    }\n    return pushBytesOp(Uint8Array.from(bytes));\n}\nexports.pushNumberOp = pushNumberOp;\n//# sourceMappingURL=op.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCO0FBQ2hHLG9CQUFvQixtQkFBTyxDQUFDLElBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0E7QUFDQSw4REFBOEQsV0FBVztBQUN6RSx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9vcC5qcz82MzhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHVzaE51bWJlck9wID0gZXhwb3J0cy5wdXNoQnl0ZXNPcCA9IGV4cG9ydHMud3JpdGVPcCA9IGV4cG9ydHMucmVhZE9wID0gZXhwb3J0cy5pc1B1c2hPcCA9IHZvaWQgMDtcbmNvbnN0IG9wY29kZV9qc18xID0gcmVxdWlyZShcIi4vb3Bjb2RlLmpzXCIpO1xuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgYFB1c2hPcGAgKi9cbmZ1bmN0aW9uIGlzUHVzaE9wKG9wKSB7XG4gICAgaWYgKCFvcCB8fCB0eXBlb2Ygb3AgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIGlmICghb3AuaGFzT3duUHJvcGVydHkoJ29wY29kZScpIHx8ICFvcC5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBvcC5vcGNvZGUgPT09ICdudW1iZXInICYmIG9wLmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuZXhwb3J0cy5pc1B1c2hPcCA9IGlzUHVzaE9wO1xuLyoqIFJlYWQgYSBzaW5nbGUgU2NyaXB0IG9wZXJhdGlvbiBmcm9tIHRoZSBieXRlcyAqL1xuZnVuY3Rpb24gcmVhZE9wKGJ5dGVzKSB7XG4gICAgY29uc3Qgb3Bjb2RlID0gYnl0ZXMucmVhZFU4KCk7XG4gICAgbGV0IG51bUJ5dGVzO1xuICAgIHN3aXRjaCAob3Bjb2RlKSB7XG4gICAgICAgIGNhc2Ugb3Bjb2RlX2pzXzEuT1BfUFVTSERBVEExOlxuICAgICAgICAgICAgbnVtQnl0ZXMgPSBieXRlcy5yZWFkVTgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZV9qc18xLk9QX1BVU0hEQVRBMjpcbiAgICAgICAgICAgIG51bUJ5dGVzID0gYnl0ZXMucmVhZFUxNigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb3Bjb2RlX2pzXzEuT1BfUFVTSERBVEE0OlxuICAgICAgICAgICAgbnVtQnl0ZXMgPSBieXRlcy5yZWFkVTMyKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChvcGNvZGUgPCAweDAxIHx8IG9wY29kZSA+IDB4NGIpIHtcbiAgICAgICAgICAgICAgICAvLyBOb24tcHVzaCBvcGNvZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gb3Bjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtQnl0ZXMgPSBvcGNvZGU7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBieXRlcy5yZWFkQnl0ZXMobnVtQnl0ZXMpO1xuICAgIHJldHVybiB7IG9wY29kZSwgZGF0YSB9O1xufVxuZXhwb3J0cy5yZWFkT3AgPSByZWFkT3A7XG4vKiogV3JpdGUgYSBTY3JpcHQgb3BlcmF0aW9uIHRvIHRoZSB3cml0ZXIgKi9cbmZ1bmN0aW9uIHdyaXRlT3Aob3AsIHdyaXRlcikge1xuICAgIGlmICh0eXBlb2Ygb3AgPT0gJ251bWJlcicpIHtcbiAgICAgICAgd3JpdGVyLnB1dFU4KG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzUHVzaE9wKG9wKSkge1xuICAgICAgICB0aHJvdyBgVW5leHBlY3RlZCBvcDogJHtvcH1gO1xuICAgIH1cbiAgICB3cml0ZXIucHV0VTgob3Aub3Bjb2RlKTtcbiAgICBzd2l0Y2ggKG9wLm9wY29kZSkge1xuICAgICAgICBjYXNlIG9wY29kZV9qc18xLk9QX1BVU0hEQVRBMTpcbiAgICAgICAgICAgIHdyaXRlci5wdXRVOChvcC5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvcGNvZGVfanNfMS5PUF9QVVNIREFUQTI6XG4gICAgICAgICAgICB3cml0ZXIucHV0VTE2KG9wLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9wY29kZV9qc18xLk9QX1BVU0hEQVRBNDpcbiAgICAgICAgICAgIHdyaXRlci5wdXRVMzIob3AuZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAob3Aub3Bjb2RlIDwgMCB8fCBvcC5vcGNvZGUgPiAweDRiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYE5vdCBhIHB1c2hvcCBvcGNvZGU6IDB4JHtvcC5vcGNvZGUudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3Aub3Bjb2RlICE9IG9wLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKGBJbmNvbnNpc3RlbnQgUHVzaE9wLCBjbGFpbXMgdG8gcHVzaCAke29wLm9wY29kZX0gYnl0ZXMgYCArXG4gICAgICAgICAgICAgICAgICAgIGBidXQgYWN0dWFsbHkgaGFzICR7b3AuZGF0YS5sZW5ndGh9IGJ5dGVzIGF0dGFjaGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlci5wdXRCeXRlcyhvcC5kYXRhKTtcbn1cbmV4cG9ydHMud3JpdGVPcCA9IHdyaXRlT3A7XG4vKiogUmV0dXJuIGFuIE9wIHRoYXQgbWluaW1hbGx5IHB1c2hlcyB0aGUgZ2l2ZW4gYnl0ZXMgb250byB0aGUgc3RhY2sgKi9cbmZ1bmN0aW9uIHB1c2hCeXRlc09wKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gb3Bjb2RlX2pzXzEuT1BfMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gMSkge1xuICAgICAgICBpZiAoZGF0YVswXSA+PSAxICYmIGRhdGFbMF0gPD0gMTYpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhWzBdICsgMHg1MDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhWzBdID09IDB4ODEpIHtcbiAgICAgICAgICAgIHJldHVybiBvcGNvZGVfanNfMS5PUF8xTkVHQVRFO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBvcGNvZGU7XG4gICAgaWYgKGRhdGEubGVuZ3RoID49IDB4MDEgJiYgZGF0YS5sZW5ndGggPD0gMHg0Yikge1xuICAgICAgICBvcGNvZGUgPSBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPj0gMHg0YyAmJiBkYXRhLmxlbmd0aCA8PSAweGZmKSB7XG4gICAgICAgIG9wY29kZSA9IG9wY29kZV9qc18xLk9QX1BVU0hEQVRBMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPj0gMHgxMDAgJiYgZGF0YS5sZW5ndGggPD0gMHhmZmZmKSB7XG4gICAgICAgIG9wY29kZSA9IG9wY29kZV9qc18xLk9QX1BVU0hEQVRBMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YS5sZW5ndGggPj0gMHgxMDAwMCAmJiBkYXRhLmxlbmd0aCA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgIG9wY29kZSA9IG9wY29kZV9qc18xLk9QX1BVU0hEQVRBNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93ICdCeXRlcyB3YXkgdG9vIGxhcmdlJztcbiAgICB9XG4gICAgcmV0dXJuIHsgb3Bjb2RlLCBkYXRhIH07XG59XG5leHBvcnRzLnB1c2hCeXRlc09wID0gcHVzaEJ5dGVzT3A7XG4vKipcbiAqIFJldHVybnMgYW4gT3AgdGhhdCBwdXNoZXMgdGhlIG1pbmltYWxseSBlbmNvZGVkIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgYVxuICogbnVtYmVyIHRvIHRoZSBzdGFjay4gVGhlIGJ5dGVzIHB1c2hlZCB0byB0aGUgc3RhY2sgY2FuIGJlIHVzZWQgZGlyZWN0bHlcbiAqIHdpdGhvdXQgdGhlIG5lZWQgZm9yIE9QX0JJTjJOVU0uXG4gKi9cbmZ1bmN0aW9uIHB1c2hOdW1iZXJPcCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSAwKSB7XG4gICAgICAgIHJldHVybiBvcGNvZGVfanNfMS5PUF8wO1xuICAgIH1cbiAgICAvLyBQcmVwYXJlIG51bWJlciBmb3IgZW5jb2RpbmcuIFRoZSBhbGdvcml0aG0gYmVsb3cgcmVwbGljYXRlcyB0aGUgb25lIHVzZWRcbiAgICAvLyBpbiBgc3JjL3NjcmlwdC9zY3JpcHQuaGAgaW50ZW50aW9uYWxseSB0byBhdm9pZCBkaXNjcmVwYW5jaWVzLlxuICAgIGNvbnN0IGF1eFZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gYXV4VmFsdWUgPCAwO1xuICAgIGxldCBhYnN2YWx1ZSA9IG5lZ2F0aXZlID8gfmF1eFZhbHVlICsgMW4gOiBhdXhWYWx1ZTtcbiAgICAvLyBFbmNvZGUgdmFsdWUgaW4gbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyIGJ5IGl0ZXJhdGl2ZWx5IHB1c2hpbmcgdGhlXG4gICAgLy8gbGVhc3Qgc2lnbmlmaWNhbnQgYnl0ZSB1bnRpbCBzaGlmdGluZyByaWdodCAxIG1vcmUgYnl0ZSBwcm9kdWNlcyAwXG4gICAgd2hpbGUgKGFic3ZhbHVlKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goTnVtYmVyKGFic3ZhbHVlICYgMHhmZm4pKTtcbiAgICAgICAgYWJzdmFsdWUgPj49IDhuO1xuICAgIH1cbiAgICAvLyBUaGUgTVNCIHdpbGwgZW5jb2RlIHRoZSBzaWduIHdoaWNoIG1lYW5zIHRoYXQsIGlmIHRoZSBwcmV2aW91cyBlbmNvZGluZ1xuICAgIC8vIG9mIHRoZSBhYnNvbHV0ZSB2YWx1ZSB1c2VzIHRoYXQgYml0LCBhIG5ldyBieXRlIG11c3QgYmUgYWRkZWQgdG8gZW5jb2RlXG4gICAgLy8gdGhlIHNpZ24uIElmIGJpdCBpcyBub3Qgc2V0LCB0aGVuIGl0IG11c3QgYmUgc2V0IGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgIGNvbnN0IGxhc3QgPSBieXRlc1tieXRlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdCAmIDB4ODApIHtcbiAgICAgICAgYnl0ZXMucHVzaChuZWdhdGl2ZSA/IDB4ODAgOiAweDAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gPSBsYXN0IHwgMHg4MDtcbiAgICB9XG4gICAgcmV0dXJuIHB1c2hCeXRlc09wKFVpbnQ4QXJyYXkuZnJvbShieXRlcykpO1xufVxuZXhwb3J0cy5wdXNoTnVtYmVyT3AgPSBwdXNoTnVtYmVyT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///243\n\n}")},251:(__unused_webpack_module,exports)=>{eval("{/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz85MTUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///251\n\n}")},540:module=>{"use strict";eval('{\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement("style");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzP2RlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///540\n\n}')},602:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{/* provided dependency */ var Buffer = __webpack_require__(8287)[\"Buffer\"];\n\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseCertPem = exports.parseCertRaw = void 0;\nconst str_js_1 = __webpack_require__(2392);\nconst bytes_js_1 = __webpack_require__(1292);\nconst TAG_VERSION = 0x00;\nconst TAG_INT = 0x02;\nconst TAG_BITSTR = 0x03;\nconst TAG_OCTSTR = 0x04;\nconst TAG_NULL = 0x05;\nconst TAG_OID = 0x06;\nconst TAG_UTF8STR = 0x0c;\nconst TAG_SEQ = 0x10;\nconst TAG_SET = 0x11;\nconst TAG_NUMSTR = 0x12;\nconst TAG_PRINSTR = 0x13;\nconst TAG_T61STR = 0x14;\nconst TAG_VIDEOSTR = 0x15;\nconst TAG_IA5STR = 0x16;\nconst TAG_UTCTIME = 0x17;\nconst TAG_GENTIME = 0x18;\nconst TAG_GRAPHSTR = 0x19;\nconst TAG_ISO646STR = 0x1a;\nconst TAG_GENSTR = 0x1b;\nconst TAG_UNISTR = 0x1c;\nconst TAG_CHARSTR = 0x1d;\nconst TAG_BMPSTR = 0x1e;\nconst REGEX_PEM_CERT = /-----BEGIN CERTIFICATE-----(.*?)-----END CERTIFICATE-----/s;\nconst REGEX_DIGITS = /\\d+/;\nfunction readSize(bytes, isPrimitive) {\n    let size = bytes.readU8();\n    // Indefinite form\n    if (!isPrimitive && size === 0x80) {\n        throw new Error('Indefinite size.');\n    }\n    // Definite form\n    if ((size & 0x80) === 0) {\n        // Short form\n        return size;\n    }\n    // Long form\n    const numBytes = size & 0x7f;\n    if (numBytes > 3) {\n        throw new Error('Length octet is too long.');\n    }\n    size = 0;\n    for (let i = 0; i < numBytes; i++) {\n        size <<= 8;\n        size |= bytes.readU8();\n    }\n    return size;\n}\nfunction readTag(bytes) {\n    let type = bytes.readU8();\n    const isPrimitive = (type & 0x20) === 0;\n    if ((type & 0x1f) === 0x1f) {\n        let oct = type;\n        type = 0;\n        while ((oct & 0x80) === 0x80) {\n            oct = bytes.readU8();\n            type <<= 7;\n            type |= oct & 0x7f;\n        }\n    }\n    else {\n        type &= 0x1f;\n    }\n    return {\n        type,\n        isPrimitive,\n        size: readSize(bytes, isPrimitive),\n    };\n}\nfunction readSeq(bytes) {\n    const tag = readTag(bytes);\n    if (tag.type !== TAG_SEQ) {\n        throw new Error(`Expected sequence type ${TAG_SEQ}, but got ${tag.type}`);\n    }\n    return bytes.readBytes(tag.size);\n}\nfunction alignBitstr(data) {\n    const padding = data[0];\n    const bits = (data.length - 1) * 8 - padding;\n    const buf = data.slice(1);\n    const shift = 8 - (bits % 8);\n    if (shift === 8 || buf.length === 0) {\n        return buf;\n    }\n    const out = Buffer.allocUnsafe(buf.length);\n    out[0] = buf[0] >>> shift;\n    for (let i = 1; i < buf.length; i++) {\n        out[i] = buf[i - 1] << (8 - shift);\n        out[i] |= buf[i] >>> shift;\n    }\n    return out;\n}\nfunction readBitstr(bytes) {\n    const tag = readTag(bytes);\n    if (tag.type !== TAG_BITSTR) {\n        throw new Error(`Expected sequence type ${TAG_BITSTR}, but got ${tag.type}`);\n    }\n    return alignBitstr(bytes.readBytes(tag.size));\n}\nfunction readString(bytes) {\n    const tag = readTag(bytes);\n    switch (tag.type) {\n        case TAG_BITSTR: {\n            return alignBitstr(bytes.readBytes(tag.size));\n        }\n        case TAG_OCTSTR:\n        case TAG_NUMSTR:\n        case TAG_PRINSTR:\n        case TAG_T61STR:\n        case TAG_VIDEOSTR:\n        case TAG_IA5STR:\n        case TAG_GRAPHSTR:\n        case TAG_UTF8STR:\n        case TAG_ISO646STR:\n        case TAG_GENSTR:\n        case TAG_UNISTR:\n        case TAG_CHARSTR:\n        case TAG_BMPSTR: {\n            return bytes.readBytes(tag.size);\n        }\n        default: {\n            throw new Error(`Expected string tag, got ${tag.type}`);\n        }\n    }\n}\nfunction readInt(bytes) {\n    const tag = readTag(bytes);\n    if (tag.type !== TAG_INT) {\n        throw new Error(`Expected integer type ${TAG_INT}, but got ${tag.type}`);\n    }\n    return bytes.readBytes(tag.size);\n}\nfunction bytesToBE(bytes) {\n    let num = 0;\n    for (const b of bytes) {\n        num <<= 8;\n        num |= b;\n    }\n    return num;\n}\nfunction readVersion(bytes) {\n    const startIdx = bytes.idx;\n    const tag = readTag(bytes);\n    if (tag.type != TAG_VERSION) {\n        bytes.idx = startIdx;\n        return undefined;\n    }\n    return bytesToBE(readInt(bytes));\n}\nfunction readAlgIdent(bytes) {\n    let params = undefined;\n    bytes = new bytes_js_1.Bytes(readSeq(bytes));\n    const oid = readOID(bytes);\n    if (oid === undefined) {\n        throw new Error('Algorithm cannot be NULL');\n    }\n    if (bytes.idx < bytes.data.length) {\n        params = readOID(bytes);\n    }\n    return { oid, params };\n}\nfunction readOID(bytes) {\n    const tag = readTag(bytes);\n    if (tag.type === TAG_NULL) {\n        return undefined;\n    }\n    if (tag.type !== TAG_OID) {\n        throw new Error(`Expected OID tag ${TAG_OID}, but got ${tag.type}`);\n    }\n    const data = bytes.readBytes(tag.size);\n    const ids = [];\n    let ident = 0;\n    let subident = 0;\n    for (const byte of data) {\n        subident = byte;\n        ident <<= 7;\n        ident |= subident & 0x7f;\n        if ((subident & 0x80) === 0) {\n            ids.push(ident);\n            ident = 0;\n        }\n    }\n    if (subident & 0x80) {\n        ids.push(ident);\n    }\n    const first = (ids[0] / 40) | 0;\n    const second = ids[0] % 40;\n    const result = [first, second].concat(ids.slice(1));\n    return result.join('.');\n}\nfunction readEntries(bytes) {\n    const values = [];\n    bytes = new bytes_js_1.Bytes(readSeq(bytes));\n    while (bytes.idx < bytes.data.length) {\n        const tagSet = readTag(bytes);\n        if (tagSet.type !== TAG_SET) {\n            throw new Error(`Expected set tag ${TAG_SET}, but got ${tagSet.type}`);\n        }\n        const tagSeq = readTag(bytes);\n        if (tagSeq.type !== TAG_SEQ) {\n            throw new Error(`Expected seq tag ${TAG_SEQ}, but got ${tagSeq.type}`);\n        }\n        const oid = readOID(bytes);\n        if (oid === undefined) {\n            throw new Error('OID for issuer or subject cannot be NULL');\n        }\n        values.push({\n            oid: oid,\n            value: (0, str_js_1.bytesToStr)(readString(bytes)),\n        });\n    }\n    return values;\n}\nfunction readTime(bytes) {\n    const tag = readTag(bytes);\n    const decoder = new TextDecoder('ascii', { fatal: true });\n    const str = decoder.decode(bytes.readBytes(tag.size));\n    let year;\n    let mon;\n    let day;\n    let hour;\n    let min;\n    let sec;\n    let pos = 0;\n    const readDigits = (numDigits) => {\n        const digits = str.slice(pos, pos + numDigits);\n        if (!REGEX_DIGITS.test(digits)) {\n            throw new Error(`Expected ${numDigits} decimal digits`);\n        }\n        pos += numDigits;\n        return Number(digits) | 0;\n    };\n    switch (tag.type) {\n        case TAG_UTCTIME: {\n            year = readDigits(2);\n            mon = readDigits(2);\n            day = readDigits(2);\n            hour = readDigits(2);\n            min = readDigits(2);\n            sec = readDigits(2);\n            if (year < 70) {\n                year = 2000 + year;\n            }\n            else {\n                year = 1900 + year;\n            }\n            break;\n        }\n        case TAG_GENTIME: {\n            year = readDigits(4);\n            mon = readDigits(2);\n            day = readDigits(2);\n            hour = readDigits(2);\n            min = readDigits(2);\n            sec = readDigits(2);\n            break;\n        }\n        default: {\n            throw new Error(`Unexpected tag: ${tag.type}.`);\n        }\n    }\n    return Date.UTC(year, mon - 1, day, hour, min, sec, 0) / 1000;\n}\nfunction readValidity(bytes) {\n    bytes = new bytes_js_1.Bytes(readSeq(bytes));\n    return {\n        notBefore: readTime(bytes),\n        notAfter: readTime(bytes),\n    };\n}\nfunction readPubkey(bytes) {\n    bytes = new bytes_js_1.Bytes(readSeq(bytes));\n    return {\n        alg: readAlgIdent(bytes),\n        data: readBitstr(bytes),\n    };\n}\nfunction readToBeSigned(bytes) {\n    const startIdx = bytes.idx;\n    const tbsBytes = new bytes_js_1.Bytes(readSeq(bytes));\n    const endIdx = bytes.idx;\n    return {\n        version: readVersion(tbsBytes),\n        serial: readInt(tbsBytes),\n        sigAlg: readAlgIdent(tbsBytes),\n        issuer: readEntries(tbsBytes),\n        validity: readValidity(tbsBytes),\n        subject: readEntries(tbsBytes),\n        pubkey: readPubkey(tbsBytes),\n        raw: bytes.data.slice(startIdx, endIdx),\n    };\n}\n/** Parse a ASN1 certificate from the given bytes */\nfunction parseCertRaw(rawCert) {\n    const bytes = new bytes_js_1.Bytes(rawCert);\n    const certBytes = new bytes_js_1.Bytes(readSeq(bytes));\n    return {\n        tbs: readToBeSigned(certBytes),\n        sigAlg: readAlgIdent(certBytes),\n        sig: readBitstr(certBytes),\n        raw: rawCert,\n    };\n}\nexports.parseCertRaw = parseCertRaw;\nfunction parseCertPem(pem) {\n    const match = REGEX_PEM_CERT.exec(pem);\n    if (match === null) {\n        throw new Error('No PEM encoded certificate found. It should start with ' +\n            '\"-----BEGIN CERTIFICATE-----\"');\n    }\n    const certRaw = Uint8Array.from(atob(match[1]), c => c.charCodeAt(0));\n    return parseCertRaw(certRaw);\n}\nexports.parseCertPem = parseCertPem;\n//# sourceMappingURL=asn1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L3BheW1lbnQvYXNuMS5qcz8yMWIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI1IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VDZXJ0UGVtID0gZXhwb3J0cy5wYXJzZUNlcnRSYXcgPSB2b2lkIDA7XG5jb25zdCBzdHJfanNfMSA9IHJlcXVpcmUoXCIuLi9pby9zdHIuanNcIik7XG5jb25zdCBieXRlc19qc18xID0gcmVxdWlyZShcIi4uL2lvL2J5dGVzLmpzXCIpO1xuY29uc3QgVEFHX1ZFUlNJT04gPSAweDAwO1xuY29uc3QgVEFHX0lOVCA9IDB4MDI7XG5jb25zdCBUQUdfQklUU1RSID0gMHgwMztcbmNvbnN0IFRBR19PQ1RTVFIgPSAweDA0O1xuY29uc3QgVEFHX05VTEwgPSAweDA1O1xuY29uc3QgVEFHX09JRCA9IDB4MDY7XG5jb25zdCBUQUdfVVRGOFNUUiA9IDB4MGM7XG5jb25zdCBUQUdfU0VRID0gMHgxMDtcbmNvbnN0IFRBR19TRVQgPSAweDExO1xuY29uc3QgVEFHX05VTVNUUiA9IDB4MTI7XG5jb25zdCBUQUdfUFJJTlNUUiA9IDB4MTM7XG5jb25zdCBUQUdfVDYxU1RSID0gMHgxNDtcbmNvbnN0IFRBR19WSURFT1NUUiA9IDB4MTU7XG5jb25zdCBUQUdfSUE1U1RSID0gMHgxNjtcbmNvbnN0IFRBR19VVENUSU1FID0gMHgxNztcbmNvbnN0IFRBR19HRU5USU1FID0gMHgxODtcbmNvbnN0IFRBR19HUkFQSFNUUiA9IDB4MTk7XG5jb25zdCBUQUdfSVNPNjQ2U1RSID0gMHgxYTtcbmNvbnN0IFRBR19HRU5TVFIgPSAweDFiO1xuY29uc3QgVEFHX1VOSVNUUiA9IDB4MWM7XG5jb25zdCBUQUdfQ0hBUlNUUiA9IDB4MWQ7XG5jb25zdCBUQUdfQk1QU1RSID0gMHgxZTtcbmNvbnN0IFJFR0VYX1BFTV9DRVJUID0gLy0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLSguKj8pLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLS9zO1xuY29uc3QgUkVHRVhfRElHSVRTID0gL1xcZCsvO1xuZnVuY3Rpb24gcmVhZFNpemUoYnl0ZXMsIGlzUHJpbWl0aXZlKSB7XG4gICAgbGV0IHNpemUgPSBieXRlcy5yZWFkVTgoKTtcbiAgICAvLyBJbmRlZmluaXRlIGZvcm1cbiAgICBpZiAoIWlzUHJpbWl0aXZlICYmIHNpemUgPT09IDB4ODApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRlZmluaXRlIHNpemUuJyk7XG4gICAgfVxuICAgIC8vIERlZmluaXRlIGZvcm1cbiAgICBpZiAoKHNpemUgJiAweDgwKSA9PT0gMCkge1xuICAgICAgICAvLyBTaG9ydCBmb3JtXG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvLyBMb25nIGZvcm1cbiAgICBjb25zdCBudW1CeXRlcyA9IHNpemUgJiAweDdmO1xuICAgIGlmIChudW1CeXRlcyA+IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggb2N0ZXQgaXMgdG9vIGxvbmcuJyk7XG4gICAgfVxuICAgIHNpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQnl0ZXM7IGkrKykge1xuICAgICAgICBzaXplIDw8PSA4O1xuICAgICAgICBzaXplIHw9IGJ5dGVzLnJlYWRVOCgpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIHJlYWRUYWcoYnl0ZXMpIHtcbiAgICBsZXQgdHlwZSA9IGJ5dGVzLnJlYWRVOCgpO1xuICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gKHR5cGUgJiAweDIwKSA9PT0gMDtcbiAgICBpZiAoKHR5cGUgJiAweDFmKSA9PT0gMHgxZikge1xuICAgICAgICBsZXQgb2N0ID0gdHlwZTtcbiAgICAgICAgdHlwZSA9IDA7XG4gICAgICAgIHdoaWxlICgob2N0ICYgMHg4MCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIG9jdCA9IGJ5dGVzLnJlYWRVOCgpO1xuICAgICAgICAgICAgdHlwZSA8PD0gNztcbiAgICAgICAgICAgIHR5cGUgfD0gb2N0ICYgMHg3ZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHlwZSAmPSAweDFmO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBpc1ByaW1pdGl2ZSxcbiAgICAgICAgc2l6ZTogcmVhZFNpemUoYnl0ZXMsIGlzUHJpbWl0aXZlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZFNlcShieXRlcykge1xuICAgIGNvbnN0IHRhZyA9IHJlYWRUYWcoYnl0ZXMpO1xuICAgIGlmICh0YWcudHlwZSAhPT0gVEFHX1NFUSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHNlcXVlbmNlIHR5cGUgJHtUQUdfU0VRfSwgYnV0IGdvdCAke3RhZy50eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMucmVhZEJ5dGVzKHRhZy5zaXplKTtcbn1cbmZ1bmN0aW9uIGFsaWduQml0c3RyKGRhdGEpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gZGF0YVswXTtcbiAgICBjb25zdCBiaXRzID0gKGRhdGEubGVuZ3RoIC0gMSkgKiA4IC0gcGFkZGluZztcbiAgICBjb25zdCBidWYgPSBkYXRhLnNsaWNlKDEpO1xuICAgIGNvbnN0IHNoaWZ0ID0gOCAtIChiaXRzICUgOCk7XG4gICAgaWYgKHNoaWZ0ID09PSA4IHx8IGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgY29uc3Qgb3V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1Zi5sZW5ndGgpO1xuICAgIG91dFswXSA9IGJ1ZlswXSA+Pj4gc2hpZnQ7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gYnVmW2kgLSAxXSA8PCAoOCAtIHNoaWZ0KTtcbiAgICAgICAgb3V0W2ldIHw9IGJ1ZltpXSA+Pj4gc2hpZnQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiByZWFkQml0c3RyKGJ5dGVzKSB7XG4gICAgY29uc3QgdGFnID0gcmVhZFRhZyhieXRlcyk7XG4gICAgaWYgKHRhZy50eXBlICE9PSBUQUdfQklUU1RSKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc2VxdWVuY2UgdHlwZSAke1RBR19CSVRTVFJ9LCBidXQgZ290ICR7dGFnLnR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBhbGlnbkJpdHN0cihieXRlcy5yZWFkQnl0ZXModGFnLnNpemUpKTtcbn1cbmZ1bmN0aW9uIHJlYWRTdHJpbmcoYnl0ZXMpIHtcbiAgICBjb25zdCB0YWcgPSByZWFkVGFnKGJ5dGVzKTtcbiAgICBzd2l0Y2ggKHRhZy50eXBlKSB7XG4gICAgICAgIGNhc2UgVEFHX0JJVFNUUjoge1xuICAgICAgICAgICAgcmV0dXJuIGFsaWduQml0c3RyKGJ5dGVzLnJlYWRCeXRlcyh0YWcuc2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgVEFHX09DVFNUUjpcbiAgICAgICAgY2FzZSBUQUdfTlVNU1RSOlxuICAgICAgICBjYXNlIFRBR19QUklOU1RSOlxuICAgICAgICBjYXNlIFRBR19UNjFTVFI6XG4gICAgICAgIGNhc2UgVEFHX1ZJREVPU1RSOlxuICAgICAgICBjYXNlIFRBR19JQTVTVFI6XG4gICAgICAgIGNhc2UgVEFHX0dSQVBIU1RSOlxuICAgICAgICBjYXNlIFRBR19VVEY4U1RSOlxuICAgICAgICBjYXNlIFRBR19JU082NDZTVFI6XG4gICAgICAgIGNhc2UgVEFHX0dFTlNUUjpcbiAgICAgICAgY2FzZSBUQUdfVU5JU1RSOlxuICAgICAgICBjYXNlIFRBR19DSEFSU1RSOlxuICAgICAgICBjYXNlIFRBR19CTVBTVFI6IHtcbiAgICAgICAgICAgIHJldHVybiBieXRlcy5yZWFkQnl0ZXModGFnLnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3RyaW5nIHRhZywgZ290ICR7dGFnLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZWFkSW50KGJ5dGVzKSB7XG4gICAgY29uc3QgdGFnID0gcmVhZFRhZyhieXRlcyk7XG4gICAgaWYgKHRhZy50eXBlICE9PSBUQUdfSU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgaW50ZWdlciB0eXBlICR7VEFHX0lOVH0sIGJ1dCBnb3QgJHt0YWcudHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzLnJlYWRCeXRlcyh0YWcuc2l6ZSk7XG59XG5mdW5jdGlvbiBieXRlc1RvQkUoYnl0ZXMpIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgKGNvbnN0IGIgb2YgYnl0ZXMpIHtcbiAgICAgICAgbnVtIDw8PSA4O1xuICAgICAgICBudW0gfD0gYjtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbn1cbmZ1bmN0aW9uIHJlYWRWZXJzaW9uKGJ5dGVzKSB7XG4gICAgY29uc3Qgc3RhcnRJZHggPSBieXRlcy5pZHg7XG4gICAgY29uc3QgdGFnID0gcmVhZFRhZyhieXRlcyk7XG4gICAgaWYgKHRhZy50eXBlICE9IFRBR19WRVJTSU9OKSB7XG4gICAgICAgIGJ5dGVzLmlkeCA9IHN0YXJ0SWR4O1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXNUb0JFKHJlYWRJbnQoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIHJlYWRBbGdJZGVudChieXRlcykge1xuICAgIGxldCBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgYnl0ZXMgPSBuZXcgYnl0ZXNfanNfMS5CeXRlcyhyZWFkU2VxKGJ5dGVzKSk7XG4gICAgY29uc3Qgb2lkID0gcmVhZE9JRChieXRlcyk7XG4gICAgaWYgKG9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWxnb3JpdGhtIGNhbm5vdCBiZSBOVUxMJyk7XG4gICAgfVxuICAgIGlmIChieXRlcy5pZHggPCBieXRlcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMgPSByZWFkT0lEKGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgb2lkLCBwYXJhbXMgfTtcbn1cbmZ1bmN0aW9uIHJlYWRPSUQoYnl0ZXMpIHtcbiAgICBjb25zdCB0YWcgPSByZWFkVGFnKGJ5dGVzKTtcbiAgICBpZiAodGFnLnR5cGUgPT09IFRBR19OVUxMKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0YWcudHlwZSAhPT0gVEFHX09JRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIE9JRCB0YWcgJHtUQUdfT0lEfSwgYnV0IGdvdCAke3RhZy50eXBlfWApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYnl0ZXMucmVhZEJ5dGVzKHRhZy5zaXplKTtcbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICBsZXQgaWRlbnQgPSAwO1xuICAgIGxldCBzdWJpZGVudCA9IDA7XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGRhdGEpIHtcbiAgICAgICAgc3ViaWRlbnQgPSBieXRlO1xuICAgICAgICBpZGVudCA8PD0gNztcbiAgICAgICAgaWRlbnQgfD0gc3ViaWRlbnQgJiAweDdmO1xuICAgICAgICBpZiAoKHN1YmlkZW50ICYgMHg4MCkgPT09IDApIHtcbiAgICAgICAgICAgIGlkcy5wdXNoKGlkZW50KTtcbiAgICAgICAgICAgIGlkZW50ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3ViaWRlbnQgJiAweDgwKSB7XG4gICAgICAgIGlkcy5wdXNoKGlkZW50KTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSAoaWRzWzBdIC8gNDApIHwgMDtcbiAgICBjb25zdCBzZWNvbmQgPSBpZHNbMF0gJSA0MDtcbiAgICBjb25zdCByZXN1bHQgPSBbZmlyc3QsIHNlY29uZF0uY29uY2F0KGlkcy5zbGljZSgxKSk7XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcuJyk7XG59XG5mdW5jdGlvbiByZWFkRW50cmllcyhieXRlcykge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGJ5dGVzID0gbmV3IGJ5dGVzX2pzXzEuQnl0ZXMocmVhZFNlcShieXRlcykpO1xuICAgIHdoaWxlIChieXRlcy5pZHggPCBieXRlcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0YWdTZXQgPSByZWFkVGFnKGJ5dGVzKTtcbiAgICAgICAgaWYgKHRhZ1NldC50eXBlICE9PSBUQUdfU0VUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHNldCB0YWcgJHtUQUdfU0VUfSwgYnV0IGdvdCAke3RhZ1NldC50eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ1NlcSA9IHJlYWRUYWcoYnl0ZXMpO1xuICAgICAgICBpZiAodGFnU2VxLnR5cGUgIT09IFRBR19TRVEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc2VxIHRhZyAke1RBR19TRVF9LCBidXQgZ290ICR7dGFnU2VxLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2lkID0gcmVhZE9JRChieXRlcyk7XG4gICAgICAgIGlmIChvaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPSUQgZm9yIGlzc3VlciBvciBzdWJqZWN0IGNhbm5vdCBiZSBOVUxMJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgb2lkOiBvaWQsXG4gICAgICAgICAgICB2YWx1ZTogKDAsIHN0cl9qc18xLmJ5dGVzVG9TdHIpKHJlYWRTdHJpbmcoYnl0ZXMpKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiByZWFkVGltZShieXRlcykge1xuICAgIGNvbnN0IHRhZyA9IHJlYWRUYWcoYnl0ZXMpO1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ2FzY2lpJywgeyBmYXRhbDogdHJ1ZSB9KTtcbiAgICBjb25zdCBzdHIgPSBkZWNvZGVyLmRlY29kZShieXRlcy5yZWFkQnl0ZXModGFnLnNpemUpKTtcbiAgICBsZXQgeWVhcjtcbiAgICBsZXQgbW9uO1xuICAgIGxldCBkYXk7XG4gICAgbGV0IGhvdXI7XG4gICAgbGV0IG1pbjtcbiAgICBsZXQgc2VjO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlYWREaWdpdHMgPSAobnVtRGlnaXRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpZ2l0cyA9IHN0ci5zbGljZShwb3MsIHBvcyArIG51bURpZ2l0cyk7XG4gICAgICAgIGlmICghUkVHRVhfRElHSVRTLnRlc3QoZGlnaXRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke251bURpZ2l0c30gZGVjaW1hbCBkaWdpdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gbnVtRGlnaXRzO1xuICAgICAgICByZXR1cm4gTnVtYmVyKGRpZ2l0cykgfCAwO1xuICAgIH07XG4gICAgc3dpdGNoICh0YWcudHlwZSkge1xuICAgICAgICBjYXNlIFRBR19VVENUSU1FOiB7XG4gICAgICAgICAgICB5ZWFyID0gcmVhZERpZ2l0cygyKTtcbiAgICAgICAgICAgIG1vbiA9IHJlYWREaWdpdHMoMik7XG4gICAgICAgICAgICBkYXkgPSByZWFkRGlnaXRzKDIpO1xuICAgICAgICAgICAgaG91ciA9IHJlYWREaWdpdHMoMik7XG4gICAgICAgICAgICBtaW4gPSByZWFkRGlnaXRzKDIpO1xuICAgICAgICAgICAgc2VjID0gcmVhZERpZ2l0cygyKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIDwgNzApIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gMjAwMCArIHllYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gMTkwMCArIHllYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRBR19HRU5USU1FOiB7XG4gICAgICAgICAgICB5ZWFyID0gcmVhZERpZ2l0cyg0KTtcbiAgICAgICAgICAgIG1vbiA9IHJlYWREaWdpdHMoMik7XG4gICAgICAgICAgICBkYXkgPSByZWFkRGlnaXRzKDIpO1xuICAgICAgICAgICAgaG91ciA9IHJlYWREaWdpdHMoMik7XG4gICAgICAgICAgICBtaW4gPSByZWFkRGlnaXRzKDIpO1xuICAgICAgICAgICAgc2VjID0gcmVhZERpZ2l0cygyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0YWc6ICR7dGFnLnR5cGV9LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBEYXRlLlVUQyh5ZWFyLCBtb24gLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKSAvIDEwMDA7XG59XG5mdW5jdGlvbiByZWFkVmFsaWRpdHkoYnl0ZXMpIHtcbiAgICBieXRlcyA9IG5ldyBieXRlc19qc18xLkJ5dGVzKHJlYWRTZXEoYnl0ZXMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBub3RCZWZvcmU6IHJlYWRUaW1lKGJ5dGVzKSxcbiAgICAgICAgbm90QWZ0ZXI6IHJlYWRUaW1lKGJ5dGVzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZFB1YmtleShieXRlcykge1xuICAgIGJ5dGVzID0gbmV3IGJ5dGVzX2pzXzEuQnl0ZXMocmVhZFNlcShieXRlcykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFsZzogcmVhZEFsZ0lkZW50KGJ5dGVzKSxcbiAgICAgICAgZGF0YTogcmVhZEJpdHN0cihieXRlcyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRUb0JlU2lnbmVkKGJ5dGVzKSB7XG4gICAgY29uc3Qgc3RhcnRJZHggPSBieXRlcy5pZHg7XG4gICAgY29uc3QgdGJzQnl0ZXMgPSBuZXcgYnl0ZXNfanNfMS5CeXRlcyhyZWFkU2VxKGJ5dGVzKSk7XG4gICAgY29uc3QgZW5kSWR4ID0gYnl0ZXMuaWR4O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IHJlYWRWZXJzaW9uKHRic0J5dGVzKSxcbiAgICAgICAgc2VyaWFsOiByZWFkSW50KHRic0J5dGVzKSxcbiAgICAgICAgc2lnQWxnOiByZWFkQWxnSWRlbnQodGJzQnl0ZXMpLFxuICAgICAgICBpc3N1ZXI6IHJlYWRFbnRyaWVzKHRic0J5dGVzKSxcbiAgICAgICAgdmFsaWRpdHk6IHJlYWRWYWxpZGl0eSh0YnNCeXRlcyksXG4gICAgICAgIHN1YmplY3Q6IHJlYWRFbnRyaWVzKHRic0J5dGVzKSxcbiAgICAgICAgcHVia2V5OiByZWFkUHVia2V5KHRic0J5dGVzKSxcbiAgICAgICAgcmF3OiBieXRlcy5kYXRhLnNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpLFxuICAgIH07XG59XG4vKiogUGFyc2UgYSBBU04xIGNlcnRpZmljYXRlIGZyb20gdGhlIGdpdmVuIGJ5dGVzICovXG5mdW5jdGlvbiBwYXJzZUNlcnRSYXcocmF3Q2VydCkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IGJ5dGVzX2pzXzEuQnl0ZXMocmF3Q2VydCk7XG4gICAgY29uc3QgY2VydEJ5dGVzID0gbmV3IGJ5dGVzX2pzXzEuQnl0ZXMocmVhZFNlcShieXRlcykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRiczogcmVhZFRvQmVTaWduZWQoY2VydEJ5dGVzKSxcbiAgICAgICAgc2lnQWxnOiByZWFkQWxnSWRlbnQoY2VydEJ5dGVzKSxcbiAgICAgICAgc2lnOiByZWFkQml0c3RyKGNlcnRCeXRlcyksXG4gICAgICAgIHJhdzogcmF3Q2VydCxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZUNlcnRSYXcgPSBwYXJzZUNlcnRSYXc7XG5mdW5jdGlvbiBwYXJzZUNlcnRQZW0ocGVtKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBSRUdFWF9QRU1fQ0VSVC5leGVjKHBlbSk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gUEVNIGVuY29kZWQgY2VydGlmaWNhdGUgZm91bmQuIEl0IHNob3VsZCBzdGFydCB3aXRoICcgK1xuICAgICAgICAgICAgJ1wiLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXCInKTtcbiAgICB9XG4gICAgY29uc3QgY2VydFJhdyA9IFVpbnQ4QXJyYXkuZnJvbShhdG9iKG1hdGNoWzFdKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xuICAgIHJldHVybiBwYXJzZUNlcnRSYXcoY2VydFJhdyk7XG59XG5leHBvcnRzLnBhcnNlQ2VydFBlbSA9IHBhcnNlQ2VydFBlbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzbjEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///602\n\n}")},674:(g,I,n)=>{"use strict";g.exports=n.p+"6a89f990ac8fedb7cca0.wasm"},749:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{var __webpack_unused_export__;\n/* provided dependency */ var Buffer = __webpack_require__(8287)[\"Buffer\"];\n\n__webpack_unused_export__ = ({ value: true });\nconst sha256_1 = __webpack_require__(2623);\nconst sha512_1 = __webpack_require__(102);\nconst pbkdf2_1 = __webpack_require__(8941);\nconst utils_1 = __webpack_require__(9175);\nconst _wordlists_1 = __webpack_require__(6907);\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' +\n    'Please pass a 2048 word array explicitly.';\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\nfunction lpad(str, padString, length) {\n    while (str.length < length) {\n        str = padString + str;\n    }\n    return str;\n}\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));\n    return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\nfunction salt(password) {\n    return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));\n    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));\n    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {\n        c: 2048,\n        dkLen: 64,\n    });\n    return Buffer.from(res);\n}\n__webpack_unused_export__ = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));\n    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));\n    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {\n        c: 2048,\n        dkLen: 64,\n    }).then((res) => Buffer.from(res));\n}\n__webpack_unused_export__ = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    const words = normalize(mnemonic).split(' ');\n    if (words.length % 3 !== 0) {\n        throw new Error(INVALID_MNEMONIC);\n    }\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map((word) => {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(INVALID_MNEMONIC);\n        }\n        return lpad(index.toString(2), '0', 11);\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    if (entropyBytes.length > 32) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    if (entropyBytes.length % 4 !== 0) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const entropy = Buffer.from(entropyBytes);\n    const newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits) {\n        throw new Error(INVALID_CHECKSUM);\n    }\n    return entropy.toString('hex');\n}\n__webpack_unused_export__ = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy)) {\n        entropy = Buffer.from(entropy, 'hex');\n    }\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    // 128 <= ENT <= 256\n    if (entropy.length < 16) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    if (entropy.length > 32) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    if (entropy.length % 4 !== 0) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    const entropyBits = bytesToBinary(Array.from(entropy));\n    const checksumBits = deriveChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = chunks.map((binary) => {\n        const index = binaryToByte(binary);\n        return wordlist[index];\n    });\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n        ? words.join('\\u3000')\n        : words.join(' ');\n}\n__webpack_unused_export__ = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.we = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.JB = validateMnemonic;\nfunction setDefaultWordlist(language) {\n    const result = _wordlists_1.wordlists[language];\n    if (result) {\n        DEFAULT_WORDLIST = result;\n    }\n    else {\n        throw new Error('Could not find wordlist for language \"' + language + '\"');\n    }\n}\n__webpack_unused_export__ = setDefaultWordlist;\nfunction getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST) {\n        throw new Error('No Default Wordlist set');\n    }\n    return Object.keys(_wordlists_1.wordlists).filter((lang) => {\n        if (lang === 'JA' || lang === 'EN') {\n            return false;\n        }\n        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n    })[0];\n}\n__webpack_unused_export__ = getDefaultWordlist;\nvar _wordlists_2 = __webpack_require__(6907);\nexports.Yu = _wordlists_2.wordlists;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5LmpzIiwibWFwcGluZ3MiOiI7O0FBQWE7QUFDYiw2QkFBNkMsRUFBRSxhQUFhLENBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsSUFBc0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsR0FBc0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsSUFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsSUFBcUI7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsSUFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pELHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLE1BQU07QUFDakI7QUFDQSx5QkFBMEI7QUFDMUI7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRCx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLLGdCQUFnQixNQUFNO0FBQzNCO0FBQ0EseUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUyxNQUFNO0FBQ2Ysa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0EsVUFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUEwQjtBQUMxQixtQkFBbUIsbUJBQU8sQ0FBQyxJQUFjO0FBQ3pDLFVBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9iaXAzOS9zcmMvaW5kZXguanM/MjljOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3Qgc2hhNTEyXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIik7XG5jb25zdCBwYmtkZjJfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3Bia2RmMlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IF93b3JkbGlzdHNfMSA9IHJlcXVpcmUoXCIuL193b3JkbGlzdHNcIik7XG5sZXQgREVGQVVMVF9XT1JETElTVCA9IF93b3JkbGlzdHNfMS5fZGVmYXVsdDtcbmNvbnN0IElOVkFMSURfTU5FTU9OSUMgPSAnSW52YWxpZCBtbmVtb25pYyc7XG5jb25zdCBJTlZBTElEX0VOVFJPUFkgPSAnSW52YWxpZCBlbnRyb3B5JztcbmNvbnN0IElOVkFMSURfQ0hFQ0tTVU0gPSAnSW52YWxpZCBtbmVtb25pYyBjaGVja3N1bSc7XG5jb25zdCBXT1JETElTVF9SRVFVSVJFRCA9ICdBIHdvcmRsaXN0IGlzIHJlcXVpcmVkIGJ1dCBhIGRlZmF1bHQgY291bGQgbm90IGJlIGZvdW5kLlxcbicgK1xuICAgICdQbGVhc2UgcGFzcyBhIDIwNDggd29yZCBhcnJheSBleHBsaWNpdGx5Lic7XG5mdW5jdGlvbiBub3JtYWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIChzdHIgfHwgJycpLm5vcm1hbGl6ZSgnTkZLRCcpO1xufVxuZnVuY3Rpb24gbHBhZChzdHIsIHBhZFN0cmluZywgbGVuZ3RoKSB7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgc3RyID0gcGFkU3RyaW5nICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gYmluYXJ5VG9CeXRlKGJpbikge1xuICAgIHJldHVybiBwYXJzZUludChiaW4sIDIpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0JpbmFyeShieXRlcykge1xuICAgIHJldHVybiBieXRlcy5tYXAoKHgpID0+IGxwYWQoeC50b1N0cmluZygyKSwgJzAnLCA4KSkuam9pbignJyk7XG59XG5mdW5jdGlvbiBkZXJpdmVDaGVja3N1bUJpdHMoZW50cm9weUJ1ZmZlcikge1xuICAgIGNvbnN0IEVOVCA9IGVudHJvcHlCdWZmZXIubGVuZ3RoICogODtcbiAgICBjb25zdCBDUyA9IEVOVCAvIDMyO1xuICAgIGNvbnN0IGhhc2ggPSBzaGEyNTZfMS5zaGEyNTYoVWludDhBcnJheS5mcm9tKGVudHJvcHlCdWZmZXIpKTtcbiAgICByZXR1cm4gYnl0ZXNUb0JpbmFyeShBcnJheS5mcm9tKGhhc2gpKS5zbGljZSgwLCBDUyk7XG59XG5mdW5jdGlvbiBzYWx0KHBhc3N3b3JkKSB7XG4gICAgcmV0dXJuICdtbmVtb25pYycgKyAocGFzc3dvcmQgfHwgJycpO1xufVxuZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzd29yZCkge1xuICAgIGNvbnN0IG1uZW1vbmljQnVmZmVyID0gVWludDhBcnJheS5mcm9tKEJ1ZmZlci5mcm9tKG5vcm1hbGl6ZShtbmVtb25pYyksICd1dGY4JykpO1xuICAgIGNvbnN0IHNhbHRCdWZmZXIgPSBVaW50OEFycmF5LmZyb20oQnVmZmVyLmZyb20oc2FsdChub3JtYWxpemUocGFzc3dvcmQpKSwgJ3V0ZjgnKSk7XG4gICAgY29uc3QgcmVzID0gcGJrZGYyXzEucGJrZGYyKHNoYTUxMl8xLnNoYTUxMiwgbW5lbW9uaWNCdWZmZXIsIHNhbHRCdWZmZXIsIHtcbiAgICAgICAgYzogMjA0OCxcbiAgICAgICAgZGtMZW46IDY0LFxuICAgIH0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXMpO1xufVxuZXhwb3J0cy5tbmVtb25pY1RvU2VlZFN5bmMgPSBtbmVtb25pY1RvU2VlZFN5bmM7XG5mdW5jdGlvbiBtbmVtb25pY1RvU2VlZChtbmVtb25pYywgcGFzc3dvcmQpIHtcbiAgICBjb25zdCBtbmVtb25pY0J1ZmZlciA9IFVpbnQ4QXJyYXkuZnJvbShCdWZmZXIuZnJvbShub3JtYWxpemUobW5lbW9uaWMpLCAndXRmOCcpKTtcbiAgICBjb25zdCBzYWx0QnVmZmVyID0gVWludDhBcnJheS5mcm9tKEJ1ZmZlci5mcm9tKHNhbHQobm9ybWFsaXplKHBhc3N3b3JkKSksICd1dGY4JykpO1xuICAgIHJldHVybiBwYmtkZjJfMS5wYmtkZjJBc3luYyhzaGE1MTJfMS5zaGE1MTIsIG1uZW1vbmljQnVmZmVyLCBzYWx0QnVmZmVyLCB7XG4gICAgICAgIGM6IDIwNDgsXG4gICAgICAgIGRrTGVuOiA2NCxcbiAgICB9KS50aGVuKChyZXMpID0+IEJ1ZmZlci5mcm9tKHJlcykpO1xufVxuZXhwb3J0cy5tbmVtb25pY1RvU2VlZCA9IG1uZW1vbmljVG9TZWVkO1xuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgd29yZGxpc3QgPSB3b3JkbGlzdCB8fCBERUZBVUxUX1dPUkRMSVNUO1xuICAgIGlmICghd29yZGxpc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFdPUkRMSVNUX1JFUVVJUkVEKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZHMgPSBub3JtYWxpemUobW5lbW9uaWMpLnNwbGl0KCcgJyk7XG4gICAgaWYgKHdvcmRzLmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfTU5FTU9OSUMpO1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IHdvcmQgaW5kaWNlcyB0byAxMSBiaXQgYmluYXJ5IHN0cmluZ3NcbiAgICBjb25zdCBiaXRzID0gd29yZHNcbiAgICAgICAgLm1hcCgod29yZCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHdvcmRsaXN0LmluZGV4T2Yod29yZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX01ORU1PTklDKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbHBhZChpbmRleC50b1N0cmluZygyKSwgJzAnLCAxMSk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIC8vIHNwbGl0IHRoZSBiaW5hcnkgc3RyaW5nIGludG8gRU5UL0NTXG4gICAgY29uc3QgZGl2aWRlckluZGV4ID0gTWF0aC5mbG9vcihiaXRzLmxlbmd0aCAvIDMzKSAqIDMyO1xuICAgIGNvbnN0IGVudHJvcHlCaXRzID0gYml0cy5zbGljZSgwLCBkaXZpZGVySW5kZXgpO1xuICAgIGNvbnN0IGNoZWNrc3VtQml0cyA9IGJpdHMuc2xpY2UoZGl2aWRlckluZGV4KTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGNoZWNrc3VtIGFuZCBjb21wYXJlXG4gICAgY29uc3QgZW50cm9weUJ5dGVzID0gZW50cm9weUJpdHMubWF0Y2goLyguezEsOH0pL2cpLm1hcChiaW5hcnlUb0J5dGUpO1xuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgfVxuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgfVxuICAgIGlmIChlbnRyb3B5Qnl0ZXMubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICB9XG4gICAgY29uc3QgZW50cm9weSA9IEJ1ZmZlci5mcm9tKGVudHJvcHlCeXRlcyk7XG4gICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBkZXJpdmVDaGVja3N1bUJpdHMoZW50cm9weSk7XG4gICAgaWYgKG5ld0NoZWNrc3VtICE9PSBjaGVja3N1bUJpdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfQ0hFQ0tTVU0pO1xuICAgIH1cbiAgICByZXR1cm4gZW50cm9weS50b1N0cmluZygnaGV4Jyk7XG59XG5leHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHk7XG5mdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGVudHJvcHkpKSB7XG4gICAgICAgIGVudHJvcHkgPSBCdWZmZXIuZnJvbShlbnRyb3B5LCAnaGV4Jyk7XG4gICAgfVxuICAgIHdvcmRsaXN0ID0gd29yZGxpc3QgfHwgREVGQVVMVF9XT1JETElTVDtcbiAgICBpZiAoIXdvcmRsaXN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihXT1JETElTVF9SRVFVSVJFRCk7XG4gICAgfVxuICAgIC8vIDEyOCA8PSBFTlQgPD0gMjU2XG4gICAgaWYgKGVudHJvcHkubGVuZ3RoIDwgMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihJTlZBTElEX0VOVFJPUFkpO1xuICAgIH1cbiAgICBpZiAoZW50cm9weS5sZW5ndGggPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRU5UUk9QWSk7XG4gICAgfVxuICAgIGlmIChlbnRyb3B5Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihJTlZBTElEX0VOVFJPUFkpO1xuICAgIH1cbiAgICBjb25zdCBlbnRyb3B5Qml0cyA9IGJ5dGVzVG9CaW5hcnkoQXJyYXkuZnJvbShlbnRyb3B5KSk7XG4gICAgY29uc3QgY2hlY2tzdW1CaXRzID0gZGVyaXZlQ2hlY2tzdW1CaXRzKGVudHJvcHkpO1xuICAgIGNvbnN0IGJpdHMgPSBlbnRyb3B5Qml0cyArIGNoZWNrc3VtQml0cztcbiAgICBjb25zdCBjaHVua3MgPSBiaXRzLm1hdGNoKC8oLnsxLDExfSkvZyk7XG4gICAgY29uc3Qgd29yZHMgPSBjaHVua3MubWFwKChiaW5hcnkpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBiaW5hcnlUb0J5dGUoYmluYXJ5KTtcbiAgICAgICAgcmV0dXJuIHdvcmRsaXN0W2luZGV4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gd29yZGxpc3RbMF0gPT09ICdcXHUzMDQyXFx1MzA0NFxcdTMwNTNcXHUzMDRmXFx1MzA1N1xcdTMwOTMnIC8vIEphcGFuZXNlIHdvcmRsaXN0XG4gICAgICAgID8gd29yZHMuam9pbignXFx1MzAwMCcpXG4gICAgICAgIDogd29yZHMuam9pbignICcpO1xufVxuZXhwb3J0cy5lbnRyb3B5VG9NbmVtb25pYyA9IGVudHJvcHlUb01uZW1vbmljO1xuZnVuY3Rpb24gZ2VuZXJhdGVNbmVtb25pYyhzdHJlbmd0aCwgcm5nLCB3b3JkbGlzdCkge1xuICAgIHN0cmVuZ3RoID0gc3RyZW5ndGggfHwgMTI4O1xuICAgIGlmIChzdHJlbmd0aCAlIDMyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoSU5WQUxJRF9FTlRST1BZKTtcbiAgICB9XG4gICAgcm5nID0gcm5nIHx8ICgoc2l6ZSkgPT4gQnVmZmVyLmZyb20odXRpbHNfMS5yYW5kb21CeXRlcyhzaXplKSkpO1xuICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhybmcoc3RyZW5ndGggLyA4KSwgd29yZGxpc3QpO1xufVxuZXhwb3J0cy5nZW5lcmF0ZU1uZW1vbmljID0gZ2VuZXJhdGVNbmVtb25pYztcbmZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMudmFsaWRhdGVNbmVtb25pYyA9IHZhbGlkYXRlTW5lbW9uaWM7XG5mdW5jdGlvbiBzZXREZWZhdWx0V29yZGxpc3QobGFuZ3VhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSBfd29yZGxpc3RzXzEud29yZGxpc3RzW2xhbmd1YWdlXTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIERFRkFVTFRfV09SRExJU1QgPSByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHdvcmRsaXN0IGZvciBsYW5ndWFnZSBcIicgKyBsYW5ndWFnZSArICdcIicpO1xuICAgIH1cbn1cbmV4cG9ydHMuc2V0RGVmYXVsdFdvcmRsaXN0ID0gc2V0RGVmYXVsdFdvcmRsaXN0O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFdvcmRsaXN0KCkge1xuICAgIGlmICghREVGQVVMVF9XT1JETElTVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIERlZmF1bHQgV29yZGxpc3Qgc2V0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhfd29yZGxpc3RzXzEud29yZGxpc3RzKS5maWx0ZXIoKGxhbmcpID0+IHtcbiAgICAgICAgaWYgKGxhbmcgPT09ICdKQScgfHwgbGFuZyA9PT0gJ0VOJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfd29yZGxpc3RzXzEud29yZGxpc3RzW2xhbmddLmV2ZXJ5KCh3b3JkLCBpbmRleCkgPT4gd29yZCA9PT0gREVGQVVMVF9XT1JETElTVFtpbmRleF0pO1xuICAgIH0pWzBdO1xufVxuZXhwb3J0cy5nZXREZWZhdWx0V29yZGxpc3QgPSBnZXREZWZhdWx0V29yZGxpc3Q7XG52YXIgX3dvcmRsaXN0c18yID0gcmVxdWlyZShcIi4vX3dvcmRsaXN0c1wiKTtcbmV4cG9ydHMud29yZGxpc3RzID0gX3dvcmRsaXN0c18yLndvcmRsaXN0cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///749\n\n}")},818:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = __webpack_require__(3449);\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = __webpack_require__(3610);\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, "base64");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsSUFBVTtBQUMvQjs7QUFFQSxXQUFXLG1CQUFPLENBQUMsSUFBZ0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanM/ZGM2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xuXG4vLyBleHRlbmRzIFdyaXRlclxudmFyIFdyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbihCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbn1cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlclxuICAgICAqL1xuICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcblxuICAgIEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyID0gdXRpbC5CdWZmZXIgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCJcbiAgICAgICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGZhc3RlciB0aGFuIGNvcHkgKHJlcXVpcmVzIG5vZGUgPj0gNCB3aGVyZSBCdWZmZXJzIGV4dGVuZCBVaW50OEFycmF5IGFuZCBzZXQgaXMgcHJvcGVybHkgaW5oZXJpdGVkKVxuICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9jb3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBpZiAodmFsLmNvcHkpIC8vIEJ1ZmZlciB2YWx1ZXNcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDspIC8vIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xuICAgICAgICB9O1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXNfYnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaChCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPCA0MCkgLy8gcGxhaW4ganMgaXMgZmFzdGVyIGZvciBzaG9ydCBzdHJpbmdzIChwcm9iYWJseSBkdWUgdG8gcmVkdW5kYW50IGFzc2VydGlvbnMpXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcbiAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcbiAgICBlbHNlXG4gICAgICAgIGJ1Zi53cml0ZSh2YWwsIHBvcyk7XG59XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGlsLkJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAbmFtZSBCdWZmZXJXcml0ZXIjZmluaXNoXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///818\n\n}')},932:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.copyTxOutput = exports.copyTxInput = exports.writeTxOutput = exports.writeTxInput = exports.writeOutPoint = exports.readTxOutput = exports.Tx = exports.DEFAULT_TX_VERSION = exports.DEFAULT_SEQUENCE = void 0;\nconst bytes_js_1 = __webpack_require__(1292);\nconst hex_js_1 = __webpack_require__(2938);\nconst varsize_js_1 = __webpack_require__(1451);\nconst writerbytes_js_1 = __webpack_require__(8161);\nconst writerlength_js_1 = __webpack_require__(7408);\nconst script_js_1 = __webpack_require__(6187);\nconst hash_js_1 = __webpack_require__(5632);\n/**\n * Default value for nSequence of inputs if left undefined; this opts out of\n * BIP68 relative lock-time, and if all inputs have this value, nLockTime is\n * disabled, too.\n *\n * This is chosen as the default as it's the default in the node too,\n * see CTxIn in /src/primitives/transaction.h.\n **/\nexports.DEFAULT_SEQUENCE = 0xffffffff;\n/** Current tx version, see CTransaction in /stc/primitives/transaction.h */\nexports.DEFAULT_TX_VERSION = 2;\n/** CTransaction, a Bitcoin transaction. */\nclass Tx {\n    constructor(params) {\n        this.version = params?.version ?? exports.DEFAULT_TX_VERSION;\n        this.inputs = params?.inputs ?? [];\n        this.outputs = params?.outputs ?? [];\n        this.locktime = params?.locktime ?? 0;\n    }\n    /** Serialize the tx to a byte array */\n    ser() {\n        const writerBytes = new writerbytes_js_1.WriterBytes(this.serSize());\n        this.write(writerBytes);\n        return writerBytes.data;\n    }\n    /** Serialize the tx to a hex string */\n    toHex() {\n        return (0, hex_js_1.toHex)(this.ser());\n    }\n    /** Calculate the serialized size of the tx */\n    serSize() {\n        const writerLength = new writerlength_js_1.WriterLength();\n        this.write(writerLength);\n        return writerLength.length;\n    }\n    /** Write the tx to the given writer */\n    write(writer) {\n        writer.putU32(this.version);\n        (0, varsize_js_1.writeVarSize)(this.inputs.length, writer);\n        for (const input of this.inputs) {\n            writeTxInput(input, writer);\n        }\n        (0, varsize_js_1.writeVarSize)(this.outputs.length, writer);\n        for (const output of this.outputs) {\n            writeTxOutput(output, writer);\n        }\n        writer.putU32(this.locktime);\n    }\n    /** Deserialize a Tx from a Uint8Array */\n    static deser(data) {\n        const bytes = new bytes_js_1.Bytes(data);\n        const version = bytes.readU32();\n        const numInputs = (0, varsize_js_1.readVarSize)(bytes);\n        const inputs = [];\n        for (let i = 0; i < numInputs; ++i) {\n            // Read OutPoint\n            const txid = bytes.readBytes(32);\n            const outIdx = bytes.readU32();\n            // Read script\n            const script = script_js_1.Script.readWithSize(bytes);\n            // Read sequence\n            const sequence = bytes.readU32();\n            inputs.push({\n                prevOut: {\n                    txid,\n                    outIdx,\n                },\n                script,\n                sequence,\n            });\n        }\n        const numOutputs = (0, varsize_js_1.readVarSize)(bytes);\n        const outputs = [];\n        for (let i = 0; i < numOutputs; ++i) {\n            outputs.push(readTxOutput(bytes));\n        }\n        const locktime = bytes.readU32();\n        return new Tx({\n            version,\n            inputs,\n            outputs,\n            locktime,\n        });\n    }\n    /** Deserialize a Tx from a hex string */\n    static fromHex(hex) {\n        return Tx.deser((0, hex_js_1.fromHex)(hex));\n    }\n    /**\n     * Compute the transaction ID (TxId) as a hex string (little-endian).\n     * This follows the eCash convention: the TxId is the double SHA256 of the\n     * serialized transaction, returned as a hex string in little-endian (reversed) order.\n     * See the node src/primitives/txid.h for more details.\n     */\n    txid() {\n        return (0, hex_js_1.toHexRev)((0, hash_js_1.sha256d)(this.ser()));\n    }\n}\nexports.Tx = Tx;\nfunction readTxOutput(bytes) {\n    const sats = bytes.readU64();\n    const script = script_js_1.Script.readWithSize(bytes);\n    return {\n        sats,\n        script,\n    };\n}\nexports.readTxOutput = readTxOutput;\n/** Write an outpoint to a Writer */\nfunction writeOutPoint(outpoint, writer) {\n    const txid = typeof outpoint.txid === 'string'\n        ? (0, hex_js_1.fromHexRev)(outpoint.txid)\n        : outpoint.txid;\n    writer.putBytes(txid);\n    writer.putU32(outpoint.outIdx);\n}\nexports.writeOutPoint = writeOutPoint;\n/** Write a TxInput to a Writer */\nfunction writeTxInput(input, writer) {\n    writeOutPoint(input.prevOut, writer);\n    (input.script ?? new script_js_1.Script()).writeWithSize(writer);\n    writer.putU32(input.sequence ?? exports.DEFAULT_SEQUENCE);\n}\nexports.writeTxInput = writeTxInput;\n/** Write a TxOutput to a Writer */\nfunction writeTxOutput(output, writer) {\n    writer.putU64(output.sats);\n    output.script.writeWithSize(writer);\n}\nexports.writeTxOutput = writeTxOutput;\n/** Create a deep copy of the TxInput */\nfunction copyTxInput(input) {\n    return {\n        prevOut: {\n            txid: typeof input.prevOut.txid === 'string'\n                ? input.prevOut.txid\n                : new Uint8Array(input.prevOut.txid),\n            outIdx: input.prevOut.outIdx,\n        },\n        script: input.script?.copy(),\n        sequence: input.sequence,\n        signData: input.signData && {\n            sats: input.signData.sats,\n            outputScript: input.signData.outputScript?.copy(),\n            redeemScript: input.signData.redeemScript?.copy(),\n        },\n    };\n}\nexports.copyTxInput = copyTxInput;\n/** Create a deep copy of the TxOutput */\nfunction copyTxOutput(output) {\n    return {\n        sats: output.sats,\n        script: output.script.copy(),\n    };\n}\nexports.copyTxOutput = copyTxOutput;\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLFVBQVUsR0FBRywwQkFBMEIsR0FBRyx3QkFBd0I7QUFDN00sbUJBQW1CLG1CQUFPLENBQUMsSUFBZTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFhO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLElBQWlCO0FBQzlDLHlCQUF5QixtQkFBTyxDQUFDLElBQXFCO0FBQ3RELDBCQUEwQixtQkFBTyxDQUFDLElBQXNCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLElBQWE7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsSUFBVztBQUNyQztBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvdHguanM/ODA2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvcHlUeE91dHB1dCA9IGV4cG9ydHMuY29weVR4SW5wdXQgPSBleHBvcnRzLndyaXRlVHhPdXRwdXQgPSBleHBvcnRzLndyaXRlVHhJbnB1dCA9IGV4cG9ydHMud3JpdGVPdXRQb2ludCA9IGV4cG9ydHMucmVhZFR4T3V0cHV0ID0gZXhwb3J0cy5UeCA9IGV4cG9ydHMuREVGQVVMVF9UWF9WRVJTSU9OID0gZXhwb3J0cy5ERUZBVUxUX1NFUVVFTkNFID0gdm9pZCAwO1xuY29uc3QgYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuL2lvL2J5dGVzLmpzXCIpO1xuY29uc3QgaGV4X2pzXzEgPSByZXF1aXJlKFwiLi9pby9oZXguanNcIik7XG5jb25zdCB2YXJzaXplX2pzXzEgPSByZXF1aXJlKFwiLi9pby92YXJzaXplLmpzXCIpO1xuY29uc3Qgd3JpdGVyYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuL2lvL3dyaXRlcmJ5dGVzLmpzXCIpO1xuY29uc3Qgd3JpdGVybGVuZ3RoX2pzXzEgPSByZXF1aXJlKFwiLi9pby93cml0ZXJsZW5ndGguanNcIik7XG5jb25zdCBzY3JpcHRfanNfMSA9IHJlcXVpcmUoXCIuL3NjcmlwdC5qc1wiKTtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCIuL2hhc2guanNcIik7XG4vKipcbiAqIERlZmF1bHQgdmFsdWUgZm9yIG5TZXF1ZW5jZSBvZiBpbnB1dHMgaWYgbGVmdCB1bmRlZmluZWQ7IHRoaXMgb3B0cyBvdXQgb2ZcbiAqIEJJUDY4IHJlbGF0aXZlIGxvY2stdGltZSwgYW5kIGlmIGFsbCBpbnB1dHMgaGF2ZSB0aGlzIHZhbHVlLCBuTG9ja1RpbWUgaXNcbiAqIGRpc2FibGVkLCB0b28uXG4gKlxuICogVGhpcyBpcyBjaG9zZW4gYXMgdGhlIGRlZmF1bHQgYXMgaXQncyB0aGUgZGVmYXVsdCBpbiB0aGUgbm9kZSB0b28sXG4gKiBzZWUgQ1R4SW4gaW4gL3NyYy9wcmltaXRpdmVzL3RyYW5zYWN0aW9uLmguXG4gKiovXG5leHBvcnRzLkRFRkFVTFRfU0VRVUVOQ0UgPSAweGZmZmZmZmZmO1xuLyoqIEN1cnJlbnQgdHggdmVyc2lvbiwgc2VlIENUcmFuc2FjdGlvbiBpbiAvc3RjL3ByaW1pdGl2ZXMvdHJhbnNhY3Rpb24uaCAqL1xuZXhwb3J0cy5ERUZBVUxUX1RYX1ZFUlNJT04gPSAyO1xuLyoqIENUcmFuc2FjdGlvbiwgYSBCaXRjb2luIHRyYW5zYWN0aW9uLiAqL1xuY2xhc3MgVHgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBwYXJhbXM/LnZlcnNpb24gPz8gZXhwb3J0cy5ERUZBVUxUX1RYX1ZFUlNJT047XG4gICAgICAgIHRoaXMuaW5wdXRzID0gcGFyYW1zPy5pbnB1dHMgPz8gW107XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IHBhcmFtcz8ub3V0cHV0cyA/PyBbXTtcbiAgICAgICAgdGhpcy5sb2NrdGltZSA9IHBhcmFtcz8ubG9ja3RpbWUgPz8gMDtcbiAgICB9XG4gICAgLyoqIFNlcmlhbGl6ZSB0aGUgdHggdG8gYSBieXRlIGFycmF5ICovXG4gICAgc2VyKCkge1xuICAgICAgICBjb25zdCB3cml0ZXJCeXRlcyA9IG5ldyB3cml0ZXJieXRlc19qc18xLldyaXRlckJ5dGVzKHRoaXMuc2VyU2l6ZSgpKTtcbiAgICAgICAgdGhpcy53cml0ZSh3cml0ZXJCeXRlcyk7XG4gICAgICAgIHJldHVybiB3cml0ZXJCeXRlcy5kYXRhO1xuICAgIH1cbiAgICAvKiogU2VyaWFsaXplIHRoZSB0eCB0byBhIGhleCBzdHJpbmcgKi9cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBoZXhfanNfMS50b0hleCkodGhpcy5zZXIoKSk7XG4gICAgfVxuICAgIC8qKiBDYWxjdWxhdGUgdGhlIHNlcmlhbGl6ZWQgc2l6ZSBvZiB0aGUgdHggKi9cbiAgICBzZXJTaXplKCkge1xuICAgICAgICBjb25zdCB3cml0ZXJMZW5ndGggPSBuZXcgd3JpdGVybGVuZ3RoX2pzXzEuV3JpdGVyTGVuZ3RoKCk7XG4gICAgICAgIHRoaXMud3JpdGUod3JpdGVyTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlckxlbmd0aC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKiBXcml0ZSB0aGUgdHggdG8gdGhlIGdpdmVuIHdyaXRlciAqL1xuICAgIHdyaXRlKHdyaXRlcikge1xuICAgICAgICB3cml0ZXIucHV0VTMyKHRoaXMudmVyc2lvbik7XG4gICAgICAgICgwLCB2YXJzaXplX2pzXzEud3JpdGVWYXJTaXplKSh0aGlzLmlucHV0cy5sZW5ndGgsIHdyaXRlcik7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgICAgIHdyaXRlVHhJbnB1dChpbnB1dCwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdmFyc2l6ZV9qc18xLndyaXRlVmFyU2l6ZSkodGhpcy5vdXRwdXRzLmxlbmd0aCwgd3JpdGVyKTtcbiAgICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2YgdGhpcy5vdXRwdXRzKSB7XG4gICAgICAgICAgICB3cml0ZVR4T3V0cHV0KG91dHB1dCwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIucHV0VTMyKHRoaXMubG9ja3RpbWUpO1xuICAgIH1cbiAgICAvKiogRGVzZXJpYWxpemUgYSBUeCBmcm9tIGEgVWludDhBcnJheSAqL1xuICAgIHN0YXRpYyBkZXNlcihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IGJ5dGVzX2pzXzEuQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBieXRlcy5yZWFkVTMyKCk7XG4gICAgICAgIGNvbnN0IG51bUlucHV0cyA9ICgwLCB2YXJzaXplX2pzXzEucmVhZFZhclNpemUpKGJ5dGVzKTtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5wdXRzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIFJlYWQgT3V0UG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHR4aWQgPSBieXRlcy5yZWFkQnl0ZXMoMzIpO1xuICAgICAgICAgICAgY29uc3Qgb3V0SWR4ID0gYnl0ZXMucmVhZFUzMigpO1xuICAgICAgICAgICAgLy8gUmVhZCBzY3JpcHRcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IHNjcmlwdF9qc18xLlNjcmlwdC5yZWFkV2l0aFNpemUoYnl0ZXMpO1xuICAgICAgICAgICAgLy8gUmVhZCBzZXF1ZW5jZVxuICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2UgPSBieXRlcy5yZWFkVTMyKCk7XG4gICAgICAgICAgICBpbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcHJldk91dDoge1xuICAgICAgICAgICAgICAgICAgICB0eGlkLFxuICAgICAgICAgICAgICAgICAgICBvdXRJZHgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY3JpcHQsXG4gICAgICAgICAgICAgICAgc2VxdWVuY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1PdXRwdXRzID0gKDAsIHZhcnNpemVfanNfMS5yZWFkVmFyU2l6ZSkoYnl0ZXMpO1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT3V0cHV0czsgKytpKSB7XG4gICAgICAgICAgICBvdXRwdXRzLnB1c2gocmVhZFR4T3V0cHV0KGJ5dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9ja3RpbWUgPSBieXRlcy5yZWFkVTMyKCk7XG4gICAgICAgIHJldHVybiBuZXcgVHgoe1xuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBsb2NrdGltZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBEZXNlcmlhbGl6ZSBhIFR4IGZyb20gYSBoZXggc3RyaW5nICovXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBUeC5kZXNlcigoMCwgaGV4X2pzXzEuZnJvbUhleCkoaGV4KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHRyYW5zYWN0aW9uIElEIChUeElkKSBhcyBhIGhleCBzdHJpbmcgKGxpdHRsZS1lbmRpYW4pLlxuICAgICAqIFRoaXMgZm9sbG93cyB0aGUgZUNhc2ggY29udmVudGlvbjogdGhlIFR4SWQgaXMgdGhlIGRvdWJsZSBTSEEyNTYgb2YgdGhlXG4gICAgICogc2VyaWFsaXplZCB0cmFuc2FjdGlvbiwgcmV0dXJuZWQgYXMgYSBoZXggc3RyaW5nIGluIGxpdHRsZS1lbmRpYW4gKHJldmVyc2VkKSBvcmRlci5cbiAgICAgKiBTZWUgdGhlIG5vZGUgc3JjL3ByaW1pdGl2ZXMvdHhpZC5oIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgdHhpZCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBoZXhfanNfMS50b0hleFJldikoKDAsIGhhc2hfanNfMS5zaGEyNTZkKSh0aGlzLnNlcigpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UeCA9IFR4O1xuZnVuY3Rpb24gcmVhZFR4T3V0cHV0KGJ5dGVzKSB7XG4gICAgY29uc3Qgc2F0cyA9IGJ5dGVzLnJlYWRVNjQoKTtcbiAgICBjb25zdCBzY3JpcHQgPSBzY3JpcHRfanNfMS5TY3JpcHQucmVhZFdpdGhTaXplKGJ5dGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzYXRzLFxuICAgICAgICBzY3JpcHQsXG4gICAgfTtcbn1cbmV4cG9ydHMucmVhZFR4T3V0cHV0ID0gcmVhZFR4T3V0cHV0O1xuLyoqIFdyaXRlIGFuIG91dHBvaW50IHRvIGEgV3JpdGVyICovXG5mdW5jdGlvbiB3cml0ZU91dFBvaW50KG91dHBvaW50LCB3cml0ZXIpIHtcbiAgICBjb25zdCB0eGlkID0gdHlwZW9mIG91dHBvaW50LnR4aWQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gKDAsIGhleF9qc18xLmZyb21IZXhSZXYpKG91dHBvaW50LnR4aWQpXG4gICAgICAgIDogb3V0cG9pbnQudHhpZDtcbiAgICB3cml0ZXIucHV0Qnl0ZXModHhpZCk7XG4gICAgd3JpdGVyLnB1dFUzMihvdXRwb2ludC5vdXRJZHgpO1xufVxuZXhwb3J0cy53cml0ZU91dFBvaW50ID0gd3JpdGVPdXRQb2ludDtcbi8qKiBXcml0ZSBhIFR4SW5wdXQgdG8gYSBXcml0ZXIgKi9cbmZ1bmN0aW9uIHdyaXRlVHhJbnB1dChpbnB1dCwgd3JpdGVyKSB7XG4gICAgd3JpdGVPdXRQb2ludChpbnB1dC5wcmV2T3V0LCB3cml0ZXIpO1xuICAgIChpbnB1dC5zY3JpcHQgPz8gbmV3IHNjcmlwdF9qc18xLlNjcmlwdCgpKS53cml0ZVdpdGhTaXplKHdyaXRlcik7XG4gICAgd3JpdGVyLnB1dFUzMihpbnB1dC5zZXF1ZW5jZSA/PyBleHBvcnRzLkRFRkFVTFRfU0VRVUVOQ0UpO1xufVxuZXhwb3J0cy53cml0ZVR4SW5wdXQgPSB3cml0ZVR4SW5wdXQ7XG4vKiogV3JpdGUgYSBUeE91dHB1dCB0byBhIFdyaXRlciAqL1xuZnVuY3Rpb24gd3JpdGVUeE91dHB1dChvdXRwdXQsIHdyaXRlcikge1xuICAgIHdyaXRlci5wdXRVNjQob3V0cHV0LnNhdHMpO1xuICAgIG91dHB1dC5zY3JpcHQud3JpdGVXaXRoU2l6ZSh3cml0ZXIpO1xufVxuZXhwb3J0cy53cml0ZVR4T3V0cHV0ID0gd3JpdGVUeE91dHB1dDtcbi8qKiBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgdGhlIFR4SW5wdXQgKi9cbmZ1bmN0aW9uIGNvcHlUeElucHV0KGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJldk91dDoge1xuICAgICAgICAgICAgdHhpZDogdHlwZW9mIGlucHV0LnByZXZPdXQudHhpZCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGlucHV0LnByZXZPdXQudHhpZFxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoaW5wdXQucHJldk91dC50eGlkKSxcbiAgICAgICAgICAgIG91dElkeDogaW5wdXQucHJldk91dC5vdXRJZHgsXG4gICAgICAgIH0sXG4gICAgICAgIHNjcmlwdDogaW5wdXQuc2NyaXB0Py5jb3B5KCksXG4gICAgICAgIHNlcXVlbmNlOiBpbnB1dC5zZXF1ZW5jZSxcbiAgICAgICAgc2lnbkRhdGE6IGlucHV0LnNpZ25EYXRhICYmIHtcbiAgICAgICAgICAgIHNhdHM6IGlucHV0LnNpZ25EYXRhLnNhdHMsXG4gICAgICAgICAgICBvdXRwdXRTY3JpcHQ6IGlucHV0LnNpZ25EYXRhLm91dHB1dFNjcmlwdD8uY29weSgpLFxuICAgICAgICAgICAgcmVkZWVtU2NyaXB0OiBpbnB1dC5zaWduRGF0YS5yZWRlZW1TY3JpcHQ/LmNvcHkoKSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5jb3B5VHhJbnB1dCA9IGNvcHlUeElucHV0O1xuLyoqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGUgVHhPdXRwdXQgKi9cbmZ1bmN0aW9uIGNvcHlUeE91dHB1dChvdXRwdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzYXRzOiBvdXRwdXQuc2F0cyxcbiAgICAgICAgc2NyaXB0OiBvdXRwdXQuc2NyaXB0LmNvcHkoKSxcbiAgICB9O1xufVxuZXhwb3J0cy5jb3B5VHhPdXRwdXQgPSBjb3B5VHhPdXRwdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///932\n\n}")},1113:module=>{"use strict";eval("{\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTExMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcz8xZGRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1113\n\n}")},1199:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\n// Copyright (c) 2023-2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FailoverProxy = exports.appendWsUrls = void 0;\nconst axios_1 = __importDefault(__webpack_require__(6425));\nconst isomorphic_ws_1 = __importDefault(__webpack_require__(169));\nconst proto = __importStar(__webpack_require__(8331));\nconst WEBSOCKET_TIMEOUT_MS = 5000;\n// Converts an array of chronik http/https urls into\n// websocket equivalents and combines them into an object array\nfunction appendWsUrls(urls) {\n    const combinedUrls = [];\n    for (const thisUrl of urls) {\n        if (thisUrl.startsWith('https://')) {\n            combinedUrls.push({\n                url: thisUrl,\n                wsUrl: 'wss://' + thisUrl.substring('https://'.length) + '/ws',\n            });\n        }\n        else if (thisUrl.startsWith('http://')) {\n            combinedUrls.push({\n                url: thisUrl,\n                wsUrl: 'ws://' + thisUrl.substring('http://'.length) + '/ws',\n            });\n        }\n        else {\n            throw new Error(`Invalid url found in array: ${thisUrl}`);\n        }\n    }\n    return combinedUrls;\n}\nexports.appendWsUrls = appendWsUrls;\n/**\n * Handles the networking to Chronik `Endpoint`s, including cycling\n * through both types of endpoints.\n */\nclass FailoverProxy {\n    constructor(urls) {\n        // Validate url input\n        const urlsArray = typeof urls === 'string' ? [urls] : urls;\n        if (urlsArray.length === 0) {\n            throw new Error('Url array must not be empty');\n        }\n        // Validate each entry in the url array\n        for (const url of urlsArray) {\n            if (url.endsWith('/')) {\n                throw new Error(\"`url` cannot end with '/', got: \" + url);\n            }\n            if (!url.startsWith('https://') && !url.startsWith('http://')) {\n                throw new Error(\"`url` must start with 'https://' or 'http://', got: \" +\n                    url);\n            }\n        }\n        // Initializes _endpointArray with an object Array containing\n        // 'url' and 'wsUrl' props\n        this._endpointArray = appendWsUrls(urlsArray);\n        this._workingIndex = 0;\n    }\n    // For unit test verification\n    getEndpointArray() {\n        return this._endpointArray;\n    }\n    // Derives the endpoint array index based on _workingIndex\n    // This is set to public for unit testing purposes\n    deriveEndpointIndex(loopIndex) {\n        return (this._workingIndex + loopIndex) % this._endpointArray.length;\n    }\n    // Overriding working index for unit testing purposes\n    setWorkingIndex(newIndex) {\n        this._workingIndex = newIndex;\n    }\n    async post(path, data) {\n        return this._request(path, 'POST', data);\n    }\n    async get(path) {\n        return this._request(path, 'GET');\n    }\n    /**\n     * Returns a Get or POST axios response from the Chronik indexer\n     *\n     * @param {string} path the path to the Chronik API endpoint\n     * @param {string} requestType the flag indicating whether this is a get or post request\n     * @param {string} data the optional axios request data specific to post requests\n     * @returns {Uint8Array} returns the axios response data from Chronik\n     * @throws {error} throws error on non-responsive server or valid error responses\n     */\n    async _request(path, requestType, data) {\n        // Cycle through known Chronik instances\n        for (let i = 0; i < this._endpointArray.length; i += 1) {\n            const index = this.deriveEndpointIndex(i);\n            const thisProxyUrl = this._endpointArray[index].url;\n            try {\n                const response = await this._callAxios(thisProxyUrl, path, requestType, data);\n                // If no errors thrown in the above call then set this index to state\n                this._workingIndex = index;\n                return response;\n            }\n            catch (err) {\n                if (err instanceof Error &&\n                    ('code' in err ||\n                        err\n                            .toString()\n                            .includes('Unable to decode error msg, chronik server is indexing or in error state') ||\n                        // We can see this type of error msg from an indexing server\n                        // Observed when a chronik node is down (e.g. bitcoin-cli stop) but\n                        // server is reachable, nginx running\n                        err.toString().trim().endsWith(':'))) {\n                    // Server outage, skip to next url in loop\n                    // Connection error msgs have a 'code' key of 'ECONNREFUSED'\n                    // Error messages from the chronik server (i.e. error\n                    // messages that should not trigger a 'try next server'\n                    // attempt) are of the chronik proto Error type, which has no 'code' key\n                    continue;\n                }\n                // Throw upon all other valid error responses from chronik\n                throw err;\n            }\n        }\n        // All known Chronik instances have not been responsive\n        throw new Error(`Error connecting to known Chronik instances`);\n    }\n    /**\n     * Calls axios for a GET or POST response\n     *\n     * @param {string} url the singular chronik url\n     * @param {string} path the path to the Chronik API endpoint\n     * @param {string} requestType the flag indicating whether this is a get or post request\n     * @param {string} data the optional axios request data for post requests\n     * @returns {Uint8Array} returns the axios response data from Chronik\n     * @throws {error} throws error on non-responsive server or valid error responses\n     */\n    async _callAxios(url, path, requestType, data) {\n        let response;\n        if (requestType === 'GET') {\n            response = await axios_1.default.get(`${url}${path}`, {\n                responseType: 'arraybuffer',\n                validateStatus: undefined,\n            });\n        }\n        else if (requestType === 'POST') {\n            response = await axios_1.default.post(`${url}${path}`, data, {\n                responseType: 'arraybuffer',\n                validateStatus: undefined,\n                // Prevents Axios encoding the Uint8Array as JSON or something\n                transformRequest: x => x,\n                headers: {\n                    'Content-Type': 'application/x-protobuf',\n                },\n            });\n        }\n        else {\n            throw new Error('Impossible by types');\n        }\n        // Parse for valid error responses (e.g. txid not found)\n        this.ensureResponseErrorThrown(response, path);\n        return new Uint8Array(response.data);\n    }\n    ensureResponseErrorThrown(response, path) {\n        if (response.status != 200) {\n            let errorCanBeDecoded = false;\n            let error;\n            try {\n                // If we can decode this error with proto, it is an expected chronik error\n                // from a working server and we should return it to the user\n                error = proto.Error.decode(new Uint8Array(response.data));\n                errorCanBeDecoded = true;\n            }\n            catch {\n                // If we can't decode this error with proto, something is wrong with this server instance\n                // It may be indexing\n                // In this case, we should try the next server\n                throw new Error('Unable to decode error msg, chronik server is indexing or in error state');\n            }\n            if (errorCanBeDecoded) {\n                throw new Error(`Failed getting ${path}: ${error.msg}`);\n            }\n        }\n    }\n    /**\n     * Check if a given websocket URL connects\n     * Note: As of 20231110 there is no msg from chronik server confirming a connection to chronik\n     * We would have to wait for a block or a transaction, which is impractical here\n     * So, this is only testing whether or not a given URL is a live websocket or not\n     * @param {string} wsUrl\n     * @returns {bool}\n     */\n    async _websocketUrlConnects(wsUrl) {\n        return new Promise(resolve => {\n            // If we do not connect in appropriate timeframe,\n            // call it a failure and try the next websocket\n            const timeoutFailure = setTimeout(() => {\n                testWs.close();\n                resolve(false);\n            }, WEBSOCKET_TIMEOUT_MS);\n            const testWs = new isomorphic_ws_1.default(wsUrl);\n            testWs.onerror = function () {\n                testWs.close();\n                clearTimeout(timeoutFailure);\n                return resolve(false);\n            };\n            testWs.onopen = function () {\n                testWs.close();\n                clearTimeout(timeoutFailure);\n                return resolve(true);\n            };\n        }).catch(() => {\n            return false;\n        });\n    }\n    // Iterates through available websocket urls and attempts connection.\n    // Upon a successful connection it handles the various websocket callbacks.\n    // Upon an unsuccessful connection it iterates to the next websocket url in the array.\n    async connectWs(wsEndpoint) {\n        for (let i = 0; i < this._endpointArray.length; i += 1) {\n            const index = this.deriveEndpointIndex(i);\n            const thisProxyWsUrl = this._endpointArray[index].wsUrl;\n            const websocketUrlConnects = await this._websocketUrlConnects(thisProxyWsUrl);\n            if (websocketUrlConnects) {\n                // Set this index to state\n                this._workingIndex = index;\n                const ws = new isomorphic_ws_1.default(thisProxyWsUrl);\n                ws.onmessage = e => wsEndpoint.handleMsg(e);\n                ws.onerror = () => {\n                    if (wsEndpoint.onError !== undefined) {\n                        wsEndpoint.close();\n                    }\n                };\n                ws.onclose = e => {\n                    // End if manually closed or no auto-reconnect\n                    if (wsEndpoint.manuallyClosed ||\n                        !wsEndpoint.autoReconnect) {\n                        if (wsEndpoint.onEnd !== undefined) {\n                            wsEndpoint.onEnd(e);\n                        }\n                        return;\n                    }\n                    if (wsEndpoint.onReconnect !== undefined) {\n                        wsEndpoint.onReconnect(e);\n                    }\n                    this._workingIndex =\n                        (this._workingIndex + 1) % this._endpointArray.length;\n                    this.connectWs(wsEndpoint);\n                };\n                wsEndpoint.ws = ws;\n                wsEndpoint.connected = new Promise(resolve => {\n                    ws.onopen = msg => {\n                        // Subscribe to all previously-subscribed scripts\n                        wsEndpoint.subs.scripts.forEach(sub => wsEndpoint.subscribeToScript(sub.scriptType, sub.payload));\n                        // Subscribe to all previously-subscribed lokadIds\n                        wsEndpoint.subs.lokadIds.forEach(lokadId => wsEndpoint.subscribeToLokadId(lokadId));\n                        // Subscribe to all previously-subscribed tokenIds\n                        wsEndpoint.subs.tokens.forEach(tokenId => wsEndpoint.subscribeToTokenId(tokenId));\n                        // Subscribe to all previously-subscribed txids\n                        wsEndpoint.subs.txids.forEach(txid => wsEndpoint.subscribeToTxid(txid));\n                        // Subscribe to blocks method, if previously subscribed\n                        if (wsEndpoint.subs.blocks === true) {\n                            wsEndpoint.subscribeToBlocks();\n                        }\n                        resolve(msg);\n                        if (wsEndpoint.onConnect !== undefined) {\n                            wsEndpoint.onConnect(msg);\n                        }\n                        // If no errors thrown from above call then set this index to state\n                        this._workingIndex = index;\n                    };\n                });\n                return;\n            }\n        }\n        // If no websocket URLs connect, throw error\n        throw new Error(`Error connecting to known Chronik websockets`);\n    }\n}\nexports.FailoverProxy = FailoverProxy;\n//# sourceMappingURL=failoverProxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9jaHJvbmlrLWNsaWVudC9kaXN0L3NyYy9mYWlsb3ZlclByb3h5LmpzPzlhZWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjMtMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFpbG92ZXJQcm94eSA9IGV4cG9ydHMuYXBwZW5kV3NVcmxzID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuY29uc3QgaXNvbW9ycGhpY193c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpc29tb3JwaGljLXdzXCIpKTtcbmNvbnN0IHByb3RvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9wcm90by9jaHJvbmlrXCIpKTtcbmNvbnN0IFdFQlNPQ0tFVF9USU1FT1VUX01TID0gNTAwMDtcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNocm9uaWsgaHR0cC9odHRwcyB1cmxzIGludG9cbi8vIHdlYnNvY2tldCBlcXVpdmFsZW50cyBhbmQgY29tYmluZXMgdGhlbSBpbnRvIGFuIG9iamVjdCBhcnJheVxuZnVuY3Rpb24gYXBwZW5kV3NVcmxzKHVybHMpIHtcbiAgICBjb25zdCBjb21iaW5lZFVybHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRoaXNVcmwgb2YgdXJscykge1xuICAgICAgICBpZiAodGhpc1VybC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgICAgICBjb21iaW5lZFVybHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzVXJsLFxuICAgICAgICAgICAgICAgIHdzVXJsOiAnd3NzOi8vJyArIHRoaXNVcmwuc3Vic3RyaW5nKCdodHRwczovLycubGVuZ3RoKSArICcvd3MnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpc1VybC5zdGFydHNXaXRoKCdodHRwOi8vJykpIHtcbiAgICAgICAgICAgIGNvbWJpbmVkVXJscy5wdXNoKHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXNVcmwsXG4gICAgICAgICAgICAgICAgd3NVcmw6ICd3czovLycgKyB0aGlzVXJsLnN1YnN0cmluZygnaHR0cDovLycubGVuZ3RoKSArICcvd3MnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdXJsIGZvdW5kIGluIGFycmF5OiAke3RoaXNVcmx9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbWJpbmVkVXJscztcbn1cbmV4cG9ydHMuYXBwZW5kV3NVcmxzID0gYXBwZW5kV3NVcmxzO1xuLyoqXG4gKiBIYW5kbGVzIHRoZSBuZXR3b3JraW5nIHRvIENocm9uaWsgYEVuZHBvaW50YHMsIGluY2x1ZGluZyBjeWNsaW5nXG4gKiB0aHJvdWdoIGJvdGggdHlwZXMgb2YgZW5kcG9pbnRzLlxuICovXG5jbGFzcyBGYWlsb3ZlclByb3h5IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmxzKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHVybCBpbnB1dFxuICAgICAgICBjb25zdCB1cmxzQXJyYXkgPSB0eXBlb2YgdXJscyA9PT0gJ3N0cmluZycgPyBbdXJsc10gOiB1cmxzO1xuICAgICAgICBpZiAodXJsc0FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVcmwgYXJyYXkgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSBlYWNoIGVudHJ5IGluIHRoZSB1cmwgYXJyYXlcbiAgICAgICAgZm9yIChjb25zdCB1cmwgb2YgdXJsc0FycmF5KSB7XG4gICAgICAgICAgICBpZiAodXJsLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdXJsYCBjYW5ub3QgZW5kIHdpdGggJy8nLCBnb3Q6IFwiICsgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykgJiYgIXVybC5zdGFydHNXaXRoKCdodHRwOi8vJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdXJsYCBtdXN0IHN0YXJ0IHdpdGggJ2h0dHBzOi8vJyBvciAnaHR0cDovLycsIGdvdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemVzIF9lbmRwb2ludEFycmF5IHdpdGggYW4gb2JqZWN0IEFycmF5IGNvbnRhaW5pbmdcbiAgICAgICAgLy8gJ3VybCcgYW5kICd3c1VybCcgcHJvcHNcbiAgICAgICAgdGhpcy5fZW5kcG9pbnRBcnJheSA9IGFwcGVuZFdzVXJscyh1cmxzQXJyYXkpO1xuICAgICAgICB0aGlzLl93b3JraW5nSW5kZXggPSAwO1xuICAgIH1cbiAgICAvLyBGb3IgdW5pdCB0ZXN0IHZlcmlmaWNhdGlvblxuICAgIGdldEVuZHBvaW50QXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRwb2ludEFycmF5O1xuICAgIH1cbiAgICAvLyBEZXJpdmVzIHRoZSBlbmRwb2ludCBhcnJheSBpbmRleCBiYXNlZCBvbiBfd29ya2luZ0luZGV4XG4gICAgLy8gVGhpcyBpcyBzZXQgdG8gcHVibGljIGZvciB1bml0IHRlc3RpbmcgcHVycG9zZXNcbiAgICBkZXJpdmVFbmRwb2ludEluZGV4KGxvb3BJbmRleCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3dvcmtpbmdJbmRleCArIGxvb3BJbmRleCkgJSB0aGlzLl9lbmRwb2ludEFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGluZyB3b3JraW5nIGluZGV4IGZvciB1bml0IHRlc3RpbmcgcHVycG9zZXNcbiAgICBzZXRXb3JraW5nSW5kZXgobmV3SW5kZXgpIHtcbiAgICAgICAgdGhpcy5fd29ya2luZ0luZGV4ID0gbmV3SW5kZXg7XG4gICAgfVxuICAgIGFzeW5jIHBvc3QocGF0aCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChwYXRoLCAnUE9TVCcsIGRhdGEpO1xuICAgIH1cbiAgICBhc3luYyBnZXQocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChwYXRoLCAnR0VUJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBHZXQgb3IgUE9TVCBheGlvcyByZXNwb25zZSBmcm9tIHRoZSBDaHJvbmlrIGluZGV4ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHRoZSBDaHJvbmlrIEFQSSBlbmRwb2ludFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VHlwZSB0aGUgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGdldCBvciBwb3N0IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSB0aGUgb3B0aW9uYWwgYXhpb3MgcmVxdWVzdCBkYXRhIHNwZWNpZmljIHRvIHBvc3QgcmVxdWVzdHNcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gcmV0dXJucyB0aGUgYXhpb3MgcmVzcG9uc2UgZGF0YSBmcm9tIENocm9uaWtcbiAgICAgKiBAdGhyb3dzIHtlcnJvcn0gdGhyb3dzIGVycm9yIG9uIG5vbi1yZXNwb25zaXZlIHNlcnZlciBvciB2YWxpZCBlcnJvciByZXNwb25zZXNcbiAgICAgKi9cbiAgICBhc3luYyBfcmVxdWVzdChwYXRoLCByZXF1ZXN0VHlwZSwgZGF0YSkge1xuICAgICAgICAvLyBDeWNsZSB0aHJvdWdoIGtub3duIENocm9uaWsgaW5zdGFuY2VzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZW5kcG9pbnRBcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRlcml2ZUVuZHBvaW50SW5kZXgoaSk7XG4gICAgICAgICAgICBjb25zdCB0aGlzUHJveHlVcmwgPSB0aGlzLl9lbmRwb2ludEFycmF5W2luZGV4XS51cmw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fY2FsbEF4aW9zKHRoaXNQcm94eVVybCwgcGF0aCwgcmVxdWVzdFR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGVycm9ycyB0aHJvd24gaW4gdGhlIGFib3ZlIGNhbGwgdGhlbiBzZXQgdGhpcyBpbmRleCB0byBzdGF0ZVxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtpbmdJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKCdjb2RlJyBpbiBlcnIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKCdVbmFibGUgdG8gZGVjb2RlIGVycm9yIG1zZywgY2hyb25payBzZXJ2ZXIgaXMgaW5kZXhpbmcgb3IgaW4gZXJyb3Igc3RhdGUnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHNlZSB0aGlzIHR5cGUgb2YgZXJyb3IgbXNnIGZyb20gYW4gaW5kZXhpbmcgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPYnNlcnZlZCB3aGVuIGEgY2hyb25payBub2RlIGlzIGRvd24gKGUuZy4gYml0Y29pbi1jbGkgc3RvcCkgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXIgaXMgcmVhY2hhYmxlLCBuZ2lueCBydW5uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIudG9TdHJpbmcoKS50cmltKCkuZW5kc1dpdGgoJzonKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VydmVyIG91dGFnZSwgc2tpcCB0byBuZXh0IHVybCBpbiBsb29wXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbm5lY3Rpb24gZXJyb3IgbXNncyBoYXZlIGEgJ2NvZGUnIGtleSBvZiAnRUNPTk5SRUZVU0VEJ1xuICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBtZXNzYWdlcyBmcm9tIHRoZSBjaHJvbmlrIHNlcnZlciAoaS5lLiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlcyB0aGF0IHNob3VsZCBub3QgdHJpZ2dlciBhICd0cnkgbmV4dCBzZXJ2ZXInXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQpIGFyZSBvZiB0aGUgY2hyb25payBwcm90byBFcnJvciB0eXBlLCB3aGljaCBoYXMgbm8gJ2NvZGUnIGtleVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgdXBvbiBhbGwgb3RoZXIgdmFsaWQgZXJyb3IgcmVzcG9uc2VzIGZyb20gY2hyb25pa1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwga25vd24gQ2hyb25payBpbnN0YW5jZXMgaGF2ZSBub3QgYmVlbiByZXNwb25zaXZlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY29ubmVjdGluZyB0byBrbm93biBDaHJvbmlrIGluc3RhbmNlc2ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBheGlvcyBmb3IgYSBHRVQgb3IgUE9TVCByZXNwb25zZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgc2luZ3VsYXIgY2hyb25payB1cmxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byB0aGUgQ2hyb25payBBUEkgZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdFR5cGUgdGhlIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXMgYSBnZXQgb3IgcG9zdCByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgdGhlIG9wdGlvbmFsIGF4aW9zIHJlcXVlc3QgZGF0YSBmb3IgcG9zdCByZXF1ZXN0c1xuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSByZXR1cm5zIHRoZSBheGlvcyByZXNwb25zZSBkYXRhIGZyb20gQ2hyb25pa1xuICAgICAqIEB0aHJvd3Mge2Vycm9yfSB0aHJvd3MgZXJyb3Igb24gbm9uLXJlc3BvbnNpdmUgc2VydmVyIG9yIHZhbGlkIGVycm9yIHJlc3BvbnNlc1xuICAgICAqL1xuICAgIGFzeW5jIF9jYWxsQXhpb3ModXJsLCBwYXRoLCByZXF1ZXN0VHlwZSwgZGF0YSkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGlmIChyZXF1ZXN0VHlwZSA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXhpb3NfMS5kZWZhdWx0LmdldChgJHt1cmx9JHtwYXRofWAsIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVTdGF0dXM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3RUeXBlID09PSAnUE9TVCcpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXhpb3NfMS5kZWZhdWx0LnBvc3QoYCR7dXJsfSR7cGF0aH1gLCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlU3RhdHVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudHMgQXhpb3MgZW5jb2RpbmcgdGhlIFVpbnQ4QXJyYXkgYXMgSlNPTiBvciBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1SZXF1ZXN0OiB4ID0+IHgsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtcHJvdG9idWYnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1wb3NzaWJsZSBieSB0eXBlcycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIGZvciB2YWxpZCBlcnJvciByZXNwb25zZXMgKGUuZy4gdHhpZCBub3QgZm91bmQpXG4gICAgICAgIHRoaXMuZW5zdXJlUmVzcG9uc2VFcnJvclRocm93bihyZXNwb25zZSwgcGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgZW5zdXJlUmVzcG9uc2VFcnJvclRocm93bihyZXNwb25zZSwgcGF0aCkge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9IDIwMCkge1xuICAgICAgICAgICAgbGV0IGVycm9yQ2FuQmVEZWNvZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbiBkZWNvZGUgdGhpcyBlcnJvciB3aXRoIHByb3RvLCBpdCBpcyBhbiBleHBlY3RlZCBjaHJvbmlrIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gZnJvbSBhIHdvcmtpbmcgc2VydmVyIGFuZCB3ZSBzaG91bGQgcmV0dXJuIGl0IHRvIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBwcm90by5FcnJvci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuZGF0YSkpO1xuICAgICAgICAgICAgICAgIGVycm9yQ2FuQmVEZWNvZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBkZWNvZGUgdGhpcyBlcnJvciB3aXRoIHByb3RvLCBzb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGlzIHNlcnZlciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIC8vIEl0IG1heSBiZSBpbmRleGluZ1xuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2Ugc2hvdWxkIHRyeSB0aGUgbmV4dCBzZXJ2ZXJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNvZGUgZXJyb3IgbXNnLCBjaHJvbmlrIHNlcnZlciBpcyBpbmRleGluZyBvciBpbiBlcnJvciBzdGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yQ2FuQmVEZWNvZGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgZ2V0dGluZyAke3BhdGh9OiAke2Vycm9yLm1zZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGdpdmVuIHdlYnNvY2tldCBVUkwgY29ubmVjdHNcbiAgICAgKiBOb3RlOiBBcyBvZiAyMDIzMTExMCB0aGVyZSBpcyBubyBtc2cgZnJvbSBjaHJvbmlrIHNlcnZlciBjb25maXJtaW5nIGEgY29ubmVjdGlvbiB0byBjaHJvbmlrXG4gICAgICogV2Ugd291bGQgaGF2ZSB0byB3YWl0IGZvciBhIGJsb2NrIG9yIGEgdHJhbnNhY3Rpb24sIHdoaWNoIGlzIGltcHJhY3RpY2FsIGhlcmVcbiAgICAgKiBTbywgdGhpcyBpcyBvbmx5IHRlc3Rpbmcgd2hldGhlciBvciBub3QgYSBnaXZlbiBVUkwgaXMgYSBsaXZlIHdlYnNvY2tldCBvciBub3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd3NVcmxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbH1cbiAgICAgKi9cbiAgICBhc3luYyBfd2Vic29ja2V0VXJsQ29ubmVjdHMod3NVcmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgLy8gSWYgd2UgZG8gbm90IGNvbm5lY3QgaW4gYXBwcm9wcmlhdGUgdGltZWZyYW1lLFxuICAgICAgICAgICAgLy8gY2FsbCBpdCBhIGZhaWx1cmUgYW5kIHRyeSB0aGUgbmV4dCB3ZWJzb2NrZXRcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRGYWlsdXJlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGVzdFdzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LCBXRUJTT0NLRVRfVElNRU9VVF9NUyk7XG4gICAgICAgICAgICBjb25zdCB0ZXN0V3MgPSBuZXcgaXNvbW9ycGhpY193c18xLmRlZmF1bHQod3NVcmwpO1xuICAgICAgICAgICAgdGVzdFdzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGVzdFdzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRGYWlsdXJlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGVzdFdzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0ZXN0V3MuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEZhaWx1cmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSXRlcmF0ZXMgdGhyb3VnaCBhdmFpbGFibGUgd2Vic29ja2V0IHVybHMgYW5kIGF0dGVtcHRzIGNvbm5lY3Rpb24uXG4gICAgLy8gVXBvbiBhIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbiBpdCBoYW5kbGVzIHRoZSB2YXJpb3VzIHdlYnNvY2tldCBjYWxsYmFja3MuXG4gICAgLy8gVXBvbiBhbiB1bnN1Y2Nlc3NmdWwgY29ubmVjdGlvbiBpdCBpdGVyYXRlcyB0byB0aGUgbmV4dCB3ZWJzb2NrZXQgdXJsIGluIHRoZSBhcnJheS5cbiAgICBhc3luYyBjb25uZWN0V3Mod3NFbmRwb2ludCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2VuZHBvaW50QXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZXJpdmVFbmRwb2ludEluZGV4KGkpO1xuICAgICAgICAgICAgY29uc3QgdGhpc1Byb3h5V3NVcmwgPSB0aGlzLl9lbmRwb2ludEFycmF5W2luZGV4XS53c1VybDtcbiAgICAgICAgICAgIGNvbnN0IHdlYnNvY2tldFVybENvbm5lY3RzID0gYXdhaXQgdGhpcy5fd2Vic29ja2V0VXJsQ29ubmVjdHModGhpc1Byb3h5V3NVcmwpO1xuICAgICAgICAgICAgaWYgKHdlYnNvY2tldFVybENvbm5lY3RzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoaXMgaW5kZXggdG8gc3RhdGVcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JraW5nSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCB3cyA9IG5ldyBpc29tb3JwaGljX3dzXzEuZGVmYXVsdCh0aGlzUHJveHlXc1VybCk7XG4gICAgICAgICAgICAgICAgd3Mub25tZXNzYWdlID0gZSA9PiB3c0VuZHBvaW50LmhhbmRsZU1zZyhlKTtcbiAgICAgICAgICAgICAgICB3cy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAod3NFbmRwb2ludC5vbkVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdzRW5kcG9pbnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd3Mub25jbG9zZSA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmQgaWYgbWFudWFsbHkgY2xvc2VkIG9yIG5vIGF1dG8tcmVjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICh3c0VuZHBvaW50Lm1hbnVhbGx5Q2xvc2VkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhd3NFbmRwb2ludC5hdXRvUmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod3NFbmRwb2ludC5vbkVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3NFbmRwb2ludC5vbkVuZChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAod3NFbmRwb2ludC5vblJlY29ubmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3c0VuZHBvaW50Lm9uUmVjb25uZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtpbmdJbmRleCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5fd29ya2luZ0luZGV4ICsgMSkgJSB0aGlzLl9lbmRwb2ludEFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0V3Mod3NFbmRwb2ludCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3c0VuZHBvaW50LndzID0gd3M7XG4gICAgICAgICAgICAgICAgd3NFbmRwb2ludC5jb25uZWN0ZWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd3Mub25vcGVuID0gbXNnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byBhbGwgcHJldmlvdXNseS1zdWJzY3JpYmVkIHNjcmlwdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdzRW5kcG9pbnQuc3Vicy5zY3JpcHRzLmZvckVhY2goc3ViID0+IHdzRW5kcG9pbnQuc3Vic2NyaWJlVG9TY3JpcHQoc3ViLnNjcmlwdFR5cGUsIHN1Yi5wYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYWxsIHByZXZpb3VzbHktc3Vic2NyaWJlZCBsb2thZElkc1xuICAgICAgICAgICAgICAgICAgICAgICAgd3NFbmRwb2ludC5zdWJzLmxva2FkSWRzLmZvckVhY2gobG9rYWRJZCA9PiB3c0VuZHBvaW50LnN1YnNjcmliZVRvTG9rYWRJZChsb2thZElkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYWxsIHByZXZpb3VzbHktc3Vic2NyaWJlZCB0b2tlbklkc1xuICAgICAgICAgICAgICAgICAgICAgICAgd3NFbmRwb2ludC5zdWJzLnRva2Vucy5mb3JFYWNoKHRva2VuSWQgPT4gd3NFbmRwb2ludC5zdWJzY3JpYmVUb1Rva2VuSWQodG9rZW5JZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGFsbCBwcmV2aW91c2x5LXN1YnNjcmliZWQgdHhpZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdzRW5kcG9pbnQuc3Vicy50eGlkcy5mb3JFYWNoKHR4aWQgPT4gd3NFbmRwb2ludC5zdWJzY3JpYmVUb1R4aWQodHhpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGJsb2NrcyBtZXRob2QsIGlmIHByZXZpb3VzbHkgc3Vic2NyaWJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdzRW5kcG9pbnQuc3Vicy5ibG9ja3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3c0VuZHBvaW50LnN1YnNjcmliZVRvQmxvY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod3NFbmRwb2ludC5vbkNvbm5lY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdzRW5kcG9pbnQub25Db25uZWN0KG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBlcnJvcnMgdGhyb3duIGZyb20gYWJvdmUgY2FsbCB0aGVuIHNldCB0aGlzIGluZGV4IHRvIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3JraW5nSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gd2Vic29ja2V0IFVSTHMgY29ubmVjdCwgdGhyb3cgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBjb25uZWN0aW5nIHRvIGtub3duIENocm9uaWsgd2Vic29ja2V0c2ApO1xuICAgIH1cbn1cbmV4cG9ydHMuRmFpbG92ZXJQcm94eSA9IEZhaWxvdmVyUHJveHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mYWlsb3ZlclByb3h5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1199\n\n}")},1216:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ECASH_LIB_WASM_BASE64: () => (/* binding */ ECASH_LIB_WASM_BASE64)\n/* harmony export */ });\nconst ECASH_LIB_WASM_BASE64 = `\nAGFzbQEAAAAB+wEeYAAAYAABf2ABfwBgAX8Bf2ACf38AYAJ/fwF/YAN/f38AYAN/f38Bf2AEf39/\nfwBgBH9/f38Bf2AFf39/f38AYAV/f39/fwF/YAZ/f39/f38AYAZ/f39/f38Bf2AHf39/f39/fwF/\nYAh/f39/f39/fwBgCH9/f39/f39/AX9gCn9/f39/f39/f38AYAt/f39/f39/f39/fwBgC39/f39/\nf39/f39/AX9gBX9/fn9/AGAFf399f38AYAV/f3x/fwBgA39+fwBgBH9+f38AYAV/fn5+fgBgCH9+\nfn5+fn5+AGAKf35+fn5+fn5+fgBgBH99f38AYAR/fH9/AAI0AgN3YmcVX193YmluZGdlbl9zdHJp\nbmdfbmV3AAUDd2JnEF9fd2JpbmRnZW5fdGhyb3cABAOBA/8CBgQGBAYGAw4IBQwKBg4EDwwGCAgE\nBAwMBwYGBg8JBQwICggICAgRBwIMDAQGEAUEBgEGBwYNBwQGCAQJBgQEFwYFBAUGBQYSBAcEBwQE\nCAUFBQQEDQoGAwUEBQULBgYGCgYFBQYGBgQCBgwJCAoMCggCBAoGBgMGCwQGBAYHCwYHCgYTCwQG\nBAQDBQYGBAoEBAQGBAQJBgQIDAYDBQoEBAQZCAgaBwYHAgIHBgkKCAobBgQGBQYIAgoOBgYBCAkK\nBAYGBgYHCAMGAwQKBAYKCAgDBAMGBAQEBQYBBAYEBQYGAgQEBwcGCAYLBgUFAwQIBAQEAgUGCwQG\nBgQEAgIJAwMFCgQEBgQFBQUEBggEBgUKCg0FBAQGBgQFBAoJAwgIAgoNBAIEAgoLFRYUAwgCBAID\nBwMFBgYDBQkCBQMCBQIFBQUGAgUFBQcCBAYKBggIBQUDCAMEBAgICAYGBgQEBgYCBAQABgQDBQAE\nBAUFBAQEBQQEBAIEBgQEBAICBAMEBQFwAVNTBQMBABEGCQF/AUGAgMAACweSBiYGbWVtb3J5AgAH\nZWNjX25ldwAzEGVjY19kZXJpdmVQdWJrZXkAUA1lY2NfZWNkc2FTaWduABIPZWNjX2VjZHNhVmVy\naWZ5ABEPZWNjX3NjaG5vcnJTaWduABgRZWNjX3NjaG5vcnJWZXJpZnkAHhFlY2NfaXNWYWxpZFNl\nY2tleQCsAQ1lY2Nfc2Vja2V5QWRkACwNZWNjX3B1YmtleUFkZAAhE2VjY19zaWduUmVjb3ZlcmFi\nbGUAGQ5lY2NfcmVjb3ZlclNpZwAMDl9fd2JnX2VjY19mcmVlAKsBFXB1YmxpY0tleUNyeXB0b1Zl\ncmlmeQBJHHB1YmxpY0tleUNyeXB0b0FsZ29TdXBwb3J0ZWQAdQtzaGE1MTJoX25ldwDcAQ5zaGE1\nMTJoX3VwZGF0ZQDFARBzaGE1MTJoX2ZpbmFsaXplAJIBDXNoYTUxMmhfY2xvbmUAeBJfX3diZ19z\naGE1MTJoX2ZyZWUA/gELc2hhMjU2aF9uZXcAvgEOc2hhMjU2aF91cGRhdGUAxgEQc2hhMjU2aF9m\naW5hbGl6ZQCTAQ1zaGEyNTZoX2Nsb25lAFkSX193Ymdfc2hhMjU2aF9mcmVlAP8BBnNoYTUxMgCN\nAQdzaGEyNTZkAH4Gc2hhMjU2ALcBCXNoYVJtZDE2MAA0HmVjYXNoX3NlY3AyNTZrMV9jb250ZXh0\nX2NyZWF0ZQDJAR9lY2FzaF9zZWNwMjU2azFfY29udGV4dF9kZXN0cm95AOMBJXNlY3AyNTZrMV9k\nZWZhdWx0X2lsbGVnYWxfY2FsbGJhY2tfZm4A5AIjc2VjcDI1NmsxX2RlZmF1bHRfZXJyb3JfY2Fs\nbGJhY2tfZm4A5QIecmluZ19jb3JlXzBfMTdfMTRfX2JuX211bF9tb250ACsfX193YmluZGdlbl9h\nZGRfdG9fc3RhY2tfcG9pbnRlcgDpAhNfX3diaW5kZ2VuX2V4cG9ydF8wAPYBE19fd2JpbmRnZW5f\nZXhwb3J0XzEA5wITX193YmluZGdlbl9leHBvcnRfMgCAAgmUAQEAQQELUokCMMgC0wLuAuoCjAHS\nAtMCyAKKAl2qApsBqQKqAqQCtAKvAqkCqQKrAqwCrQKLAlPzAvkC9AL/AvgCXMEC5wFSxwLAAmQ1\n4AHJAuMCygJa7wLAApUCD+0BCcICwwLEApEC7gGAAz0iJfsBlwIdORSUAc0CP0jZATucAd0CTNoC\n9QIn2wL2AoEBVuQC5QIKz4wI/wL1PgFIfyAAIAAoAmAiCiACajYCYCAAQSBqIUUgCkE/cSEKA0Ag\nAkHAACAKayI/SUUEQCAKIEVqIAEgPxApGiAAIAAoAlgiCkEYdCAKQQh0QYCA/AdxciAKQQh2QYD+\nA3EgCkEYdnJyIgMgACgCXCIKQRh0IApBCHRBgID8B3FyIApBCHZBgP4DcSAKQRh2cnIiBEEZdyAE\n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\n/w+DIAI1AggiDiARfiIPQiCIfCAPQv////8PgyACNQIEIg8gEX4iCUIgiHwgCUL/////D4MgFUIg\niHwiFUIgiHwiCUIgiHwiEkL/////D4N8IAlC/////w+DIBVC/////w+DIAYgFnxCIIh8IBdC////\n/w+DfCIJQiCIfCADQv////8Pg3wiG0IgiHwiEEIgiCACNQIQIhcgEX4iA0L/////D4MgBUIgiHwg\nEkIgiHwiBUL/////D4N8IhJCIIggAjUCFCIVIBF+IiBC/////w+DIANCIIh8IAVCIIh8IgNC////\n/w+DfCIFQiCIIBZ8IAI1AhgiFiARfiIYQv////8PgyAgQiCIfCADQiCIfCIgQv////8Pg3wiGUL/\n////D4MgFyABNQIEIgN+Ig1CIIggAyAVfiIcQv////8Pg3wgDUL/////D4MgAyAIfiINQiCIfCAN\nQv////8PgyADIA5+Ig1CIIh8IA1C/////w+DIAMgD34iDUIgiHwgDUL/////D4MgAyATfiINQiCI\nfCIKQiCIfCILQiCIfCIMQiCIfCIaQiCIfCIdQv////8Pg3wgBUL/////D4MgGkL/////D4N8IBJC\n/////w+DIAxC/////w+DfCALQv////8PgyAKQv////8PgyAJQv////8PgyANQv////8Pg3wiBUIg\niHwgG0L/////D4N8IglCIIh8IBBC/////w+DfCISQiCIfCIQQiCIfCIbQiCIfCINQv////8PgyAb\nQv////8PgyASQv////8PgyAJQv////8PgyAFQv////8PgyIJQv////8PfiIFQv////8PgyISIAl8\nQiCIfCAFQiCIIhsgEnwiBUL/////D4N8IgpCIIh8IAUgBUIgiHwiBUL/////D4N8IgtCIIggBUIg\niCAbfHwgEEL/////D4N8IhBCIIh8IgxCIIh8IhpC/////w+DIAggATUCCCIFfiIHQiCIIAUgF34i\nHkL/////D4N8IAdC/////w+DIAUgDn4iB0IgiHwgB0L/////D4MgBSAPfiIHQiCIfCAHQv////8P\ngyAFIBN+IgdCIIh8IiFCIIh8IiJCIIh8IiNCIIh8Ih9C/////w+DfCAMQv////8PgyAjQv////8P\ng3wgIkL/////D4MgIUL/////D4MgCkL/////D4MgB0L/////D4N8IgpCIIh8IAtC/////w+DfCIL\nQiCIfCAQQv////8Pg3wiEEIgiHwiDEIgiHwiB0IgiCAFIBV+IiFC/////w+DIB5CIIh8IB9CIIh8\nIh5C/////w+DfCAaQiCIIAl8IBlCIIggBnwgESACNQIcIhF+IhlC/////w+DIBhCIIh8ICBCIIh8\nIhhC/////w+DfCIaQv////8PgyADIBZ+IiJC/////w+DIBxCIIh8IB1CIIh8IhxC/////w+DfCAN\nQiCIfCINQv////8Pg3wiHUL/////D4N8IiNC/////w+DIAdC/////w+DIBBC/////w+DIAtC////\n/w+DIApC/////w+DIglC/////w9+IgZC/////w+DIhAgCXxCIIh8IAZCIIgiICAQfCIGQv////8P\ng3wiCkIgiHwgBiAGQiCIfCIGQv////8Pg3wiC0IgiCAGQiCIICB8fCAMQv////8Pg3wiDEIgiHwi\nB0IgiHwiH0L/////D4MgCCABNQIMIgZ+IgRCIIggBiAXfiIkQv////8Pg3wgBEL/////D4MgBiAO\nfiIEQiCIfCAEQv////8PgyAGIA9+IgRCIIh8IARC/////w+DIAYgE34iBEIgiHwiJUIgiHwiJ0Ig\niHwiJkIgiHwiKEL/////D4N8IAdC/////w+DICZC/////w+DfCAnQv////8PgyAlQv////8PgyAK\nQv////8PgyAEQv////8Pg3wiCkIgiHwgC0L/////D4N8IgtCIIh8IAxC/////w+DfCIMQiCIfCIH\nQiCIfCIEQiCIIAYgFX4iJUL/////D4MgJEIgiHwgKEIgiHwiJEL/////D4N8IB9CIIggCXwgBSAW\nfiIfQv////8PgyAhQiCIfCAeQiCIfCIeQv////8PgyAjQiCIfCAdQiCIIBJ8IBhCIIggGUIgiHwg\nFHwgGkIgiHwiGEL/////D4MgAyARfiIZQv////8PgyAiQiCIfCAcQiCIfCIcQv////8Pg3wgDUIg\niHwiDUL/////D4N8IhpC/////w+DfCIdQv////8Pg3wiIUL/////D4N8IiJC/////w+DIARC////\n/w+DIAxC/////w+DIAtC/////w+DIApC/////w+DIhRC/////w9+IgNC/////w+DIgkgFHxCIIh8\nIANCIIgiEiAJfCIDQv////8Pg3wiCkIgiHwgAyADQiCIfCIDQv////8Pg3wiC0IgiCADQiCIIBJ8\nfCAHQv////8Pg3wiDEIgiHwiB0IgiHwiI0L/////D4MgCCABNQIQIgN+IgRCIIggAyAXfiInQv//\n//8Pg3wgBEL/////D4MgAyAOfiIEQiCIfCAEQv////8PgyADIA9+IgRCIIh8IARC/////w+DIAMg\nE34iBEIgiHwiJkIgiHwiKEIgiHwiKUIgiHwiKkL/////D4N8IAdC/////w+DIClC/////w+DfCAo\nQv////8PgyAmQv////8PgyAKQv////8PgyAEQv////8Pg3wiCkIgiHwgC0L/////D4N8IgtCIIh8\nIAxC/////w+DfCIMQiCIfCIHQiCIfCIEQiCIIAMgFX4iJkL/////D4MgJ0IgiHwgKkIgiHwiJ0L/\n////D4N8ICNCIIggFHwgBiAWfiIjQv////8PgyAlQiCIfCAkQiCIfCIkQv////8PgyAiQiCIfCAh\nQiCIIBB8IAUgEX4iIUL/////D4MgH0IgiHwgHkIgiHwiHkL/////D4MgHUIgiHwgGkIgiCAbfCAc\nQiCIIBlCIIh8IBhCIIh8IA1CIIh8IhhC/////w+DfCIZQv////8Pg3wiDUL/////D4N8IhxC////\n/w+DfCIaQv////8Pg3wiHUL/////D4N8IiJC/////w+DIARC/////w+DIAxC/////w+DIAtC////\n/w+DIApC/////w+DIhRC/////w9+IgVC/////w+DIhsgFHxCIIh8IAVCIIgiECAbfCIFQv////8P\ng3wiCkIgiHwgBSAFQiCIfCIFQv////8Pg3wiC0IgiCAFQiCIIBB8fCAHQv////8Pg3wiDEIgiHwi\nB0IgiHwiH0L/////D4MgCCABNQIUIgV+IgRCIIggBSAXfiIlQv////8Pg3wgBEL/////D4MgBSAO\nfiIEQiCIfCAEQv////8PgyAFIA9+IgRCIIh8IARC/////w+DIAUgE34iBEIgiHwiKEIgiHwiKUIg\niHwiKkIgiHwiK0L/////D4N8IAdC/////w+DICpC/////w+DfCApQv////8PgyAoQv////8PgyAK\nQv////8PgyAEQv////8Pg3wiCkIgiHwgC0L/////D4N8IgtCIIh8IAxC/////w+DfCIMQiCIfCIH\nQiCIfCIEQiCIIAUgFX4iKEL/////D4MgJUIgiHwgK0IgiHwiJUL/////D4N8IB9CIIggFHwgAyAW\nfiIfQv////8PgyAmQiCIfCAnQiCIfCInQv////8PgyAiQiCIfCAdQiCIIAl8IAYgEX4iHUL/////\nD4MgI0IgiHwgJEIgiHwiIkL/////D4MgGkIgiHwgHEIgiCAgfCAeQiCIICFCIIh8IBhCIIh8IBlC\nIIh8IA1CIIh8IhhC/////w+DfCIZQv////8Pg3wiDUL/////D4N8IhxC/////w+DfCIaQv////8P\ng3wiHkL/////D4N8IiFC/////w+DIARC/////w+DIAxC/////w+DIAtC/////w+DIApC/////w+D\nIhRC/////w9+IgZC/////w+DIgkgFHxCIIh8IAZCIIgiICAJfCIGQv////8Pg3wiCkIgiHwgBiAG\nQiCIfCIGQv////8Pg3wiC0IgiCAGQiCIICB8fCAHQv////8Pg3wiDEIgiHwiB0IgiHwiI0L/////\nD4MgCCABNQIYIgZ+IgRCIIggBiAXfiIkQv////8Pg3wgBEL/////D4MgBiAOfiIEQiCIfCAEQv//\n//8PgyAGIA9+IgRCIIh8IARC/////w+DIAYgE34iBEIgiHwiJkIgiHwiKUIgiHwiKkIgiHwiK0L/\n////D4N8IAdC/////w+DICpC/////w+DfCApQv////8PgyAmQv////8PgyAKQv////8PgyAEQv//\n//8Pg3wiCkIgiHwgC0L/////D4N8IgtCIIh8IAxC/////w+DfCIMQiCIfCIHQiCIfCIEQiCIIAYg\nFX4iJkL/////D4MgJEIgiHwgK0IgiHwiJEL/////D4N8ICNCIIggFHwgBSAWfiIjQv////8PgyAo\nQiCIfCAlQiCIfCIlQv////8PgyAhQiCIfCAeQiCIIBt8IAMgEX4iHkL/////D4MgH0IgiHwgJ0Ig\niHwiIUL/////D4MgGkIgiHwgHEIgiCASfCAiQiCIIB1CIIh8IBhCIIh8IBlCIIh8IA1CIIh8IhhC\n/////w+DfCIZQv////8Pg3wiDUL/////D4N8IhxC/////w+DfCIaQv////8Pg3wiHUL/////D4N8\nIiJC/////w+DIARC/////w+DIAxC/////w+DIAtC/////w+DIApC/////w+DIhRC/////w9+IgNC\n/////w+DIhIgFHxCIIh8IANCIIgiGyASfCIDQv////8Pg3wiCkIgiHwgAyADQiCIfCIDQv////8P\ng3wiC0IgiCADQiCIIBt8fCAHQv////8Pg3wiDEIgiHwiB0IgiHwiH0L/////D4MgCCABNQIcIgN+\nIghCIIggAyAXfiIXQv////8Pg3wgCEL/////D4MgAyAOfiIIQiCIfCAIQv////8PgyADIA9+IghC\nIIh8IAhC/////w+DIAMgE34iE0IgiHwiCEIgiHwiDkIgiHwiD0IgiHwiBEL/////D4N8IAdC////\n/w+DIA9C/////w+DfCAOQv////8PgyAIQv////8PgyAKQv////8PgyATQv////8Pg3wiE0IgiHwg\nC0L/////D4N8IghCIIh8IAxC/////w+DfCIOQiCIfCIKQiCIfCIPQiCIIAMgFX4iC0L/////D4Mg\nF0IgiHwgBEIgiHwiDEL/////D4N8IB9CIIggFHwgBiAWfiIHQv////8PgyAmQiCIfCAkQiCIfCIf\nQv////8PgyAiQiCIfCAdQiCIIAl8IAUgEX4iCUL/////D4MgI0IgiHwgJUIgiHwiHUL/////D4Mg\nGkIgiHwgHEIgiCAQfCAhQiCIIB5CIIh8IBhCIIh8IBlCIIh8IA1CIIh8IhBC/////w+DfCIYQv//\n//8Pg3wiGUL/////D4N8Ig1C/////w+DfCIcQv////8Pg3wiGkL/////D4N8Ih5C/////w+DIA9C\n/////w+DIA5C/////w+DIAhC/////w+DIBNC/////w+DIhNC/////w9+Ig5C/////w+DIgggE3xC\nIIh8IA5CIIgiDiAIfCIPQv////8Pg3wiF0IgiHwgDyAPQiCIfCIVQv////8Pg3wiD0IgiCAVQiCI\nIA58fCAKQv////8Pg3wiFUIgiHwiBUIgiHwiFEIgiCATfCADIBZ+IhZC/////w+DIAtCIIh8IAxC\nIIh8IgpC/////w+DIB5CIIh8IBpCIIggEnwgBiARfiIGQv////8PgyAHQiCIfCAfQiCIfCISQv//\n//8PgyAcQiCIfCANQiCIICB8IB1CIIggCUIgiHwgEEIgiHwgGEIgiHwgGUIgiHwiCUL/////D4N8\nIhBC/////w+DfCIgQv////8Pg3wiGEL/////D4N8IhlC/////w+DfCITQiCIIAh8IAMgEX4iCEL/\n////D4MgFkIgiHwgCkIgiHwiFkL/////D4MgGUIgiHwgGEIgiCAbfCASQiCIIAZCIIh8IAlCIIh8\nIBBCIIh8ICBCIIh8IgNC/////w+DfCIGQv////8Pg3wiCUL/////D4N8IhFCIIggDnwgFkIgiCAI\nQiCIfCADQiCIfCAGQiCIfCAJQiCIfCIOQv////8Pg3wiCEIgiCAOQiCIfEIAIAhC/////w+DQgAg\nEUL/////D4MgE0L/////D4NCACAUQv////8Pg0IAIAVC/////w+DQgAgFUL/////D4NCACAPQv//\n//8Pg0IAIBdC/////w+DQv////8PfSIOQiCIfUL/AYN9Qv////8PfSIWQiCIfUL/AYN9Qv////8P\nfSIDQiCIfUL/AYN9IgZCIIh9Qv8Bg30iCUIgiH1C/wGDfSISQiCIQgF9QoB+hHwiG0IgiH1C/wGD\nfUL/////D30iEEIgiH1C/wGDfUIgiKdB/wFxGyIBQX9zIQIgACACIBCncSABIAincXI2AhwgACAC\nIBuncSABIBGncXI2AhggACACIBKncSABIBOncXI2AhQgACACIAmncSABIBSncXI2AhAgACACIAan\ncSABIAWncXI2AgwgACACIAOncSABIBWncXI2AgggACACIBancSABIA+ncXI2AgQgACACIA6ncSAB\nIBencXI2AgALoiUCAX81fkF/QQAgATUCACIFIAV+IgxC/////w+DIhRC/////w9+Ig1CIIgiCyAN\nQv////8PgyIXfCIPIA9CIIh8IhBCIIggC3wgBSABNQIMIg1+IgNC/////w+DIgogBSABNQIIIg5+\nIglCIIgiBHwgCUL/////D4MiCCAFIAE1AgQiCX4iEUIgiCIHfCARQv////8PgyIRIAxCIIh8IgxC\nIIh8IgZCIIh8IhJC/////w+DfCAGQv////8PgyAMQv////8PgyAUIBd8QiCIfCAPQv////8Pg3wi\nBkIgiHwgEEL/////D4N8IhBCIIh8IhNCIIggBSABNQIQIg9+IhVC/////w+DIhkgA0IgiCIWfCAS\nQiCIfCIDQv////8Pg3wiEkIgiCAFIAE1AhQiDH4iGkL/////D4MiJCAVQiCIIhV8IANCIIh8IgNC\n/////w+DfCIYQiCIIBR8IAUgATUCGCIUfiIbQv////8PgyIvIBpCIIgiGnwgA0IgiHwiHEL/////\nD4N8IilC/////w+DIAkgDH4iJUL/////D4MiKiAJIA9+IgNCIIgiHnwgA0L/////D4MiHyAJIA1+\nIgNCIIgiJnwgA0L/////D4MiHSAJIA5+IgNCIIgiJ3wgA0L/////D4MiICAJIAl+IgNCIIh8IAcg\nA0L/////D4N8IgNCIIh8IgdCIIh8IitCIIh8IiFCIIh8IihC/////w+DfCAYQv////8PgyAhQv//\n//8Pg3wgEkL/////D4MgK0L/////D4N8IAdC/////w+DIANC/////w+DIAZC/////w+DIBF8IgNC\nIIh8IBBC/////w+DfCIQQiCIfCATQv////8Pg3wiEUIgiHwiBkIgiHwiB0IgiHwiEkL/////D4Mg\nB0L/////D4MgEUL/////D4MgEEL/////D4MgA0L/////D4MiEEL/////D34iEUL/////D4MiAyAQ\nfEIgiHwgEUIgiCIRIAN8IgdC/////w+DfCITQiCIfCAHIAdCIIh8IgdC/////w+DfCIYQiCIIAdC\nIIggEXx8IAZC/////w+DfCIHQiCIfCIGQiCIfCIrQv////8PgyAOIA9+IiFC/////w+DIjAgDSAO\nfiIiQiCIIix8ICJC/////w+DIiIgDiAOfiIjQiCIfCAjQv////8PgyAnfCAEICB8IgRCIIh8IidC\nIIh8IiBCIIh8IiNC/////w+DfCAGQv////8PgyAgQv////8Pg3wgJ0L/////D4MgBEL/////D4Mg\nE0L/////D4MgCHwiBEIgiHwgGEL/////D4N8IghCIIh8IAdC/////w+DfCIHQiCIfCIGQiCIfCIT\nQiCIIAwgDn4iGEL/////D4MiJyAhQiCIIiB8ICNCIIh8IiFC/////w+DfCArQiCIIBB8IClCIIgg\nF3wgBSABNQIcIhd+IilC/////w+DIisgG0IgiCIbfCAcQiCIfCIcQv////8Pg3wiI0L/////D4Mg\nCSAUfiIxQv////8PgyI1ICVCIIgiJXwgKEIgiHwiKEL/////D4N8IBJCIIh8IhJC/////w+DfCIy\nQv////8Pg3wiLUL/////D4MgE0L/////D4MgB0L/////D4MgCEL/////D4MgBEL/////D4MiBUL/\n////D34iB0L/////D4MiECAFfEIgiHwgB0IgiCIHIBB8IgRC/////w+DfCIIQiCIfCAEIARCIIh8\nIgRC/////w+DfCITQiCIIARCIIggB3x8IAZC/////w+DfCIEQiCIfCIGQiCIfCIzQv////8PgyAN\nIA9+Ii5C/////w+DIjYgDSANfiI0QiCIfCA0Qv////8PgyAsfCAiICZ8IBYgHXwiFkIgiHwiJkIg\niHwiHUIgiHwiIkL/////D4N8IAZC/////w+DIB1C/////w+DfCAmQv////8PgyAWQv////8PgyAI\nQv////8PgyAKfCIKQiCIfCATQv////8Pg3wiCEIgiHwgBEL/////D4N8IgRCIIh8IgZCIIh8IhNC\nIIggDCANfiIWQv////8PgyImIC5CIIgiHXwgIkIgiHwiIkL/////D4N8IDNCIIggBXwgDiAUfiIs\nQv////8PgyIzIBhCIIgiGHwgIUIgiHwiIUL/////D4MgLUIgiHwgMkIgiCADfCApQiCIIikgHEIg\niHwgC3wgI0IgiHwiHEL/////D4MgCSAXfiIjQv////8PgyIyIDFCIIgiMXwgKEIgiHwiKEL/////\nD4N8IBJCIIh8IhJC/////w+DfCItQv////8Pg3wiLkL/////D4N8IjRC/////w+DfCI3Qv////8P\ngyATQv////8PgyAEQv////8PgyAIQv////8PgyAKQv////8PgyIFQv////8PfiILQv////8PgyIJ\nIAV8QiCIfCALQiCIIgsgCXwiA0L/////D4N8IgRCIIh8IAMgA0IgiHwiA0L/////D4N8IgpCIIgg\nA0IgiCALfHwgBkL/////D4N8IgNCIIh8IghCIIh8IgZC/////w+DIA8gD34iE0L/////D4MgHXwg\nICA2fCAeIDB8IBUgH3wiFUIgiHwiHkIgiHwiH0IgiHwiHUL/////D4N8IAhC/////w+DIB9C////\n/w+DfCAeQv////8PgyAVQv////8PgyAEQv////8PgyAZfCIEQiCIfCAKQv////8Pg3wiCkIgiHwg\nA0L/////D4N8IgNCIIh8IghCIIh8IhVCIIggDCAPfiIZQv////8PgyIeIBNCIIh8IB1CIIh8IhNC\n/////w+DfCAGQiCIIAV8IA0gFH4iBkL/////D4MiHyAWQiCIIhZ8ICJCIIh8Ih1C/////w+DIDdC\nIIh8IDRCIIggEHwgDiAXfiIgQv////8PgyIwICxCIIgiInwgIUIgiHwiIUL/////D4MgLkIgiHwg\nLUIgiCARfCAjQiCIIhEgKEIgiHwgHEIgiHwgEkIgiHwiEkL/////D4N8IhxC/////w+DfCIoQv//\n//8Pg3wiLEL/////D4N8IiNC/////w+DfCItQv////8Pg3wiLkL/////D4MgFUL/////D4MgA0L/\n////D4MgCkL/////D4MgBEL/////D4MiBUL/////D34iEEL/////D4MiDiAFfEIgiHwgEEIgiCIQ\nIA58IgNC/////w+DfCIEQiCIfCADIANCIIh8IgNC/////w+DfCIKQiCIIANCIIggEHx8IAhC////\n/w+DfCIDQiCIfCIIQiCIfCIVQv////8PgyAWIB58IBggJnwgJSAnfCAaICp8IhZCIIh8IhpCIIh8\nIhhCIIh8IiVC/////w+DfCAIQv////8PgyAYQv////8Pg3wgGkL/////D4MgFkL/////D4MgBEL/\n////D4MgJHwiBEIgiHwgCkL/////D4N8IgpCIIh8IANC/////w+DfCIDQiCIfCIIQiCIfCIWQiCI\nIBlCIIgiGSAMIAx+IhpC/////w+DfCAlQiCIfCIkQv////8Pg3wgFUIgiCAFfCAZIA8gFH4iFUL/\n////D4MiGXwgE0IgiHwiE0L/////D4MgLkIgiHwgLUIgiCAJfCANIBd+IhhC/////w+DIiUgBkIg\niCIGfCAdQiCIfCIqQv////8PgyAjQiCIfCAsQiCIIAd8ICBCIIgiByAhQiCIfCASQiCIfCAcQiCI\nfCAoQiCIfCISQv////8Pg3wiHEL/////D4N8Ih5C/////w+DfCImQv////8Pg3wiHUL/////D4N8\nIidC/////w+DfCIgQv////8PgyAWQv////8PgyADQv////8PgyAKQv////8PgyAEQv////8PgyIF\nQv////8PfiIJQv////8PgyINIAV8QiCIfCAJQiCIIgkgDXwiA0L/////D4N8IgRCIIh8IAMgA0Ig\niHwiA0L/////D4N8IgpCIIggA0IgiCAJfHwgCEL/////D4N8IgNCIIh8IghCIIh8IhZC/////w+D\nIAYgGXwgHyAifCAxIDN8IBsgNXwiBkIgiHwiGUIgiHwiG0IgiHwiH0L/////D4N8IAhC/////w+D\nIBtC/////w+DfCAZQv////8PgyAGQv////8PgyAEQv////8PgyAvfCIEQiCIfCAKQv////8Pg3wi\nCkIgiHwgA0L/////D4N8IgNCIIh8IghCIIh8IgZCIIggDCAUfiIZQv////8PgyIbIBVCIIgiFXwg\nH0IgiHwiL0L/////D4N8IBZCIIggBXwgGyAaQiCIfCAkQiCIfCIWQv////8PgyAgQiCIfCAnQiCI\nIA58IBUgDyAXfiIVQv////8PgyIafCATQiCIfCITQv////8PgyAdQiCIfCAmQiCIIAt8IBhCIIgi\nJCAqQiCIfCASQiCIfCAcQiCIfCAeQiCIfCISQv////8Pg3wiGEL/////D4N8IhtC/////w+DfCIc\nQv////8Pg3wiKkL/////D4N8Ih5C/////w+DfCIfQv////8PgyAGQv////8PgyADQv////8PgyAK\nQv////8PgyAEQv////8PgyIFQv////8PfiIPQv////8PgyIOIAV8QiCIfCAPQiCIIg8gDnwiC0L/\n////D4N8IgNCIIh8IAsgC0IgiHwiC0L/////D4N8IgRCIIggC0IgiCAPfHwgCEL/////D4N8IgtC\nIIh8IgpCIIh8IghC/////w+DIBogJHwgByAlfCARIDB8ICkgMnwiEUIgiHwiB0IgiHwiBkIgiHwi\nGkL/////D4N8IApC/////w+DIAZC/////w+DfCAHQv////8PgyARQv////8PgyADQv////8PgyAr\nfCIDQiCIfCAEQv////8Pg3wiEUIgiHwgC0L/////D4N8IgtCIIh8IgdCIIh8IgRCIIggDCAXfiIK\nQv////8PgyIMIBVCIIgiBnwgGkIgiHwiFUL/////D4N8IAhCIIggBXwgGUIgiCIFIBQgFH4iCEL/\n////D4N8IC9CIIh8IhlC/////w+DIB9CIIh8IB5CIIggDXwgBSAMfCAWQiCIfCIWQv////8PgyAq\nQiCIfCAcQiCIIBB8IBNCIIggBnwgEkIgiHwgGEIgiHwgG0IgiHwiBkL/////D4N8IhJC/////w+D\nfCITQv////8Pg3wiGkL/////D4N8IiRC/////w+DfCIYQv////8Pg3wiG0L/////D4MgBEL/////\nD4MgC0L/////D4MgEUL/////D4MgA0L/////D4MiBUL/////D34iDEL/////D4MiDSAFfEIgiHwg\nDEIgiCIMIA18IgtC/////w+DfCIQQiCIfCALIAtCIIh8IgNC/////w+DfCILQiCIIANCIIggDHx8\nIAdC/////w+DfCIDQiCIfCIRQiCIfCIHQiCIIAV8IBQgF34iFEL/////D4MiBSAKQiCIIgR8IBVC\nIIh8IgpC/////w+DIBtCIIh8IBhCIIggDnwgBSAIQiCIfCAZQiCIfCIOQv////8PgyAkQiCIfCAa\nQiCIIAl8IBZCIIggBHwgBkIgiHwgEkIgiHwgE0IgiHwiCUL/////D4N8IgRC/////w+DfCIIQv//\n//8Pg3wiBkL/////D4N8IhJC/////w+DfCIFQiCIIA18IBRCIIgiDSAXIBd+IhRC/////w+DfCAK\nQiCIfCIXQv////8PgyASQiCIfCAGQiCIIA98IA5CIIggDXwgCUIgiHwgBEIgiHwgCEIgiHwiDkL/\n////D4N8IglC/////w+DfCIPQv////8Pg3wiDUIgiCAMfCAXQiCIIBRCIIh8IA5CIIh8IAlCIIh8\nIA9CIIh8IglC/////w+DfCIOQiCIIAlCIIh8QgAgDkL/////D4NCACANQv////8PgyAFQv////8P\ng0IAIAdC/////w+DQgAgEUL/////D4NCACADQv////8Pg0IAIAtC/////w+DQgAgEEL/////D4NC\n/////w99IglCIIh9Qv8Bg31C/////w99Ig9CIIh9Qv8Bg31C/////w99IgxCIIh9Qv8Bg30iFEIg\niH1C/wGDfSIXQiCIfUL/AYN9IgRCIIhCAX1CgH6EfCIKQiCIfUL/AYN9Qv////8PfSIIQiCIfUL/\nAYN9QiCIp0H/AXEbIgFBf3MhAiAAIAIgCKdxIAEgDqdxcjYCHCAAIAIgCqdxIAEgDadxcjYCGCAA\nIAIgBKdxIAEgBadxcjYCFCAAIAIgF6dxIAEgB6dxcjYCECAAIAIgFKdxIAEgEadxcjYCDCAAIAIg\nDKdxIAEgA6dxcjYCCCAAIAIgD6dxIAEgC6dxcjYCBCAAIAIgCadxIAEgEKdxcjYCAAu6KgElfyMA\nQYABayIDJAAgA0EAQcAA/AsAIAEgAkEGdGohJyAAKAIcISMgACgCGCEkIAAoAhQhHyAAKAIQISAg\nACgCDCElIAAoAgghJiAAKAIEISEgACgCACEiA0AgASAnRkUEQEEAIQIDQCACQcAARkUEQCACIANq\nIAEgAmooAAAiD0EYdCAPQYD+A3FBCHRyIA9BCHZBgP4DcSAPQRh2cnI2AgAgAkEEaiECDAEFCwsg\nAygCPCEVIAMoAjghFiADKAI0IR0gAygCMCECIAMoAiwhFyADKAIoIRggAygCJCEZIAMoAiAhECAD\nKAIcIRogAygCGCEbIAMoAhQhHCADKAIQIREgAygCDCEPIAMoAgghEiADKAIEIRMgAygCACEUIAMg\nJjYCYCADICU2AmQgAyAkNgJoIAMgIzYCbCADIB82AnwgAyAgNgJ4IAMgITYCdCADICI2AnAgA0HQ\nAGoiCSADQeAAaiIKIANB8ABqIgsgE0GRid2JB2ogFEGY36iUBGoQbyADKAJQIQQgAygCVCEFIAMo\nAlghBiADKAJcIQcgAyAfNgJsIAMgIDYCaCADICE2AmQgAyAiNgJgIAMgBzYCfCADIAY2AnggAyAF\nNgJ0IAMgBDYCcCAJIAogCyAPQdvIqLIBayASQbGI/NEEaxBvIAMoAlAhCCADKAJUIQwgAygCWCEN\nIAMoAlwhDiADIAc2AmwgAyAGNgJoIAMgBTYCZCADIAQ2AmAgAyAONgJ8IAMgDTYCeCADIAw2AnQg\nAyAINgJwIAkgCiALIBxB8aPEzwVqIBFB24TbygNqEG8gAygCUCEEIAMoAlQhBSADKAJYIQYgAygC\nXCEHIAMgDjYCbCADIA02AmggAyAMNgJkIAMgCDYCYCADIAc2AnwgAyAGNgJ4IAMgBTYCdCADIAQ2\nAnAgCSAKIAsgGkGrwo6nBWsgG0Hc+oHuBmsQbyADKAJQIQggAygCVCEMIAMoAlghDSADKAJcIQ4g\nAyAHNgJsIAMgBjYCaCADIAU2AmQgAyAENgJgIAMgDjYCfCADIA02AnggAyAMNgJ0IAMgCDYCcCAJ\nIAogCyAZQYG2jZQBaiAQQeiq4b8CaxBvIAMoAlAhBCADKAJUIQUgAygCWCEGIAMoAlwhByADIA42\nAmwgAyANNgJoIAMgDDYCZCADIAg2AmAgAyAHNgJ8IAMgBjYCeCADIAU2AnQgAyAENgJwIAkgCiAL\nIBdBw/uxqAVqIBhBvovGoQJqEG8gAygCUCEIIAMoAlQhDCADKAJYIQ0gAygCXCEOIAMgBzYCbCAD\nIAY2AmggAyAFNgJkIAMgBDYCYCADIA42AnwgAyANNgJ4IAMgDDYCdCADIAg2AnAgCSAKIAsgHUGC\nnIX5B2sgAkH0uvmVB2oQbyADKAJQIQQgAygCVCEFIAMoAlghBiADKAJcIQcgAyAONgJsIAMgDTYC\naCADIAw2AmQgAyAINgJgIAMgBzYCfCADIAY2AnggAyAFNgJ0IAMgBDYCcCAJIAogCyAVQYydkPMD\nayAWQdnyj6EGaxBvIAMoAlAhCCADKAJUIQwgAygCWCENIAMoAlwhDiADIBQ2AlwgAyATNgJYIAMg\nEjYCVCADIA82AlAgAyAQNgJsIAMgGTYCaCADIBg2AmQgAyAXNgJgIAMgAjYCfCADIB02AnggAyAW\nNgJ0IAMgFTYCcCADQUBrIh4gCSARIAogCxBiIAMoAkAhEiADKAJEIRMgAygCSCEUIAMoAkwhDyAD\nIAc2AmwgAyAGNgJoIAMgBTYCZCADIAQ2AmAgAyAONgJ8IAMgDTYCeCADIAw2AnQgAyAINgJwIAkg\nCiALIBRB+vCGggFrIA9Bv6yS2wFrEG8gAygCUCEEIAMoAlQhBSADKAJYIQYgAygCXCEHIAMgDjYC\nbCADIA02AmggAyAMNgJkIAMgCDYCYCADIAc2AnwgAyAGNgJ4IAMgBTYCdCADIAQ2AnAgCSAKIAsg\nEkHMw7KgAmogE0HGu4b+AGoQbyADKAJQIQggAygCVCEMIAMoAlghDSADKAJcIQ4gAyARNgJcIAMg\nHDYCWCADIBs2AlQgAyAaNgJQIAMgAjYCbCADIB02AmggAyAWNgJkIAMgFTYCYCADIA82AnwgAyAU\nNgJ4IAMgEzYCdCADIBI2AnAgHiAJIBAgCiALEGIgAygCQCEaIAMoAkQhGyADKAJIIRwgAygCTCER\nIAMgBzYCbCADIAY2AmggAyAFNgJkIAMgBDYCYCADIA42AnwgAyANNgJ4IAMgDDYCdCADIAg2AnAg\nCSAKIAsgHEGqidLTBGogEUHv2KTvAmoQbyADKAJQIQQgAygCVCEFIAMoAlghBiADKAJcIQcgAyAO\nNgJsIAMgDTYCaCADIAw2AmQgAyAINgJgIAMgBzYCfCADIAY2AnggAyAFNgJ0IAMgBDYCcCAJIAog\nCyAaQdqR5rcHaiAbQdzTwuUFahBvIAMoAlAhCCADKAJUIQwgAygCWCENIAMoAlwhDiADIBA2Alwg\nAyAZNgJYIAMgGDYCVCADIBc2AlAgAyAPNgJsIAMgFDYCaCADIBM2AmQgAyASNgJgIAMgETYCfCAD\nIBw2AnggAyAbNgJ0IAMgGjYCcCAeIAkgAiAKIAsQYiADKAJAIRcgAygCRCEYIAMoAkghGSADKAJM\nIRAgAyAHNgJsIAMgBjYCaCADIAU2AmQgAyAENgJgIAMgDjYCfCADIA02AnggAyAMNgJ0IAMgCDYC\ncCAJIAogCyAZQZPzuL4FayAQQa7dhr4GaxBvIAMoAlAhBCADKAJUIQUgAygCWCEGIAMoAlwhByAD\nIA42AmwgAyANNgJoIAMgDDYCZCADIAg2AmAgAyAHNgJ8IAMgBjYCeCADIAU2AnQgAyAENgJwIAkg\nCiALIBdBuYCahQRrIBhBuLDz/wRrEG8gAygCUCEIIAMoAlQhDCADKAJYIQ0gAygCXCEOIAMgAjYC\nXCADIB02AlggAyAWNgJUIAMgFTYCUCADIBE2AmwgAyAcNgJoIAMgGzYCZCADIBo2AmAgAyAQNgJ8\nIAMgGTYCeCADIBg2AnQgAyAXNgJwIB4gCSAPIAogCxBiIAMoAkAhFSADKAJEIRYgAygCSCEdIAMo\nAkwhAiADIAc2AmwgAyAGNgJoIAMgBTYCZCADIAQ2AmAgAyAONgJ8IAMgDTYCeCADIAw2AnQgAyAI\nNgJwIAkgCiALIB1Bud3h0gJrIAJBjej/yANrEG8gAygCUCEEIAMoAlQhBSADKAJYIQYgAygCXCEH\nIAMgDjYCbCADIA02AmggAyAMNgJkIAMgCDYCYCADIAc2AnwgAyAGNgJ4IAMgBTYCdCADIAQ2AnAg\nCSAKIAsgFUHn0qShAWogFkHRxqk2ahBvIAMoAlAhCCADKAJUIQwgAygCWCENIAMoAlwhDiADIA82\nAlwgAyAUNgJYIAMgEzYCVCADIBI2AlAgAyAQNgJsIAMgGTYCaCADIBg2AmQgAyAXNgJgIAMgAjYC\nfCADIB02AnggAyAWNgJ0IAMgFTYCcCAeIAkgESAKIAsQYiADKAJAIRIgAygCRCETIAMoAkghFCAD\nKAJMIQ8gAyAHNgJsIAMgBjYCaCADIAU2AmQgAyAENgJgIAMgDjYCfCADIA02AnggAyAMNgJ0IAMg\nCDYCcCAJIAogCyAUQbjC7PACaiAPQYWV3L0CahBvIAMoAlAhBCADKAJUIQUgAygCWCEGIAMoAlwh\nByADIA42AmwgAyANNgJoIAMgDDYCZCADIAg2AmAgAyAHNgJ8IAMgBjYCeCADIAU2AnQgAyAENgJw\nIAkgCiALIBJBk5rgmQVqIBNB/Nux6QRqEG8gAygCUCEIIAMoAlQhDCADKAJYIQ0gAygCXCEOIAMg\nETYCXCADIBw2AlggAyAbNgJUIAMgGjYCUCADIAI2AmwgAyAdNgJoIAMgFjYCZCADIBU2AmAgAyAP\nNgJ8IAMgFDYCeCADIBM2AnQgAyASNgJwIB4gCSAQIAogCxBiIAMoAkAhGiADKAJEIRsgAygCSCEc\nIAMoAkwhESADIAc2AmwgAyAGNgJoIAMgBTYCZCADIAQ2AmAgAyAONgJ8IAMgDTYCeCADIAw2AnQg\nAyAINgJwIAkgCiALIBxBu5WoswdqIBFB1OapqAZqEG8gAygCUCEEIAMoAlQhBSADKAJYIQYgAygC\nXCEHIAMgDjYCbCADIA02AmggAyAMNgJkIAMgCDYCYCADIAc2AnwgAyAGNgJ4IAMgBTYCdCADIAQ2\nAnAgCSAKIAsgGkH7prfsBmsgG0HS7fTxB2sQbyADKAJQIQggAygCVCEMIAMoAlghDSADKAJcIQ4g\nAyAQNgJcIAMgGTYCWCADIBg2AlQgAyAXNgJQIAMgDzYCbCADIBQ2AmggAyATNgJkIAMgEjYCYCAD\nIBE2AnwgAyAcNgJ4IAMgGzYCdCADIBo2AnAgHiAJIAIgCiALEGIgAygCQCEXIAMoAkQhGCADKAJI\nIRkgAygCTCEQIAMgBzYCbCADIAY2AmggAyAFNgJkIAMgBDYCYCADIA42AnwgAyANNgJ4IAMgDDYC\ndCADIAg2AnAgCSAKIAsgGUG1s5a/BWsgEEHfroDqBWsQbyADKAJQIQQgAygCVCEFIAMoAlghBiAD\nKAJcIQcgAyAONgJsIAMgDTYCaCADIAw2AmQgAyAINgJgIAMgBzYCfCADIAY2AnggAyAFNgJ0IAMg\nBDYCcCAJIAogCyAXQd3czsQDayAYQZDp0e0DaxBvIAMoAlAhCCADKAJUIQwgAygCWCENIAMoAlwh\nDiADIAI2AlwgAyAdNgJYIAMgFjYCVCADIBU2AlAgAyARNgJsIAMgHDYCaCADIBs2AmQgAyAaNgJg\nIAMgEDYCfCADIBk2AnggAyAYNgJ0IAMgFzYCcCAeIAkgDyAKIAsQYiADKAJAIRUgAygCRCEWIAMo\nAkghHSADKAJMIQIgAyAHNgJsIAMgBjYCaCADIAU2AmQgAyAENgJgIAMgDjYCfCADIA02AnggAyAM\nNgJ0IAMgCDYCcCAJIAogCyAdQdzzm8sCayACQeevtPMCaxBvIAMoAlAhBCADKAJUIQUgAygCWCEG\nIAMoAlwhByADIA42AmwgAyANNgJoIAMgDDYCZCADIAg2AmAgAyAHNgJ8IAMgBjYCeCADIAU2AnQg\nAyAENgJwIAkgCiALIBVB8MCqgwFqIBZB+5TH3wBrEG8gAygCUCEIIAMoAlQhDCADKAJYIQ0gAygC\nXCEOIAMgDzYCXCADIBQ2AlggAyATNgJUIAMgEjYCUCADIBA2AmwgAyAZNgJoIAMgGDYCZCADIBc2\nAmAgAyACNgJ8IAMgHTYCeCADIBY2AnQgAyAVNgJwIB4gCSARIAogCxBiIAMoAkAhEiADKAJEIRMg\nAygCSCEUIAMoAkwhDyADIAc2AmwgAyAGNgJoIAMgBTYCZCADIAQ2AmAgAyAONgJ8IAMgDTYCeCAD\nIAw2AnQgAyAINgJwIAkgCiALIBRBiNjd8QFqIA9BloKTzQFqEG8gAygCUCEEIAMoAlQhBSADKAJY\nIQYgAygCXCEHIAMgDjYCbCADIA02AmggAyAMNgJkIAMgCDYCYCADIAc2AnwgAyAGNgJ4IAMgBTYC\ndCADIAQ2AnAgCSAKIAsgEkG1+cKlA2ogE0HM7qG6AmoQbyADKAJQIQggAygCVCEMIAMoAlghDSAD\nKAJcIQ4gAyARNgJcIAMgHDYCWCADIBs2AlQgAyAaNgJQIAMgAjYCbCADIB02AmggAyAWNgJkIAMg\nFTYCYCADIA82AnwgAyAUNgJ4IAMgEzYCdCADIBI2AnAgHiAJIBAgCiALEGIgAygCQCERIAMoAkQh\nGiADKAJIIRsgAygCTCEcIAMgBzYCbCADIAY2AmggAyAFNgJkIAMgBDYCYCADIA42AnwgAyANNgJ4\nIAMgDDYCdCADIAg2AnAgCSAKIAsgG0HK1OL2BGogHEGzmfDIA2oQbyADKAJQIQQgAygCVCEFIAMo\nAlghBiADKAJcIQcgAyAONgJsIAMgDTYCaCADIAw2AmQgAyAINgJgIAMgBzYCfCADIAY2AnggAyAF\nNgJ0IAMgBDYCcCAJIAogCyARQfPfucEGaiAaQc+U89wFahBvIAMoAlAhCCADKAJUIQwgAygCWCEN\nIAMoAlwhDiADIBA2AlwgAyAZNgJYIAMgGDYCVCADIBc2AlAgAyAPNgJsIAMgFDYCaCADIBM2AmQg\nAyASNgJgIAMgHDYCfCADIBs2AnggAyAaNgJ0IAMgETYCcCAeIAkgAiAKIAsQYiADKAJAIRAgAygC\nRCESIAMoAkghEyADKAJMIRQgAyAHNgJsIAMgBjYCaCADIAU2AmQgAyAENgJgIAMgDjYCfCADIA02\nAnggAyAMNgJ0IAMgCDYCcCAJIAogCyATQe/GlcUHaiAUQe6FvqQHahBvIAMoAlAhFyADKAJUIRgg\nAygCWCEZIAMoAlwhBCADIA42AmwgAyANNgJoIAMgDDYCZCADIAg2AmAgAyAENgJ8IAMgGTYCeCAD\nIBg2AnQgAyAXNgJwIAkgCiALIBBB+PvjmQdrIBJB7I/e2QdrEG8gAygCUCEFIAMoAlQhBiADKAJY\nIQcgAygCXCEIIAMgAjYCXCADIB02AlggAyAWNgJUIAMgFTYCUCADIBw2AmwgAyAbNgJoIAMgGjYC\nZCADIBE2AmAgAyAUNgJ8IAMgEzYCeCADIBI2AnQgAyAQNgJwIB4gCSAPIAogCxBiIAMoAkAhFSAD\nKAJEIRYgAygCSCECIAMoAkwhDyADIAQ2AmwgAyAZNgJoIAMgGDYCZCADIBc2AmAgAyAINgJ8IAMg\nBzYCeCADIAY2AnQgAyAFNgJwIAkgCiALIAJBlaa+3QVrIA9BhoCE+gZrEG8gAygCUCECIAMoAlQh\nDyADKAJYIREgAygCXCEQIAMgCDYCbCADIAc2AmggAyAGNgJkIAMgBTYCYCADIBA2AnwgAyARNgJ4\nIAMgDzYCdCADIAI2AnAgCSAKIAsgFUGOjrrMA2sgFkGJuJmIBGsQbyABQUBrIQEgECAjaiEjIBEg\nJGohJCAPICVqISUgAiAmaiEmIAMoAlwgH2ohHyADKAJYICBqISAgAygCVCAhaiEhIAMoAlAgImoh\nIgwBBQsLIAAgIzYCHCAAICQ2AhggACAfNgIUIAAgIDYCECAAICU2AgwgACAmNgIIIAAgITYCBCAA\nICI2AgAgA0GAAWokAAuBKgIDfyJ+IwBBsAFrIgMkACADQQBBgAH8CwAgASACQQd0aiEFIAApAzgh\nJiAAKQMwISQgACkDKCEiIAApAyAhHyAAKQMYIScgACkDECElIAApAwghIyAAKQMAISADQCABIAVH\nBEAgAUGAAWpBACECA0AgAkGAAUcEQCACIANqIAEgAmopAAAiD0I4hiAPQoD+A4NCKIaEIA9CgID8\nB4NCGIYgD0KAgID4D4NCCIaEhCAPQgiIQoCAgPgPgyAPQhiIQoCA/AeDhCAPQiiIQoD+A4MgD0I4\niISEhDcDACACQQhqIQIMAQULCyADKQMYIQwgAykDECEOIAMpAwghGiADQaABaiIBICAgHyAjICIg\nJSAkICcgJiADKQMAIiFCotyiuY3zi8XCAHwQsgEgASADKQOgASIPIAMpA6gBIgsgICAfICMgIiAl\nICQgGkLNy72fkpLRm/EAfBCyASABIAMpA6ABIhAgAykDqAEiESAPIAsgICAfICMgIiAOQtGJy52B\nhsGfygB9ELIBIAEgAykDoAEiBiADKQOoASITIBAgESAPIAsgICAfIAxCxMjY86eLiaUWfRCyASAD\nKQM4IRcgAykDMCEYIAMpAyghHCABIAMpA6ABIhsgAykDqAEiDSAGIBMgECARIA8gCyADKQMgIh1C\nuOqimr/LsKs5fBCyASABIAMpA6ABIg8gAykDqAEiCyAbIA0gBiATIBAgESAcQpmgl7CbvsT42QB8\nELIBIAEgAykDoAEiESADKQOoASISIA8gCyAbIA0gBiATIBhC5eCah7Wrn+DtAH0QsgEgASADKQOg\nASIGIAMpA6gBIhMgESASIA8gCyAbIA0gF0Lo/cmsoqXo8dQAfRCyASADKQNYIRsgAykDUCEQIAMp\nA0ghDSABIAMpA6ABIhUgAykDqAEiFCAGIBMgESASIA8gCyADKQNAIh5Cvvvz5/WslfwnfRCyASAB\nIAMpA6ABIgsgAykDqAEiGSAVIBQgBiATIBEgEiANQr7fwauU4NbBEnwQsgEgASADKQOgASISIAMp\nA6gBIgcgCyAZIBUgFCAGIBMgEEKM5ZL35LfhmCR8ELIBIAEgAykDoAEiBiADKQOoASITIBIgByAL\nIBkgFSAUIBtC4un+r724n4bVAHwQsgEgAykDeCERIAMpA3AhDyADKQNoIRUgASADKQOgASIUIAMp\nA6gBIhYgBiATIBIgByALIBkgAykDYCIZQu+S7pPPrpff8gB8ELIBIAEgAykDoAEiCSADKQOoASII\nIBQgFiAGIBMgEiAHIBVCz9Klp5zA05D/AH0QsgEgASADKQOgASISIAMpA6gBIgcgCSAIIBQgFiAG\nIBMgD0LL2+PRjav+keQAfRCyASABIAMpA6ABIhMgAykDqAEiCiASIAcgCSAIIBQgFiARQuyy24Sz\n0YOyPn0QsgEgAykDqAEhCyADKQOgASEGIANBgAFqIgIgGiAhIA4gECANIBEgDxCmASADQZABaiIE\nIAwgDiAdIBkgGyADKQOAASIhIAMpA4gBIhoQpgEgAykDkAEhFCADKQOYASEWIAEgBiALIBMgCiAS\nIAcgCSAIIBpCruq6iObHpbIbfRCyASABIAMpA6ABIgkgAykDqAEiCCAGIAsgEyAKIBIgByAhQp20\nw72cj+6gEH0QsgEgASADKQOgASISIAMpA6gBIgcgCSAIIAYgCyATIAogFkK1q7Pc6Ljn4A98ELIB\nIAEgAykDoAEiCiADKQOoASIMIBIgByAJIAggBiALIBRC5biyvce5qIYkfBCyASADKQOoASEGIAMp\nA6ABIQ4gASAcIB0gGCAPIBUgFCAWEKYBIAEgFyAYIB4gGiARIAMpA6ABIhogAykDqAEiExCmASAD\nKQOgASEYIAMpA6gBIQsgASAOIAYgCiAMIBIgByAJIAggE0L1hKzJ9Y3L9C18ELIBIAEgAykDoAEi\nCSADKQOoASIIIA4gBiAKIAwgEiAHIBpCg8mb9aaVobrKAHwQsgEgASADKQOgASISIAMpA6gBIgcg\nCSAIIA4gBiAKIAwgC0LU94fqy7uq2NwAfBCyASABIAMpA6ABIgogAykDqAEiDCASIAcgCSAIIA4g\nBiAYQrWnxZiom+L89gB8ELIBIAMpA6gBIQYgAykDoAEhDiABIA0gHiAQIBYgISAYIAsQpgEgASAb\nIBAgGSATIBQgAykDoAEiFiADKQOoASIbEKYBIAMpA6ABIQ0gAykDqAEhECABIA4gBiAKIAwgEiAH\nIAkgCCAbQtXA5IzR1evg5wB9ELIBIAEgAykDoAEiFCADKQOoASIJIA4gBiAKIAwgEiAHIBZC8Juv\nkq2yjufXAH0QsgEgASADKQOgASIHIAMpA6gBIgggFCAJIA4gBiAKIAwgEELBvZO49oa2/s8AfRCy\nASABIAMpA6ABIgogAykDqAEiDCAHIAggFCAJIA4gBiANQpziw4iEh6DTwAB9ELIBIAMpA6gBIQYg\nAykDoAEhDiABIBUgGSAPIAsgGiANIBAQpgEgASARIA8gAykDiAEiESAbIBggAykDoAEiFyADKQOo\nASISEKYBIAMpA6ABIRUgAykDqAEhDyABIA4gBiAKIAwgByAIIBQgCSASQr7g3ZLMgf2POX0QsgEg\nASADKQOgASIJIAMpA6gBIhwgDiAGIAogDCAHIAggF0LbsdXnhtebrCp9ELIBIAEgAykDoAEiByAD\nKQOoASIIIAkgHCAOIAYgCiAMIA9C74SOgJ7qmOUGfBCyASABIAMpA6ABIgogAykDqAEiDCAHIAgg\nCSAcIA4gBiAVQvDcudDwrMqUFHwQsgEgAykDqAEhBiADKQOgASEOIAEgAykDgAEgESADKQOYASIR\nIBAgFiAVIA8QpgEgASADKQOQASARIBMgEiANIAMpA6ABIh0gAykDqAEiFBCmASADKQOgASEZIAMp\nA6gBIREgASAOIAYgCiAMIAcgCCAJIBwgFEL838i21NDC2yd8ELIBIAEgAykDoAEiCSADKQOoASIc\nIA4gBiAKIAwgByAIIB1CppKb4YWnyI0ufBCyASABIAMpA6ABIgcgAykDqAEiCCAJIBwgDiAGIAog\nDCARQu3VkNbFv5uWzQB8ELIBIAEgAykDoAEiCiADKQOoASIMIAcgCCAJIBwgDiAGIBlC3+fW7Lmi\ng5zTAHwQsgEgAykDqAEhBiADKQOgASEOIAIgGiATIAsgDyAXIBkgERCmASAEIBggCyAbIBQgFSAD\nKQOAASIhIAMpA4gBIgsQpgEgAykDkAEhGiADKQOYASEeIAEgDiAGIAogDCAHIAggCSAcIAtC3se9\n3cjqnIXlAHwQsgEgASADKQOgASIJIAMpA6gBIhwgDiAGIAogDCAHIAggIUKo5d7js9eCtfYAfBCy\nASABIAMpA6ABIgcgAykDqAEiCCAJIBwgDiAGIAogDCAeQpqiycCb2s2e/gB9ELIBIAEgAykDoAEi\nCiADKQOoASIMIAcgCCAJIBwgDiAGIBpCxZX3267v9MbtAH0QsgEgAykDqAEhBiADKQOgASEOIAEg\nFiAbIBAgESAdIBogHhCmASABIA0gECASIAsgGSADKQOgASIWIAMpA6gBIhMQpgEgAykDoAEhGCAD\nKQOoASELIAEgDiAGIAogDCAHIAggCSAcIBNCnPm7mOvrhaDdAH0QsgEgASADKQOgASINIAMpA6gB\nIgkgDiAGIAogDCAHIAggFkL/n/edxLbm8tcAfRCyASABIAMpA6ABIgcgAykDqAEiCCANIAkgDiAG\nIAogDCALQu/QnfjykZ3aPX0QsgEgASADKQOgASIKIAMpA6gBIgwgByAIIA0gCSAOIAYgGELQg63N\nz8vryTh9ELIBIAMpA6gBIRAgAykDoAEhBiABIBcgEiAPIB4gISAYIAsQpgEgASAVIA8gFCATIBog\nAykDoAEiGiADKQOoASIOEKYBIAMpA6ABIRsgAykDqAEhDyABIAYgECAKIAwgByAIIA0gCSAOQujb\n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\nKAIANgIAIAdBqAFqIAFBCGopAgA3AwAgByABKQIANwOgASAHIAg2ApwBIAcgCTYCmAEgByARNwOQ\nASAHQbgBakEAQYAI/AsAIAdBmAFqIQ4CQAJAIAYgBygCoAEiAUEDdiABQQdxQQBHakcNACAHQcgA\naiAIEI8BAkAgBSAGIAcoAkgiCiAHKAJMIgEQbSAIRXIgASAIR3JFBEAgCiAJIAgQpwENAQULIAFF\nDQEgCiABQQJ0EMwBDAELQQAhASAKIQIgCCEGA0AgAigCACABciEBIAJBBGohAiAGQQFrIgYNAAsC\nQCABEL4CBEBBACELDAEFCyAHQUBrIAgQjwECfwJAIAcpA5ABQn6DIhBQRQRAIAcoAkQhAiAHKAJA\nIQYgByAHKAKgATYC3AkgByAHKQKkATcC1AkgByAHKAKcASIBNgLQCSAHIAcoApgBNgLMCSAHQThq\nIAEQjwEgB0HUCWohCSAHKAI8IQEgBygCOCEPIAcoAtAJIgVBBEkNASAFQYACTQRAQQEhDAJAIAco\nArABIgsgBUcNACABIAtHBEAgASELDAEFCyABIAhHBEAgCCELDAEFCyAPIAogBygCrAEgBygCzAkg\nCSAIECtBACEMCyAHQTBqIAwgCxC4AiAHKAIwDAMFCyAHQShqIAUQ1wIgBygCKAwCBQtBjtDAAEEr\nIAdBzAlqQdiuwABB2K/AABCvAQALIAdBIGogBRDYAiAHKAIgCxD1ASABIAJGBEAgAkECdCINBEAg\nBiAPIA38CgAABQtCASAQeUI/hYYhESAHKALQCSELIAcoAswJIQEgAiEFA0AgEUIBWARAIAIEQCAP\nIA0QzAEFCyAHIAg2AsQJIAcgCjYCwAkgByAFNgK8CSAHIAY2ArgJIAdBuAlqIAcoAswJIAcoAtAJ\nIAkQlwEQ9QECQAJAIAcoAqABIgFBA3YgAUEHcUEAR2oiDEEDakH8////B3EiCUGBCEkEQCAHIAk2\nAsgJIAcgBUECdCIBNgK4CSABIAlHDQEgB0EANgKICiAHQgA3AoAKIAdBADYC3AkgB0EANgLMCSAH\nIAk2AvQJIAcgB0G4AWoiDSAJaiICNgL8CSAHIAY2AuwJIAcgASAGajYC8AkgB0HcCWohCwNAAkAg\nAiANRg0AIAcgDUEBajYC+AkCQAJAA0AgB0EYaiAHQcwJahDUASAHLQAYBEAgBy0AGSEBQQEhAgwC\nBQsCQCAHKALsCSICRQ0AIAIgBygC8AkiAUYNACAHQQQ2AtQJIAdCATcCzAkgByABQQRrIgE2AvAJ\nIAcgASgCACIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYC2AkMAQsLIAdBEGogCxDU\nASAHLQARIQEgBy0AECICRQ0BCyAHIAcoAvQJQQFrNgL0CQsgAkEBcUUNACANIAE6AAAgBygC/Akh\nAiAHKAL4CSENDAELCyAJIAxJDQIgCSAMayICIAdBuAFqIgFqIQsCQANAIAJFDQEgAkEBayECIAEt\nAAAgAUEBaiEBRQ0AC0GIsMAAQTFBvLDAABDsAQALIAYgBRDMAgwGBQsgCUGACEHor8AAEOICAAsg\nB0EANgLMCSAHQcgJaiAHQbgJaiAHQcwJakGgpsAAENACAAsgB0EANgLcCSAHQQE2AtAJIAdB6LTA\nADYCzAkgB0IENwLUCSAHQcwJakH4r8AAEHsABQsgB0EIaiAGIAUgB0HMCWoQpQEgBygCDCEFIAco\nAgghBiARQgGIIhEgEINQDQAgByACNgLECSAHIA82AsAJIAcgBTYCvAkgByAGNgK4CSAHQbgJaiAB\nIAsgCRCXARD1AQwACwAFCyACIAFByLLAABDEAQALIAogCBDMAiALDQELIA4QvAIMAQsgB0HMCWoi\nAiAAKAIAIgEgACgCBCIAKAIQEQMAIAMgBBAVIAdBADYCwAkgByAMNgK8CSAHIAs2ArgJIAEgAiAH\nQbgJaiAHKAKgASAAKAIUEQkAIAcoAsAJIQEgBygCvAkgDhC8AiABR3IMAQtBAQsgB0GQCmokAAuz\nDwIBfxd+IwBB4ANrIgQkACAEQeACaiACKQMAIgwgDEI/hyIUIAApAwAiBiAGQj+HIggQowEgBEGA\nA2ogAikDCCINIA1CP4ciFSABKQMAIgkgCUI/hyIFEKMBIARB8AJqIAIpAxAiECAQQj+HIhkgBiAI\nEKMBIARBkANqIAIpAxgiESARQj+HIhogCSAFEKMBIARBwAJqIA0gASkDICIWQj+HIgiDIAwgACkD\nICIXQj+HIgWDfCIGIAYgAykDKCIOIAQpA4ADIgogBCkD4AJ8Igl+fEL//////////z+DfSIPIA9C\nP4ciGCADKQMAIgYgBkI/hyIHEKMBIARB0AJqIAggEYMgBSAQg3wiBSAFIA4gBCkDkAMiEiAEKQPw\nAnwiCH58Qv//////////P4N9Ig4gDkI/hyIbIAYgBxCjASAEQaADaiAMIBQgACkDCCIGIAZCP4ci\nBxCjASAEQcADaiANIBUgASkDCCIFIAVCP4ciCxCjASAEQbADaiAQIBkgBiAHEKMBIARB0ANqIBEg\nGiAFIAsQowEgBCkD0AMiBSAEKQOwA3wiBiAFVK0gBEHYA2opAwAgBEG4A2opAwB8fCAEKQPQAiIF\nIAh8IgcgBVStIARB2AJqKQMAIAggElStIARBmANqKQMAIARB+AJqKQMAfHx8fCIIQj6HfCAGIAYg\nCEIChiAHQj6IhHwiBlatfCEIIAQpA8ADIgcgBCkDoAN8IgUgB1StIARByANqKQMAIARBqANqKQMA\nfHwgBCkDwAIiByAJfCISIAdUrSAEQcgCaikDACAJIApUrSAEQYgDaikDACAEQegCaikDAHx8fHwi\nCUI+h3wgBSAJQgKGIBJCPoiEfCIJIAVUrXwhBSABKQMYIQogASkDECEHIAApAxghEiAAKQMQIQsg\nAykDCCITUEUEQCAEQbACaiAPIBggEyATQj+HIhgQowEgBEGgAmogDiAbIBMgGBCjASAGIAYgBCkD\noAJ8IgZWrSAIIARBqAJqKQMAfHwhCCAJIAkgBCkDsAJ8IglWrSAFIARBuAJqKQMAfHwhBQULIAAg\nCUL//////////z+DNwMAIAEgBkL//////////z+DNwMAIARBkAJqIAwgFCALIAtCP4ciExCjASAE\nQfABaiANIBUgByAHQj+HIhQQowEgBEGAAmogECAZIAsgExCjASAEQeABaiARIBogByAUEKMBIAQp\nA+ABIgsgBCkDgAJ8IgcgC1StIARB6AFqKQMAIARBiAJqKQMAfHwgCEI+h3wgByAIQgKGIAZCPoiE\nfCIIIAdUrXwhBiAEKQPwASILIAQpA5ACfCIHIAtUrSAEQfgBaikDACAEQZgCaikDAHx8IAVCPod8\nIAcgBUIChiAJQj6IhHwiBSAHVK18IQkgAykDECIHUEUEQCAEQdABaiAHIAdCP4ciCyAPIA9CP4cQ\nowEgBEHAAWogByALIA4gDkI/hxCjASAEKQPAASIHIAh8IgggB1StIARByAFqKQMAIAZ8fCEGIAQp\nA9ABIgcgBXwiBSAHVK0gBEHYAWopAwAgCXx8IQkFCyAAIAVC//////////8/gzcDCCABIAhC////\n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\nAGogB0H4AGooAgAiAzYCACADRQRAIAYgByAGEN4BBQsgAkHYAGohAiAHQYABaiEHDAALAAsgAEHQ\ngQRqIQYgBEHQgwhqIQNBACEHQQAhCANAIAhBwABHBEBBACECIAMhBANAIAJBgAhHBEAgCSgCACAH\naiACaiAEENcBIAJBQGshAiAEQdgAaiEEDAEFCwsgB0GACGohByADQYALaiEDIAhBAWohCAwBBQsL\nIwBBgANrIgMkACADQThqQgA3AwAgA0EwakIANwMAIANBKGpCADcDACADQgA3AyAgCSICQaABakEA\nNgIAIAJBKGoiCEGA78AAQSgQKSEEIAJB0ABqQajvwABBKBApGiACQYABakIANwMAIAJB+ABqQgE3\nAwAgAkGIAWpCADcDACACQZABakIANwMAIAJBmAFqQgA3AwAgBCAEEOQBIAJBEGpCADcDACACQgE3\nAwggAkEYakIANwMAIAJBIGpCADcDACADQZABaiIEIAJBCGoiCRBOIANBGGogA0GoAWoiCykDADcD\nACADQRBqIANBoAFqIgwpAwA3AwAgAyADKQOYATcDCCADIAMpA5ABNwMAIANByABqIgogA0EgEHYg\nCiAEEIoBIANBuAFqIgdB6PHAACAHIAQQRUUgAykD2AEgAykD0AEgAykDyAEgAykDwAEgAykDuAGE\nhISEUHIQmAEgCCAHENgBIAcQogIgCiAEEIoBIANB4AJqIgcgBEEAEEIgB0GY7sAAIANB+AJqIgQp\nAwAgA0HwAmoiCikDACADQegCaiINKQMAIAMpA+AChISEUBCoASALQgA3AwAgDEIANwMAIANCADcD\nmAEgA0IANwOQASACIANB4AFqIgIgBxATIAcgBxCRASAJQRhqIAQpAwA3AwAgCUEQaiAKKQMANwMA\nIAlBCGogDSkDADcDACAJIAMpA+ACNwMAIAggAkGAARApGiACELACIANBgANqJAAFCwJAIAFBgAJx\nRQ0AIAAoAgANACAFQQA2AvgCIAVBgAJqIgNBgO/AAEEoECkaIAVBqAJqQajvwABBKBApGiAFQdgC\nakIANwMAIAVB4AJqQgA3AwAgBUHoAmpCADcDACAFQfACakIANwMAIAAgBjYCACAFQgE3A9ACIAYg\nAxA8IAAgBkGAgCBqNgIEQYABIQIgBUHQgwhqIANBgAEQKRoDQCACBEAgBUHQgwhqIgYgBkEAEDIg\nAkEBayECDAEFCwsgACgCBCAFQdCDCGoQPAsgACABQQp2QQFxNgLAASAAIQIFCyAFQYDEDWokACAC\nC6MPAgl/AX4jAEHgAmsiBiQAIAZBGGogARD9ASAGKAIcIQ0gBigCGCEIIAZBEGogAiADEOgBIAYo\nAhQhCiAGKAIQIQsgBkEIaiAEIAUQ6AEgCgRAIAYoAgwhDCAGKAIIIQUgBkEAIAstAAAiAUEfayIC\nIAEgAkkbIgI6ADMCQAJAIAJBBEkNACAGQQE2ApQCIAZB/IPAADYCkAIgBkIBNwKcAiAGQQc2ApwB\nIAYgBkGYAWo2ApgCIAYgBkEzajYCmAEgBkE0aiAGQZACahBUIAYtADghAiAGKAI0IgFBgICAgHhG\nDQAgBkEsaiAGQTxqKAAANgAAIAYgBigAOTYAKSAGIAI6ACggBiABNgIkIAZBATYCIAwBCwJAAkAg\nCkEBayIBRQ0AIAZBkAJqQQBBwQD8CwAgAUHAAEcNAEHk9MAAKAIAIQkgBkGQAmohAyALQQFqIQdB\nACEEIwBB0ABrIgEkACABQQA2AgwCQCACQf8BcSICQQRPBEBB2+vAACAJQbQBaigCACAJKAKwAREE\nAAwBBQsgAUEwaiAHIAFBDGoiBBBCIAEoAgwgAUEQaiAHQSBqIAQQQiABKAIMckUEQCADIAEpAzA3\nAAAgAyABKQMQNwAgIAMgAjoAQCADQRhqIAFByABqKQMANwAAIANBEGogAUFAaykDADcAACADQQhq\nIAFBOGopAwA3AAAgA0EoaiABQRhqKQMANwAAIANBMGogAUEgaikDADcAACADQThqIAFBKGopAwA3\nAABBASEEDAEFC0EAIQQgA0HBABBDGgsgAUHQAGokACAEQQFGDQELIAZBJGpBhITAAEEYELUBIAZB\nATYCIAwBCyAGQTZqIAZBkgJqLQAAOgAAIAYgBi8AkAI7ATQgBikAkwIhDyAGQZgBaiIBIAZBmwJq\nQTb8CgAAIAZBP2ogAUE2/AoAACAGIA83ADcgDEEgRwRAIAZBATYC3AEgBkGwhMAANgLYASAGQgE3\nAuQBIAZBBjYC2AIgBiAMNgLcAiAGIAZB1AJqNgLgASAGIAZB3AJqNgLUAiAGQZQCaiAGQdgBahBU\nIAZBLGogBkGcAmooAgA2AgAgBiAGKQKUAiIPNwCbASAGQQE2AiAgBiAPNwIkDAEFCyAGQYABaiAF\nQQhqKQAANwMAIAZBiAFqIAVBEGopAAA3AwAgBkGQAWogBUEYaikAADcDACAGIAUpAAA3A3ggCCgC\nACEDIAZBkAJqIglBAEHAAPwLACAGQTRqIQEgBkH4AGohBCMAQcAFayICJAACfyADKAIARQRAQfTr\nwAAgA0G0AWooAgAgAygCsAERBABBAAwBBQsgAkHgAGoiByABQRhqKQAANwMAIAJB2ABqIgggAUEQ\naikAADcDACACQdAAaiIOIAFBCGopAAA3AwAgAkEwaiABQShqKQAANwMAIAJBOGogAUEwaikAADcD\nACACQUBrIAFBOGopAAA3AwAgAiABKQAANwNIIAIgASkAIDcDKCABLQBAIQEgAkEIaiAEQQAQQgJA\nIAcpAwAgCCkDACAOKQMAIAIpA0iEhIRQDQAgAikDQCACKQM4IAIpAzAgAikDKISEhFANACACQaAF\naiIEIAJByABqEE4gAkH4BGogBBBFGiABQQJxBEAgAkH4BGoQ1QFBAE4NASACQfgEakGI8cAAEN8B\nBQsgAkGgBGogAkH4BGogAUEBcRCpAUUNACACIAIoAvAENgKYBCACQaADaiIHIAJBoARqQSgQKRog\nAkHIA2ogAkHIBGpBKBApGiACQfgDakIANwMAIAJBgARqQgA3AwAgAkGIBGpCADcDACACQZAEakIA\nNwMAIAJCATcD8AMgAkGAA2oiASACQcgAahCVASACQeACaiIEIAEgAkEIahAbIAQgBBCRASACQcAC\naiIIIAEgAkEoahAbIAMgAkHAAWoiASAHIAggBBANIwBB0ABrIgMkACACQegAaiIIIAEoAngiBDYC\nUCAERQRAIAFB0ABqIgQgBBDwASADQShqIgcgBBAXIAMgBCAHEA4gASABIAcQDiABQShqIgQgBCAD\nEA4gAUHYAGpCADcDACABQgE3A1AgAUHgAGpCADcDACABQegAakIANwMAIAFB8ABqQgA3AwAgCCAB\nQSgQKUEoaiAEQSgQKRoFCyADQdAAaiQAIAIoArgCDQAgCSACQegAahCcAkEBDAELIAlBwAAQQxpB\nAAsgAkHABWokAEEBRwRAIAZBJGpBuITAAEEZELUBIAZBATYCIAwBBQsgBkGaAWogBkGSAmotAAA6\nAAAgBiAGLwCQAjsBmAEgBikAkwIhDyAGQdgBaiIBIAZBmwJqQTX8CgAAIAZBowFqIAFBNfwKAAAg\n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\n//////8fIAUpA+AnfTcD4CcgBUL8////////HyAFKQPoJ303A+gnIAVC/P///////wEgBSkD8Cd9\nNwPwJwsgASABIAVBqCdqIAVBgCdqECYLAkAgCSAQSg0AIAVBoB5qIARBAnRqKAIAIgNFDQAgACgC\nBCEJAkAgA0EASgRAIAVBqCdqIAkgA0EFdEEga0FAcWoQsQIMAQULIAVBqCdqIAkgA0F/c0ECbUEG\ndGoQsQIgBUK84f//v///HyAFKQPQJ303A9AnIAVC/P///////x8gBSkD2Cd9NwPYJyAFQvz/////\n//8fIAUpA+AnfTcD4CcgBUL8////////HyAFKQPoJ303A+gnIAVC/P///////wEgBSkD8Cd9NwPw\nJwsgASABIAVBqCdqIAVBgCdqECYLIAJBBGshAiAEIQkMAQULCyABKAJ4RQRAIAFB0ABqIgAgACAF\nQYAnahAOBQsgBUGAKGokAAuYDQIBfxl+IwBB8ANrIgMkACADQUBrIAIpAxgiBEIAIAEpAwAiBUIA\nEKMBIANB0AFqIAIpAxAiBkIAIAEpAwgiC0IAEKMBIANBwAJqIAIpAwgiDEIAIAEpAxAiDUIAEKMB\nIANBkANqIAIpAwAiB0IAIAEpAxgiD0IAEKMBIANB4ANqIAIpAyAiEEIAIAEpAyAiEUIAEKMBIANB\n0ANqIAMpA+ADIghC/////////weDQgBCkPqAgIACQgAQowEgA0HQAGogEEIAIAVCABCjASADQZAB\naiAEQgAgC0IAEKMBIANBkAJqIAZCACANQgAQowEgA0HwAmogDEIAIA9CABCjASADQbADaiAHQgAg\nEUIAEKMBIANBwANqIANB6ANqKQMAIg5CDIYgCEI0iIQgDkI0iEKQ+oCAgAJCABCjASADQeAAaiAH\nQgAgBUIAEKMBIANB4AFqIBBCACALQgAQowEgA0GgAWogBEIAIA1CABCjASADQaACaiAGQgAgD0IA\nEKMBIANBgANqIAxCACARQgAQowEgAyADKQOgAiIZIAMpA6ABfCIOIAMpA4ADfCITIAMpA+ABfCIU\nIAMpA5ACIhsgAykDkAF8IgkgAykD8AJ8IhUgAykDsAN8IhYgAykDUHwiFyADKQPAA3wiEiADKQPQ\nASIcIAMpA0B8IgggAykDwAJ8IgogAykDkAN8IhggAykD0AN8IhpCNIggGCAaVq0gA0HYA2opAwAg\nCiAYVq0gA0GYA2opAwAgCCAKVq0gA0HIAmopAwAgCCAcVK0gA0HYAWopAwAgA0HIAGopAwB8fHx8\nfHx8fCIKQgyGhHwiCEI0iCAIIBJUrSASIBdUrSADQcgDaikDACAWIBdWrSADQdgAaikDACAVIBZW\nrSADQbgDaikDACAJIBVWrSADQfgCaikDACAJIBtUrSADQZgCaikDACADQZgBaikDAHx8fHx8fHx8\nfHwgCkI0iHx8IhJCDIaEfCIJQgSGQvD/////////AIMgCEIwiEIPg4RCAELRh4CAEEIAEKMBIAAg\nAykDACIKIAMpA2B8IhVC/////////weDNwMAIANB8ABqIAxCACAFQgAQowEgA0HwAWogB0IAIAtC\nABCjASADQdACaiAQQgAgDUIAEKMBIANBsAFqIARCACAPQgAQowEgA0GwAmogBkIAIBFCABCjASAD\nQTBqIAMpA7ACIhggAykDsAF8IhYgAykD0AJ8IhcgCSAUVK0gEyAUVq0gA0HoAWopAwAgDiATVq0g\nA0GIA2opAwAgDiAZVK0gA0GoAmopAwAgA0GoAWopAwB8fHx8fHwgEkI0iHx8IhJCDIYgCUI0iIR8\nIg5C/////////weDQgBCkPqAgIACQgAQowEgACADKQPwASIZIAMpA3B8IhMgAykDMHwiFCAKIBVW\nrSADQQhqKQMAIANB6ABqKQMAfHwiCkIMhiAVQjSIhHwiCUL/////////B4M3AwggA0GAAWogBkIA\nIAVCABCjASADQYACaiAMQgAgC0IAEKMBIANB4AJqIAdCACANQgAQowEgA0GgA2ogEEIAIA9CABCj\nASADQcABaiAEQgAgEUIAEKMBIANBIGogAykDoAMiByADKQPAAXwiBCAOIBdUrSAWIBdWrSADQdgC\naikDACAWIBhUrSADQbgCaikDACADQbgBaikDAHx8fHwgEkI0iHx8Ig9CDIYgDkI0iIR8IgVC////\n/////weDQgBCkPqAgIACQgAQowEgACADKQOAAiIQIAMpA4ABfCIGIAMpA+ACfCILIAMpAyB8Igwg\nCSAUVK0gEyAUVq0gA0E4aikDACATIBlUrSADQfgBaikDACADQfgAaikDAHx8fHwgCkI0iHx8IhFC\nDIYgCUI0iIR8Ig1C/////////weDNwMQIANBEGogBCAFVq0gBCAHVK0gA0GoA2opAwAgA0HIAWop\n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\nAUUEQCAHQbwJaiALQRBqIAEQpwFFDQMgCygCACgCAEHoAGohAkEAIQADQCAAQTBHBEAgB0G8Bmog\nAGogACACaigCADYCACAAQQRqIQAMAQULCyAHQewJaiIAIAdBvAZqQTD8CgAAIAdBvAlqIAEgACAB\nIAogARCUAg0CIAMgBCAHQbwJaiAHQYwJaiAHQZwEahCGAUUNAwULQQAMAwULQY7QwABBKyAHQYwD\nakGwpsAAQbSnwAAQrwEACxDmAgALQQELIAdBoApqJAALwAwCA38VfiMAQcADayICJAAgAkGIA2pB\nKBBDGiACQYADakIANwMAIAJB+AJqQgA3AwAgAkHwAmpCADcDACACQgA3A+gCIAJCATcD4AIgACkD\nICEVIAApAxghESAAKQMQIQ8gACkDCCEQIAApAwAhBiABKQMgIQ4gASkDGCESIAEpAxAhFiABKQMI\nIRcgASkDACEKQn8hGANAIANBCkZFBEBCACEHQgghCEE7IQQgCiELIAYhDUIAIQxCCCEJA0AgBARA\nIAIgGEI/hzcDuAMgAikDuAMhBSACIA1CAYM3A7ADQgAgAikDsAN9IhMgBSALhSAFfYMgDXwiGUIB\niCENIBkgBSATgyIUgyALfCELIAUgDIUgBX0gE4MgCHwiCCAUgyAMfEIBhiEMIAUgCYUgBX0gE4Mg\nB3wiByAUgyAJfEIBhiEJIARBAWshBCAUIBiFQgF9IRgMAQULCyACIAg3A9gCIAIgBzcD0AIgAiAM\nNwPIAiACIAk3A8ACIAJBiANqIAJB4AJqIAJBwAJqIAEQCiACQbACaiAJIAlCP4ciCyAKIApCP4ci\nExCjASACQZACaiAMIAxCP4ciDSAGIAZCP4ciFBCjASACQaACaiAHIAdCP4ciBSAKIBMQowEgAkGA\nAmogCCAIQj+HIgogBiAUEKMBIAJB8AFqIAkgCyAXIBdCP4ciBhCjASACQdABaiAMIA0gECAQQj+H\nIhMQowEgAkHgAWogByAFIBcgBhCjASACQcABaiAIIAogECATEKMBIAJBsAFqIAkgCyAWIBZCP4ci\nBhCjASACQZABaiAMIA0gDyAPQj+HIhAQowEgAkGgAWogByAFIBYgBhCjASACQYABaiAIIAogDyAQ\nEKMBIAJB8ABqIAkgCyASIBJCP4ciBhCjASACQdAAaiAMIA0gESARQj+HIg8QowEgAkHgAGogByAF\nIBIgBhCjASACQUBrIAggCiARIA8QowEgAkEwaiAJIAsgDiAOQj+HIgYQowEgAkEQaiAMIA0gFSAV\nQj+HIgsQowEgAkEgaiAHIAUgDiAGEKMBIAIgCCAKIBUgCxCjASACKQMgIgkgAikDAHwiBiACKQNg\nIgcgAikDQHwiCiACKQOgASIIIAIpA4ABfCILIAIpA+ABIgUgAikDwAF8Ig0gAikDoAIiDCACKQOA\nAnwiDkI+iCAMIA5WrSACQagCaikDACACQYgCaikDAHx8Ig5CAoaEfCIMQj6IIAwgDVStIAUgDVat\nIAJB6AFqKQMAIAJByAFqKQMAfHwgDkI+h3x8IgVCAoaEfCINQj6IIAsgDVatIAggC1atIAJBqAFq\nKQMAIAJBiAFqKQMAfHwgBUI+h3x8IghCAoaEfCILQj6IIAogC1atIAcgClatIAJB6ABqKQMAIAJB\nyABqKQMAfHwgCEI+h3x8IgdCAoaEfCIKQj6IIAYgClatIAYgCVStIAJBKGopAwAgAkEIaikDAHx8\nIAdCPod8fEIChoQhFSACKQMwIg4gAikDEHwiBiACKQNwIhEgAikDUHwiCSACKQOwASIPIAIpA5AB\nfCIHIAIpA/ABIhAgAikD0AF8IgggAikDsAIiBSACKQOQAnwiEkI+iCAFIBJWrSACQbgCaikDACAC\nQZgCaikDAHx8IhJCAoaEfCIFQj6IIAUgCFStIAggEFStIAJB+AFqKQMAIAJB2AFqKQMAfHwgEkI+\nh3x8IhBCAoaEfCIIQj6IIAcgCFatIAcgD1StIAJBuAFqKQMAIAJBmAFqKQMAfHwgEEI+h3x8Ig9C\nAoaEfCIHQj6IIAcgCVStIAkgEVStIAJB+ABqKQMAIAJB2ABqKQMAfHwgD0I+h3x8IhFCAoaEfCIJ\nQj6IIAYgCVatIAYgDlStIAJBOGopAwAgAkEYaikDAHx8IBFCPod8fEIChoQhDiAKQv//////////\nP4MhESAJQv//////////P4MhEiALQv//////////P4MhDyAHQv//////////P4MhFiANQv//////\n////P4MhECAIQv//////////P4MhFyAMQv//////////P4MhBiAFQv//////////P4MhCiADQQFq\nIQMMAQULCyACQYgDaiIDIA4gARBBIAAgA0EoECkaIAJBwANqJAALygsCB38BfiMAQaADayIIJAAg\n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\nPoaENwMAIAJBoAFqIAdqIgUgBSkDACAYQj6GhDcDACAEIQYMAQsLIAJBmAJqIgQgDCABEEEgACAE\nQSgQKRogAkHAAmokAAvjCQIBfw9+IwBB0AJrIgIkACACQUBrIAEpAxgiBEIAIAEpAwAiB0IBhiIK\nQgAQowEgAkGQAmogASkDCCIIQgGGIgVCACABKQMQIgZCABCjASACQeABaiABKQMgIglCACAJQgAQ\nowEgAkHQAWogAikD4AEiA0L/////////B4NCAEKQ+oCAgAJCABCjASACQbABaiAJQgGGIglCACAH\nQgAQowEgAkHQAGogBEIAIAVCABCjASACQYACaiAGQgAgBkIAEKMBIAJBwAFqIAJB6AFqKQMAIgVC\nDIYgA0I0iIQgBUI0iEKQ+oCAgAJCABCjASACQcACaiAHQgAgB0IAEKMBIAJBoAFqIAlCACAIQgAQ\nowEgAkHgAGogBkIBhkIAIARCABCjASACIAIpA6ABIg8gAikDYHwiBSACKQNQIg4gAikDgAJ8IgMg\nAikDsAF8IgsgAikDwAF8IgwgAikDQCINIAIpA5ACfCIHIAIpA9ABfCIQQjSIIAcgEFatIAJB2AFq\nKQMAIAcgDVStIAJByABqKQMAIAJBmAJqKQMAfHx8fCINQgyGhHwiB0I0iCAHIAxUrSALIAxWrSAC\nQcgBaikDACADIAtWrSACQbgBaikDACADIA5UrSACQdgAaikDACACQYgCaikDAHx8fHx8fCANQjSI\nfHwiDkIMhoR8IgNCBIZC8P////////8AgyAHQjCIQg+DhEIAQtGHgIAQQgAQowEgACACKQMAIg0g\nAikDwAJ8IgtC/////////weDNwMAIAJBsAJqIApCACAIQgAQowEgAkGQAWogCUIAIAZCABCjASAC\nQfAAaiAEQgAgBEIAEKMBIAJBMGogAikDkAEiESACKQNwfCIMIAMgBVStIAUgD1StIAJBqAFqKQMA\nIAJB6ABqKQMAfHwgDkI0iHx8Ig9CDIYgA0I0iIR8IgVC/////////weDQgBCkPqAgIACQgAQowEg\nACACKQMwIg4gAikDsAJ8IgMgCyANVK0gAkEIaikDACACQcgCaikDAHx8Ig1CDIYgC0I0iIR8IgtC\n/////////weDNwMIIAJB8AFqIAZCACAKQgAQowEgAkGgAmogCEIAIAhCABCjASACQYABaiAJQgAg\nBEIAEKMBIAJBIGogBSAMVK0gDCARVK0gAkGYAWopAwAgAkH4AGopAwB8fCAPQjSIfHwiCkIMhiAF\nQjSIhCIFIAIpA4ABfCIEQv////////8Hg0IAQpD6gICAAkIAEKMBIAAgAikD8AEiDCACKQOgAnwi\nBiACKQMgfCIIIAMgC1atIAMgDlStIAJBOGopAwAgAkG4AmopAwB8fCANQjSIfHwiA0IMhiALQjSI\nhHwiCUL/////////B4M3AxAgAkEQaiAEIAVUrSACQYgBaikDACAKQjSIfHwiCkIMhiAEQjSIhCAK\nQjSIQpD6gICAAkIAEKMBIAAgAikDECIKIBBC/v///////weDfCIEIAggCVatIAYgCFatIAJBKGop\nAwAgBiAMVK0gAkH4AWopAwAgAkGoAmopAwB8fHx8IANCNIh8fCIIQgyGIAlCNIiEfCIGQv//////\n//8HgzcDGCAAIAdC////////P4MgBCAGVq0gAkEYaikDACAEIApUrXwgCEI0iHx8QgyGIAZCNIiE\nfDcDICACQdACaiQAC5gJAQl/IwBB8AFrIgYkACAGQRBqIAEQ/QEgBigCFCELIAYoAhAhASAGQQhq\nIAIgAxDoASAGKAIMIQwgBigCCCENIAYgBCAFEOgBIAYoAgQhBCAGKAIAIQUgBkGsAWogDSAMEGYC\nQAJAIAYtAKwBQQFGBEAgBkEkaiAGQbgBaigCADYCACAGIAYpArABNwIcIAZBATYCGAwBBQsgBkEw\naiAGQbUBaiICKQAANwMAIAZBOGogBkG9AWoiAykAADcDACAGQUBrIAZBxQFqIgopAAA3AwAgBiAG\nKQCtATcDKCAGQawBaiAFIAQQswEgBi0ArAFBAUYEQCAGQSRqIAZBuAFqKAIANgIAIAYgBikCsAE3\nAhwgBkEBNgIYDAEFCyAGQdAAaiACKQAANwMAIAZB2ABqIAMpAAA3AwAgBkHgAGogCikAADcDACAG\nIAYpAK0BNwNIIAEoAgAhASAGQawBaiICQQBBwAD8CwAgBkHIAGohCiAGQShqIQdB1O3AACgCACEI\nIwBB4ARrIgMkAAJAIAEoAghFBEBBqOzAACABQbQBaigCACABKAKwAREEAAwBBQsgASADQeAAaiAH\nEH9FDQAgASADQQhqIANB4ABqEMcBRQ0AIANBoAFqIgkgByADQQRqEEIgAyADKAIEIAMpA7gBIAMp\n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\nVK18IgUgC1QgAWogBSAFQsS/3YWV48ioxQBCACABG3wiBVZqIAUgB3wiBiAFVGqtIgVCAEK//ab+\nsq7olsAAQgAQowEgACADKQMQIgcgCnwiCjcDACADIAVCAELEv92FlePIqMUAQgAQowEgACAIIAMp\nAwAiCHwiBCADQRhqKQMAIAcgClatfHwiCjcDCCAAIAUgCXwiByAEIApWrSADQQhqKQMAIAQgCFSt\nfHx8IgQ3AxAgACAFIAdWrSAEIAdUrXwiBSAGfCIENwMYIAAgABDTASAEIAVUahCeARogA0GgAmok\nAAuuBwIBfwl+IwBBgAJrIgMkACADQfABaiACKQMAQgAgASkDAEIAEKMBIAAgAykD8AE3AwAgA0HQ\nAWogAikDCEIAIAEpAwBCABCjASADQeABaiACKQMAQgAgASkDCEIAEKMBIAAgAykD0AEiBSADQfgB\naikDAHwiBCADKQPgAXwiBjcDCCADQaABaiACKQMQQgAgASkDAEIAEKMBIANBsAFqIAIpAwhCACAB\nKQMIQgAQowEgA0HAAWogAikDAEIAIAEpAxBCABCjASAAIANB2AFqKQMAIAQgBVStfCIHIANB6AFq\nKQMAIAQgBlatfHwiBCADKQOgAXwiBSADKQOwAXwiBiADKQPAAXwiCDcDECADQeAAaiACKQMYQgAg\nASkDAEIAEKMBIANB8ABqIAIpAxBCACABKQMIQgAQowEgA0GAAWogAikDCEIAIAEpAxBCABCjASAD\nQZABaiACKQMAQgAgASkDGEIAEKMBIAAgA0GoAWopAwAgBCAFVq18IgogBCAHVK18IgQgA0G4AWop\nAwAgBSAGVq18fCIFIANByAFqKQMAIAYgCFatfHwiBiADKQNgfCIHIAMpA3B8IgggAykDgAF8Igkg\nAykDkAF8Igs3AxggA0EwaiACKQMYQgAgASkDCEIAEKMBIANBQGsgAikDEEIAIAEpAxBCABCjASAD\nQdAAaiACKQMIQgAgASkDGEIAEKMBIAAgA0GYAWopAwAgCSALVq18IgsgBSAGVq0gBCAFVq0gBCAK\nVK18fCIKIANB6ABqKQMAIAYgB1atfHwiBCADQfgAaikDACAHIAhWrXx8IgUgA0GIAWopAwAgCCAJ\nVq18fCIJfCIGIAMpAzB8IgcgAykDQHwiCCADKQNQfCIMNwMgIANBEGogAikDGEIAIAEpAxBCABCj\n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\nA0EBcjYCBCAEIAZqIgIgAzYCACACIAIoAgRBfnE2AgQLQZj4wAAgATYCAEGQ+MAAIAM2AgAMCgsg\nBSABIAdBAXFyQQJyNgIAIAEgBmoiASACQQNyNgIEIAggCCgCBEEBcjYCBCABIAIQQAwJC0GU+MAA\nKAIAIARqIgQgAUsNBwsgAxAIIgFFDQEgA0F8QXggBSgCACICQQNxGyACQXhxaiICIAIgA0sbIgIE\nQCABIAAgAvwKAAAFCyAAECogAQ8LIAMgASABIANLGyIDBEAgAiAAIAP8CgAABQsgBSgCACIDQXhx\nIgUgAUEEQQggA0EDcSIBG2pJDQMgAUEAIAUgCEsbDQQgABAqCyACDwULQbHSwABBLkHg0sAAEOwB\nAAtB8NLAAEEuQaDTwAAQ7AEAC0Gx0sAAQS5B4NLAABDsAQALQfDSwABBLkGg08AAEOwBAAsgBSAB\nIAdBAXFyQQJyNgIAIAEgBmoiAiAEIAFrIgFBAXI2AgRBlPjAACABNgIAQZz4wAAgAjYCACAADwsg\nAAuCBwEDfyMAQZAEayIDJAAgA0HAA2oiAiABEBcgAiACIAEQDiADQZgDaiIEIAIQFyAEIAQgARAO\nIANB8AJqIARBKBApGkEDIQIDQCACBEAgAkEBayECIANB8AJqIgQgBBAXDAEFCwsgA0HwAmoiAiAC\nIANBmANqEA4gA0HIAmogAkEoECkaQQMhAgNAIAIEQCACQQFrIQIgA0HIAmoiBCAEEBcMAQULCyAD\nQcgCaiICIAIgA0GYA2oQDiADQaACaiACQSgQKRpBAiECA0AgAgRAIAJBAWshAiADQaACaiIEIAQQ\nFwwBBQsLIANBoAJqIgIgAiADQcADahAOIANB+AFqIAJBKBApGkELIQIDQCACBEAgAkEBayECIANB\n+AFqIgQgBBAXDAEFCwsgA0H4AWoiAiACIANBoAJqEA4gA0HQAWogAkEoECkaQRYhAgNAIAIEQCAC\nQQFrIQIgA0HQAWoiBCAEEBcMAQULCyADQdABaiICIAIgA0H4AWoQDiADQagBaiACQSgQKRpBLCEC\nA0AgAgRAIAJBAWshAiADQagBaiIEIAQQFwwBBQsLIANBqAFqIgIgAiADQdABahAOIANBgAFqIAJB\nKBApGkHYACECA0AgAgRAIAJBAWshAiADQYABaiIEIAQQFwwBBQsLIANBgAFqIgIgAiADQagBahAO\nIANB2ABqIAJBKBApGkEsIQIDQCACBEAgAkEBayECIANB2ABqIgQgBBAXDAEFCwsgA0HYAGoiAiAC\nIANB0AFqEA4gA0EwaiACQSgQKRpBAyECA0AgAgRAIAJBAWshAiADQTBqIgQgBBAXDAEFCwsgA0Ew\naiICIAIgA0GYA2oQDiADQQhqIAJBKBApGkEXIQIDQCACBEAgAkEBayECIANBCGoiBCAEEBcMAQUL\nCyADQQhqIgIgAiADQfgBahAOQQYhAgNAIAIEQCACQQFrIQIgA0EIaiIEIAQQFwwBBQsLIANBCGoi\nAiACIANBwANqEA4gAiACEBcgACACEBcgAiAAEBcgA0K84f//v///HyADKQMIfTcD6AMgA0L8////\n////HyADKQMQfTcD8AMgA0L8////////HyADKQMYfTcD+AMgA0L8////////HyADKQMgfTcDgAQg\nA0L8////////ASADKQMofTcDiAQgA0HoA2oiACABEN8BIAAQnQEgA0GQBGokAAuSBwIJfwF+IwBB\nkAJrIgYkACAGQRBqIAEQ/QEgBigCFCEIIAYoAhAhASAGQQhqIAIgAxDoASAGKAIMIQkgBigCCCEK\nIAYgBCAFEOgBIAYoAgQhBSAGKAIAIQsgBkHsAGogCiAJEFgCQCAGLQBsQQFGBEAgBkEkaiAGQfgA\naigCADYCACAGIAYpAnA3AhwgBkEBNgIYDAEFCyAGQShqIgIgBkHsAGoiA0EBckHAAPwKAAAgBkGw\nAWogAkHAAPwKAAAgAyALIAUQayAGLQBsQQFGBEAgBkEkaiAGQfgAaigCADYCACAGIAYpAnA3Ahwg\nBkEBNgIYDAEFCyAGQfgBaiAGQfUAaikAADcDACAGQYACaiAGQf0AaikAADcDACAGQYgCaiAGQYUB\naikAADcDACAGIAYpAG03A/ABIAEoAgAhASAGQbABaiECIAZB8AFqIQwjAEHgAGsiAyQAAkAgASgC\nAEUEQEH068AAIAFBtAFqKAIAIAEoArABEQQADAEFCyABIANBCGogAhDHASACQcAAEEMhDUUNACAD\nQQhqIQQjAEHQAWsiAiQAIAJBADYCDCACQRBqIAwgAkEMahBCIAIoAgxFBEAgAiAEKAJQNgLIASAC\nQdAAaiIHIARBKBApGiACQfgAaiAEQShqQSgQKRogAkGoAWpCADcDACACQbABakIANwMAIAJBuAFq\n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\nGHwhFSAGQYABayEGIAVBgAFqIQUMBAUgAiAEaiIDQYABaiADKQMAIANByABqKQMAIANBCGopAwAi\nCkI4iSAKQj+JhSAKQgeIhXx8IANB8ABqKQMAIgpCA4kgCkItiYUgCkIGiIV8NwMAIAJBCGohAgwB\nCwALAAUgAyAEaiADIAVqKQAAIgpCOIYgCkKA/gODQiiGhCAKQoCA/AeDQhiGIApCgICA+A+DQgiG\nhIQgCkIIiEKAgID4D4MgCkIYiEKAgPwHg4QgCkIoiEKA/gODIApCOIiEhIQ3AwAgA0EIaiEDDAEL\nAAsACwAFC0HQw8AAQShBgLfAABDsAQALIAEgDjcDQCABIA83AzggASAQNwMwIAEgETcDKCABIBI3\nAyAgASATNwMYIAEgFDcDECABIBU3AwggACAHNgIIIAAgCDYCBCAAIAk2AgAgBEGABWokAAuEBwIF\nfwR+IwBB4ANrIgQkAAJAIAIoAlAEQCAAIAFBgAEQKRoMAQULIAEoAngEQCAAQQA2AnggBEG4A2oi\nASADEBcgBEGQA2oiBiABIAMQDiAAIAIgARAOIABBKGogAkEoaiAGEA4gAEHYAGpCADcDACAAQgE3\nA1AgAEHgAGpCADcDACAAQegAakIANwMAIABB8ABqQgA3AwAMAQULIABBADYCeCAEQbgDaiIGIAFB\n0ABqIgcgAxAOIARBkANqIgMgBhAXIARB6AJqIgUgAUEoECkaIAUQqgEgBEHAAmogAiADEA4gBEGY\nAmoiBSABQShqQSgQKRogBRCqASAEQfABaiIFIAJBKGogAxAOIAUgBSAGEA4gBCAEKQPAAiAEKQPo\nAn1CvOH//7///x98NwPIASAEIAQpA8gCIAQpA/ACfUL8////////H3w3A9ABIAQgBCkD0AIgBCkD\n+AJ9Qvz///////8ffDcD2AEgBCAEKQPYAiAEKQOAA31C/P///////x98NwPgASAEIAQpA+ACIAQp\nA4gDfUL8////////AXw3A+gBIAQpA7gCIQkgBCkDsAIhCiAEKQOoAiELIAQpA6ACIQwgBCAEKQPw\nASAEKQOYAn1CvOH//7///x98NwOgASAEIAQpA/gBIAx9Qvz///////8ffDcDqAEgBCAEKQOAAiAL\nfUL8////////H3w3A7ABIAQgBCkDiAIgCn1C/P///////x98NwO4ASAEIAQpA5ACIAl9Qvz/////\n//8BfDcDwAEgBEHIAWoQiwEEQCAEQaABahCLAQRAIAAgAUEAEDIMAgULIAAQsgIMAQULIARB+ABq\nIgUgBEGgAWoiCBAXIARB0ABqIgMgBEHIAWoiBhAXIARBKGoiAiAGIAMQDiAAQdAAaiAHQSgQKSIB\nIAEgBhAOIAQgBEHoAmogAxAOIAAgBEEoECkiAEECEOUBIAAgAhDfASAAIABBAxDPASAAIAUQ3wEg\nAEEoaiIBIABBBRDPASABIAQQ3wEgASABIAgQDiACIAIgBEGYAmoQDiAEQrzh//+///8fIAQpAyh9\nNwMoIARC/P///////x8gBCkDMH03AzAgBEL8////////HyAEKQM4fTcDOCAEQvz///////8fIAQp\nA0B9NwNAIARC/P///////wEgBCkDSH03A0ggASACEN8BCyAEQeADaiQAC7UFARZ/IwBBgAJrIgQk\nAAJAIAEoAgBBAUYEQCAEIAIgAyADQUBxENkCIAQoAgwhFyAEKAIIIRggBCgCACESIAEoAiAhCSAB\nKAIcIQogASgCGCELIAEoAhQhDCABKAIQIQ0gASgCDCEOIAEoAgghDyABKAIEIRAgBCgCBEFAcSIZ\nIRMDQCATRQ0CQQAhAyAEQQBBgAL8CwADQCADQcAARgRAQQAhAgNAIAJBwAFGBEBBACEGIAwhFiAN\nIRQgDiEFIA8hByAQIQIgCyEDIAohESAJIQgDQCARIRUgAyERIBYhAyAGQYACRkUEQCAFIAdxIAUg\nB3IgBCAGaigCACAGQdiswABqKAIAIAggA0EVdyADQRp3cyADQQd3c2ogFSADQX9zcSADIBFxcmpq\naiIIIBRqIRYgBkEEaiEGIAUhFCAHIQUgAiIHcXIgAkETdyACQR53cyACQQp3c2ogCGohAiAVIQgM\nAQULCyAIIAlqIQkgCiAVaiEKIAsgEWohCyADIAxqIQwgDSAUaiENIAUgDmohDiAHIA9qIQ8gAiAQ\naiEQIBNBQGohEyASQUBrIRIMBAUgAiAEaiIDQUBrIAMoAgAgA0EkaigCACADQQRqKAIAIgVBDncg\nBUEZd3MgBUEDdnNqaiADQThqKAIAIgNBDXcgA0EPd3MgA0EKdnNqNgIAIAJBBGohAgwBCwALAAUg\nAyAEaiADIBJqKAAAIgJBGHQgAkGA/gNxQQh0ciACQQh2QYD+A3EgAkEYdnJyNgIAIANBBGohAwwB\nCwALAAsABQtB0MPAAEEoQfC2wAAQ7AEACyABIAk2AiAgASAKNgIcIAEgCzYCGCABIAw2AhQgASAN\nNgIQIAEgDjYCDCABIA82AgggASAQNgIEIAAgFzYCCCAAIBg2AgQgACAZNgIAIARBgAJqJAALugUB\nDX8jAEGABGsiCiQAIAUQgQIhDSAJEIECIQ4gCkGAA2ogBRAFAkAgBkUEQCAKQeADaiILIAkQBSAK\nQeACaiADIAsQBCAKQaACaiIGIAUgCRA6IAYgBhAFIAYgBiAKQYADahBGIAYgBiALEEYgCkHAAmoi\nBiAJIAsQBCAGIAYgBBAEDAEFCyAKQeACaiADEPwCIApBoAJqIAUgBRA6IApBwAJqIAQQ/AILIApB\ngAJqIgYgByAKQYADaiILEAQgCkHgAWoiDCAGIApB4AJqEEYgCigC/AEhBiAKKAL4ASEPIAooAvQB\nIRAgCigC8AEhESAKKALsASESIAooAugBIRMgCigC5AEhFCAKKALgASEVIApBoANqIAwgCkGgAmoQ\nBCAKQcABaiIMIAUgCxAEIApBoAFqIhYgCCAMEAQgCkGAAWoiCyAWIApBwAJqEEYgCyALIAsQOgJA\nQQAgDkEBayAOQX9zcSANQQFrIA1Bf3NxckEfdUF/cyAKKAKcASAKKAKYASAKKAKUASAKKAKQASAK\nKAKMASAKKAKIASAKKAKEASAKKAKAASAGIA8gECARIBIgEyAUIBVycnJycnJycnJycnJycnIbBEAg\nACABIAIgAyAEIAUQcAwBBQsgCkHgAGoiBiAKQeABaiILIAsQOiAGIAYQBSAKQUBrIg8gCyAGEAQg\nCkEgaiIMIApB4AJqIAYQBCAKQeADaiIGIApBgAFqIhAQBSAGIAYgDxBGIAYgBiAMEEYgBiAGIAwQ\nRiAKQcADaiILIAwgBhBGIAsgCyAQEAQgCiAKQcACaiAPEAQgCyALIAoQRiALIAsgChBGIAYgDSAH\nIAYQbiAAIA4gAyAGEG4gCyANIAggCxBuIAEgDiAEIAsQbiAKQaADaiIAIA0gCSAAEG4gAiAOIAUg\nABBuCyAKQYAEaiQAC5AFAQh/AkAgAkEQSQRAIAAhAwwBBQsCQCAAIABBACAAa0EDcSIGaiIFTw0A\nIAAhAyABIQQgBgRAIAYhBwNAIAMgBC0AADoAACAEQQFqIQQgA0EBaiEDIAdBAWsiBw0ACwULIAZB\n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\nA9gCIAMpA4ADfUL8////////H3w3A+ABIAMgAykD4AIgAykDiAN9Qvz///////8BfDcD6AEgAykD\nuAIhCSADKQOwAiEKIAMpA6gCIQsgAykDoAIhDCADIAMpA/ABIAMpA5gCfUK84f//v///H3w3A6AB\nIAMgAykD+AEgDH1C/P///////x98NwOoASADIAMpA4ACIAt9Qvz///////8ffDcDsAEgAyADKQOI\nAiAKfUL8////////H3w3A7gBIAMgAykDkAIgCX1C/P///////wF8NwPAASADQcgBahCLAQRAIANB\noAFqEIsBBEAgACABQQAQMgwCBQsgABCyAgwBBQsgA0H4AGoiBSADQaABaiIGEBcgA0HQAGoiBCAD\nQcgBaiIBEBcgA0EoaiICIAEgBBAOIAEgASAHEA4gAEHQAGogCCABEA4gAyADQegCaiAEEA4gACAD\nQSgQKSIAQQIQ5QEgACACEN8BIAAgAEEDEM8BIAAgBRDfASAAQShqIgEgAEEFEM8BIAEgAxDfASAB\nIAEgBhAOIAIgAiADQZgCahAOIANCvOH//7///x8gAykDKH03AyggA0L8////////HyADKQMwfTcD\nMCADQvz///////8fIAMpAzh9NwM4IANC/P///////x8gAykDQH03A0AgA0L8////////ASADKQNI\nfTcDSCABIAIQ3wELIANB4ANqJAALtQUCB38CfiMAQdADayIIJAAgAUEYakIANwMAIAFBEGpCADcD\nACABQQhqQgA3AwAgAUIANwMAIAJBGGpCADcDACACQRBqQgA3AwAgAkEIakIANwMAIAJCADcDACAD\nBEAgA0EANgIABQsgCEHgAGoiCUGY7sAAIAkgBRCDAiILRRCoAUEAIQkgCEEgaiAEQQAQQiAAQQhq\nIQwgBkHQACAGGyENIAhB0AFqIQ5BACEGA0ACQCAIIAQgBSAHQQAgBiANEQ0ABEAgCEFAayAIEIMC\nRQ0BIAhBADYChAEgDCAIQYACaiIKIAhBQGsQEyAIQagBaiIAIAoQiQEgABBzIA4QcyAIQYADaiIK\nIAAQRCABIAogCEGEAWoQQiADBEAgAyAIKALQAUEBcSAIKAKEAUEBdHI2AgAFCyAIQYgBaiIAIAEg\nCEHgAGoQGyAAIAAgCEEgahCOASAIIAgpA1giD0I4iDcDyAMgCCAIKQNAIhBC//////////8/gzcD\nqAMgCCAPQgaGIAgpA1AiD0I6iIRC//////////8/gzcDwAMgCCAPQgSGIAgpA0giD0I8iIRC////\n//////8/gzcDuAMgCCAPQgKGIBBCPoiEQv//////////P4M3A7ADIAhBqANqIgpBsPHAABAQIAIg\nChDCASACIAIgABAbIAhBgAJqELACIAhBqAFqEL8CIAIgAhDLASIAEH0gAwRAIAMgAygCACAAczYC\nAAULIAEQtQIgAhC1AnINAUEBIQkFCyAIQRhqQgA3AwAgCEEQakIANwMAIAhCADcDCCAIQgA3AwAg\nAUH47cAAIAkgC3EiAUUiABCoASACQfjtwAAgABCoASADBEAgCCAANgKAAiADIAMoAgAgCCgCgAJB\nAWtxNgIABQsgCEHQA2okACABDwsgBkEBaiEGDAALAAvpBAEIfyMAQYABayIEJAAgACgCACEAAn8C\nQAJAAkAgASgCCCICQYCAgBBxRQRAIAJBgICAIHENAkEKIQMgACgCACIGIAZBH3UiAHMgAGsiAEHo\nB08NASAAIQIMAwULIAAoAgAhAEGBASECA0AgAiAEakECayAAQQ9xIgNBMHIgA0HXAGogA0EKSRs6\nAAAgAkEBayECIABBD0sgAEEEdiEADQALIAFBAUGOjcAAQQIgAiAEakEBa0GBASACaxA3DAMLA0Ag\nAyAEaiIFQQNrIAAgAEGQzgBuIgJBkM4AbGsiB0H//wNxQeQAbiIIQQF0IglBkY3AAGotAAA6AAAg\nBUEEayAJQZCNwABqLQAAOgAAIAVBAWsgByAIQeQAbGtB//8DcUEBdCIHQZGNwABqLQAAOgAAIAVB\nAmsgB0GQjcAAai0AADoAACADQQRrIQMgAEH/rOIESyACIQANAAsMAQsgACgCACEAQYEBIQIDQCAC\nIARqQQJrIABBD3EiA0EwciADQTdqIANBCkkbOgAAIAJBAWshAiAAQQ9LIABBBHYhAA0ACyABQQFB\njo3AAEECIAIgBGpBAWtBgQEgAmsQNwwBCwJAIAJBCU0EQCACIQAMAQULIAMgBGpBAWsgAiACQf//\nA3FB5ABuIgBB5ABsa0H//wNxQQF0IgJBkY3AAGotAAA6AAAgBCADQQJrIgNqIAJBkI3AAGotAAA6\nAAALQQAgBiAAG0UEQCAEIANBAWsiA2ogAEEBdEEecUGRjcAAai0AADoAAAULIAEgBkF/c0EfdkEB\nQQAgAyAEakEKIANrEDcLIARBgAFqJAAL0wQCBX8EfiMAQZABayICJAAgAkEoakIANwMAIAJBIGpC\nADcDACACQRhqQgA3AwAgAkIANwMQIAJByABqQgA3AwAgAkFAa0IANwMAIAJBOGpCADcDACABQShq\nIgUgAS0AaCIDakGAAToAACACQgA3AzAgASkDICEHIAJBCGogA0EBaiAFQcAAQaCcwAAQkgIgAigC\nDCEEIAIoAgghBgNAIAQEQCAGQQA6AAAgBEEBayEEIAZBAWohBgwBBQsLIAOtQjuGIAdCCYYiCSAD\nQQN0rYQiCEKA/gODQiiGhCAIQoCA/AeDQhiGIAhCgICA+A+DQgiGhIQgB0IBhkKAgID4D4MgB0IP\niEKAgPwHg4QgB0IfiEKA/gODIAlCOIiEhIQhBwJAIANBOHFBOEcEQCABIAc3A2AgASAFEPECDAEF\nCyABIAUQ8QIgAkHQAGoiA0EAQTj8CwAgAiAHNwCIASABIAMQ8QILQQAhBCABQQA6AGhBIEEEEL0C\nIgNBCCADQQhJG0ECdCEFA0AgBCAFRkUEQCACIAEgBGooAgAiA0EYdCADQYD+A3FBCHRyIANBCHZB\ngP4DcSADQRh2cnI2AlAgAkEwaiAEakEEIAJB0ABqQQRBiJ7AABCdAiAEQQRqIQQMAQULCyACQShq\nIAJByABqKQMAIgc3AwAgAkEgaiACQUBrKQMAIgg3AwAgAkEYaiACQThqKQMAIgk3AwAgAiACKQMw\nIgo3AxAgAEEYaiAHNwAAIABBEGogCDcAACAAQQhqIAk3AAAgACAKNwAAIAJBkAFqJAALqAUCBH8F\nfgJAIAEoAngEQCAAQQE2AnggAkUNASACQgA3AwggAkIBNwMAIAJBEGpCADcDACACQRhqQgA3AwAg\nAkEgakIANwMADwULIAIEQCACIAFBKGpBKBApIgIQqgEgAkECEOUBBQsjAEGgAWsiAiQAIAAgASgC\neDYCeCAAQdAAaiIDIAFB0ABqIAFBKGoiBhAOIANBAhDlASACQfgAaiIEIAEQFyACIAIpA3hCA343\nA3ggAiACKQOAAUIDfjcDgAEgAiACKQOIAUIDfjcDiAEgAiACKQOQAUIDfjcDkAEgAiACKQOYAUID\nfjcDmAEgAkHQAGoiBSAEEBcgAkEoaiIDIAYQFyACIAIpAyhCAYY3AyggAiACKQMwQgGGNwMwIAIg\nAikDOEIBhjcDOCACIAIpA0BCAYY3A0AgAiACKQNIQgGGNwNIIAIgAxAXIAIpAwAhByACKQMIIQgg\nAikDECEJIAIpAxghCiACKQMgIQsgAyADIAEQDiAAIANBKBApIgBBBBDlASAAIABBBBDPASAAIAUQ\n3wEgAiACKQNIQgZ+IAIpA3B9Qvz///////8BfDcDSCACIAIpA0BCBn4gAikDaH1C/P///////x98\nNwNAIAIgAikDOEIGfiACKQNgfUL8////////H3w3AzggAiACKQMwQgZ+IAIpA1h9Qvz///////8f\nfDcDMCACIAIpAyhCBn4gAikDUH1CvOH//7///x98NwMoIABBKGoiACAEIAMQDiACQvr///////8C\nIAtCAYZ9NwNwIAJC+v///////y8gCkIBhn03A2ggAkL6////////LyAJQgGGfTcDYCACQvr/////\n//8vIAhCAYZ9NwNYIAJCmtL//5///y8gB0IBhn03A1AgACAFEN8BIAJBoAFqJAALC7UFAQN/IwBB\nIGsiACQAIABBsOjAAC0AACIBNgIEAkACQAJAAkACQAJAAkACQAJAAkACQCABQQRGBEAgAEGx6MAA\nLQAAIgE2AgQgAUEERw0BIABBsujAAC0AACIBNgIEIAFBBEcNAiAAQbPowAAtAAAiATYCBCABQQRH\nDQMgAEG06MAALQAAIgE2AgQgAUEERw0EIABBtejAAC0AACIBNgIEIAFBBEcNBSAAQbbowAAtAAAi\nATYCBCABQQFHDQYgAEG36MAALQAAIgE2AgQgAUEBRw0HIABBuOjAAC0AACIBNgIEIAFBBEcNCCAA\nQbnowAAtAAAiATYCBCABQQRHDQlBgQYQggIiAUHx////B08NCkHU+MAALQAAGiABQRAQugIiAUUN\nCyABQYEGEAshAkHU+MAALQAAGkEIEAgiAUUNCyABIAI2AgQgAUEANgIAIABBIGokACABDwULIABB\nADYCCEG0ocAAIABBBGogAEEIakHwocAAENACAAsgAEEANgIIQbShwAAgAEEEaiAAQQhqQYCiwAAQ\n0AIACyAAQQA2AghBtKHAACAAQQRqIABBCGpBkKLAABDQAgALIABBADYCCEG0ocAAIABBBGogAEEI\nakGgosAAENACAAsgAEEANgIIQbShwAAgAEEEaiAAQQhqQbCiwAAQ0AIACyAAQQA2AghBtKHAACAA\nQQRqIABBCGpBwKLAABDQAgALIABBADYCCEHQosAAIABBBGogAEEIakHUosAAENACAAsgAEEANgII\nQdCiwAAgAEEEaiAAQQhqQeSiwAAQ0AIACyAAQQA2AghBtKHAACAAQQRqIABBCGpB9KLAABDQAgAL\nIABBADYCCEG0ocAAIABBBGogAEEIakGEo8AAENACAAtBjtDAAEErIABBCGpBoKDAAEHYoMAAEK8B\nCwALiQUCBX8BfiMAQaADayIDJAAgA0EoaiABIAIQ6AEgA0FAayIEIAMoAigiBiADKAIsIgcQrQEg\nA0GAAWoiAUEAQcEA/AsAIANB8ABqIgJBuJzAACkDADcDACADQfgAaiIFQcCcwAAoAgA2AgAgA0IA\nNwNgIANBsJzAACkDADcDaCADQSBqQQAgAUHAAEHwm8AAEJICIANBGGpBICADKAIgIAMoAiRBgJzA\nABCjAiADKAIYIAMoAhwgBEEgQZCcwAAQnQIgA0EgOgDAASADQcgBaiADQeAAakHoAPwKAAAgA0HA\nAmpBADYCACADQbgCakIANwMAIANCADcDsAIgAykDyAEhCCADLQCoAiEEIANB2AJqIAUoAgA2AgAg\nA0HQAmogAikDADcDACAEIANB6AFqIgVqQYABOgAAIAMgAykDaDcDyAIgA0EQaiAEQQFqIAVBwABB\noJzAABCSAiADKAIUIQIgAygCECEBA0AgAgRAIAFBADoAACACQQFrIQIgAUEBaiEBDAEFCwsgBEED\ndK0gCEIJhoQhCAJAIARBOHFBOEcEQCADIAg3A6ACIANByAJqIAUQAwwBBQsgA0HIAmoiASAFEAMg\nA0HgAmoiAkEAQTj8CwAgAyAINwCYAyABIAIQAwtBACECIANBADoAqAJBFEEEEL0CIgFBBSABQQVJ\nG0ECdCEBA0AgASACRkUEQCADIANByAJqIAJqKAIANgLgAiADQbACaiACakEEIANB4AJqQQRBnJ3A\nABCdAiACQQRqIQIMAQULCyADQTRqIgEgA0GwAmpBFBC1ASAGIAcQ3wIgA0EIaiABEPkBIAMoAgwh\nASAAIAMoAgg2AgAgACABNgIEIANBoANqJAALsAQBDH8gAUEBayEOIAAoAgQhCiAAKAIAIQsgACgC\nCCEMAkADQCAFDQECfwJAIAIgA0kNAANAIAEgA2ohBQJAAkACQCACIANrIgdBB00EQCACIANHDQEg\n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\n/wFxQQFqIQYgAigCACEAA0ACQCAAQQRqKAIAIgVFDQAgAygCACAAKAIAIAUgAygCBCgCDBEHAEUN\nAEEBDAULQQEgASgCACADIAFBBGooAgARBQANBBogAEEIaiEAIAQgAUEIaiIBRw0ACwwCCyAAQRhs\nIQogAEEBa0H/////AXFBAWohBiACKAIIIQQgAigCACEAA0ACQCAAQQRqKAIAIgFFDQAgAygCACAA\nKAIAIAEgAygCBCgCDBEHAEUNAEEBDAQLQQAhB0EAIQgCQAJAAkAgBSAJaiIBQQhqLwEAQQFrDgIB\nAgALIAFBCmovAQAhCAwBCyAEIAFBDGooAgBBA3RqLwEEIQgLAkACQAJAIAEvAQBBAWsOAgECAAsg\nAUECai8BACEHDAELIAQgAUEEaigCAEEDdGovAQQhBwsgAyAHOwEOIAMgCDsBDCADIAFBFGooAgA2\nAghBASAEIAFBEGooAgBBA3RqIgEoAgAgAyABQQRqKAIAEQUADQMaIABBCGohACAFQRhqIgUgCkcN\nAAsMAQsLAkAgBiACKAIETw0AIAMoAgAgAigCACAGQQN0aiIAKAIAIAAoAgQgAygCBCgCDBEHAEUN\nAEEBDAELQQALIANBEGokAAuiBAEKfyMAQZABayIHJAAgB0EAQZAB/AsAIwBBwAFrIgIkACACQeAA\nakHgABBDGiACQUBrIQkgAkEgaiEKIAJBoAFqIQUgAkGAAWohBkH/ASEEA0AgBEHgAWsiA0EgSQRA\nIAgEQCACQeAAaiILIAYgBSALIAYgBRBwBQsgASAEQcABa0EDdkH8////AXFqKAIAIAN2QQFxIAEg\nBEGAAWtBA3ZB/P///wFxaigCACADdkEBdEECcSABIARBQGpBA3ZB/P///wFxaigCACADdkECdEEE\ncSABIARBA3ZB/P///wFxaigCACADdkEDdEEIcXJyckHw4MAAIAIQvAECQCAIBEAgAkHgAGoiCCAG\nIAUgCCAGIAVBASACIAogCRAoDAEFCyACQeAAaiACEPwCIAYgChD8AiAFIAkQ/AILQQEhCCABIANB\nA3ZB/P///wFxaigCACADdkEBcSABIARBoAFrQQN2Qfz///8BcWooAgAgA3ZBAXRBAnEgASAEQeAA\na0EDdkH8////AXFqKAIAIAN2QQJ0QQRxIAEgBEEga0EDdkH8////AXFqKAIAIAN2QQN0QQhxcnJy\nQbDZwAAgAhC8ASACQeAAaiIDIAYgBSADIAYgBUEBIAIgCiAJECggBEEBayEEDAEFCwsgByACQeAA\nahCWAiAHQSBqIAYQlgIgB0FAayAFEJYCIAJBwAFqJAAgACAHQZAB/AoAACAHQZABaiQAC/sDARB+\nQX9BACACNQIcIAE1Ahx8IAI1AhggATUCGHwgAjUCFCABNQIUfCACNQIQIAE1AhB8IAI1AgwgATUC\nDHwgAjUCCCABNQIIfCACNQIEIAE1AgQgAjUCACABNQIAfCIDQiCIfHwiBEIgiHwiBUIgiHwiBkIg\niHwiB0IgiHwiCEIgiHwiCUIgiHwiCkIgiEIAIApC/////w+DQgAgCUL/////D4MgCEL/////D4NC\nACAHQv////8Pg0IAIAZC/////w+DQgAgBUL/////D4NCACAEQv////8Pg0IAIANC/////w+DQv//\n//8PfSILQiCIfUL/AYN9Qv////8PfSIMQiCIfUL/AYN9Qv////8PfSINQiCIfUL/AYN9Ig5CIIh9\nQv8Bg30iD0IgiH1C/wGDfSIQQiCIQgF9QoB+hHwiEUIgiH1C/wGDfUL/////D30iEkIgiH1C/wGD\nfUIgiKdB/wFxGyIBQX9zIQIgACACIBKncSABIAqncXI2AhwgACACIBGncSABIAmncXI2AhggACAC\nIBCncSABIAincXI2AhQgACACIA+ncSABIAencXI2AhAgACACIA6ncSABIAancXI2AgwgACACIA2n\ncSABIAWncXI2AgggACACIAyncSABIASncXI2AgQgACACIAuncSABIAOncXI2AgALnQQBBH8jACIE\nIARBgBRrQUBxIgQkACAEQcATaiEGA0AgBUEwTwRAQQBBMSAFayIBIAFBMUsbIQEgBSAGaiEFA0Ag\nAQRAIAVBADoAACAFQQFqIQUgAUEBayEBDAEFCwsFIAUgBmogASAFaigCADYAACAFQQRqIQUMAQsL\nIARBwAFqIgEgAhD6AiABQTByIAMQ+gIgBEGgAmpB4NjAABD6AiAEQdACaiICIAEQSiAEQeADaiIF\nIAIgARA+IARB8ARqIgMgAhBKIARBkAdqIgIgBRBKIARBsAlqIgUgAxBKIARB8A1qIgYgAhBKIARB\ngAZqIgcgAyABED4gBEGgCGoiAyACIAEQPiAEQcAKaiAFIAEQPiAEQYAPaiAGIAEQPiAEQZAQaiIC\nIAMQSiAEQdALaiIDIAcQSiAEQaARaiACIAEQPiAEQeAMaiADIAEQPiAEQbASaiAFEEogBEG8AWog\nBEG4AWogBC0A7xNBA3YQ4gEgBCABIAQoArgBEF9B+wIhAwNAIANBAWpBBU8EQCADQfsCRwRAIAQg\nBEHAE2ogA0EDdmovAAAgA0EHcXZBP3EgBEHAAWoQdwULIANBBWshAyAEIAQQSiAEIAQQSiAEIAQQ\nSiAEIAQQSiAEIAQQSgwBBQsLIAQgBC0AwBNBAXRBPnEgBEHAAWoQdyAAIAQQ+gIgAEEwaiAEQTBy\nEPoCIABB4ABqIARB4ABqEPoCJAALywQCB38FfiMAQYAFayICJAAgAkGABGoiBCABQQAQMiACQagD\naiAEQSgQKRogAkHQA2ogAkGoBGpBKBApGiACQQA2AvgDIAJB0AJqIgUgASACQdAEaiIEEN4BIAJB\n0AFqIAVBKBApGiACQfgBaiACQfgCaiIIQSgQKSEFIAJBoAJqIAFB0ABqQSgQKSEBIAJBADYCyAID\nQCADQcD/H0ZFBEAgBRBqIAAgA2oiB0EgaiAFEM4BIAJB0AFqIgYgBiACQagDaiACQYABaiIGECQg\nBhBqIAcgBhDOASADQUBrIQMMAQULCyACQagBaiIDIAEgBBAOIAMgAxDwASACQdACaiIFIAJB0AFq\nIAMQ3gEgAEHA/x9qIAUQ1wEgBCADIAEQDiACQdgAaiIBIAQQFyABIAEgAkGABGoQDkGA/x8hAyAC\nKQN4IQkgAikDcCEKIAIpA2ghCyACKQNgIQwgAikDWCENA0AgA0FARkUEQCACQdACaiIEIAAgA2oi\nARCxAiACQagBaiIFIAUgBBAOIAJBMGoiBiAFEBcgAkEIaiIHIAYgBRAOIAQgBCAGEA4gAiAJIAIp\nA/ACfUL8////////AXw3A/ACIAIgCiACKQPoAn1C/P///////x98NwPoAiACIAsgAikD4AJ9Qvz/\n//////8ffDcD4AIgAiAMIAIpA9gCfUL8////////H3w3A9gCIAIgDSACKQPQAn1CvOH//7///x98\nNwPQAiAIIAggBxAOIAEgBBDXASADQUBqIQMMAQULCyACQYAFaiQAC6oEAQh/IwBBoAhrIgQkACAE\nQQpqQQBB/gf8CwACQAJAAkACQAJAIANBA3YiCCADQQdxQQBHIgNqIgVBgQhJBEAgBSAAKAIIIgYg\nACgCAEHRAGotAAAiCmoiB0ELakkNASAFRQ0CIARBADoACCAFQQFGDQMgBSAHayEJIARBAToACUEA\nIAVrIQsgByAIayADa0EDaiEIQQIhAwJAAkADQCADIAhqQQJHBEAgAyALakUNAiAEQQhqIANqQf8B\nOgAAIANBAWohAwwBBQsLIAUgCUEBayIDSwRAIARBCGogA2pBADoAACAFIAdJDQcgBiAHTQ0CIARB\nADYCmAggBEEBNgKMCCAEQei0wAA2AogIIARCBDcCkAggBEGICGpBiKvAABB7AAULIAMgBUHoqsAA\nEMMBAAsgAyAFQbirwAAQwwEACyAEQQhqIAlqIgMgBiAAKAIEIAZBmKvAABCdAiADIAZqIAogAUEE\naiABKAIAQdEAai0AAEGoq8AAEJ0CIAQgAiACKAIEIAIoAghrEOEBIAQoAgAiAEUNBUEBIQMgBSAE\nKAIERgRAIAAgBEEIaiAFEOYBQQBHIQMFCyAEQaAIaiQAIAMPBQsgBUGACEH4qcAAEOICAAtBiKrA\nAEEtQbiqwAAQ7AEAC0EAQQBByKrAABDDAQALQQFBAUHYqsAAEMMBAAsgCSAFQfiqwAAQ4QIAC0GO\n0MAAQSsgBEGICGpBjKjAAEGEqcAAEK8BAAv+AwENfyMAQaAFayIDJAAgAUHgAGoiCBDvASEJIAJB\n4ABqIgoQ7wEhCyADQYADaiIHIAoQ+wIgA0GwA2oiBiAIEPsCIANB4ANqIgQgByAKENwCIANBwARq\nIgUgBiAIENwCIAQgBCABQTBqIgwQ3AIgBSAFIAJBMGoiDRDcAiADQaACaiAFIAQQfCADQZAEaiIE\nIAEgBxDcAiADQfAEaiIFIAIgBhDcAiADQdACaiAFIAQQfAJAIAQgBRDaASAJIAtyQX9zcQRAIANB\n4ANqIANBwARqENoBBEAgACABEEoMAgULIAAQpgIgAEEwahCmAiAAQeAAahCmAgwBBQsgA0HAAWoi\nDiADQaACaiIPEPsCIAMgA0HQAmoiBSAIENwCIANB8AFqIgQgBRD7AiADIAMgChDcAiADQZABaiIH\nIAQgBRDcAiADQfAEaiIGIANBkARqIAQQ3AIgBCAGEOgCIANB4ABqIgUgDiAEEHwgBSAFIAcQfCAD\nQTBqIgQgBiAFEHwgA0HABGoiBiADQeADaiAHENwCIAQgDyAEENwCIAQgBCAGEHwgBSACIAkQ6gEg\nBCANIAkQ6gEgAyAKIAkQ6gEgBSABIAsQ6gEgBCAMIAsQ6gEgAyAIIAsQ6gEgACAFEPoCIABBMGog\nBBD6AiAAQeAAaiADEPoCCyADQaAFaiQAC4MEAQ5/IwBB8AdrIgMkACADIAEQjAIgA0EwaiICIAMQ\njAIgA0HgAGoiBiACIAEQjQIgA0GQAWoiBSAGIAMQjQIgA0HAAWoiBCACEIwCIANB8AFqIgcgBBCM\nAiADQaACaiIEIAcQjAIgA0HQAmoiCSAFIAQQjQIgA0GAA2oiByACIAkQjQIgA0GwA2oiCCACIAcQ\njQIgA0HgA2oiCiAEIAgQjQIgA0GQBGoiAiAHEIwCIANBwARqIgsgBiACEI0CIANB8ARqIgIgASAL\nEI0CIANBoAVqIgwgBSACEI0CIANB0AVqIg0gAiAMEI0CIANBgAZqIg4gBCANEI0CIANBsAZqIgIg\nBCAOEI0CIANB4AZqIg8gAkEIIAIQjgIgA0GQB2oiBCAPQRAgDxCOAiADQcAHaiICIARBwAAgBBCO\nAiACQSAgBBDFAiACQQYgCBDFAiACQQUgBRDFAiACQQogDhDFAiACQQQgBhDFAiACQQggCxDFAiAC\nQQcgCRDFAiACQQkgCBDFAiACQQUgBRDFAiACQQMgBhDFAiACQQsgChDFAiACQQUgBRDFAiACQQQg\nBRDFAiACQQUgBRDFAiACQQggBxDFAiACQQwgDRDFAiACQQogDBDFAiACQQMgARDFAiACQQUgBhDF\nAiACQQggChDFAiAAIAJBMPwKAAAgA0HwB2okAAv9AwECfyAAIAFqIQICQAJAIAAoAgQiA0EBcQ0A\nIANBAnFFDQEgACgCACIDIAFqIQEgACADayIAQZj4wAAoAgBGBEAgAigCBEEDcUEDRw0BQZD4wAAg\nATYCACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAIgATYCAAwCBQsgACADEE8LAkACQAJAIAIoAgQi\nA0ECcUUEQCACQZz4wAAoAgBGDQIgAkGY+MAAKAIARg0DIAIgA0F4cSICEE8gACABIAJqIgFBAXI2\nAgQgACABaiABNgIAIABBmPjAACgCAEcNAUGQ+MAAIAE2AgAPBQsgAiADQX5xNgIEIAAgAUEBcjYC\nBCAAIAFqIAE2AgALIAFBgAJPBEAgACABEFUPBQsgAUH4AXFBgPbAAGohAgJ/QYj4wAAoAgAiA0EB\nIAFBA3Z0IgFxRQRAQYj4wAAgASADcjYCACACDAEFCyACKAIICyEBIAIgADYCCCABIAA2AgwgACAC\nNgIMIAAgATYCCA8LQZz4wAAgADYCAEGU+MAAQZT4wAAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEGY\n+MAAKAIARw0BQZD4wABBADYCAEGY+MAAQQA2AgAPC0GY+MAAIAA2AgBBkPjAAEGQ+MAAKAIAIAFq\nIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsLygMCAX8KfiAAKQMYIQQgACkDECEFIAApAwghBiAA\nKQMAIQcjAEEQayIDIAApAyAiCEI/hzcDCCADKQMIIQkgAykDCCEKIAMpAwghCyADKQMIIQwgAykD\nCCENIAMgAUI/hzcDACADIAMpAwAgCCACKQMgIgEgDYN8hSADKQMAfSADKQMAIAQgAikDGCIIIAyD\nfIUgAykDAH0gAykDACAFIAIpAxAiBCALg3yFIAMpAwB9IAMpAwAgBiACKQMIIgUgCoN8hSADKQMA\nfSADKQMAIAcgAikDACIGIAmDfIUgAykDAH0iB0I+h3wiCUI+h3wiCkI+h3wiC0I+h3wiDEI/hzcD\nCCAAIAYgAykDCIMgB0L//////////z+DfCIGQv//////////P4M3AwAgACAFIAMpAwiDIAlC////\n//////8/g3wgBkI+h3wiBUL//////////z+DNwMIIAAgBCADKQMIgyAKQv//////////P4N8IAVC\nPod8IgRC//////////8/gzcDECAAIAggAykDCIMgC0L//////////z+DfCAEQj6HfCIEQv//////\n////P4M3AxggACABIAMpAwiDIAx8IARCPod8NwMgC7kDAQF+IAAgASkAGCIDQjiGIANCKIZCgICA\ngICAwP8Ag4QgA0IYhkKAgICAgOA/gyADQgiGQoCAgIDwH4OEhCADQgiIQoCAgPgPgyADQhiIQoCA\n/AeDhCADQiiIQoD+A4MgA0I4iISEhDcDACAAIAEpABAiA0I4hiADQiiGQoCAgICAgMD/AIOEIANC\nGIZCgICAgIDgP4MgA0IIhkKAgICA8B+DhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA\n/gODIANCOIiEhIQ3AwggACABKQAIIgNCOIYgA0IohkKAgICAgIDA/wCDhCADQhiGQoCAgICA4D+D\nIANCCIZCgICAgPAfg4SEIANCCIhCgICA+A+DIANCGIhCgID8B4OEIANCKIhCgP4DgyADQjiIhISE\nNwMQIAAgASkAACIDQjiGIANCKIZCgICAgICAwP8Ag4QgA0IYhkKAgICAgOA/gyADQgiGQoCAgIDw\nH4OEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhDcDGCAAIAAQ0wEQ\nngEhACACBEAgAiAANgIABQsLigMBBH8CQCABQRBJBEAgACECDAEFCwJAIAAgAEEAIABrQQNxIgRq\nIgNPDQAgACECIAQEQCAEIQUDQCACQQA6AAAgAkEBaiECIAVBAWsiBQ0ACwULIARBAWtBB0kNAANA\nIAJBADoAACACQQdqQQA6AAAgAkEGakEAOgAAIAJBBWpBADoAACACQQRqQQA6AAAgAkEDakEAOgAA\nIAJBAmpBADoAACACQQFqQQA6AAAgAkEIaiICIANHDQALCyADIAEgBGsiAUF8cWoiAiADSwRAA0Ag\nA0EANgIAIANBBGoiAyACSQ0ACwULIAFBA3EhAQsCQCACIAEgAmoiBE8NACABQQdxIgMEQANAIAJB\nADoAACACQQFqIQIgA0EBayIDDQALBQsgAUEBa0EHSQ0AA0AgAkEAOgAAIAJBB2pBADoAACACQQZq\nQQA6AAAgAkEFakEAOgAAIAJBBGpBADoAACACQQNqQQA6AAAgAkECakEAOgAAIAJBAWpBADoAACAC\nQQhqIgIgBEcNAAsLIAALqwMAIAAgASkDIEIoiDwAACAAIAFBJGo1AgA8AAEgACABKQMgQhiIPAAC\nIAAgASkDIEIQiDwAAyAAIAEpAyBCCIg8AAQgACABKQMgPAAFIAAgASkDGEIsiDwABiAAIAEpAxhC\nJIg8AAcgACABKQMYQhyIPAAIIAAgASkDGEIUiDwACSAAIAEpAxhCDIg8AAogACABKQMYQgSIPAAL\nIAAgAUEWajMBAEIPgyABKQMYQgSGhDwADCAAIAEpAxBCKIg8AA0gACABQRRqNQIAPAAOIAAgASkD\nEEIYiDwADyAAIAEpAxBCEIg8ABAgACABKQMQQgiIPAARIAAgASkDEDwAEiAAIAEpAwhCLIg8ABMg\nACABKQMIQiSIPAAUIAAgASkDCEIciDwAFSAAIAEpAwhCFIg8ABYgACABKQMIQgyIPAAXIAAgASkD\nCEIEiDwAGCAAIAEzAQZCD4MgASkDCEIEhoQ8ABkgACABKQMAQiiIPAAaIAAgATUCBDwAGyAAIAEp\nAwBCGIg8ABwgACABKQMAQhCIPAAdIAAgASkDAEIIiDwAHiAAIAEpAwA8AB8L/gIBBX4gACABMQAf\nIAExAB5CCIaEIAExAB1CEIaEIAExABxCGIaEIAExABtCIIaEIAExABpCKIaEIAExABlCD4NCMIaE\nIgI3AwAgACABLQAZQQR2rSABMQAYQgSGhCABMQAXQgyGhCABMQAWQhSGhCABMQAVQhyGhCABMQAU\nQiSGhCABMQATQiyGhCIDNwMIIAAgATEAEiABMQARQgiGhCABMQAQQhCGhCABMQAPQhiGhCABMQAO\nQiCGhCABMQANQiiGhCABMQAMQg+DQjCGhCIENwMQIAAgAS0ADEEEdq0gATEAC0IEhoQgATEACkIM\nhoQgATEACUIUhoQgATEACEIchoQgATEAB0IkhoQgATEABkIshoQiBTcDGCAAIAExAAUgATEABEII\nhoQgATEAA0IQhoQgATEAAkIYhoQgATEAAUIghoQgATEAAEIohoQiBjcDICADIASDIAWDQv//////\n//8HUiAGQv///////z9SciACQq/4///v//8HVHILgQMBCX4gAEF/QQAgATUCHCACNQIcQgAgATUC\nGCACNQIYQgAgATUCFCACNQIUQgAgATUCECACNQIQQgAgATUCDCACNQIMQgAgATUCCCACNQIIQgAg\nATUCBCACNQIEQgAgATUCACACNQIAfSIEQiCIfUL/AYN8fSIFQiCIfUL/AYN8fSIGQiCIfUL/AYN8\nfSIHQiCIfUL/AYN8fSIIQiCIfUL/AYN8fSIJQiCIfUL/AYN8fSIKQiCIfUL/AYN8fSILQoCAgIDw\nH4NCAFIbIgGtIgMgBEL/////D4N8IgQ+AgAgACAFQv////8PgyADfCAEQiCIfCIEPgIEIAAgBkL/\n////D4MgA3wgBEIgiHwiAz4CCCAAIAdC/////w+DIANCIIh8IgM+AgwgACAIQv////8PgyADQiCI\nfCIDPgIQIAAgCUL/////D4MgA0IgiHwiAz4CFCAAIAFBAXGtIApC/////w+DfCADQiCIfCIDPgIY\nIAAgASADQiCIIAt8p2o2AhwL6QIBBX8CQCABQc3/eyAAQRAgAEEQSxsiAGtPDQAgAEEQIAFBC2pB\n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\nNgIAIARBAWshBAsCQCAGRSAEQSBLckUEQCADIARrQTBqIAUgBBApGiAAIANBEGogA0E8ahBCIAMo\nAjxFDQEFCyAAQgA3AwAgAEEYakIANwMAIABBEGpCADcDACAAQQhqQgA3AwALIAEgASgCACAEajYC\nAEEBIQYLIANBQGskACAGC4gDAQN/IwBB0AVrIgMkAANAIAJBgANGRQRAIAIgA2pBAEEw/AsAIAJB\nMGohAgwBBQsLIAMgAUEw/AoAACADQYADaiADEI8CQQAhAgNAIAJB0AJGRQRAIANBoAVqIgQgAiAD\naiIBIANBgANqEJACIAFBMGogBEEw/AoAACACQTBqIQIMAQULCyADQbADaiICIANB0AJqIgFBBCAB\nEOkBIANB4ANqIgQgAkEIIAIQ6QEgA0GQBGoiASAEQRAgBBDpASADQcAEaiIEIAFBICABEOkBIANB\n8ARqIgIgBEEgIAEQ6QEgA0GgBWogAkHgACACEOkBQQAhAgNAAkACQCACQc4ARwRAIAJBxcvAAGot\nAAAiBEEHSw0CIAJBAmohASACQcTLwABqLQAAIQIDQCACRQ0CIAJBAWshAiADQaAFahD3AgwACwAF\nCyAAIANBoAVqQTD8CgAAIANB0AVqJAAPCyADQaAFaiICIAIgAyAEQTBsahDdAiABIQIMAQsLIARB\nCEG0y8AAEMMBAAvXAgILfwF+IwBBIGsiAyQAIABBhAQQQyEJIANBGGogAUEYaikDACIONwMAIANB\nEGogAUEQaikDADcDACADQQhqIAFBCGopAwA3AwAgAyABKQMANwMAQQEhBiAOQgBTBEAgAyADEJEB\nQX8hBgULIAJBAWshCkF/IQUDQEGBASAEayEAIAkgBEECdGohCCAEIQECQANAIAFBgAFKDQEgByAD\nIAFBBnYiC0EDdCIMaikDACABQT9xIg2tiCIOp0EBcUYEQCAIQQRqIQggAEEBayEAIAFBAWohAQwB\nBQsLIAggByALIAIgACAAIAJKGyABaiIEQQFrQQZ2RwR+IAMgDGpBCGopAwBBwAAgDWuthiAOhAUg\nDgtCf0GBASABayIFIAIgAiAFShuthkJ/hYOnaiIAIAAgCnZBAXEiByACdGsgBmw2AgAgASEFDAEL\nCyADQSBqJAAgBUEBaguNAwAgACABQR9qMQAAPAAAIAAgAUEeajMBADwAASAAIAEpAxhCKIg8AAIg\n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\nAUGOjcAAQQIgAiAEakEBa0GBASACaxA3DAELIAAoAgAhAEGBASECA0AgAiAEakECayAAQQ9xIgNB\nMHIgA0E3aiADQQpJGzoAACACQQFrIQIgAEEPSyAAQQR2IQANAAsgAUEBQY6NwABBAiACIARqQQFr\nQYEBIAJrEDcLIARBgAFqJAALhgIBA38jAEGAAWsiBCQAAn8CQCABKAIIIgJBgICAEHFFBEAgAkGA\ngIAgcQ0BIAAgARCMAQwCBQsgAC0AACECQYEBIQADQCAAIARqQQJrIAJBD3EiA0EwciADQdcAaiAD\nQQpJGzoAACACIgNBBHYhAiAAQQFrIQAgA0EPSw0ACyABQQFBjo3AAEECIAAgBGpBAWtBgQEgAGsQ\nNwwBCyAALQAAIQJBgQEhAANAIAAgBGpBAmsgAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAiIDQQR2\nIQIgAEEBayEAIANBD0sNAAsgAUEBQY6NwABBAiAAIARqQQFrQYEBIABrEDcLIARBgAFqJAALkgIB\nAn8jAEEgayIDJAACQCACQSBHBEAgAEEEakEAIAIQNkEBIQEMAQULIANBAmoiBCABQQJqLQAAOgAA\nIANBE2ogAUETaikAADcAACADQRhqIAFBGGopAAA3AAAgAyABLwAAOwEAIAMgASkACzcACyADIAEp\nAAM3AANBACEBQeT0wAAoAgAaIwBBIGsiAiQAIAIgAxCDAiACQSBqJABFBEBBASEBIABBBGpBASAD\nEDYMAQULIAAgAy8BADsAASAAIAMpAAM3AgQgACADQQtqIgIpAAA3AAwgAEEDaiAELQAAOgAAIABB\nFGogAkEIaikAADcAACAAQRlqIAJBDWopAAA3AAALIAAgAToAACADQSBqJAALiwIBBX8jAEEgayID\nJAACQCACIAFrIgUgACgCACICIAAoAggiBmtNBEAgBSAGaiEHIAAoAgQhAgwBBQsCQAJ/QQAgBiAF\nIAZqIgdLDQAaQQAgByACQQF0IgQgBCAHSRsiBEEIIARBCEsbIgRBAEgNABoCfyACRQRAQQAhAiAD\nQRhqDAEFCyADQQE2AhggAyAAKAIENgIUIANBHGoLIAI2AgAgA0EIakEBIAQgA0EUahCaASADKAII\nQQFHDQEgAygCECEAIAMoAgwLIABB+NHAABDPAgALIAMoAgwhAiAAIAQ2AgAgACACNgIECyAFBEAg\nAiAGaiABIAX8CgAABQsgACAHNgIIIANBIGokAAvwAQIBfwZ+IwBBQGoiAyQAIAMgASACEBwgAEIA\nNwMQIABBGGpCADcDACAAIAMpAzA3AwAgACADKQM4NwMIIwBBEGsiASADKQMoQj+IPgIMIAAgASgC\nDEEBa0GAAnEiAUHAAEmtIAFBP3GtIgaGIgQgACkDAHwiBzcDACAAIAFBBnYiAUEBRq0gBoYiCCAA\nKQMIfCIFIAQgB1atfCIHNwMIIAAgAUECRq0gBoYiCSAAKQMQfCIEIAUgCFStIAUgB1atfHwiBTcD\nECAAIAApAxggAUEDRq0gBoZ8IAQgCVStIAQgBVatfHw3AxggA0FAayQAC/8BAQR/IwBBMGsiAyQA\nIAMgACgCYCICQQV2IgRBgICAOHE2AiggAyAEQYD+A3EgAkELdEGAgPwHcSACQRt0cnIgAkEDdEEY\ndnI2AiwgAEHA8sAAQTcgAmtBP3FBAWoQAiAAIANBKGpBCBACQQAhAgNAIAJBIEZFBEAgACACaiIF\nKAIAIQQgBUEANgIAIAIgA2ogBEEIdEGAgPwHcSAEQRh0ciAEQQh2QYD+A3EgBEEYdnJyNgIAIAJB\nBGohAgwBBQsLIAEgAykDADcAACABQQhqIAMpAwg3AAAgAUEYaiADQRhqKQMANwAAIAFBEGogA0EQ\naikDADcAACADQTBqJAALxQIBB34gACkDCCAAKQMAIAApAyAiBEIwiELRh4CAEH58IgFCNIh8IgJC\n/////////weDIQUgACkDGCAAKQMQIAJCNIh8IgdCNIh8IgNC/////////weDIQYgACAEQv//////\n/z+DIANCNIh8IgRCMIggAiAHQv////////8HgyICgyADg0L/////////B1EgBEL///////8/UXEg\nAUL/////////B4MiA0Ku+P//7///B1ZxrYRQBH4gBAUgA0LRh4CAEHwiAUL/////////B4MhAyAF\nIAFCNIh8IgFC/////////weDIQUgAiABQjSIfCIBQv////////8HgyECIAYgAUI0iHwiAUL/////\n////B4MhBiABQjSIIAR8Qv///////z+DCzcDICAAIAY3AxggACACNwMQIAAgBTcDCCAAIAM3AwAL\nkgIBBH8jAEEgayIDJAACQCACQSBHBEAgAEEEakEEIAIQNkEBIQIMAQULIANBAmogAUECaiIELQAA\nOgAAIANBE2ogAUETaikAADcAACADQRhqIAFBGGopAAA3AAAgAyABLwAAOwEAIAMgASgAByIFNgAH\nIAMgASgAAyIGNgADIAMgASkACzcAC0EBIQIgA0HooMAAQSAQ5gFBAEoEQCAAQQRqQQUgAxA2DAEF\nCyAAIAU2AgggACAGNgIEIAAgAS8AADsAASAAIAFBC2oiASkAADcADCAAQQNqIAQtAAA6AAAgAEEU\naiABQQhqKQAANwAAIABBGWogAUENaikAADcAAEEAIQILIAAgAjoAACADQSBqJAALpgIBAX8jAEHw\nAGsiBiQAIAYgATYCDCAGIAA2AgggBiADNgIUIAYgAjYCECAGQQI2AhwgBkHEi8AANgIYAkAgBCgC\nAARAIAZBMGogBEEQaikCADcDACAGQShqIARBCGopAgA3AwAgBiAEKQIANwMgIAZBBDYCXCAGQayM\nwAA2AlggBkIENwJkIAYgBkEQaq1CgICAgDCENwNQIAYgBkEIaq1CgICAgDCENwNIIAYgBkEgaq1C\ngICAgIABhDcDQAwBBQsgBkEDNgJcIAZB+IvAADYCWCAGQgM3AmQgBiAGQRBqrUKAgICAMIQ3A0gg\nBiAGQQhqrUKAgICAMIQ3A0ALIAYgBkEYaq1CgICAgMAAhDcDOCAGIAZBOGo2AmAgBkHYAGogBRB7\nAAvrAQEEfyMAQRBrIgUkAEEBIQQgAUUgAUECdiABQQNxQQBHaiADS3JFBEAgAiADQQJ0aiEGA38g\nAwR/QQAhBEEAIAIgAiAGRhsgAiAGR0ECdCEHAkAgAEUEQEEAIQAMAQULIAFFBEBBACEBQQAhAAwB\nBQsgBUEANgIMIAUgAUEEIAFBBEkbIgRrQRBqIAQgACABIARrIgFqIAQQ8QEgBSgCDCIEQRh0IARB\ngP4DcUEIdHIgBEEIdkGA/gNxIARBGHZyciEECyACIAdqIQIgBDYCACADQQFrIQMMAQVBAAsLIQQF\nCyAFQRBqJAAgBAv6AQEPf0F/QQAgARsiAUF/cyEEIAIoAgAhBSADKAIAIQYgAigCBCEHIAMoAgQh\nCCACKAIIIQkgAygCCCEKIAIoAgwhCyADKAIMIQwgAigCECENIAMoAhAhDiACKAIUIQ8gAygCFCEQ\nIAIoAhghESADKAIYIRIgACADKAIcIAFxIAIoAhwgBHFyNgIcIAAgASAScSAEIBFxcjYCGCAAIAEg\nEHEgBCAPcXI2AhQgACABIA5xIAQgDXFyNgIQIAAgASAMcSAEIAtxcjYCDCAAIAEgCnEgBCAJcXI2\nAgggACABIAhxIAQgB3FyNgIEIAAgBCAFcSABIAZxcjYCAAvWAQEFfyAAIAEoAgwgAigCCCIFQRp3\nIAVBFXdzIAVBB3dzIARqaiABKAIIIgcgAigCDCIIcyAFcSAHc2oiBCABKAIEaiIGNgIMIAAgBCAC\nKAIAIgQgASgCACIJIAIoAgQiAnNxIAIgCXFzIARBHncgBEETd3MgBEEKd3NqaiIBNgIEIAAgCSAD\nIAdqIAggBiAFIAhzcXNqIAZBGncgBkEVd3MgBkEHd3NqIgNqNgIIIAAgAUEedyABQRN3cyABQQp3\ncyABIAIgBHNxIAIgBHFzaiADajYCAAvsAQEHfyMAQYACayIGJAAgBkHgAWoiCCAFEAUgBkHAAWoi\nByAEEAUgBkGgAWoiCyADIAcQBCAGQYABaiIKIAMgCBBGIAZB4ABqIgkgAyAIEDogBkFAayIDIAkg\nCRA6IAkgCSADEDogBkEgaiIMIAogCRAEIAAgDBAFIAYgCyALEDogBiAGIAYQOiADIAYgBhA6IAAg\nACADEEYgCCAHIAgQOiAKIAQgBRA6IAIgChAFIAIgAiAIEEYgASAGIAAQRiAHIAcgBxA6IAcgBxAF\nIAEgDCABEAQgByAHIAcQOiABIAEgBxBGIAZBgAJqJAAL6QECA38BfiAAIAI1AgAgATUCAHwiCD4C\nACAEQQEgBEEBSxsiB0EBayEGQQQhBQNAIAYEQCAAIAVqIAIgBWo1AgAgASAFajUCACAIQiCIfHwi\nCD4CACAGQQFrIQYgBUEEaiEFDAEFCwsgACAANQIAIAMoAgAgACADIAQQpwFBf3NBfyAIQoCAgIAQ\nVBsiAXGtfSIIPgIAIANBBGohAiAAQQRqIQUgB0EBayEGA0AgBgRAIAUgBTUCACACKAIAIAFxrSAI\nQiCIQgGDfH0iCD4CACACQQRqIQIgBUEEaiEFIAZBAWshBgwBBQsLC9sBAgR/AX4gA0ECdCABakEE\naygCACEHIAMhBgNAIAYEQCAAIARqIAUgASAEaigCACIFQQF0cjYCACAEQQRqIQQgBkEBayEGIAVB\nH3YhBQwBBQJAIAAgADUCACACKAIAIAAgAiADEKcBQX9zQX8gB0EAThsiAXGtfSIIPgIAIAJBBGoh\nBSAAQQRqIQQgA0EBIANBAUsbQQFrIQYDQCAGRQ0BIAQgBDUCACAFKAIAIAFxrSAIQiCIQgGDfH0i\nCD4CACAFQQRqIQUgBEEEaiEEIAZBAWshBgwACwALCwsLpwIBBX4gACAAKQMYIAApAxAgACkDCCAA\nKQMAIAApAyAiA0IwiELRh4CAEH58IgJCNIh8IgFCNIh8IgRCNIh8IgVCNIggA0L///////8/g3wi\nA0IwiCAEQv////////8HgyIEIAGDIAWDQv////////8HUSADQv///////z9RcSACQv////////8H\ngyICQq74///v//8HVnGthELRh4CAEH4gAnwiAkL/////////B4M3AwAgACABQv////////8HgyAC\nQjSIfCIBQv////////8HgzcDCCAAIAFCNIggBHwiAUL/////////B4M3AxAgACAFQv////////8H\ngyABQjSIfCIBQv////////8HgzcDGCAAIAFCNIggA3xC////////P4M3AyAL7gEBA38jAEFAaiIC\nJAAgAkEoakIANwMAIAJBMGpCADcDACACQThqQgA3AwAgAkEYaiABQRhqKQAANwMAIAJBEGogAUEQ\naikAADcDACACQgA3AyAgAiABKQAANwMAIAIgAUEIaikAADcDCCAAQeQAaiIDEKgCQQAhAQNAIAFB\nwABGRQRAIAEgAmoiBCAELQAAQdwAczoAACABQQFqIQEMAQULCyADIAJBwAAQAiAAEKgCQQAhAQNA\nIAFBwABGRQRAIAEgAmoiAyADLQAAQeoAczoAACABQQFqIQEMAQULCyAAIAJBwAAQAiACQUBrJAAL\n+QEBAX8jAEHQAGsiBSQAIAVBCGogASACEOgBIAUgBSgCDCIBNgIcIAUgBSgCCCICNgIYIAUgATYC\nFCAFQSBqIAMgBBDbASAFQcQAaiACIAFBACAFKAIkIAUoAiBBgICAgHhGGyAFKAIoECMCQAJAIAUo\nAkRBBUYNACAFQThqIAVBxABqEFsgBSgCOCIBQYCAgIB4Rg0AIAUgBSkCPDcCMCAFIAE2AiwMAQsg\nBUGAgICAeDYCLAsgBUEgahDLAiAFQRRqEOMCIAUgBUEsahCGAiAFKAIEIQEgACAFKAIAIgI2AgQg\nACABQQAgAkEBcRs2AgAgBUHQAGokAAuLAgEDfyMAQdABayIFJAAgAEKBgoSIkKDAgAE3AgAgAEIA\n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\nACkDGCACQjSIfCIFQv////////8Hg4QgA0L///////8/gyAFQjSIfCIDhFAgASAEgyACgyAFgyAD\nQoCAgICAgMAHhYNC/////////wdRcgsLqQEBA38jAEEQayIDJABBAyECIAAtAAAiACEEIABBCk8E\nQCADIAAgAEHkAG4iBEHkAGxrQf8BcUEBdCICQZGNwABqLQAAOgAPIAMgAkGQjcAAai0AADoADkEB\nIQIFC0EAIAAgBBtFBEAgAkEBayICIANBDWpqIARBAXRB/gFxQZGNwABqLQAAOgAABQsgAUEBQQFB\nACADQQ1qIAJqQQMgAmsQNyADQRBqJAALuwEBA38jAEGgBGsiAyQAIANBCGogASACEOgBIAMoAgwh\nASADKAIIIQIgA0GwAWpBAEGBAfwLACADQeAAaiIEQdCewABBwAD8CgAAIANCADcDqAEgA0IANwOg\nASAEIAIgARBgIANBwAJqIgUgBEHgAfwKAAAgA0EgaiIEIAUQLSADQRRqIgUgBEHAABC1ASACIAEQ\n3wIgAyAFEPkBIAMoAgQhASAAIAMoAgA2AgAgACABNgIEIANBoARqJAALlwEBBX4gACACKQMAIgMg\nASkDAHwiBDcDACAAIAMgBFatIgUgASkDCHwiAyACKQMIfCIGNwMIIAAgAikDECIHIAEpAxB8IgQg\nAyAFVK0gAyAGVq18fCIFNwMQIAAgAikDGCIGIAEpAxh8IgMgBCAHVK0gBCAFVq18fCIENwMYIAAg\nABDTASADIAZUrSADIARWrXynahCeARoLuAEBA38jAEEgayICJAAgAkEUaiABQQFBBEEEEIMBIAIo\nAhghAwJAIAIoAhRBAUcEQCACIAIoAhwiBDYCDCACIAM2AgggAiABNgIQIAAgASADSQR/IAIgAkEI\naiABQQRBBBCQASACKAIAIgFBgYCAgHhHDQIgAigCDCEEIAIoAhAFIAELNgIEIAAgBDYCACACQSBq\nJAAPBQsgAyACKAIcQbiswAAQzwIACyABIAIoAgRByKzAABDPAgALsQEBBH8jAEEQayIGJAACfyAB\nKAIAIgVFBEAgBkEMaiEHQQAMAQULIAYgAzYCDCABKAIEIQggBkEIaiEHIAQgBWwLIQUgByAFNgIA\nAkAgBigCDCIFBEAgBigCCCEHAkAgAkUEQCAIIAcQ3wIMAQULIAggByAFIAIgBGwiBBAfIgNFDQIL\n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\nIgUgAUEwahD6AiADQfABaiIGIAFB4ABqEPoCIAMgAhD6AiADQTBqIAJBMGoQ+gIgA0HgAGogAkHg\nAGoQ+gIgBCAEIAMQPiAAIAQQ+gIgAEEwaiAFEPoCIABB4ABqIAYQ+gIgA0GgAmokAAuQAQEFfiAA\nKQMIIAApAwAgACkDICIBQjCIQtGHgIAQfnwiAkI0iHwiAyAChCAAKQMQIANCNIh8IgSEIAApAxgg\nBEI0iHwiBYRC/////////weDIAFC////////P4MgBUI0iHwiAYRQIAMgAkLQh4CAEIWDIASDIAWD\nIAFCgICAgICAwAeFg0L/////////B1FyC4UBAQV+IAAgACkDACIEIAGtIgJCv/2m/rKu6JbAAH58\nIgU3AwAgACAAKQMIIgYgAkLEv92FlePIqMUAfnwiAyAEIAVWrXwiBDcDCCAAIAApAxAiBSACfCIC\nIAMgBlStIAMgBFatfHwiAzcDECAAIAApAxggAiAFVK0gAiADVq18fDcDGCABC4gBACACIANLBEAj\nAEEwayIAJAAgACADNgIEIAAgAjYCACAAQQI2AgwgAEGEkMAANgIIIABCAjcCFCAAIABBBGqtQoCA\ngIDgAIQ3AyggACAArUKAgICA4ACENwMgIAAgAEEgajYCECAAQQhqIAQQewAFCyAAIAMgAms2AgQg\nACABIAJBAnRqNgIAC5gBAQV+IAEpAwAhBSABKQMIIQIgASkDECEDIAEpAxghBCAAIAEpAyAiBkIo\niDcDICAAIAZCFoZCgICA/v////8/gyAEQh6IhDcDGCAAIARCIIZCgICAgPD///8/gyADQhSIhDcD\nECAAIANCKoZCgICAgICA//8/gyACQgqIhDcDCCAAIAUgAkI0hoRC//////////8/gzcDAAuUAQEF\nfiABKQMIIQIgASkDECEDIAEpAyAhBSABKQMYIQQgACABKQMAIgZC/////////weDNwMAIAAgBUIo\nhiAEQhaIhDcDICAAIARCHoZCgICAgPz//weDIANCIIiENwMYIAAgA0IUhkKAgMD/////B4MgAkIq\niIQ3AxAgACACQgqGQoD4//////8HgyAGQjSIhDcDCAuGAQEDfyMAQSBrIgIkACABQQRqIQNBASEE\nAkAgASgCAEEBRgRAIAMQuQIhAQwBBQsgAkEYaiADQQhqKAIANgIAIAIgAykCADcDECACQQhqIAJB\nEGpB9KTAABC9ASACKAIIIQEgACACKAIMNgIIQQAhBAsgACAENgIAIAAgATYCBCACQSBqJAALbgEG\nfiAAIANC/////w+DIgUgAUL/////D4MiBn4iByAGIANCIIgiBn4iCCAFIAFCIIgiCX58IgVCIIZ8\nIgo3AwAgACAHIApWrSAGIAl+IAUgCFStQiCGIAVCIIiEfHwgASAEfiACIAN+fHw3AwgLpQEBAn8j\nAEGgAWsiBCQAIARBADYCnAEgBEEANgKQASAEQquzj/yRo7Pw2wA3A0ggBEL/pLmIxZHagpt/NwNA\nIARC8ua746On/aelfzcDOCAEQufMp9DW0Ouzu383AzAgBEEwaiIFIAFBIBACIAIgBCAEQZgBakEB\nEMABGiAFIARBIRACIAUgA0EgEAIgBSAEEGkgACAEIARBnAFqEEIgBEGgAWokAAt/AQJ/IwBBEGsi\nBCQAAn8gAygCBCIFQQRPBEAgBUGAAk0EQEEAIAIgBUcNAhogASABIAEgAygCACADQQhqIAIQK0ED\nDAIFCyAEQQhqIAUQ1wIgBCgCCAwBBQsgBCAFENgCIAQoAgALEPUBIAAgAjYCBCAAIAE2AgAgBEEQ\naiQAC14AIAAgASAEfCADQj+JIANCOImFIANCB4iFfCAGQi2JIAZCA4mFIAZCBoiFfDcDACAAIAFC\nP4kgAUI4iYUgAUIHiIUgAnwgBXwgB0ItiSAHQgOJhSAHQgaIhXw3AwgLcQICfwF+IAFBBGohAyAA\nQQRqIQQgADUCACABNQIAfSEFIAJBASACQQFLG0EBayECA38gBUIgiKdBAXEhACACBH8gAkEBayEC\nIAQ1AgAgAzUCACAArXx9IQUgA0EEaiEDIARBBGohBAwBBUEAIABrCwsLeQIBfwJ+IwBBEGsiAyAC\nNgIMIAAgAzQCDCIEQgF9IgUgACkDAINCACAEfSIEIAEpAwCDhDcDACAAIAEpAwggBIMgACkDCCAF\ng4Q3AwggACABKQMQIASDIAApAxAgBYOENwMQIAAgASkDGCAEgyAAKQMYIAWDhDcDGAt3AQJ/IwBB\n0ABrIgMkACAAIAFBKBApIQAgA0EoaiIEIAEQFyADIAEgBBAOIABBADYCUCADQbjwwAAQ3wECf0EA\nIABBKGoiACADECBFDQAaIAAQakEBIAAoAgBBAXEgAkYNABogACAAQQEQzwFBAQsgA0HQAGokAAuW\nAQECfiAAIAApAwAgACkDICICQjCIQtGHgIAQfnwiAUL/////////B4M3AwAgACAAKQMIIAFCNIh8\nIgFC/////////weDNwMIIAAgACkDECABQjSIfCIBQv////////8HgzcDECAAIAApAxggAUI0iHwi\nAUL/////////B4M3AxggACACQv///////z+DIAFCNIh8NwMgC4kBAQJ/IwBBEGsiAiQAIAAQxgIC\nQCAAKAIARQRAIAAoAgQhASAAQQgQzAFB0IEEQdABIAEoAggbIgBBgIDAAHIgACABKAIAGyEAIAEQ\nuQEgAEHx////B08NASABIAAQzAEgAkEQaiQADwULEOsCAAtBjtDAAEErIAJBD2pB7J/AAEH8n8AA\nEK8BAAt3AQJ/IwBBQGoiAyQAIANBEGogABD9ASADKAIUIQAgA0EIaiABIAIQ6AEgA0EcaiADKAII\nIgEgAygCDCICEGYgAy0AHCIEBEAgAygCICADKAIkEOACBQsgASACEN8CIAAgACgCAEEBazYCACAD\nQUBrJAAgBEEBcwuGAQEBfyMAQeABayIDJAAgA0EoakEAQcEA/AsAIANBGGpBsJ7AACkDADcDACAD\nQRBqQaiewAApAwA3AwAgA0EIakGgnsAAKQMANwMAIANCADcDICADQZiewAApAwA3AwAgAyABIAIQ\nYSADQfAAaiIBIANB8AD8CgAAIAAgARAxIANB4AFqJAALbgEEfiACrSEEQQAhAgN/IAMEfyAAIAA1\nAgAgAq0gATUCACAEfiIFQv////8Pg3wiBkL/////D4N8Igc+AgAgBkIgiCAFQiCIfCAHQiCIfKch\nAiAAQQRqIQAgAUEEaiEBIANBAWshAwwBBSACCwsLegEBfyMAQUBqIgUkACAFIAE2AgwgBSAANgII\nIAUgAzYCFCAFIAI2AhAgBUECNgIcIAVB0IzAADYCGCAFQgI3AiQgBSAFQRBqrUKAgICAMIQ3Azgg\nBSAFQQhqrUKAgICAwACENwMwIAUgBUEwajYCICAFQRhqIAQQewALdgECfyMAQeAAayIEJAAgBEEw\naiIFQQBBMPwLACAFIAEQ9AIgBCAFQTD8CgAAIAJBAWshAQNAIAEEQCAEIAQQ9AIgAUEBayEBDAEF\nCwsgBEEwaiIBQQBBMPwLACABIAQgAxD5AiAAIAFBMPwKAAAgBEHgAGokAAt9AQF/IwBBsANrIgUk\n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\nQQRqIAL8CgAAIAUgAWokACAAC0EBAX8jAEEgayIDJAAgA0EANgIQIANBATYCBCADQgQ3AgggAyAB\nNgIcIAMgADYCGCADIANBGGo2AgAgAyACEHsAC0MBAX8jAEEQayICJAAgAiAAQQhqNgIMIAFBuZPA\nAEENQcaTwABBCyAAQQpB0ZPAAEEIIAJBDGpBCxCFASACQRBqJAALQwEBfyMAQRBrIgIkACACIABB\nBGo2AgwgAUHMsMAAQQVB0bDAAEEKIABBGUHbsMAAQREgAkEMakEaEIUBIAJBEGokAAs5AQJ/QQwh\nAQN/IAEEfyABQQFrIQEgACgCACACciECIABBBGohAAwBBSACQQFrIAJBf3NxQR91CwsLPwECfyMA\nQdAAayICJAAgAkEoaiIDIAFBKBApGiADEGogAiADEKABIAJBiPDAABAWIAAgAhChASACQdAAaiQA\nCzgAIAMgASABIANLGyEBA0AgAQRAIAAgAi0AADoAACABQQFrIQEgAkEBaiECIABBAWohAAwBBQsL\nCzsBAn8jAEEwayEDA0AgAkEwRkUEQCACIANqIAEgAmooAgA2AgAgAkEEaiECDAEFCwsgACADQTD8\nCgAACzsBAX8jAEEQayICJAAgARDGAiACQQhqIAEQ7QIgAigCDCEBIAAgAigCCDYCACAAIAE2AgQg\nAkEQaiQACzsBAX8jAEEQayICJAAgARDGAiACQQhqIAEQ7AIgAigCDCEBIAAgAigCCDYCACAAIAE2\nAgQgAkEQaiQAC04AIABBA0cEQAJAAkACQCAAQQFrDgIBAgALQdDDwABBKEHossAAEOwBAAtB0MPA\nAEEoQfiywAAQ7AEAC0HQw8AAQShBiLPAABDsAQAFCws5AAJAIAFpQQFHIABBgICAgHggAWtLcg0A\nIAAEQEHU+MAALQAAGiAAIAEQugIiAUUNAQULIAEPCwALOgEBfyMAQRBrIgMkACADQQhqIAEgAkEA\nEL8BIAMoAgwhASAAIAMoAgg2AgAgACABNgIEIANBEGokAAs5AAJAIAJBgIDEAEYNACAAIAIgASgC\nEBEFAEUNAEEBDwsgA0UEQEEADwULIAAgAyAEIAEoAgwRBwALOwEBfyMAQRBrIgIkACACQQhqIAFB\n9KTAABC9ASACKAIMIQEgACACKAIINgIAIAAgATYCBCACQRBqJAALNQAgACABIAEQzQIgAkEBIAJB\n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\nA0Hst8AAEMQBAAsjACACQQxBCCABQQFxGyIBIAMgASAAIAEQlAIEQBDmAgAFCwskAQF/A0AgAUEo\nRkUEQCAAIAFqQgA3AwAgAUEIaiEBDAEFCwsLIwAgASADSwRAIAEgAyAEEOICAAULIAAgATYCBCAA\nIAI2AgALJgAgAEUEQEGEpcAAQTIQ8gIABQsgACACIAMgBCAFIAEoAhARCwALIgADQCABBEAgAEEA\nOgAAIAFBAWshASAAQQFqIQAMAQULCwsjAQF/A0AgAUEwRwRAIAAgAWpBADYCACABQQRqIQEMAQUL\nCwsiAANAIAEEQCAAQQA6AAAgAEEBaiEAIAFBAWshAQwBBQsLC0kAIABBADYCYCAAQquzj/yRo7Pw\n2wA3AhggAEL/pLmIxZHagpt/NwIQIABC8ua746On/aelfzcCCCAAQufMp9DW0Ouzu383AgALJAAg\nAEUEQEGEpcAAQTIQ8gIABQsgACACIAMgBCABKAIQEQgACyQAIABFBEBBhKXAAEEyEPICAAULIAAg\nAiADIAQgASgCEBEJAAskACAARQRAQYSlwABBMhDyAgAFCyAAIAIgAyAEIAEoAhARHAALJAAgAEUE\nQEGEpcAAQTIQ8gIABQsgACACIAMgBCABKAIQER0ACyQAIABFBEBBhKXAAEEyEPICAAULIAAgAiAD\nIAQgASgCEBEYAAsdAQF/IwBBMGsiASQAIAFBCGogABAgIAFBMGokAAsiACAARQRAQYSlwABBMhDy\nAgAFCyAAIAIgAyABKAIQEQYACx8AIABBADYCeCAAEKICIABBKGoQogIgAEHQAGoQogILHQAgACAB\nELQBIABBKGogAUEgahC0ASAAQQA2AlALHwAgAEEBNgJ4IAAQogIgAEEoahCiAiAAQdAAahCiAgse\nAQF/A38gACABai0AAAR/IAFBAWohAQwBBSABCwsLIAAgAEUEQEGEpcAAQTIQ8gIABQsgACACIAEo\nAhARBQALGgAgACkDGCAAKQMQIAApAwggACkDAISEhFALHABB1PjAAC0AABogACABELoCIgBFBEAA\nBQsgAAsYACAAIAApAyAgAq18NwMgIAAgASACEAYLGAAgACACNgIEIABBAEEDIAFBAXEbNgIACxwB\nAX8gACgCBCIBIAAoAggQACAAKAIAIAEQ4AILFgAgAUEJTwRAIAEgABBHDwULIAAQCAsXACABIANG\nBH8gACACIAEQ5gEFQQELRQscACAAKAIAIAAoAgQQzAIgACgCFCAAKAIYEMwCCxcAIAFFBEBBzLTA\nABD+AgAFCyAAIAFuCxAAIABBAWsgAEF/c3FBH3ULFgAgAEEANgJQIAAQogIgAEEoahCiAgsZACAB\nKAIAQbSTwABBBSABKAIEKAIMEQcACxkBAX8gACgCACIBBEAgACgCBCABEMwBBQsLGQAgASgCAEGo\nocAAQQsgASgCBCgCDBEHAAsZACABKAIAQcy7wABBCyABKAIEKAIMEQcACxkAIAEoAgBBnKjAAEEK\nIAEoAgQoAgwRBwALFAAgACAAIAEQ+gEgACAAIAIQzQILFAAgAARADwULQbzUwABBGxDyAgALEwAg\nASgCBBogAEGUiMAAIAEQOAsUACAAKAIAIAEgACgCBCgCDBEFAAsTACABKAIEGiAAQeCMwAAgARA4\nCw8AIAAgASABIAJqEGdBAAsXACAAKAIAQYCAgIB4RwRAIAAQ4wIFCwsSACABBEAgACABQQJ0EMwB\nBQsLFgAgACABIAJBgNfAAEGg18AAQQgQKwsQACAAIAEgAiADIARBDBArCw8AIAAEQAAFCyACEP0C\nAAsSACAAIAEgAiADQbSLwAAQhAILEgAgACABIAIgA0GYocAAEIQCCxAAIAEoAgAgASgCBCAAEDgL\nEAAgASAAKAIAIAAoAgQQGgsSACAAQYACQfwBQRBB8AEQ6wELEgAgACABIAIgA0Ggm8AAEMEBCxIA\nIABBgAFB/ABBCEH4ABDrAQsQACAAIAE2AgQgAEECNgIACxAAIAAgATYCBCAAQQE2AgALEgAgACAB\nIAIgA0HstcAAEMEBCxIAIABByMbAACABIAIgAxCxAQsSACAAQfjJwAAgASACIAMQsQELFQAgACAB\nIAJBsNfAAEHQ2MAAEM4CCxUAIAAgASACQeDXwABBkNjAABDOAgsRACAAIAEgAkGw18AAQQwQcQsP\nACABBEAgACABEMwBBQsLDQAgACABQQFBARDSAQsQACAAIAEgAkGwj8AAEMgBCxAAIAAgASACQdCP\nwAAQyAELDwAgACgCACAAKAIEEOACCxMAIAAgAUGYpMAAQZCkwAAQ0QELEwAgACABQeSkwABB3KTA\nABDRAQsSAEHQw8AAQShBvMTAABDsAQALDwAgAQRAIAAgARDMAQULCw8AIAAgAUGw18AAQQwQcgsL\nACAAIwBqJAAjAAsLACAAKAIAIAEQUQsOAEHX1MAAQc8AEPICAAsLACAAIAFBCBCYAgsLACAAIAFB\nEBCYAgsMACAAKAIAIAEQ6gILDQAgAEHEksAAIAEQOAsKACAAIAFBARAHCwoAIAAgAUEBEAYLCQAg\nACABEAEACw0AIAFBudDAAEECEBoLCwAgACABIAEQ+QILDgAgAEHkxsAAIAEQiAELDgAgAEGUysAA\nIAEQiAELCwAgACAAIAAQ3QILDAAgACABKQIANwMACwsAIAAgASACENwCCwsAIAAgAUEwEJkCCwsA\nIAAgASABENwCCwsAIAAgAUEgEJkCCwwAIABBwIjAABCFAgsMACAAQfSOwAAQhQILCQAgAEEANgIA\nCwcAIAAoAgALC7VvLgBBgIDAAAuhCS9hcHAvbW9kdWxlcy9lY2FzaC1zZWNwMjU2azEvc3JjL2Vj\nZHNhL3NlcmlhbGl6ZWRfc2lnbmF0dXJlLnJzAABIAAAAYXR0ZW1wdCB0byBzZXQgbGVuZ3RoIHRv\nICBidXQgdGhlIG1heGltdW0gaXMgAAAARAAQABkAAABdABAAFAAAAAAAEAA+AAAAtQAAAAkAAABm\nZmkgcmV0dXJuZWQgaW52YWxpZCBSZWNvdmVyeUlkIQAJEAAyAAAAaQAAAB4AAABhc3NlcnRpb24g\nZmFpbGVkOiBlcnIgPT0gMQAAAAkQADIAAABmAAAADQAAAAAAAAAIAAAABAAAACAAAABJbmNvcnJl\nY3RTaWduYXR1cmVJbnZhbGlkTWVzc2FnZUludmFsaWRQdWJsaWNLZXlJbnZhbGlkU2lnbmF0dXJl\nSW52YWxpZFNlY3JldEtleUludmFsaWRTaGFyZWRTZWNyZXRJbnZhbGlkUmVjb3ZlcnlJZEludmFs\naWRUd2Vha05vdEVub3VnaE1lbW9yeUludmFsaWRQdWJsaWNLZXlTdW1JbnZhbGlkRWxsU3dpZnRt\nb2R1bGVzL2VjYXNoLWxpYi13YXNtL3NyYy9lY2MucnMAALEBEAAhAAAAAAEAABsAAABJbnZhbGlk\nIHJlY292ZXJ5IElEOiAAAADkARAAFQAAAEludmFsaWQgc2lnbmF0dXJlIGZvcm1hdEludmFsaWQg\nbXNnIGxlbmd0aCAAHAIQABMAAABTaWduYXR1cmUgcmVjb3ZlcnkgZmFpbGVkSW52YWxpZCBzZWNy\nZXQga2V5IHNpemUsIGV4cGVjdGVkIDMyIGJ5dGVzIGJ1dCBnb3QgUQIQADMAAABTZWNyZXQga2V5\nIG5vdCB2YWxpZCBmb3Igc2VjcDI1NmsxSW52YWxpZCBwdWJsaWMga2V5IHNpemUsIGV4cGVjdGVk\nIDMzIGJ5dGVzIGJ1dCBnb3QgAAAArgIQADMAAABQdWJrZXkga2V5IG5vdCB2YWxpZCBmb3Igc2Vj\ncDI1NmsxSW52YWxpZCBzY2FsYXIgc2l6ZSwgZXhwZWN0ZWQgMzIgYnl0ZXMgYnV0IGdvdCAAAAAO\nAxAALwAAAFNjYWxhciBub3QgdmFsaWQgZm9yIHNlY3AyNTZrMUludmFsaWQgbWVzc2FnZSBzaXpl\nLCBleHBlY3RlZCAzMiBieXRlcyBidXQgZ290IAAAZgMQADAAAABJbnZhbGlkIERFUiBzaWduYXR1\ncmUgZm9ybWF0SW52YWxpZCBTY2hub3JyIHNpZ25hdHVyZSBzaXplLCBleHBlY3RlZCA2NCBieXRl\ncyBidXQgZ290IAAAvAMQADoAAABJbmNvcnJlY3Qgc2lnbmF0dXJlACEAAAAMAAAABAAAACIAAAAj\nAAAAJAAAAGNhcGFjaXR5IG92ZXJmbG93AAAALAQQABEAAABsaWJyYXJ5L2FsbG9jL3NyYy9yYXdf\ndmVjL21vZC5yc0gEEAAgAAAALgIAABEAAABsaWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAeAQQ\nABsAAADoAQAAFwBBrInAAAutCQEAAAAlAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbWVudGF0\naW9uIHJldHVybmVkIGFuIGVycm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRpZCBub3Rs\naWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAAAoFEAAYAAAAigIAAA4AAAB4BBAAGwAAAH0FAAAbAAAA\nKVtjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlaW5kZXggb3V0IG9m\nIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAAcQUQACAAAACRBRAAEgAAAAAA\nAAAEAAAABAAAACYAAAA9PWFzc2VydGlvbiBgbGVmdCAgcmlnaHRgIGZhaWxlZAogIGxlZnQ6IAog\ncmlnaHQ6IAAAxgUQABAAAADWBRAAFwAAAO0FEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6\nIAAAAMYFEAAQAAAAEAYQABAAAAAgBhAACQAAAO0FEAAJAAAAOiAAAAEAAAAAAAAATAYQAAIAAAAA\nAAAADAAAAAQAAAAnAAAAKAAAACkAAAAgICAgIHsgLCAgewosCn0gfSgoCgpdMHgwMDAxMDIwMzA0\nMDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIz\nMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYx\nNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5\nMDkxOTI5Mzk0OTU5Njk3OTg5OWF0dGVtcHQgdG8gZGl2aWRlIGJ5IHplcm8AAABYBxAAGQAAAHJh\nbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCB8BxAAEgAA\nAI4HEAAiAAAAcmFuZ2UgZW5kIGluZGV4IMAHEAAQAAAAjgcQACIAAABzbGljZSBpbmRleCBzdGFy\ndHMgYXQgIGJ1dCBlbmRzIGF0IADgBxAAFgAAAPYHEAANAAAAY29weV9mcm9tX3NsaWNlOiBzb3Vy\nY2Ugc2xpY2UgbGVuZ3RoICgpIGRvZXMgbm90IG1hdGNoIGRlc3RpbmF0aW9uIHNsaWNlIGxlbmd0\naCAoAAAAFAgQACYAAAA6CBAAKwAAAEQFEAABAAAAL2FwcC9tb2R1bGVzL2VjYXNoLXNlY3AyNTZr\nMS9zcmMvc2Nobm9ycmFiYy5ycwAAgAgQAC4AAAAaAAAADQAAAC9hcHAvbW9kdWxlcy9lY2FzaC1z\nZWNwMjU2azEvc3JjL2VjZHNhL21vZC5ycwAAAMAIEAAtAAAAAwEAAA0AAAAvYXBwL21vZHVsZXMv\nZWNhc2gtc2VjcDI1NmsxL3NyYy9lY2RzYS9yZWNvdmVyeS5ycwAAAAkQADIAAACnAAAADQAAACoA\nAAAMAAAABAAAACsAAAAsAAAALQBB5JLAAAvNBgEAAAAuAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0\naW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQCcKBAASwAAANEKAAAOAAAARXJyb3JS\nc2FQYXJhbWV0ZXJzcGFkZGluZ19hbGdtaW5fYml0czEuMy4xMzIuMC4zMzEuMi44NDAuMTAwNDUu\nMy4xLjcxLjMuMTMyLjAuMzQxLjMuMTMyLjAuMzVhbnNpcDUyMXIxYW5zaXAyMjRyMTEuMi44NDAu\nMTAwNDAuNC4xMS4yLjg0MC4xMDA0MC40LjIxLjIuODQwLjEwMDQwLjQuMzEuMi44NDAuMTEzNTQ5\nLjEuMS4xMS4yLjg0MC4xMTM1NDkuMS4xLjIxLjIuODQwLjExMzU0OS4xLjEuMzEuMi44NDAuMTEz\nNTQ5LjEuMS40MS4yLjg0MC4xMTM1NDkuMS4xLjUxLjIuODQwLjExMzU0OS4xLjEuMTExLjIuODQw\nLjExMzU0OS4xLjEuMTIxLjIuODQwLjExMzU0OS4xLjEuMTMxLjIuODQwLjExMzU0OS4xLjEuMTQy\nLjE2Ljg0MC4xLjEwMS4zLjQuMi44Mi4xNi44NDAuMS4xMDEuMy40LjIuOTIuMTYuODQwLjEuMTAx\nLjMuNC4yLjEwMS4yLjg0MC4xMDA0NS4yLjExLjIuODQwLjEwMDQ1LjQuMTEuMi44NDAuMTAwNDUu\nNC4zLjExLjIuODQwLjEwMDQ1LjQuMy4yMS4yLjg0MC4xMDA0NS40LjMuMzEuMi44NDAuMTAwNDUu\nNC4zLjRlY2RzYVdpdGhTSEE1MTIAAAAAABAAAAAEAAAALwAAADAAAABlY2RzYVdpdGhTSEEyMjRl\nY2RzYVdpdGhTSEExZWNQdWJsaWNLZXlzaGEzLTUxMnNoYTMtMzg0c2hhMy0yNTZzaGEyMjRXaXRo\nUlNBRW5jcnlwdGlvbgAAAAAAAAwAAAAEAAAAMQAAADIAAABtZDVXaXRoUlNBRW5jcnlwdGlvbm1k\nNFdpdGhSU0FFbmNyeXB0aW9ubWQyV2l0aFJTQUVuY3J5cHRpb25yc2FFbmNyeXB0aW9uZHNhV2l0\naFNoYTFkc2FNYXRjaGRzYQAEAEG8mcAAC4kFSW5zZWN1cmUgYWxnb3JpdGhtOiC8DBAAFAAAAEFs\nZ29yaXRobSBub3Qgc3VwcG9ydGVkOiAAAADYDBAAGQAAAE1pc3NpbmcgcGFyYW1zIGZvciBFQ1Vu\na25vd24gYWxnb3JpdGhtSW52YWxpZCBzaWduYXR1cmUgb3IgcHVibGljIGtleS91c3IvbG9jYWwv\nY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2Jsb2Nr\nLWJ1ZmZlci0wLjEwLjQvc3JjL2xpYi5ycwAAQQ0QAF0AAACiAAAAJwAAAEENEABdAAAApAAAABgA\nAABBDRAAXQAAAKQAAAAgAAAAQQ0QAF0AAACuAAAAFAAAAEENEABdAAAArgAAABoAAABBDRAAXQAA\nAJ0AAAAYAAAAQQ0QAF0AAACdAAAAHwAAAEENEABdAAAAnQAAACUAAABBDRAAXQAAAC0BAAAiAAAA\nASNFZ4mrze/+3LqYdlQyEPDh0sMvdXNyL2xvY2FsL2NhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5j\ncmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9yaXBlbWQtMC4xLjMvc3JjL2xpYi5ycwAARA4QAFYA\nAACgAAAAAQAAAC91c3IvbG9jYWwvY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0x\nOTQ5Y2Y4YzZiNWI1NTdmL3NoYTItMC4xMC45L3NyYy9jb3JlX2FwaS5ycwAArA4QAFoAAABCAAAA\nEwAAAGfmCWqFrme7cvNuPDr1T6V/Ug5RjGgFm6vZgx8ZzeBbrA4QAFoAAACMAAAAEwBB0J7AAAuZ\nAQjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMf\neSF+ExnN4FsvcnVzdGMvMTcwNjdlOWFjNmQ3ZWNiNzBlNTBmOTJjMTk0NGU1NDUxODhkMjM1OS9s\naWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAkA8QAEoAAAC+AQAAHQBB9J/AAAsqAQAAADMAAAAw\nEBAAJgAAALsAAABAAAAASW52YWxpZFBhcml0eVZhbHVlAEGooMAAC4UGAQAAADMAAABtb2R1bGVz\nL2VjYXNoLXNlY3AyNTZrMS9zcmMvY29udGV4dC5ycwAAMBAQACYAAADeAAAAQAAAAP//////////\n//////////66rtzmr0igO7/SXozQNkFAAAAAAAAAAAABAAAAMwAAAAAAAAAEAAAABAAAAAIAAABM\nYXlvdXRFcnJvcgAEAAAAbW9kdWxlcy9lY2FzaC1zZWNwMjU2azEvZWNhc2gtc2VjcDI1NmsxLXN5\ncy9zcmMvdHlwZXMucnO4EBAAOAAAAFcAAAAJAAAAuBAQADgAAABYAAAACQAAALgQEAA4AAAAWgAA\nAAkAAAC4EBAAOAAAAFsAAAAJAAAAuBAQADgAAABdAAAACQAAALgQEAA4AAAAXgAAAAkAAAABAAAA\nuBAQADgAAABgAAAACQAAALgQEAA4AAAAYQAAAAkAAAC4EBAAOAAAAGMAAAAJAAAAuBAQADgAAABk\nAAAACQAAAG1vZHVsZXMvZWNhc2gtc2VjcDI1NmsxL2VjYXNoLXNlY3AyNTZrMS1zeXMvc3JjL2xp\nYi5ycwAAlBEQADYAAAChAwAAQgAAAJQREAA2AAAAygMAAEIAAABbbGlic2VjcDI1NmsxXSBpbGxl\nZ2FsIGFyZ3VtZW50LiAAAADsERAAIQAAAJQREAA2AAAA8gMAAAUAAABbbGlic2VjcDI1NmsxXSBp\nbnRlcm5hbCBjb25zaXN0ZW5jeSBjaGVjayBmYWlsZWQgAAAAKBIQADEAAACUERAANgAAABQEAAAF\nAAAApioQAGgAAAAZAQAAEgAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBi\nZWluZyBkcm9wcGVkL3Vzci9sb2NhbC9jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlv\nLTE5NDljZjhjNmI1YjU1N2YvcmluZy0wLjE3LjE0L3NyYy9saW1iLnJzAAAAthIQAFcAAACHAAAA\nGQAAALYSEABXAAAA4wAAAAUAQbimwAAL3QwBAAAANAAAAC91c3IvbG9jYWwvY2FyZ28vcmVnaXN0\ncnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3JpbmctMC4xNy4xNC9zcmMv\nZWMvc3VpdGVfYi9lY2RzYS9kaWdlc3Rfc2NhbGFyLnJzAAAAQBMQAHEAAABBAAAACgAAADAhMAkG\nBSsOAwIaBQAEFDAxMA0GCWCGSAFlAwQCAQUABCAwQTANBglghkgBZQMEAgIFAAQwMFEwDQYJYIZI\nAWUDBAIDBQAEQAAAAAAAAAAAAQAAADUAAABFbmRPZklucHV0L3Vzci9sb2NhbC9jYXJnby9yZWdp\nc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvdW50cnVzdGVkLTAuOS4w\nL3NyYy9yZWFkZXIucnMAACYUEABcAAAAaQAAACIAAAAvdXNyL2xvY2FsL2NhcmdvL3JlZ2lzdHJ5\nL3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9yaW5nLTAuMTcuMTQvc3JjL3Jz\nYS9wYWRkaW5nL3BrY3MxLnJzlBQQAGQAAAA9AAAAKQAAAGFzc2VydGlvbiBmYWlsZWQ6IGVtLmxl\nbigpID49IGRpZ2VzdF9sZW4gKyAxMQAAAJQUEABkAAAAUQAAAAUAAACUFBAAZAAAAFMAAAAFAAAA\nlBQQAGQAAABUAAAABQAAAJQUEABkAAAAWAAAAAUAAACUFBAAZAAAAFoAAAApAAAAlBQQAGQAAABa\nAAAAOQAAAJQUEABkAAAAWwAAABMAAACUFBAAZAAAAFwAAAAQAAAAlBQQAGQAAABWAAAACQAAAC91\nc3IvbG9jYWwvY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1\nNTdmL3JpbmctMC4xNy4xNC9zcmMvYXJpdGhtZXRpYy9iaWdpbnQvYm94ZWRfbGltYnMucnPIFRAA\ncAAAAEkAAAAUAAAAyBUQAHAAAABJAAAAIQAAAJgvikKRRDdxz/vAtaXbtelbwlY58RHxWaSCP5LV\nXhyrmKoH2AFbgxK+hTEkw30MVXRdvnL+sd6Apwbcm3Txm8HBaZvkhke+78adwQ/MoQwkbyzpLaqE\ndErcqbBc2oj5dlJRPphtxjGoyCcDsMd/Wb/zC+DGR5Gn1VFjygZnKSkUhQq3JzghGy78bSxNEw04\nU1RzCmW7Cmp2LsnCgYUscpKh6L+iS2YaqHCLS8KjUWzHGeiS0SQGmdaFNQ70cKBqEBbBpBkIbDce\nTHdIJ7W8sDSzDBw5SqrYTk/KnFvzby5o7oKPdG9jpXgUeMiECALHjPr/vpDrbFCk96P5vvJ4ccYA\nAAAAAAAAAAEAAAA2AAAAVHJ5RnJvbUludEVycm9yL3Vzci9sb2NhbC9jYXJnby9yZWdpc3RyeS9z\ncmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcmluZy0wLjE3LjE0L3NyYy9yc2Ev\ncHVibGljX2tleS5yc3cXEABhAAAAuAAAAFgAAAB3FxAAYQAAAN8AAAAXAAAAdxcQAGEAAADhAAAA\nHgAAAGFzc2VydGlvbiBmYWlsZWQ6IHBhZGRpbmcuaXRlcigpLmFsbCh8JmJ8IGIgPT0gMCkAAAB3\nFxAAYQAAAOIAAAAFAAAAUEtDUzFkaWdlc3RfYWxnZGlnZXN0aW5mb19wcmVmaXjIGRAAxBMQAA8A\nAAAAAAAADAAAAAQAAAA3AAAAOAAAADkAAABsGBAAeBgQAAAIAABYJhAA0xMQABMAAACcGBAAeBgQ\nAAAIAADwJhAA5hMQABMAAAC0GBAAeBgQAAAIAAAAHBAA+RMQABMAAADMGBAAeBgQAAAIAAAvdXNy\nL2xvY2FsL2NhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3\nZi9yaW5nLTAuMTcuMTQvc3JjL2FyaXRobWV0aWMvYmlnaW50LnJz5BgQAGQAAABdAAAAEwAAAOQY\nEABkAAAANAMAAAUAAADkGBAAZAAAADsDAAArAAAA5BgQAGQAAAA8AwAAKAAAAOQYEABkAAAAPQMA\nACcAQaCzwAALQAEAAAA0AAAAkBsQAFkAAAAVAQAAFQAAAJAbEABZAAAAJgEAAAoAAAABAAAAASNF\nZ4mrze/+3LqYdlQyEPDh0sMAQZC0wAAL6QM6AAAAFAAAAAAUQAAAAAAAQml0TGVuZ3RoU0hBMVNI\nQTI1NlNIQTM4NFNIQTUxMlNIQTUxMl8yNTYAAAA7KBAATgAAACMIAAARAAAAbWlkID4gbGVuAAAA\nXBoQAAkAAAA7KBAATgAAAKwGAAAVAAAAL3Vzci9sb2NhbC9jYXJnby9yZWdpc3RyeS9zcmMvaW5k\nZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcmluZy0wLjE3LjE0L3NyYy9wb2x5ZmlsbC9z\nbGljZS9hc19jaHVua3MucnMAgBoQAGsAAAAWAAAALAAAAC91c3IvbG9jYWwvY2FyZ28vcmVnaXN0\ncnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3JpbmctMC4xNy4xNC9zcmMv\nZGlnZXN0L2R5bnN0YXRlLnJzAAD8GhAAYgAAADkAAAANAAAA/BoQAGIAAABKAAAADQAAAPwaEABi\nAAAAWwAAAA0AAAAvdXNyL2xvY2FsL2NhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8t\nMTk0OWNmOGM2YjViNTU3Zi9yaW5nLTAuMTcuMTQvc3JjL2RpZ2VzdC5ycwAAAJAbEABZAAAAGAIA\nAA8AQYi4wAALSwjJvPNn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgF\nm2u9Qfur2YMfeSF+ExnN4Fs7AAAAQAAAAANAgABB4LjAAAuADAEAAAA0AAAAL3Vzci9sb2NhbC9j\nYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcmluZy0w\nLjE3LjE0L3NyYy9hcml0aG1ldGljL21vbnRnb21lcnkucnNoHBAAaAAAABgBAAAGAAAAaBwQAGgA\nAAAlAQAABgAAAGgcEABoAAAAKAEAACYAAABoHBAAaAAAACcBAAAJAAAAYXNzZXJ0aW9uIGZhaWxl\nZDogbWluX2JpdHMgPj0gTUlOX0JJVFMvdXNyL2xvY2FsL2NhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRl\neC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9yaW5nLTAuMTcuMTQvc3JjL3JzYS9wdWJsaWNf\nbW9kdWx1cy5ycwA2HRAAZQAAAD4AAAAJAAAANh0QAGUAAABBAAAADgAAAGgcEABoAAAA6wAAAB8A\nAABVbnNwZWNpZmllZAAirijXmC+KQs1l7yORRDdxLztN7M/7wLW824mBpdu16Ti1SPNbwlY5GdAF\ntvER8VmbTxmvpII/khiBbdrVXhyrQgIDo5iqB9i+b3BFAVuDEoyy5E6+hTEk4rT/1cN9DFVviXvy\ndF2+crGWFjv+sd6ANRLHJacG3JuUJmnPdPGbwdJK8Z7BaZvk4yVPOIZHvu+11YyLxp3BD2WcrHfM\noQwkdQIrWW8s6S2D5KZuqoR0StT7Qb3cqbBctVMRg9qI+Xar32buUlE+mBAytC1txjGoPyH7mMgn\nA7DkDu++x39Zv8KPqD3zC+DGJacKk0eRp9VvggPgUWPKBnBuDgpnKSkU/C/SRoUKtycmySZcOCEb\nLu0qxFr8bSxN37OVnRMNOFPeY6+LVHMKZaiydzy7Cmp25q7tRy7JwoE7NYIUhSxykmQD8Uyh6L+i\nATBCvEtmGqiRl/jQcItLwjC+VAajUWzHGFLv1hnoktEQqWVVJAaZ1iogcVeFNQ70uNG7MnCgahDI\n0NK4FsGkGVOrQVEIbDcemeuO30x3SCeoSJvhtbywNGNaycWzDBw5y4pB40qq2E5z42N3T8qcW6O4\nstbzby5o/LLvXe6Cj3RgLxdDb2OleHKr8KEUeMiE7DlkGggCx4woHmMj+v++kOm9gt7rbFCkFXnG\nsvej+b4rU3Lj8nhxxpxhJurOPifKB8LAIce4htEe6+DN1n3a6njRbu5/T331um8Xcqpn8AammMii\nxX1jCq4N+b4EmD8RG0ccEzULcRuEfQQj9XfbKJMkx0B7q8oyvL7JFQq+njxMDRCcxGcdQ7ZCPsu+\n1MVMKn5l/Jwpf1ns+tY6q2/LXxdYR0qMGURsTCIQAJwjEAAvdXNyL2xvY2FsL2NhcmdvL3JlZ2lz\ndHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9yaW5nLTAuMTcuMTQvc3Jj\nL2FyaXRobWV0aWMvYmlnaW50L21vZHVsdXMucnNgIBAAbAAAAFwAAAAuAAAAYCAQAGwAAABiAAAA\nJgAAAGAgEABsAAAAkwAAAAkAAABgIBAAbAAAAKQAAAAdAAAAL3Vzci9sb2NhbC9jYXJnby9yZWdp\nc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcmluZy0wLjE3LjE0L3Ny\nYy9lYy9zdWl0ZV9iL29wcy5ycwAAAAwhEABhAAAABgEAADQAAAAMIRAAYQAAAAYBAAAeAAAADCEQ\nAGEAAAANAQAANAAAAAwhEABhAAAADQEAAB4AAAAMIRAAYQAAABQBAAA0AAAADCEQAGEAAAAUAQAA\nHgAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGVhc3NlcnRpb24gZmFp\nbGVkOiAhc2VsZi5zY2FsYXJfb3BzLmNvbW1vbi5pc196ZXJvKGEpDCEQAGEAAADYAQAACQAAAAwh\nEABhAAAAYQIAAAUAAAA8AAAAPQAAAP///////////////wBB7MTAAAsIAQAAAP////8AQYTFwAAL\nHQMAAAAAAAAA//////v////+//////////3///8EAEG0xcAACyBRJWP8wsq584SeF6et+ua8////\n//////8AAAAA/////wBB5MXAAAsN/P//////////////AwBB/MXAAAsIBAAAAPz///8AQZTGwAAL\nIN+9xCli35zYkDCEeM0F8KzWLiH3qyCi5TRIhwQdBjDcAEHIxsAAC0RMIhAAPgAAAD8AAABAAAAA\nQQAAAEwiEABCAAAAXCMQAEMAAACi7nm+lUwkg6ZvvUmceZlGWexrKzmyRSggVtnzlC3hZgBBnMfA\nAAtZHAAAAB0AAAD/////AAAAAAAAAAD//////v//////////////////////////////////////\n//8BAAAA/v///wAAAAACAAAAAAAAAP7///8AAAAAAgAAAAEAQYTIwAALsARzKcXMahns7HqnsEiy\nDRpY3y039IFNY8f////////////////////////////////8////AwAAAAAAAAD8////+///////\n///////////////////////////////////MLUGdcYgRCOwyTHrYrSn3LgIgGZsg8nfiipOU7ks3\n45QgAh/0ISu2+b9PYEsRCM0BAAAAKLXASWZ10D04ztag4njjIG5NG1T8OpyH/w6jWYSGVGQr3k5h\nI/cvgRMVninCrTpN/qQDS609BCOsqbR7v6i/oVCwgy5W562L2f/0aBlSw8ZAqGk5JgKA3enFFVrC\nq3grnCMQAEQAAABFAAAARgAAAEcAAACcIxAASAAAAAwlEABJAAAAqQm0GSSbMS0ZpBrf5YE9/0cp\nuPw6SD68xRyrShdJDdSVaCYoeluwPyG/OSsB7oQML3Vzci9sb2NhbC9jYXJnby9yZWdpc3RyeS9z\ncmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcmluZy0wLjE3LjE0L3NyYy9lYy9z\ndWl0ZV9iL29wcy9wMzg0LnJzAABMJRAAZgAAAAgBAAA8AAAAAgEGAwMBBQEFBAQFCgcDAgUABAUE\nBAUGBAYEBwUFCgYJBgQFBgQDAAcFBwIFAwUHBQUEBQUDAwEHAQYFBAIDAQQBBAEGAgUCBQICAQQA\nAABcIxAAWCAQAEoAAABLAAAArtqcAz01Rgx7YehYUwUZQwBB2MzAAAskAQAAAGfmCWqFrme7cvNu\nPDr1T6V/Ug5RjGgFm6vZgx8ZzeBbAEGgzcAACzhMAAAAIAAAAAEgQAAAAAAADCUQAFwgEABNAAAA\nTgAAAIzWOjOW5hMThVhPt0zy5acf0sgLfrKcOABB+M3AAAv/CNieBcFdnbvLB9V8NiopmmIX3XAw\nWgFZkTlZDvfY7C8VMQvA/2cmM2cRFVhoh0q0jqeP+WQNLgzbpE/6vh1ItUc7AAAAQAAAAAIwgAAA\nAAAAFCYQAFgmEABPAAAAAAAAABQmEADwJhAATwAAAAIAAACwJhAAWCYQAE8AAAADAAAAsCYQAPAm\nEABPAAAABAAAAEVDRFNBX1AyNTZfU0hBMjU2X0FTTjFFQ0RTQV9QMjU2X1NIQTI1Nl9GSVhFREVD\nRFNBX1AyNTZfU0hBMzg0X0FTTjFFQ0RTQV9QMzg0X1NIQTI1Nl9BU04xRUNEU0FfUDM4NF9TSEEz\nODRfQVNOMUVDRFNBX1AzODRfU0hBMzg0X0ZJWEVEY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBv\nbiBhbiBgRXJyYCB2YWx1ZSgpL3J1c3RjLzE3MDY3ZTlhYzZkN2VjYjcwZTUwZjkyYzE5NDRlNTQ1\nMTg4ZDIzNTkvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pdGVyLnJzAAAAOygQAE4AAACDBwAAEQAA\nAC9ydXN0Yy8xNzA2N2U5YWM2ZDdlY2I3MGU1MGY5MmMxOTQ0ZTU0NTE4OGQyMzU5L2xpYnJhcnkv\nYWxsb2Mvc3JjL3N0cmluZy5ycwCcKBAASwAAAH0FAAAbAAAA3CkQAFAAAAAuAgAAEQAAAC9ydXN0\nL2RlcHMvZGxtYWxsb2MtMC4yLjcvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNp\nemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZAAIKRAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxl\nZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAACCkQACkAAACuBAAADQAAAFRyaWVkIHRv\nIHNocmluayB0byBhIGxhcmdlciBjYXBhY2l0ebApEAAkAAAAL3J1c3RjLzE3MDY3ZTlhYzZkN2Vj\nYjcwZTUwZjkyYzE5NDRlNTQ1MTg4ZDIzNTkvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy9tb2Qu\ncnPcKRAAUAAAALkCAAAJAAAAbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVz\nZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNp\nbmcgaW4gcnVzdC91c3IvbG9jYWwvY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0x\nOTQ5Y2Y4YzZiNWI1NTdmL3dhc20tYmluZGdlbi0wLjIuOTIvc3JjL2NvbnZlcnQvc2xpY2VzLnJz\nAACmKhAAaAAAAN4AAAABAAAABAAAAAYAAAAGAAAABgAAAAoAAAApGhAALRoQADMaEAA5GhAAPxoQ\nABYAAAAXAAAAFgAAABYAAAAWAAAAFwAAAIgnEACeJxAAtScQAMsnEADhJxAA9ycQAEGA18AAC5gB\nUSVj/MLKufOEnhenrfrmvP//////////AAAAAP////9PvADuqsjRzAAAAAAAAAAA/////wAAAAAA\nAAAA//////7/////////////////////////////////////////cynFzGoZ7Ox6p7BIsg0aWN8t\nN/SBTWPH////////////////////////////////RdyP6Ilg1G4AQaPYwAALMoAAAAAAAAAAgP//\n/3//////////////////////////////////////////fwEAAAABAEHg2MAACxEBAAAA////////\n//8AAAAAAQBBkNnAAAsBAQBBnNnAAAueD/////////////////7///8AAAAAPBSpGNQw53kBtu1f\n/JW6dRAlYncrc/t5xlU3pXZfkBgKVpXOV1Py3VzkGbrkuEqLJfMh3YiG6NKFXYglGP9xhbvSoBbF\nL5JPmTRiGmzBXA2LLMZXOs9Bkn9mG/1haV4vlxeg9QvHFVySYZVgTbQgPVLbHwc3G5EEew9vjRb5\nSPa8uzfhR2hWnuwLaoqeRjTkYzTXeWEnxLEVAD0ThQK+Wqt9TMB8g6qSBwwmQ0yfPVc3zOZ4YhWT\nDINzb2tbcruUJQniv0TCqGJn6NyPw5rBkWNwON3VpZZa9iTTIdSH1WHqc3GjonN26GWLd1MIgIQj\nPrS6BR5E+BC+7yFGEv4R+v2fsSwrH4kcIzySsVuNugGOysWKZz3Qtty+Ex9MsG5YCe3oJ+XGNQzi\n7RkYPKOBHvpSxlbA1o8nEU+GcAis1RnVM7XSNHdXYsDdvaH2ijtnk8Kep5p8flexZrLDUeZtu7NZ\nUrY6MOnngHQ60NOvoNYn/Dyb0YOsxZu5GF2aYbRgHKrlGuE4ar1YNudJK2W3uO2HX+4UABMLzf/r\nrrInD51VCnN6MUaSyjrIu90vW5WccZoBrODfwQeNxG41bVZKJGqx+PQOQfhWaiZ7xP4aJJfBh5xt\njmtAChurQs0CPj+AaezbBKgJA39f0Lo794U7qH8Zjq1zcgnGwa1nUA5El8A0q3nD8lZqhNH4HYSL\nBu6o72hsF1lEMSAwH1+R1TKv8VC9dV0xdcOZvGcv97r/fIM/ctdIGKQTBosc1OIw8dAjK1q+1SXi\nk+3G8zRZg5nnb/xvYiImCRRDaiGQedm0u1A+xn7lxpGBN7LNHRhALEJl9uA2ApsJqEHDSf4BGAEQ\nK5MVOZvFtWj8/HCCWaL1hcO73JrRqvNEcQyu+4OZiVXd9C+4dI6LuJPJNOdxQDzg0ioywEOvnnqa\nQWCdFFHF5Ob+IeyA/kvhX4K+VcJqEc72Z11KLwdavJivY37bSHHS+rMFqymstsCQ5holTjyoqTd9\n3qrCdch9CoQaDp/jfTh31w1spUnMnh50bAhG2PzPpc6uBfUIFHqPfsTwvsCFe7OPag7M5LaWNSOP\nOGu/S239Tu+cw/pTpKvVKPb5yFoTnL74yJWUchwKv2LzO4DEYSms1GPfA4RBngDp7JHL+QnBBVeU\nWNCV0MLAhevdlj0IuZtEQHqNK2mE4R7uLk80w5t0MJFCVuNaDbFCpUgnG0lVKnMQs2WmnEbBTBpf\nUh1ZKT+YT7hrW2/n4YRfn0Hvfr6JobqAltQAEiwz7xgfVXZjmlFHQQKGKCDwcrMmrB6Y0MjrhafK\np9Sp6Vjf2w3FU9mPD1n9zGFjnRfJ5kRrYulyz2TrIhBh2X/ziLKefrs+hjQ95rAx7udPq0/lqXIF\nYPSktefVNDNJwDFI1QaS+4mFOlWDZcz1cKrlSVbiSgl5CFJGBBAHRZDMTxxUAm1psOuZ2ok7wKC6\nqyJAKLie1/Km6AUcuGJ4hCdjTeUFWUt6M0p59yENUGc8YX9tfbcFcCDo1s8EgTdaCtb7wvTV4GUN\nz0k1bQ/lM9ReZs36b2kzb7T8Ec6s/VtpYJh8r1LiDoEsu1lx4Q9FZXs1i3W+vt/3cuqf1nR+BStF\nF3OSenGF1Gl2P+i7aR/Oa32HcoKu+AmNJ0QyVK5IlZzBwuPeVXcgRRnvb9lhvYfDKC2x7zyBGKpk\n33LW0byfDbBUceVe3EhUMZr0nkYP75ouK26VpYU+nEqSqh7sqkUZR56gyN8Sqh2f9k0ncvImc17/\noizI5OBE3am3c87YuQGpjORzbgNs8FNxpOEh5OHJGASSeTtsuHJ2XXCHzr2Td5q3ypPnWvIMnYZt\no5QxH2TChkmCyFWdXpRuCaNe+0k+CtsTU+a4OUqz0DXAe0Hjp8Ang2s4C0TRYgOsLSa3j0P5zeBM\nEUEssaCVrfHOpStiQ9VnqDebwMmG5AHSzdYml5L/Qr96RyDSZwq8QRsSD4okTUQKdtRiN0ebZR1P\nBA6otAslZeP9CIfyi4Taw+6sbp0204IhpsKClESS3N+CNddsXVbSL34va4eKF7UiAQq0BFEI/5b/\nUXaf8hSrMQsF5tSHX4uyq4QKeXCCn0Pt1Wv044WdtWwtEiIebBtc9XVAVmUXZ29D5W1Z65rMXpbC\ntJI8AucD6gFhOQEutrQER2ejXpA//agMYSsbVUI6UpIGzQ85nKi3Hj6mkgO+0vHnMwzbTWSi3JZI\nmDMVDiEcI42Md3DoKHrocOFWaWHmHZ0LnLArOMnDSn2YmGlRBb4Z1vQJrsR2I4s9kz8aZbfgHfQF\nl+PHlA04HcMxjEuVhTYMGvJbAD1TaMmex3VuYtcLVJ3GQkd1F8qy29L2/9puzBidShe9jA396HhF\nqpOHXofmLKucE6d2qduhPrQRqzfOktJZUqnxfwqG8YSPIQIbhROt+t7qKyKnRJEKK+x4rKLFWfry\nUUACWjjOR2Gl7NGRkMYqvCPVlL4PGux5/a6NLZecs8791rw7lRr2WPxfV/UgtPetxIbZ27ee8xUU\niKqBbJeNufX84m59cS/PXUdlVNC7YGjE0ySOBAQEBAQEAQEEBABB8OnAAAsJUQAAAAAAAABSAEGI\n6sAAC80DUQAAAAAAAABJbnZhbGlkIGZsYWdzAGN0eCAhPSBzZWNwMjU2azFfY29udGV4dF9ub19w\ncmVjb21wAHNlbGYgdGVzdCBmYWlsZWQARm9yIHRoaXMgc2FtcGxlLCB0aGlzIDYzLWJ5dGUgc3Ry\naW5nIHdpbGwgYmUgdXNlZCBhcyBpbnB1dCBkYXRhAChmbGFncyAmIFNFQ1AyNTZLMV9GTEFHU19U\nWVBFX01BU0spID09IFNFQ1AyNTZLMV9GTEFHU19UWVBFX0NPTVBSRVNTSU9OAHJlY2lkID49IDAg\nJiYgcmVjaWQgPD0gMwBzZWNwMjU2azFfZWNtdWx0X2NvbnRleHRfaXNfYnVpbHQoJmN0eC0+ZWNt\ndWx0X2N0eCkAc2VjcDI1NmsxX2VjbXVsdF9nZW5fY29udGV4dF9pc19idWlsdCgmY3R4LT5lY211\nbHRfZ2VuX2N0eCkAIXNlY3AyNTZrMV9mZV9pc196ZXJvKCZnZS0+eCkAKm91dHB1dGxlbiA+PSAo\nKGZsYWdzICYgU0VDUDI1NksxX0ZMQUdTX0JJVF9DT01QUkVTU0lPTikgPyAzM3UgOiA2NXUpAFIA\nAAAAAAAAUAAAAFAAQeDtwAALEEVDRFNBK0RFUiAgICAgICAAQZjuwAALAQEAQcDuwAALEEVDRFNB\nK1JlY292ZXJ5ICAAQeDuwAALbvCKeMu67ggrBSrgcI8y+h5QxcQhqncrpdu0BqLqa+NCmBf4FluB\nAgCflY3i3LINAPybAgcLhw4AXCkGWsW6CwDc+X5mvnkAALjUEPuP0AcAxJlBVWiKBAC0F/2oCBEO\nAMC/T9pVRgwAoyZ32jpIAEHg78AACzBUaGUgc2NhbGFyIGZvciB0aGlzIHggaXMgdW5rbm93bgAA\nAAAAAAAAL/z///7///8AQanwwAALEAEAAAAAAADPytot4vbHJwcAQeDwwAALFO66yS9yoQ0AAkT8\ndQuVAQAjUUUBAEGI8cAAC0BBQTbQjF4CAP27A4r0ag4A3K66/v//DwD///////8PAP///////wAA\nQUE20Ixe0j/ugCK9mnO7Kuv/////////AEHR8cAACxgBAAAAAAAAwU53qpkA8jQAAQAAAAAAAAEA\nQZDywAALAQEAQcDywAALAYAAQYDzwAALEMPkvwqpf1RvKIgOAdZ+Q+QAQaDzwAALpgEsVrE9qM1l\n1200dAfFCiiK/v///////////////////zGw20WaIJPof8rocRSKqj0V64SS5JBs6M1r1Kch0oYw\ncX/Eiq60cRXGBvWdrAgSIsTkvwqpf1RvKIgOAdZ+Q+RyvSMbfJYC33hmgSDqIi4SWmQSiAIcJqXg\nMFzATK1jU+4BlXEobAkAE1yZWC9RBwBJ8JzpNDQMAOp5ROYGcQAAfGUraul6AEHQ9MAACxBTY2hu\nb3JyK1NIQTI1NiAgAEHk9MAACwNANBAAKgRuYW1lASMB6QIfX193YmluZGdlbl9hZGRfdG9fc3Rh\nY2tfcG9pbnRlcgCIAQlwcm9kdWNlcnMCCGxhbmd1YWdlAgRSdXN0AANDOTkADHByb2Nlc3NlZC1i\neQQFcnVzdGMdMS44Ny4wICgxNzA2N2U5YWMgMjAyNS0wNS0wOSkMRGViaWFuIGNsYW5nBjE0LjAu\nNgZ3YWxydXMGMC4yMC4zDHdhc20tYmluZGdlbgYwLjIuOTIAaw90YXJnZXRfZmVhdHVyZXMGKw9t\ndXRhYmxlLWdsb2JhbHMrE25vbnRyYXBwaW5nLWZwdG9pbnQrC2J1bGstbWVtb3J5KwhzaWduLWV4\ndCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxNi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvZmZpL2VjYXNoX2xpYl93YXNtX2JnX2Jyb3dzZXIuanM/OTdiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRUNBU0hfTElCX1dBU01fQkFTRTY0ID0gYFxuQUdGemJRRUFBQUFCK3dFZVlBQUFZQUFCZjJBQmZ3QmdBWDhCZjJBQ2YzOEFZQUovZndGL1lBTi9mMzhBWUFOL2YzOEJmMkFFZjM5L1xuZndCZ0JIOS9mMzhCZjJBRmYzOS9mMzhBWUFWL2YzOS9md0YvWUFaL2YzOS9mMzhBWUFaL2YzOS9mMzhCZjJBSGYzOS9mMzkvZndGL1xuWUFoL2YzOS9mMzkvZndCZ0NIOS9mMzkvZjM5L0FYOWdDbjkvZjM5L2YzOS9mMzhBWUF0L2YzOS9mMzkvZjM5L2Z3QmdDMzkvZjM5L1xuZjM5L2YzOS9BWDlnQlg5L2ZuOS9BR0FGZjM5OWYzOEFZQVYvZjN4L2Z3QmdBMzkrZndCZ0JIOStmMzhBWUFWL2ZuNStmZ0JnQ0g5K1xuZm41K2ZuNStBR0FLZjM1K2ZuNStmbjUrZmdCZ0JIOTlmMzhBWUFSL2ZIOS9BQUkwQWdOM1ltY1ZYMTkzWW1sdVpHZGxibDl6ZEhKcFxuYm1kZmJtVjNBQVVEZDJKbkVGOWZkMkpwYm1SblpXNWZkR2h5YjNjQUJBT0JBLzhDQmdRR0JBWUdBdzRJQlF3S0JnNEVEd3dHQ0FnRVxuQkF3TUJ3WUdCZzhKQlF3SUNnZ0lDQWdSQndJTURBUUdFQVVFQmdFR0J3WU5Cd1FHQ0FRSkJnUUVGd1lGQkFVR0JRWVNCQWNFQndRRVxuQ0FVRkJRUUVEUW9HQXdVRUJRVUxCZ1lHQ2dZRkJRWUdCZ1FDQmd3SkNBb01DZ2dDQkFvR0JnTUdDd1FHQkFZSEN3WUhDZ1lUQ3dRR1xuQkFRREJRWUdCQW9FQkFRR0JBUUpCZ1FJREFZREJRb0VCQVFaQ0FnYUJ3WUhBZ0lIQmdrS0NBb2JCZ1FHQlFZSUFnb09CZ1lCQ0FrS1xuQkFZR0JnWUhDQU1HQXdRS0JBWUtDQWdEQkFNR0JBUUVCUVlCQkFZRUJRWUdBZ1FFQndjR0NBWUxCZ1VGQXdRSUJBUUVBZ1VHQ3dRR1xuQmdRRUFnSUpBd01GQ2dRRUJnUUZCUVVFQmdnRUJnVUtDZzBGQkFRR0JnUUZCQW9KQXdnSUFnb05CQUlFQWdvTEZSWVVBd2dDQkFJRFxuQndNRkJnWURCUWtDQlFNQ0JRSUZCUVVHQWdVRkJRY0NCQVlLQmdnSUJRVURDQU1FQkFnSUNBWUdCZ1FFQmdZQ0JBUUFCZ1FEQlFBRVxuQkFVRkJBUUVCUVFFQkFJRUJnUUVCQUlDQkFNRUJRRndBVk5UQlFNQkFCRUdDUUYvQVVHQWdNQUFDd2VTQmlZR2JXVnRiM0o1QWdBSFxuWldOalgyNWxkd0F6RUdWalkxOWtaWEpwZG1WUWRXSnJaWGtBVUExbFkyTmZaV05rYzJGVGFXZHVBQklQWldOalgyVmpaSE5oVm1WeVxuYVdaNUFCRVBaV05qWDNOamFHNXZjbkpUYVdkdUFCZ1JaV05qWDNOamFHNXZjbkpXWlhKcFpua0FIaEZsWTJOZmFYTldZV3hwWkZObFxuWTJ0bGVRQ3NBUTFsWTJOZmMyVmphMlY1UVdSa0FDd05aV05qWDNCMVltdGxlVUZrWkFBaEUyVmpZMTl6YVdkdVVtVmpiM1psY21GaVxuYkdVQUdRNWxZMk5mY21WamIzWmxjbE5wWndBTURsOWZkMkpuWDJWalkxOW1jbVZsQUtzQkZYQjFZbXhwWTB0bGVVTnllWEIwYjFabFxuY21sbWVRQkpISEIxWW14cFkwdGxlVU55ZVhCMGIwRnNaMjlUZFhCd2IzSjBaV1FBZFF0emFHRTFNVEpvWDI1bGR3RGNBUTV6YUdFMVxuTVRKb1gzVndaR0YwWlFERkFSQnphR0UxTVRKb1gyWnBibUZzYVhwbEFKSUJEWE5vWVRVeE1taGZZMnh2Ym1VQWVCSmZYM2RpWjE5elxuYUdFMU1USm9YMlp5WldVQS9nRUxjMmhoTWpVMmFGOXVaWGNBdmdFT2MyaGhNalUyYUY5MWNHUmhkR1VBeGdFUWMyaGhNalUyYUY5bVxuYVc1aGJHbDZaUUNUQVExemFHRXlOVFpvWDJOc2IyNWxBRmtTWDE5M1ltZGZjMmhoTWpVMmFGOW1jbVZsQVA4QkJuTm9ZVFV4TWdDTlxuQVFkemFHRXlOVFprQUg0R2MyaGhNalUyQUxjQkNYTm9ZVkp0WkRFMk1BQTBIbVZqWVhOb1gzTmxZM0F5TlRack1WOWpiMjUwWlhoMFxuWDJOeVpXRjBaUURKQVI5bFkyRnphRjl6WldOd01qVTJhekZmWTI5dWRHVjRkRjlrWlhOMGNtOTVBT01CSlhObFkzQXlOVFpyTVY5a1xuWldaaGRXeDBYMmxzYkdWbllXeGZZMkZzYkdKaFkydGZabTRBNUFJamMyVmpjREkxTm1zeFgyUmxabUYxYkhSZlpYSnliM0pmWTJGc1xuYkdKaFkydGZabTRBNVFJZWNtbHVaMTlqYjNKbFh6QmZNVGRmTVRSZlgySnVYMjExYkY5dGIyNTBBQ3NmWDE5M1ltbHVaR2RsYmw5aFxuWkdSZmRHOWZjM1JoWTJ0ZmNHOXBiblJsY2dEcEFoTmZYM2RpYVc1a1oyVnVYMlY0Y0c5eWRGOHdBUFlCRTE5ZmQySnBibVJuWlc1ZlxuWlhod2IzSjBYekVBNXdJVFgxOTNZbWx1WkdkbGJsOWxlSEJ2Y25SZk1nQ0FBZ21VQVFFQVFRRUxVb2tDTU1nQzB3THVBdW9DakFIU1xuQXRNQ3lBS0tBbDJxQXBzQnFRS3FBcVFDdEFLdkFxa0NxUUtyQXF3Q3JRS0xBbFB6QXZrQzlBTC9BdmdDWE1FQzV3RlN4d0xBQW1RMVxuNEFISkF1TUN5Z0phN3dMQUFwVUNEKzBCQ2NJQ3d3TEVBcEVDN2dHQUF6MGlKZnNCbHdJZE9SU1VBYzBDUDBqWkFUdWNBZDBDVE5vQ1xuOVFJbjJ3TDJBb0VCVnVRQzVRSUt6NHdJL3dMMVBnRklmeUFBSUFBb0FtQWlDaUFDYWpZQ1lDQUFRU0JxSVVVZ0NrRS9jU0VLQTBBZ1xuQWtIQUFDQUtheUkvU1VVRVFDQUtJRVZxSUFFZ1B4QXBHaUFBSUFBb0FsZ2lDa0VZZENBS1FRaDBRWUNBL0FkeGNpQUtRUWgyUVlEK1xuQTNFZ0NrRVlkbkp5SWdNZ0FDZ0NYQ0lLUVJoMElBcEJDSFJCZ0lEOEIzRnlJQXBCQ0haQmdQNERjU0FLUVJoMmNuSWlCRUVaZHlBRVxuUVE1M2N5QUVRUU4yYzJvZ0FDZ0NSQ0lLUVJoMElBcEJDSFJCZ0lEOEIzRnlJQXBCQ0haQmdQNERjU0FLUVJoMmNuSWlHaUFBS0FJZ1xuSWdwQkdIUWdDa0VJZEVHQWdQd0hjWElnQ2tFSWRrR0EvZ054SUFwQkdIWnljaUlZSUFBb0FpUWlDa0VZZENBS1FRaDBRWUNBL0FkeFxuY2lBS1FRaDJRWUQrQTNFZ0NrRVlkbkp5SWc1QkdYY2dEa0VPZDNNZ0RrRURkbk5xYWlBRFFROTNJQU5CRFhkeklBTkJDblp6YWlJRlxuSUFBb0Fqd2lDa0VZZENBS1FRaDBRWUNBL0FkeGNpQUtRUWgyUVlEK0EzRWdDa0VZZG5KeUloVWdBQ2dDUUNJS1FSaDBJQXBCQ0hSQlxuZ0lEOEIzRnlJQXBCQ0haQmdQNERjU0FLUVJoMmNuSWlGa0VaZHlBV1FRNTNjeUFXUVFOMmMycHFJQUFvQWpRaUNrRVlkQ0FLUVFoMFxuUVlDQS9BZHhjaUFLUVFoMlFZRCtBM0VnQ2tFWWRuSnlJak1nQUNnQ09DSUtRUmgwSUFwQkNIUkJnSUQ4QjNGeUlBcEJDSFpCZ1A0RFxuY1NBS1FSaDJjbklpTkVFWmR5QTBRUTUzY3lBMFFRTjJjMm9nQTJvZ0FDZ0NVQ0lLUVJoMElBcEJDSFJCZ0lEOEIzRnlJQXBCQ0haQlxuZ1A0RGNTQUtRUmgyY25JaUx5QUFLQUlzSWdwQkdIUWdDa0VJZEVHQWdQd0hjWElnQ2tFSWRrR0EvZ054SUFwQkdIWnljaUlNSUFBb1xuQWpBaUNrRVlkQ0FLUVFoMFFZQ0EvQWR4Y2lBS1FRaDJRWUQrQTNFZ0NrRVlkbkp5SWdwQkdYY2dDa0VPZDNNZ0NrRURkbk5xYWlBQVxuS0FKSUlnWkJHSFFnQmtFSWRFR0FnUHdIY1hJZ0JrRUlka0dBL2dOeElBWkJHSFp5Y2lJd0lBQW9BaWdpQmtFWWRDQUdRUWgwUVlDQVxuL0FkeGNpQUdRUWgyUVlEK0EzRWdCa0VZZG5KeUlnMUJHWGNnRFVFT2QzTWdEVUVEZG5NZ0RtcHFJQVJCRDNjZ0JFRU5kM01nQkVFS1xuZG5OcUlnWkJEM2NnQmtFTmQzTWdCa0VLZG5OcUlnZEJEM2NnQjBFTmQzTWdCMEVLZG5OcUlnaEJEM2NnQ0VFTmQzTWdDRUVLZG5OcVxuSWdscUlBQW9BbFFpQzBFWWRDQUxRUWgwUVlDQS9BZHhjaUFMUVFoMlFZRCtBM0VnQzBFWWRuSnlJalZCR1hjZ05VRU9kM01nTlVFRFxuZG5NZ0wyb2dDR29nQUNnQ1RDSUxRUmgwSUF0QkNIUkJnSUQ4QjNGeUlBdEJDSFpCZ1A0RGNTQUxRUmgyY25JaU1VRVpkeUF4UVE1M1xuY3lBeFFRTjJjeUF3YWlBSGFpQWFRUmwzSUJwQkRuZHpJQnBCQTNaeklCWnFJQVpxSUJWQkdYY2dGVUVPZDNNZ0ZVRURkbk1nTkdvZ1xuQkdvZ00wRVpkeUF6UVE1M2N5QXpRUU4yY3lBS2FpQTFhaUFNUVJsM0lBeEJEbmR6SUF4QkEzWnpJQTFxSURGcUlBVkJEM2NnQlVFTlxuZDNNZ0JVRUtkbk5xSWd0QkQzY2dDMEVOZDNNZ0MwRUtkbk5xSWc5QkQzY2dEMEVOZDNNZ0QwRUtkbk5xSWhGQkQzY2dFVUVOZDNNZ1xuRVVFS2RuTnFJaE5CRDNjZ0UwRU5kM01nRTBFS2RuTnFJaFJCRDNjZ0ZFRU5kM01nRkVFS2RuTnFJaGRCRDNjZ0YwRU5kM01nRjBFS1xuZG5OcUlobEJHWGNnR1VFT2QzTWdHVUVEZG5NZ0EwRVpkeUFEUVE1M2N5QURRUU4yY3lBMWFpQVJhaUF2UVJsM0lDOUJEbmR6SUM5QlxuQTNaeklERnFJQTlxSURCQkdYY2dNRUVPZDNNZ01FRURkbk1nR21vZ0Myb2dDVUVQZHlBSlFRMTNjeUFKUVFwMmMyb2lHMEVQZHlBYlxuUVExM2N5QWJRUXAyYzJvaUhFRVBkeUFjUVExM2N5QWNRUXAyYzJvaUhXb2dCVUVaZHlBRlFRNTNjeUFGUVFOMmN5QUVhaUFUYWlBZFxuUVE5M0lCMUJEWGR6SUIxQkNuWnphaUllSUFsQkdYY2dDVUVPZDNNZ0NVRURkbk1nRVdwcUlBaEJHWGNnQ0VFT2QzTWdDRUVEZG5NZ1xuRDJvZ0hXb2dCMEVaZHlBSFFRNTNjeUFIUVFOMmN5QUxhaUFjYWlBR1FSbDNJQVpCRG5keklBWkJBM1p6SUFWcUlCdHFJQmxCRDNjZ1xuR1VFTmQzTWdHVUVLZG5OcUloOUJEM2NnSDBFTmQzTWdIMEVLZG5OcUlpQkJEM2NnSUVFTmQzTWdJRUVLZG5OcUlpRkJEM2NnSVVFTlxuZDNNZ0lVRUtkbk5xSWlKcUlCZEJHWGNnRjBFT2QzTWdGMEVEZG5NZ0hHb2dJV29nRkVFWmR5QVVRUTUzY3lBVVFRTjJjeUFiYWlBZ1xuYWlBVFFSbDNJQk5CRG5keklCTkJBM1p6SUFscUlCOXFJQkZCR1hjZ0VVRU9kM01nRVVFRGRuTWdDR29nR1dvZ0QwRVpkeUFQUVE1M1xuY3lBUFFRTjJjeUFIYWlBWGFpQUxRUmwzSUF0QkRuZHpJQXRCQTNaeklBWnFJQlJxSUI1QkQzY2dIa0VOZDNNZ0hrRUtkbk5xSWlOQlxuRDNjZ0kwRU5kM01nSTBFS2RuTnFJaVJCRDNjZ0pFRU5kM01nSkVFS2RuTnFJaVZCRDNjZ0pVRU5kM01nSlVFS2RuTnFJaVpCRDNjZ1xuSmtFTmQzTWdKa0VLZG5OcUlpZEJEM2NnSjBFTmQzTWdKMEVLZG5OcUlpaEJEM2NnS0VFTmQzTWdLRUVLZG5OcUlpbEJHWGNnS1VFT1xuZDNNZ0tVRURkbk1nSFVFWmR5QWRRUTUzY3lBZFFRTjJjeUFYYWlBbGFpQWNRUmwzSUJ4QkRuZHpJQnhCQTNaeklCUnFJQ1JxSUJ0QlxuR1hjZ0cwRU9kM01nRzBFRGRuTWdFMm9nSTJvZ0lrRVBkeUFpUVExM2N5QWlRUXAyYzJvaUtrRVBkeUFxUVExM2N5QXFRUXAyYzJvaVxuSzBFUGR5QXJRUTEzY3lBclFRcDJjMm9pTEdvZ0hrRVpkeUFlUVE1M2N5QWVRUU4yY3lBWmFpQW1haUFzUVE5M0lDeEJEWGR6SUN4QlxuQ25aemFpSXRJQ0pCR1hjZ0lrRU9kM01nSWtFRGRuTWdKV3BxSUNGQkdYY2dJVUVPZDNNZ0lVRURkbk1nSkdvZ0xHb2dJRUVaZHlBZ1xuUVE1M2N5QWdRUU4yY3lBamFpQXJhaUFmUVJsM0lCOUJEbmR6SUI5QkEzWnpJQjVxSUNwcUlDbEJEM2NnS1VFTmQzTWdLVUVLZG5OcVxuSWk1QkQzY2dMa0VOZDNNZ0xrRUtkbk5xSWpaQkQzY2dOa0VOZDNNZ05rRUtkbk5xSWpkQkQzY2dOMEVOZDNNZ04wRUtkbk5xSWpocVxuSUNoQkdYY2dLRUVPZDNNZ0tFRURkbk1nSzJvZ04yb2dKMEVaZHlBblFRNTNjeUFuUVFOMmN5QXFhaUEyYWlBbVFSbDNJQ1pCRG5kelxuSUNaQkEzWnpJQ0pxSUM1cUlDVkJHWGNnSlVFT2QzTWdKVUVEZG5NZ0lXb2dLV29nSkVFWmR5QWtRUTUzY3lBa1FRTjJjeUFnYWlBb1xuYWlBalFSbDNJQ05CRG5keklDTkJBM1p6SUI5cUlDZHFJQzFCRDNjZ0xVRU5kM01nTFVFS2RuTnFJakpCRDNjZ01rRU5kM01nTWtFS1xuZG5OcUlqbEJEM2NnT1VFTmQzTWdPVUVLZG5OcUlqcEJEM2NnT2tFTmQzTWdPa0VLZG5OcUlqdEJEM2NnTzBFTmQzTWdPMEVLZG5OcVxuSWp4QkQzY2dQRUVOZDNNZ1BFRUtkbk5xSWtCQkQzY2dRRUVOZDNNZ1FFRUtkbk5xSWtFZ1BDQTZJRElnTENBcUlDRWdIeUFYSUJNZ1xuRHlBRklDOGdGaUFLSUJnZ0FDZ0NIQ0pISUFBb0FoQWlHRUVhZHlBWVFSVjNjeUFZUVFkM2Myb2dBQ2dDR0NKQ0lBQW9BaFFpUFhNZ1xuR0hFZ1FuTnFha0dZMzZpVUJHb2lFaUFBS0FJTUlraHFJZ3BxSUF3Z0dHb2dEU0E5YWlBT0lFSnFJQW9nR0NBOWMzRWdQWE5xSUFwQlxuR25jZ0NrRVZkM01nQ2tFSGQzTnFRWkdKM1lrSGFpSkRJQUFvQWdnaVJtb2lEQ0FLSUJoemNTQVljMm9nREVFYWR5QU1RUlYzY3lBTVxuUVFkM2MycEJzWWo4MFFScklrUWdBQ2dDQkNJK2FpSU5JQW9nREhOeElBcHphaUFOUVJwM0lBMUJGWGR6SUExQkIzZHpha0hieUtpeVxuQVdzaVNTQUFLQUlBSWdwcUloQWdEQ0FOYzNFZ0RITnFJQkJCR25jZ0VFRVZkM01nRUVFSGQzTnFRZHVFMjhvRGFpSktJRVlnQ2lBK1xuY25FZ0NpQStjWElnQ2tFZWR5QUtRUk4zY3lBS1FRcDNjMm9nRW1vaURtb2lFbW9nRUNBVmFpQU5JRFJxSUF3Z00yb2dFaUFOSUJCelxuY1NBTmMyb2dFa0VhZHlBU1FSVjNjeUFTUVFkM2MycEI4YVBFendWcUlqTWdDaUFPY2lBK2NTQUtJQTV4Y2lBT1FSNTNJQTVCRTNkelxuSUE1QkNuZHphaUJEYWlJTWFpSVZJQkFnRW5OeElCQnphaUFWUVJwM0lCVkJGWGR6SUJWQkIzZHpha0hjK29IdUJtc2lOQ0FNSUE1eVxuSUFweElBd2dEbkZ5SUF4QkhuY2dERUVUZDNNZ0RFRUtkM05xSUVScUlnMXFJaEFnRWlBVmMzRWdFbk5xSUJCQkduY2dFRUVWZDNNZ1xuRUVFSGQzTnFRYXZDanFjRmF5SkRJQXdnRFhJZ0RuRWdEQ0FOY1hJZ0RVRWVkeUFOUVJOM2N5QU5RUXAzYzJvZ1NXb2lEbW9pRWlBUVxuSUJWemNTQVZjMm9nRWtFYWR5QVNRUlYzY3lBU1FRZDNjMnBCNktyaHZ3SnJJa1FnRFNBT2NpQU1jU0FOSUE1eGNpQU9RUjUzSUE1QlxuRTNkeklBNUJDbmR6YWlCS2FpSU1haUlXYWlBU0lERnFJQkFnTUdvZ0ZTQWFhaUFXSUJBZ0VuTnhJQkJ6YWlBV1FScDNJQlpCRlhkelxuSUJaQkIzZHpha0dCdG8yVUFXb2lHaUFNSUE1eUlBMXhJQXdnRG5GeUlBeEJIbmNnREVFVGQzTWdERUVLZDNOcUlETnFJZzFxSWhBZ1xuRWlBV2MzRWdFbk5xSUJCQkduY2dFRUVWZDNNZ0VFRUhkM05xUWI2THhxRUNhaUl2SUF3Z0RYSWdEbkVnRENBTmNYSWdEVUVlZHlBTlxuUVJOM2N5QU5RUXAzYzJvZ05Hb2lEbW9pRWlBUUlCWnpjU0FXYzJvZ0VrRWFkeUFTUVJWM2N5QVNRUWQzYzJwQncvdXhxQVZxSWpBZ1xuRFNBT2NpQU1jU0FOSUE1eGNpQU9RUjUzSUE1QkUzZHpJQTVCQ25kemFpQkRhaUlNYWlJVklCQWdFbk54SUJCemFpQVZRUnAzSUJWQlxuRlhkeklCVkJCM2R6YWtIMHV2bVZCMm9pTVNBTUlBNXlJQTF4SUF3Z0RuRnlJQXhCSG5jZ0RFRVRkM01nREVFS2QzTnFJRVJxSWcxcVxuSWhacUlBUWdGV29nQXlBU2FpQVFJRFZxSUJZZ0VpQVZjM0VnRW5OcUlCWkJHbmNnRmtFVmQzTWdGa0VIZDNOcVFZS2NoZmtIYXlJU1xuSUF3Z0RYSWdEbkVnRENBTmNYSWdEVUVlZHlBTlFSTjNjeUFOUVFwM2Myb2dHbW9pQTJvaURpQVZJQlp6Y1NBVmMyb2dEa0VhZHlBT1xuUVJWM2N5QU9RUWQzYzJwQjJmS1BvUVpySWhVZ0F5QU5jaUFNY1NBRElBMXhjaUFEUVI1M0lBTkJFM2R6SUFOQkNuZHphaUF2YWlJRVxuYWlJTUlBNGdGbk54SUJaemFpQU1RUnAzSUF4QkZYZHpJQXhCQjNkemFrR01uWkR6QTJzaUZpQURJQVJ5SUExeElBTWdCSEZ5SUFSQlxuSG5jZ0JFRVRkM01nQkVFS2QzTnFJREJxSWdWcUlnMGdEQ0FPYzNFZ0RuTnFJQTFCR25jZ0RVRVZkM01nRFVFSGQzTnFRYitza3RzQlxuYXlJYUlBUWdCWElnQTNFZ0JDQUZjWElnQlVFZWR5QUZRUk4zY3lBRlFRcDNjMm9nTVdvaUEyb2lFR29nQnlBTmFpQUxJQXhxSUFZZ1xuRG1vZ0VDQU1JQTF6Y1NBTWMyb2dFRUVhZHlBUVFSVjNjeUFRUVFkM2MycEIrdkNHZ2dGcklnNGdBeUFGY2lBRWNTQURJQVZ4Y2lBRFxuUVI1M0lBTkJFM2R6SUFOQkNuZHphaUFTYWlJRWFpSUdJQTBnRUhOeElBMXphaUFHUVJwM0lBWkJGWGR6SUFaQkIzZHpha0hHdTRiK1xuQUdvaURDQURJQVJ5SUFWeElBTWdCSEZ5SUFSQkhuY2dCRUVUZDNNZ0JFRUtkM05xSUJWcUlnVnFJZ2NnQmlBUWMzRWdFSE5xSUFkQlxuR25jZ0IwRVZkM01nQjBFSGQzTnFRY3pEc3FBQ2FpSU5JQVFnQlhJZ0EzRWdCQ0FGY1hJZ0JVRWVkeUFGUVJOM2N5QUZRUXAzYzJvZ1xuRm1vaUEyb2lDeUFHSUFkemNTQUdjMm9nQzBFYWR5QUxRUlYzY3lBTFFRZDNjMnBCNzlpazd3SnFJaEFnQXlBRmNpQUVjU0FESUFWeFxuY2lBRFFSNTNJQU5CRTNkeklBTkJDbmR6YWlBYWFpSUVhaUlQYWlBSklBdHFJQWNnRVdvZ0JpQUlhaUFQSUFjZ0MzTnhJQWR6YWlBUFxuUVJwM0lBOUJGWGR6SUE5QkIzZHpha0dxaWRMVEJHb2lFU0FESUFSeUlBVnhJQU1nQkhGeUlBUkJIbmNnQkVFVGQzTWdCRUVLZDNOcVxuSUE1cUlnVnFJZ1lnQ3lBUGMzRWdDM05xSUFaQkduY2dCa0VWZDNNZ0JrRUhkM05xUWR6VHd1VUZhaUlMSUFRZ0JYSWdBM0VnQkNBRlxuY1hJZ0JVRWVkeUFGUVJOM2N5QUZRUXAzYzJvZ0RHb2lBMm9pQnlBR0lBOXpjU0FQYzJvZ0IwRWFkeUFIUVJWM2N5QUhRUWQzYzJwQlxuMnBIbXR3ZHFJZzhnQXlBRmNpQUVjU0FESUFWeGNpQURRUjUzSUFOQkUzZHpJQU5CQ25kemFpQU5haUlFYWlJSUlBWWdCM054SUFaelxuYWlBSVFScDNJQWhCRlhkeklBaEJCM2R6YWtHdTNZYStCbXNpRXlBRElBUnlJQVZ4SUFNZ0JIRnlJQVJCSG5jZ0JFRVRkM01nQkVFS1xuZDNOcUlCQnFJZ1ZxSWdscUlBZ2dIR29nQnlBVWFpQUdJQnRxSUFrZ0J5QUljM0VnQjNOcUlBbEJHbmNnQ1VFVmQzTWdDVUVIZDNOcVxuUVpQenVMNEZheUlVSUFRZ0JYSWdBM0VnQkNBRmNYSWdCVUVlZHlBRlFSTjNjeUFGUVFwM2Myb2dFV29pQTJvaUJpQUlJQWx6Y1NBSVxuYzJvZ0JrRWFkeUFHUVJWM2N5QUdRUWQzYzJwQnVMRHovd1JySWhFZ0F5QUZjaUFFY1NBRElBVnhjaUFEUVI1M0lBTkJFM2R6SUFOQlxuQ25kemFpQUxhaUlFYWlJSElBWWdDWE54SUFsemFpQUhRUnAzSUFkQkZYZHpJQWRCQjNkemFrRzVnSnFGQkdzaUN5QURJQVJ5SUFWeFxuSUFNZ0JIRnlJQVJCSG5jZ0JFRVRkM01nQkVFS2QzTnFJQTlxSWdWcUlnZ2dCaUFIYzNFZ0JuTnFJQWhCR25jZ0NFRVZkM01nQ0VFSFxuZDNOcVFZM28vOGdEYXlJUElBUWdCWElnQTNFZ0JDQUZjWElnQlVFZWR5QUZRUk4zY3lBRlFRcDNjMm9nRTJvaUEyb2lDV29nQ0NBZVxuYWlBSElCbHFJQVlnSFdvZ0NTQUhJQWh6Y1NBSGMyb2dDVUVhZHlBSlFSVjNjeUFKUVFkM2MycEJ1ZDNoMGdKckloTWdBeUFGY2lBRVxuY1NBRElBVnhjaUFEUVI1M0lBTkJFM2R6SUFOQkNuZHphaUFVYWlJRWFpSUdJQWdnQ1hOeElBaHphaUFHUVJwM0lBWkJGWGR6SUFaQlxuQjNkemFrSFJ4cWsyYWlJVUlBTWdCSElnQlhFZ0F5QUVjWElnQkVFZWR5QUVRUk4zY3lBRVFRcDNjMm9nRVdvaUJXb2lCeUFHSUFselxuY1NBSmMyb2dCMEVhZHlBSFFSVjNjeUFIUVFkM2MycEI1OUtrb1FGcUloRWdCQ0FGY2lBRGNTQUVJQVZ4Y2lBRlFSNTNJQVZCRTNkelxuSUFWQkNuZHphaUFMYWlJRGFpSUlJQVlnQjNOeElBWnphaUFJUVJwM0lBaEJGWGR6SUFoQkIzZHpha0dGbGR5OUFtb2lDeUFESUFWeVxuSUFSeElBTWdCWEZ5SUFOQkhuY2dBMEVUZDNNZ0EwRUtkM05xSUE5cUlnUnFJZ2xxSUFnZ0pHb2dCeUFnYWlBR0lDTnFJQWtnQnlBSVxuYzNFZ0IzTnFJQWxCR25jZ0NVRVZkM01nQ1VFSGQzTnFRYmpDN1BBQ2FpSVBJQU1nQkhJZ0JYRWdBeUFFY1hJZ0JFRWVkeUFFUVJOM1xuY3lBRVFRcDNjMm9nRTJvaUJXb2lCaUFJSUFsemNTQUljMm9nQmtFYWR5QUdRUlYzY3lBR1FRZDNjMnBCL051eDZRUnFJaE1nQkNBRlxuY2lBRGNTQUVJQVZ4Y2lBRlFSNTNJQVZCRTNkeklBVkJDbmR6YWlBVWFpSURhaUlISUFZZ0NYTnhJQWx6YWlBSFFScDNJQWRCRlhkelxuSUFkQkIzZHpha0dUbXVDWkJXb2lGQ0FESUFWeUlBUnhJQU1nQlhGeUlBTkJIbmNnQTBFVGQzTWdBMEVLZDNOcUlCRnFJZ1JxSWdnZ1xuQmlBSGMzRWdCbk5xSUFoQkduY2dDRUVWZDNNZ0NFRUhkM05xUWRUbXFhZ0dhaUlSSUFNZ0JISWdCWEVnQXlBRWNYSWdCRUVlZHlBRVxuUVJOM2N5QUVRUXAzYzJvZ0Myb2lCV29pQ1dvZ0NDQW1haUFISUNKcUlBWWdKV29nQ1NBSElBaHpjU0FIYzJvZ0NVRWFkeUFKUVJWM1xuY3lBSlFRZDNjMnBCdTVXb3N3ZHFJZ3NnQkNBRmNpQURjU0FFSUFWeGNpQUZRUjUzSUFWQkUzZHpJQVZCQ25kemFpQVBhaUlEYWlJR1xuSUFnZ0NYTnhJQWh6YWlBR1FScDNJQVpCRlhkeklBWkJCM2R6YWtIUzdmVHhCMnNpRHlBRElBVnlJQVJ4SUFNZ0JYRnlJQU5CSG5jZ1xuQTBFVGQzTWdBMEVLZDNOcUlCTnFJZ1JxSWdjZ0JpQUpjM0VnQ1hOcUlBZEJHbmNnQjBFVmQzTWdCMEVIZDNOcVFmdW10K3dHYXlJVFxuSUFNZ0JISWdCWEVnQXlBRWNYSWdCRUVlZHlBRVFSTjNjeUFFUVFwM2Myb2dGR29pQldvaUNDQUdJQWR6Y1NBR2Myb2dDRUVhZHlBSVxuUVJWM2N5QUlRUWQzYzJwQjM2NkE2Z1ZySWhRZ0JDQUZjaUFEY1NBRUlBVnhjaUFGUVI1M0lBVkJFM2R6SUFWQkNuZHphaUFSYWlJRFxuYWlJSmFpQUlJQ2hxSUFjZ0syb2dCaUFuYWlBSklBY2dDSE54SUFkemFpQUpRUnAzSUFsQkZYZHpJQWxCQjNkemFrRzFzNWEvQldzaVxuRVNBRElBVnlJQVJ4SUFNZ0JYRnlJQU5CSG5jZ0EwRVRkM01nQTBFS2QzTnFJQXRxSWdScUlnWWdDQ0FKYzNFZ0NITnFJQVpCR25jZ1xuQmtFVmQzTWdCa0VIZDNOcVFaRHAwZTBEYXlJTElBTWdCSElnQlhFZ0F5QUVjWElnQkVFZWR5QUVRUk4zY3lBRVFRcDNjMm9nRDJvaVxuQldvaUJ5QUdJQWx6Y1NBSmMyb2dCMEVhZHlBSFFSVjNjeUFIUVFkM2MycEIzZHpPeEFOcklnOGdCQ0FGY2lBRGNTQUVJQVZ4Y2lBRlxuUVI1M0lBVkJFM2R6SUFWQkNuZHphaUFUYWlJRGFpSUlJQVlnQjNOeElBWnphaUFJUVJwM0lBaEJGWGR6SUFoQkIzZHpha0hucjdUelxuQW1zaUV5QURJQVZ5SUFSeElBTWdCWEZ5SUFOQkhuY2dBMEVUZDNNZ0EwRUtkM05xSUJScUlnUnFJZ2xxSUFnZ0xtb2dCeUF0YWlBR1xuSUNscUlBa2dCeUFJYzNFZ0IzTnFJQWxCR25jZ0NVRVZkM01nQ1VFSGQzTnFRZHp6bThzQ2F5SVVJQU1nQkhJZ0JYRWdBeUFFY1hJZ1xuQkVFZWR5QUVRUk4zY3lBRVFRcDNjMm9nRVdvaUJXb2lCaUFJSUFsemNTQUljMm9nQmtFYWR5QUdRUlYzY3lBR1FRZDNjMnBCKzVUSFxuM3dCckloRWdCQ0FGY2lBRGNTQUVJQVZ4Y2lBRlFSNTNJQVZCRTNkeklBVkJDbmR6YWlBTGFpSURhaUlISUFZZ0NYTnhJQWx6YWlBSFxuUVJwM0lBZEJGWGR6SUFkQkIzZHpha0h3d0txREFXb2lDeUFESUFWeUlBUnhJQU1nQlhGeUlBTkJIbmNnQTBFVGQzTWdBMEVLZDNOcVxuSUE5cUlnUnFJZ2dnQmlBSGMzRWdCbk5xSUFoQkduY2dDRUVWZDNNZ0NFRUhkM05xUVphQ2s4MEJhaUlQSUFNZ0JISWdCWEVnQXlBRVxuY1hJZ0JFRWVkeUFFUVJOM2N5QUVRUXAzYzJvZ0Uyb2lCV29pQ1dvZ0NDQTNhaUFISURscUlBWWdObW9nQ1NBSElBaHpjU0FIYzJvZ1xuQ1VFYWR5QUpRUlYzY3lBSlFRZDNjMnBCaU5qZDhRRnFJaE1nQkNBRmNpQURjU0FFSUFWeGNpQUZRUjUzSUFWQkUzZHpJQVZCQ25kelxuYWlBVWFpSURhaUlHSUFnZ0NYTnhJQWh6YWlBR1FScDNJQVpCRlhkeklBWkJCM2R6YWtITTdxRzZBbW9pRkNBRElBVnlJQVJ4SUFNZ1xuQlhGeUlBTkJIbmNnQTBFVGQzTWdBMEVLZDNOcUlCRnFJZ1JxSWdjZ0JpQUpjM0VnQ1hOcUlBZEJHbmNnQjBFVmQzTWdCMEVIZDNOcVxuUWJYNXdxVURhaUlSSUFNZ0JISWdCWEVnQXlBRWNYSWdCRUVlZHlBRVFSTjNjeUFFUVFwM2Myb2dDMm9pQldvaUNDQUdJQWR6Y1NBR1xuYzJvZ0NFRWFkeUFJUVJWM2N5QUlRUWQzYzJwQnM1bnd5QU5xSWdzZ0JDQUZjaUFEY1NBRUlBVnhjaUFGUVI1M0lBVkJFM2R6SUFWQlxuQ25kemFpQVBhaUlEYWlJSmFpQXFRUmwzSUNwQkRuZHpJQ3BCQTNaeklDWnFJREpxSURoQkQzY2dPRUVOZDNNZ09FRUtkbk5xSWc4Z1xuQ0dvZ0J5QTdhaUFHSURocUlBa2dCeUFJYzNFZ0IzTnFJQWxCR25jZ0NVRVZkM01nQ1VFSGQzTnFRY3JVNHZZRWFpSVhJQU1nQlhJZ1xuQkhFZ0F5QUZjWElnQTBFZWR5QURRUk4zY3lBRFFRcDNjMm9nRTJvaUJHb2lCaUFJSUFsemNTQUljMm9nQmtFYWR5QUdRUlYzY3lBR1xuUVFkM2MycEJ6NVR6M0FWcUloTWdBeUFFY2lBRmNTQURJQVJ4Y2lBRVFSNTNJQVJCRTNkeklBUkJDbmR6YWlBVWFpSUZhaUlISUFZZ1xuQ1hOeElBbHphaUFIUVJwM0lBZEJGWGR6SUFkQkIzZHpha0h6MzduQkJtb2lGQ0FFSUFWeUlBTnhJQVFnQlhGeUlBVkJIbmNnQlVFVFxuZDNNZ0JVRUtkM05xSUJGcUlnTnFJZ2dnQmlBSGMzRWdCbk5xSUFoQkduY2dDRUVWZDNNZ0NFRUhkM05xUWU2RnZxUUhhaUlaSUFNZ1xuQlhJZ0JIRWdBeUFGY1hJZ0EwRWVkeUFEUVJOM2N5QURRUXAzYzJvZ0Myb2lCR29pQ1dvZ0xFRVpkeUFzUVE1M2N5QXNRUU4yY3lBb1xuYWlBNmFpQXJRUmwzSUN0QkRuZHpJQ3RCQTNaeklDZHFJRGxxSUE5QkQzY2dEMEVOZDNNZ0QwRUtkbk5xSWd0QkQzY2dDMEVOZDNNZ1xuQzBFS2RuTnFJaEVnQ0dvZ0J5QkFhaUFHSUF0cUlBa2dCeUFJYzNFZ0IzTnFJQWxCR25jZ0NVRVZkM01nQ1VFSGQzTnFRZS9HbGNVSFxuYWlJR0lBTWdCSElnQlhFZ0F5QUVjWElnQkVFZWR5QUVRUk4zY3lBRVFRcDNjMm9nRjJvaUJXb2lCeUFJSUFsemNTQUljMm9nQjBFYVxuZHlBSFFSVjNjeUFIUVFkM2MycEI3SS9lMlFkckloY2dCQ0FGY2lBRGNTQUVJQVZ4Y2lBRlFSNTNJQVZCRTNkeklBVkJDbmR6YWlBVFxuYWlJRGFpSUlJQWNnQ1hOeElBbHphaUFJUVJwM0lBaEJGWGR6SUFoQkIzZHpha0g0KytPWkIyc2lFeUFESUFWeUlBUnhJQU1nQlhGeVxuSUFOQkhuY2dBMEVUZDNNZ0EwRUtkM05xSUJScUlnUnFJZ2tnQnlBSWMzRWdCM05xSUFsQkduY2dDVUVWZDNNZ0NVRUhkM05xUVlhQVxuaFBvR2F5SVVJQU1nQkhJZ0JYRWdBeUFFY1hJZ0JFRWVkeUFFUVJOM2N5QUVRUXAzYzJvZ0dXb2lCV29pQ3lCSGFqWUNIQ0FBSUVnZ1xuQkNBRmNpQURjU0FFSUFWeGNpQUZRUjUzSUFWQkUzZHpJQVZCQ25kemFpQUdhaUlEUVI1M0lBTkJFM2R6SUFOQkNuZHpJQU1nQlhJZ1xuQkhFZ0F5QUZjWEpxSUJkcUlnUkJIbmNnQkVFVGQzTWdCRUVLZDNNZ0F5QUVjaUFGY1NBRElBUnhjbW9nRTJvaUJVRWVkeUFGUVJOM1xuY3lBRlFRcDNjeUFFSUFWeUlBTnhJQVFnQlhGeWFpQVVhaUlHYWpZQ0RDQUFJRUlnQXlBdFFSbDNJQzFCRG5keklDMUJBM1p6SUNscVxuSUR0cUlCRkJEM2NnRVVFTmQzTWdFVUVLZG5OcUloRWdCMm9nQ3lBSUlBbHpjU0FJYzJvZ0MwRWFkeUFMUVJWM2N5QUxRUWQzYzJwQlxubGFhKzNRVnJJZ05xSWdkcU5nSVlJQUFnUmlBRklBWnlJQVJ4SUFVZ0JuRnlJQVpCSG5jZ0JrRVRkM01nQmtFS2QzTnFJQU5xSWdOcVxuTmdJSUlBQWdQU0FFSUMwZ0xrRVpkeUF1UVE1M2N5QXVRUU4yYzJvZ0Qyb2dRVUVQZHlCQlFRMTNjeUJCUVFwMmMyb2dDR29nQnlBSlxuSUF0emNTQUpjMm9nQjBFYWR5QUhRUlYzY3lBSFFRZDNjMnBCaWJpWmlBUnJJZ1JxSWdocU5nSVVJQUFnUGlBRElBWnlJQVZ4SUFNZ1xuQm5GeUlBTkJIbmNnQTBFVGQzTWdBMEVLZDNOcUlBUnFJZ1JxTmdJRUlBQWdMaUF5UVJsM0lESkJEbmR6SURKQkEzWnphaUE4YWlBUlxuUVE5M0lCRkJEWGR6SUJGQkNuWnphaUFKYWlBSUlBY2dDM054SUF0emFpQUlRUnAzSUFoQkZYZHpJQWhCQjNkemFrR09qcnJNQTJzaVxuQnlBRklCaHFhallDRUNBQUlBb2dBeUFFY2lBR2NTQURJQVJ4Y21vZ0JFRWVkeUFFUVJOM2N5QUVRUXAzYzJvZ0IybzJBZ0FnQWlBL1xuYXlFQ0lBRWdQMm9oQVVFQUlRb01BUVVMQ3lBQ0JFQWdDaUJGYWlBQklBSVFLUm9GQ3d1eExBRWhmeU1BUVVCcUlncEJBRUhBQVB3TFxuQUFOQUlCQkJ3QUJHUlFSQUlBb2dFR29nQVNBUWFpZ0FBRFlDQUNBUVFRUnFJUkFNQVFVTEN5QUFJQW9vQWl3aUFTQUtLQUlvSWhBZ1xuQ2lnQ0ZDSVRJQk1nQ2lnQ05DSWFJQkFnRXlBS0tBSWNJaFVnQ2lnQ0pDSWJJQW9vQWlBaUN5QWJJQW9vQWhnaUZ5QVZJQUVnRnlBS1xuS0FJRUloUWdBQ2dDRUNJZWFpQUFLQUlJSWg5QkNuY2lCU0FBS0FJRUloMXpJQW9vQWdBaUdDQUFLQUlBSWlBZ0FDZ0NEQ0lFSUIwZ1xuSDNOemFtcEJDM2NnSG1vaUVYTnFRUTUzSUFScUloSkJDbmNpQW1vZ0NpZ0NFQ0lXSUIxQkNuY2lDR29nQ2lnQ0NDSVpJQVJxSUFnZ1xuRVhNZ0VuTnFRUTkzSUFWcUlnTWdBbk1nQ2lnQ0RDSWNJQVZxSUJJZ0VVRUtkeUlSY3lBRGMycEJESGNnQ0dvaUVuTnFRUVYzSUJGcVxuSWdjZ0VrRUtkeUlKY3lBUklCTnFJQklnQTBFS2R5SVJjeUFIYzJwQkNIY2dBbW9pRW5OcVFRZDNJQkZxSWdKQkNuY2lBMm9nR3lBSFxuUVFwM0lnZHFJQkVnRldvZ0J5QVNjeUFDYzJwQkNYY2dDV29pRVNBRGN5QUpJQXRxSUFJZ0VrRUtkeUlTY3lBUmMycEJDM2NnQjJvaVxuQW5OcVFRMTNJQkpxSWdjZ0FrRUtkeUlKY3lBUUlCSnFJQUlnRVVFS2R5SVNjeUFIYzJwQkRuY2dBMm9pQW5OcVFROTNJQkpxSWdOQlxuQ25jaURHb2dDU0FhYWlBU0lBb29BakFpRVdvZ0FpQUhRUXAzSWdkeklBTnpha0VHZHlBSmFpSUpJQU1nQWtFS2R5SUNjM05xUVFkM1xuSUFkcUlnTkJDbmNpRFNBQ0lBb29BandpRW1vZ0J5QUtLQUk0SWdwcUlBa2dESE1nQTNOcVFRbDNJQUpxSWdjZ0F5QUpRUXAzSWdselxuYzJwQkNIY2dER29pQWtGL2MzRnFJQUlnQjNGcVFabnppZFFGYWtFSGR5QUphaUlEUVFwM0lneHFJQTBnR21vZ0FrRUtkeUlHSUFrZ1xuRm1vZ0IwRUtkeUlISUFOQmYzTnhhaUFDSUFOeGFrR1o4NG5VQldwQkJuY2dEV29pQWtGL2MzRnFJQUlnQTNGcVFabnppZFFGYWtFSVxuZHlBSGFpSURRUXAzSWdrZ0JpQVFhaUFDUVFwM0lnMGdCeUFVYWlBTUlBTkJmM054YWlBQ0lBTnhha0daODRuVUJXcEJEWGNnQm1vaVxuQWtGL2MzRnFJQUlnQTNGcVFabnppZFFGYWtFTGR5QU1haUlEUVg5emNXb2dBaUFEY1dwQm1mT0oxQVZxUVFsM0lBMXFJZ2RCQ25jaVxuREdvZ0NTQWNhaUFEUVFwM0lnWWdDU0FOSUJKcUlBSkJDbmNpQ1NBSFFYOXpjV29nQXlBSGNXcEJtZk9KMUFWcVFRZDNhaUlDUVg5elxuY1dvZ0FpQUhjV3BCbWZPSjFBVnFRUTkzSUFscUlnTkJDbmNpRFNBR0lCaHFJQUpCQ25jaURpQUpJQkZxSUF3Z0EwRi9jM0ZxSUFJZ1xuQTNGcVFabnppZFFGYWtFSGR5QUdhaUlDUVg5emNXb2dBaUFEY1dwQm1mT0oxQVZxUVF4M0lBeHFJZ05CZjNOeGFpQUNJQU54YWtHWlxuODRuVUJXcEJEM2NnRG1vaUIwRUtkeUlKYWlBTklCbHFJQU5CQ25jaURDQU5JQTRnRTJvZ0FrRUtkeUlOSUFkQmYzTnhhaUFESUFkeFxuYWtHWjg0blVCV3BCQ1hkcUlnSkJmM054YWlBQ0lBZHhha0daODRuVUJXcEJDM2NnRFdvaUEwRUtkeUlISUFFZ0RHb2dBa0VLZHlJR1xuSUFvZ0RXb2dDU0FEUVg5emNXb2dBaUFEY1dwQm1mT0oxQVZxUVFkM0lBeHFJZ0pCZjNOeGFpQUNJQU54YWtHWjg0blVCV3BCRFhjZ1xuQ1dvaUEwRi9jeUlOY1dvZ0FpQURjV3BCbWZPSjFBVnFRUXgzSUFacUlnbEJDbmNpREdvZ0ZpQURRUXAzSWdOcUlBTWdDaUFDUVFwM1xuSWdKcUlBSWdCeUFRYWlBR0lCeHFJQWtnRFhJZ0FuTnFRYUhYNS9ZR2FrRUxkeUFIYWlJQ0lBbEJmM055SUFOemFrR2gxK2YyQm1wQlxuRFhkcUlnTWdBa0YvYzNJZ0RITnFRYUhYNS9ZR2FrRUdkMm9pQnlBRFFYOXpjaUFDUVFwM0lnSnpha0doMStmMkJtcEJCM2NnREdvaVxuQ1NBSFFYOXpjaUFEUVFwM0lnTnpha0doMStmMkJtcEJEbmNnQW1vaURFRUtkeUlOYWlBWklBbEJDbmNpQm1vZ0ZDQUhRUXAzSWdkcVxuSUFNZ0Myb2dBaUFTYWlBTUlBbEJmM055SUFkemFrR2gxK2YyQm1wQkNYY2dBMm9pQWlBTVFYOXpjaUFHYzJwQm9kZm45Z1pxUVExM1xuSUFkcUlnTWdBa0YvYzNJZ0RYTnFRYUhYNS9ZR2FrRVBkeUFHYWlJSElBTkJmM055SUFKQkNuY2lBbk5xUWFIWDUvWUdha0VPZHlBTlxuYWlJSklBZEJmM055SUFOQkNuY2lBM05xUWFIWDUvWUdha0VJZHlBQ2FpSU1RUXAzSWcxcUlBRWdDVUVLZHlJR2FpQWFJQWRCQ25jaVxuQjJvZ0F5QVhhaUFDSUJocUlBd2dDVUYvYzNJZ0IzTnFRYUhYNS9ZR2FrRU5keUFEYWlJQ0lBeEJmM055SUFaemFrR2gxK2YyQm1wQlxuQm5jZ0Iyb2lBeUFDUVg5emNpQU5jMnBCb2RmbjlnWnFRUVYzSUFacUlnY2dBMEYvYzNJZ0FrRUtkeUlKYzJwQm9kZm45Z1pxUVF4M1xuSUExcUlnd2dCMEYvYzNJZ0EwRUtkeUlEYzJwQm9kZm45Z1pxUVFkM0lBbHFJZzFCQ25jaUFtb2dHeUFIUVFwM0lnZHFJQWtnRVdvZ1xuRFNBTVFYOXpjaUFIYzJwQm9kZm45Z1pxUVFWM0lBTnFJZ2tnQWtGL2MzRnFJQU1nRkdvZ0RTQU1RUXAzSWdOQmYzTnhhaUFESUFseFxuYWtHa2hwR0hCMnRCQzNjZ0Iyb2lEQ0FDY1dwQnBJYVJod2RyUVF4M0lBTnFJZzBnREVFS2R5SUhRWDl6Y1dvZ0FpQUJJQU5xSUF3Z1xuQ1VFS2R5SUNRWDl6Y1dvZ0FpQU5jV3BCcElhUmh3ZHJRUTUzYWlJTUlBZHhha0draHBHSEIydEJEM2NnQW1vaUJrRUtkeUlEYWlBUlxuSUExQkNuY2lDV29nQWlBWWFpQU1JQWxCZjNOeGFpQUdJQWx4YWtHa2hwR0hCMnRCRG5jZ0Iyb2lEU0FEUVg5emNXb2dCeUFMYWlBR1xuSUF4QkNuY2lBa0YvYzNGcUlBSWdEWEZxUWFTR2tZY0hhMEVQZHlBSmFpSUpJQU54YWtHa2hwR0hCMnRCQ1hjZ0Ftb2lEQ0FKUVFwM1xuSWdkQmYzTnhhaUFDSUJacUlBa2dEVUVLZHlJQ1FYOXpjV29nQWlBTWNXcEJwSWFSaHdkclFRaDNJQU5xSWcwZ0IzRnFRYVNHa1ljSFxuYTBFSmR5QUNhaUlHUVFwM0lnTnFJQklnREVFS2R5SUphaUFDSUJ4cUlBMGdDVUYvYzNGcUlBWWdDWEZxUWFTR2tZY0hhMEVPZHlBSFxuYWlJTUlBTkJmM054YWlBSElCVnFJQVlnRFVFS2R5SUNRWDl6Y1dvZ0FpQU1jV3BCcElhUmh3ZHJRUVYzSUFscUlna2dBM0ZxUWFTR1xua1ljSGEwRUdkeUFDYWlJTklBbEJDbmNpQjBGL2MzRnFJQUlnQ21vZ0NTQU1RUXAzSWdKQmYzTnhhaUFDSUExeGFrR2tocEdIQjJ0QlxuQ0hjZ0Eyb2lEQ0FIY1dwQnBJYVJod2RyUVFaM0lBSnFJZ1pCQ25jaURtb2dHQ0FNUVFwM0lnTnFJQU1nRmlBTlFRcDNJZ2xxSUFjZ1xuR1dvZ0JpQURRWDl6Y1dvZ0FpQVhhaUFNSUFsQmYzTnhhaUFHSUFseGFrR2tocEdIQjJ0QkJYY2dCMm9pQWlBRGNXcEJwSWFSaHdkclxuUVF4M0lBbHFJZ01nQWlBT1FYOXpjbk5xUWJLRnNMVUZhMEVKZDJvaUJ5QURJQUpCQ25jaUFrRi9jM0p6YWtHeWhiQzFCV3RCRDNjZ1xuRG1vaUNTQUhJQU5CQ25jaUEwRi9jM0p6YWtHeWhiQzFCV3RCQlhjZ0Ftb2lERUVLZHlJTmFpQVpJQWxCQ25jaUJtb2dFU0FIUVFwM1xuSWdkcUlBTWdGV29nQWlBYmFpQU1JQWtnQjBGL2MzSnpha0d5aGJDMUJXdEJDM2NnQTJvaUFpQU1JQVpCZjNOeWMycEJzb1d3dFFWclxuUVFaM0lBZHFJZ01nQWlBTlFYOXpjbk5xUWJLRnNMVUZhMEVJZHlBR2FpSUhJQU1nQWtFS2R5SUNRWDl6Y25OcVFiS0ZzTFVGYTBFTlxuZHlBTmFpSUpJQWNnQTBFS2R5SURRWDl6Y25OcVFiS0ZzTFVGYTBFTWR5QUNhaUlNUVFwM0lnMXFJQXNnQ1VFS2R5SUdhaUFjSUFkQlxuQ25jaUIyb2dBeUFVYWlBQ0lBcHFJQXdnQ1NBSFFYOXpjbk5xUWJLRnNMVUZhMEVGZHlBRGFpSUNJQXdnQmtGL2MzSnpha0d5aGJDMVxuQld0QkRIY2dCMm9pQXlBQ0lBMUJmM055YzJwQnNvV3d0UVZyUVExM0lBWnFJZ2NnQXlBQ1FRcDNJZ2xCZjNOeWMycEJzb1d3dFFWclxuUVE1M0lBMXFJZ3dnQnlBRFFRcDNJZ05CZjNOeWMycEJzb1d3dFFWclFRdDNJQWxxSWcxQkNuY2lJaUFFYWlBS0lBc2dHeUFZSUJZZ1xuR0NBQklCd2dGQ0FTSUJnZ0VTQVNJQmtnSUNBZklBUkJmM055SUIxemFpQVRha0htbDRxRkJXcEJDSGNnSG1vaUFrRUtkeUlHYWlBSVxuSUJ0cUlBVWdHR29nQkNBVmFpQWVJQUlnSFNBRlFYOXpjbk5xSUFwcVFlYVhpb1VGYWtFSmR5QUVhaUlFSUFJZ0NFRi9jM0p6YWtIbVxubDRxRkJXcEJDWGNnQldvaUJTQUVJQVpCZjNOeWMycEI1cGVLaFFWcVFRdDNJQWhxSWdnZ0JTQUVRUXAzSWdSQmYzTnljMnBCNXBlS1xuaFFWcVFRMTNJQVpxSWdJZ0NDQUZRUXAzSWdWQmYzTnljMnBCNXBlS2hRVnFRUTkzSUFScUlnWkJDbmNpRG1vZ0Z5QUNRUXAzSWc5cVxuSUJvZ0NFRUtkeUlJYWlBRklCWnFJQUVnQkdvZ0JpQUNJQWhCZjNOeWMycEI1cGVLaFFWcVFROTNJQVZxSWdRZ0JpQVBRWDl6Y25OcVxuUWVhWGlvVUZha0VGZHlBSWFpSUZJQVFnRGtGL2MzSnpha0htbDRxRkJXcEJCM2NnRDJvaUNDQUZJQVJCQ25jaUJFRi9jM0p6YWtIbVxubDRxRkJXcEJCM2NnRG1vaUFpQUlJQVZCQ25jaUJVRi9jM0p6YWtIbWw0cUZCV3BCQ0hjZ0JHb2lCa0VLZHlJT2FpQWNJQUpCQ25jaVxuRDJvZ0VDQUlRUXAzSWdocUlBVWdGR29nQkNBTGFpQUdJQUlnQ0VGL2MzSnpha0htbDRxRkJXcEJDM2NnQldvaUJDQUdJQTlCZjNOeVxuYzJwQjVwZUtoUVZxUVE1M0lBaHFJZ1VnQkNBT1FYOXpjbk5xUWVhWGlvVUZha0VPZHlBUGFpSUlJQVVnQkVFS2R5SUNRWDl6Y25OcVxuUWVhWGlvVUZha0VNZHlBT2FpSUdJQWdnQlVFS2R5SU9RWDl6Y25OcVFlYVhpb1VGYWtFR2R5QUNhaUlQUVFwM0lnUnFJQndnQ0VFS1xuZHlJRmFpQUNJQmRxSUFZZ0JVRi9jM0ZxSUFVZ0QzRnFRYVNpdCtJRmFrRUpkeUFPYWlJQ0lBUkJmM054YWlBRklBRWdEbW9nRHlBR1xuUVFwM0lnVkJmM054YWlBQ0lBVnhha0drb3JmaUJXcEJEWGRxSWdZZ0JIRnFRYVNpdCtJRmFrRVBkeUFGYWlJT0lBWkJDbmNpQ0VGL1xuYzNGcUlBUWdCU0FWYWlBR0lBSkJDbmNpQkVGL2MzRnFJQVFnRG5GcVFhU2l0K0lGYWtFSGQyb2lCaUFJY1dwQnBLSzM0Z1ZxUVF4M1xuSUFScUlnOUJDbmNpQldvZ0VDQU9RUXAzSWdKcUlBUWdHbW9nQmlBQ1FYOXpjV29nQWlBUGNXcEJwS0szNGdWcVFRaDNJQWhxSWc0Z1xuQlVGL2MzRnFJQWdnRTJvZ0R5QUdRUXAzSWdSQmYzTnhhaUFFSUE1eGFrR2tvcmZpQldwQkNYY2dBbW9pQWlBRmNXcEJwS0szNGdWcVxuUVF0M0lBUnFJZ1lnQWtFS2R5SUlRWDl6Y1dvZ0JDQUthaUFDSUE1QkNuY2lCRUYvYzNGcUlBUWdCbkZxUWFTaXQrSUZha0VIZHlBRlxuYWlJT0lBaHhha0drb3JmaUJXcEJCM2NnQkdvaUQwRUtkeUlGYWlBV0lBWkJDbmNpQW1vZ0JDQUxhaUFPSUFKQmYzTnhhaUFDSUE5eFxuYWtHa29yZmlCV3BCREhjZ0NHb2lCaUFGUVg5emNXb2dDQ0FSYWlBUElBNUJDbmNpQkVGL2MzRnFJQVFnQm5GcVFhU2l0K0lGYWtFSFxuZHlBQ2FpSUNJQVZ4YWtHa29yZmlCV3BCQm5jZ0JHb2lEaUFDUVFwM0lnaEJmM054YWlBRUlCdHFJQUlnQmtFS2R5SUVRWDl6Y1dvZ1xuQkNBT2NXcEJwS0szNGdWcVFROTNJQVZxSWdJZ0NIRnFRYVNpdCtJRmFrRU5keUFFYWlJR1FRcDNJZzlxSUJRZ0FrRUtkeUloYWlBVFxuSUE1QkNuY2lCV29nQ0NBU2FpQUVJQmxxSUFJZ0JVRi9jM0ZxSUFVZ0JuRnFRYVNpdCtJRmFrRUxkeUFJYWlJRUlBWkJmM055SUNGelxuYWtIei9jRHJCbXBCQ1hjZ0JXb2lCU0FFUVg5emNpQVBjMnBCOC8zQTZ3WnFRUWQzSUNGcUlnZ2dCVUYvYzNJZ0JFRUtkeUlFYzJwQlxuOC8zQTZ3WnFRUTkzSUE5cUlnSWdDRUYvYzNJZ0JVRUtkeUlGYzJwQjgvM0E2d1pxUVF0M0lBUnFJZ1pCQ25jaURtb2dHeUFDUVFwM1xuSWc5cUlCY2dDRUVLZHlJSWFpQUZJQXBxSUFRZ0ZXb2dCaUFDUVg5emNpQUljMnBCOC8zQTZ3WnFRUWgzSUFWcUlnUWdCa0YvYzNJZ1xuRDNOcVFmUDl3T3NHYWtFR2R5QUlhaUlGSUFSQmYzTnlJQTV6YWtIei9jRHJCbXBCQm5jZ0Qyb2lDQ0FGUVg5emNpQUVRUXAzSWdSelxuYWtIei9jRHJCbXBCRG5jZ0Rtb2lBaUFJUVg5emNpQUZRUXAzSWdWemFrSHovY0RyQm1wQkRIY2dCR29pQmtFS2R5SU9haUFRSUFKQlxuQ25jaUQyb2dHU0FJUVFwM0lnaHFJQVVnRVdvZ0JDQUxhaUFHSUFKQmYzTnlJQWh6YWtIei9jRHJCbXBCRFhjZ0JXb2lCQ0FHUVg5elxuY2lBUGMycEI4LzNBNndacVFRVjNJQWhxSWdVZ0JFRi9jM0lnRG5OcVFmUDl3T3NHYWtFT2R5QVBhaUlJSUFWQmYzTnlJQVJCQ25jaVxuQkhOcVFmUDl3T3NHYWtFTmR5QU9haUlDSUFoQmYzTnlJQVZCQ25jaUJYTnFRZlA5d09zR2FrRU5keUFFYWlJR1FRcDNJZzVxSUFVZ1xuR21vZ0FrRUtkeUlQSUFVZ0JDQVdhaUFJUVFwM0lnVWdCaUFDUVg5emNuTnFRZlA5d09zR2FrRUhkMm9pQ0NBR1FYOXpjbk5xUWZQOVxud09zR2FrRUZkeUFGYWlJRVFRcDNJZ0lnRHlBWGFpQUlRUXAzSWdZZ0JTQUxhaUFPSUFSQmYzTnhhaUFFSUFoeGFrSHA3YlhUQjJwQlxuRDNjZ0Qyb2lDMEYvYzNGcUlBUWdDM0ZxUWVudHRkTUhha0VGZHlBT2FpSUVRWDl6Y1dvZ0JDQUxjV3BCNmUyMTB3ZHFRUWgzSUFacVxuSWdWQkNuY2lDR29nQWlBY2FpQUVRUXAzSWc0Z0FpQUdJQlJxSUF0QkNuY2lBaUFGUVg5emNXb2dCQ0FGY1dwQjZlMjEwd2RxUVF0M1xuYWlJTFFYOXpjV29nQlNBTGNXcEI2ZTIxMHdkcVFRNTNJQUpxSWdSQkNuY2lCaUFPSUJKcUlBdEJDbmNpRHlBQklBSnFJQWdnQkVGL1xuYzNGcUlBUWdDM0ZxUWVudHRkTUhha0VPZHlBT2FpSUxRWDl6Y1dvZ0JDQUxjV3BCNmUyMTB3ZHFRUVozSUFocUlnUkJmM054YWlBRVxuSUF0eGFrSHA3YlhUQjJwQkRuY2dEMm9pQlVFS2R5SUlhaUFHSUJGcUlBUkJDbmNpQWlBR0lBOGdFMm9nQzBFS2R5SUdJQVZCZjNOeFxuYWlBRUlBVnhha0hwN2JYVEIycEJCbmRxSWd0QmYzTnhhaUFGSUF0eGFrSHA3YlhUQjJwQkNYY2dCbW9pQkVFS2R5SU9JQUlnR21vZ1xuQzBFS2R5SVBJQVlnR1dvZ0NDQUVRWDl6Y1dvZ0JDQUxjV3BCNmUyMTB3ZHFRUXgzSUFKcUlndEJmM054YWlBRUlBdHhha0hwN2JYVFxuQjJwQkNYY2dDR29pQkVGL2MzRnFJQVFnQzNGcVFlbnR0ZE1IYWtFTWR5QVBhaUlGUVFwM0lnZ2dFbW9nQ2lBTFFRcDNJZ3RxSUFnZ1xuRGlBUWFpQUVRUXAzSWdJZ0R5QVZhaUFMSUFWQmYzTnhhaUFFSUFWeGFrSHA3YlhUQjJwQkJYY2dEbW9pQ2tGL2MzRnFJQVVnQ25GcVxuUWVudHRkTUhha0VQZHlBTGFpSUxRWDl6Y1dvZ0NpQUxjV3BCNmUyMTB3ZHFRUWgzSUFKcUlnUWdDMEVLZHlJRmN5QUNJQkZxSUFzZ1xuQ2tFS2R5SUtjeUFFYzJwQkNIY2dDR29pQzNOcVFRVjNJQXBxSWhGQkNuY2lDR29nRkNBRVFRcDNJaFJxSUFvZ0VHb2dDeUFVY3lBUlxuYzJwQkRIY2dCV29pQ2lBSWN5QUZJQlpxSUJFZ0MwRUtkeUlRY3lBS2MycEJDWGNnRkdvaUMzTnFRUXgzSUJCcUloUWdDMEVLZHlJV1xuY3lBUUlCTnFJQXNnQ2tFS2R5SUtjeUFVYzJwQkJYY2dDR29pRUhOcVFRNTNJQXBxSWhOQkNuY2lDMm9nRkVFS2R5SVVJQmxxSUFvZ1xuRldvZ0VDQVVjeUFUYzJwQkJuY2dGbW9pQ2lBTGN5QVdJQmRxSUJNZ0VFRUtkeUlRY3lBS2MycEJDSGNnRkdvaUUzTnFRUTEzSUJCcVxuSWhVZ0UwRUtkeUlVY3lBUUlCcHFJQk1nQ2tFS2R5SUtjeUFWYzJwQkJuY2dDMm9pRUhOcVFRVjNJQXBxSWhOQkNuY2lDMm8yQWdnZ1xuQUNBS0lCaHFJQkFnRlVFS2R5SUtjeUFUYzJwQkQzY2dGR29pRlVFS2R5SVpJQjhnQ1NBWGFpQU5JQXdnQjBFS2R5SVhRWDl6Y25OcVxuUWJLRnNMVUZhMEVJZHlBRGFpSVlRUXAzYW1vMkFnUWdBQ0FkSUFNZ0Vtb2dHQ0FOSUF4QkNuY2lGa0YvYzNKemFrR3loYkMxQld0QlxuQlhjZ0Yyb2lFV29nRkNBY2FpQVRJQkJCQ25jaUVITWdGWE5xUVExM0lBcHFJaE5CQ25kcU5nSUFJQUFnQ2lBYmFpQUxJQlZ6SUJOelxuYWtFTGR5QVFhaUlLSUJZZ0lHb2dGeUFhYWlBUklCZ2dJa0YvYzNKemFrR3loYkMxQld0QkJuZHFhallDRUNBQUlCWWdIbW9nQzJvZ1xuQVNBUWFpQVRJQmx6SUFwemFrRUxkMm8yQWd3TC9DY0JLWDVCZjBFQUlBSTFBZ0FpRXlBQk5RSUFJaEYrSWhWQy8vLy8vdytESWhaQ1xuLy8vLy93OStJZ2hDSUlnaUZDQUlRdi8vLy84UGd5SUdmQ0lYSUJkQ0lJaDhJZ05DSUlnZ0ZId2dBalVDRENJSUlCRitJZ1ZDLy8vL1xuL3crRElBSTFBZ2dpRGlBUmZpSVBRaUNJZkNBUFF2Ly8vLzhQZ3lBQ05RSUVJZzhnRVg0aUNVSWdpSHdnQ1VMLy8vLy9ENE1nRlVJZ1xuaUh3aUZVSWdpSHdpQ1VJZ2lId2lFa0wvLy8vL0Q0TjhJQWxDLy8vLy93K0RJQlZDLy8vLy93K0RJQVlnRm54Q0lJaDhJQmRDLy8vL1xuL3crRGZDSUpRaUNJZkNBRFF2Ly8vLzhQZzN3aUcwSWdpSHdpRUVJZ2lDQUNOUUlRSWhjZ0VYNGlBMEwvLy8vL0Q0TWdCVUlnaUh3Z1xuRWtJZ2lId2lCVUwvLy8vL0Q0TjhJaEpDSUlnZ0FqVUNGQ0lWSUJGK0lpQkMvLy8vL3crRElBTkNJSWg4SUFWQ0lJaDhJZ05DLy8vL1xuL3crRGZDSUZRaUNJSUJaOElBSTFBaGdpRmlBUmZpSVlRdi8vLy84UGd5QWdRaUNJZkNBRFFpQ0lmQ0lnUXYvLy8vOFBnM3dpR1VML1xuLy8vL0Q0TWdGeUFCTlFJRUlnTitJZzFDSUlnZ0F5QVZmaUljUXYvLy8vOFBnM3dnRFVMLy8vLy9ENE1nQXlBSWZpSU5RaUNJZkNBTlxuUXYvLy8vOFBneUFESUE1K0lnMUNJSWg4SUExQy8vLy8vdytESUFNZ0QzNGlEVUlnaUh3Z0RVTC8vLy8vRDRNZ0F5QVRmaUlOUWlDSVxuZkNJS1FpQ0lmQ0lMUWlDSWZDSU1RaUNJZkNJYVFpQ0lmQ0lkUXYvLy8vOFBnM3dnQlVMLy8vLy9ENE1nR2tMLy8vLy9ENE44SUJKQ1xuLy8vLy93K0RJQXhDLy8vLy93K0RmQ0FMUXYvLy8vOFBneUFLUXYvLy8vOFBneUFKUXYvLy8vOFBneUFOUXYvLy8vOFBnM3dpQlVJZ1xuaUh3Z0cwTC8vLy8vRDROOElnbENJSWg4SUJCQy8vLy8vdytEZkNJU1FpQ0lmQ0lRUWlDSWZDSWJRaUNJZkNJTlF2Ly8vLzhQZ3lBYlxuUXYvLy8vOFBneUFTUXYvLy8vOFBneUFKUXYvLy8vOFBneUFGUXYvLy8vOFBneUlKUXYvLy8vOFBmaUlGUXYvLy8vOFBneUlTSUFsOFxuUWlDSWZDQUZRaUNJSWhzZ0Vud2lCVUwvLy8vL0Q0TjhJZ3BDSUloOElBVWdCVUlnaUh3aUJVTC8vLy8vRDROOElndENJSWdnQlVJZ1xuaUNBYmZId2dFRUwvLy8vL0Q0TjhJaEJDSUloOElneENJSWg4SWhwQy8vLy8vdytESUFnZ0FUVUNDQ0lGZmlJSFFpQ0lJQVVnRjM0aVxuSGtMLy8vLy9ENE44SUFkQy8vLy8vdytESUFVZ0RuNGlCMElnaUh3Z0IwTC8vLy8vRDRNZ0JTQVBmaUlIUWlDSWZDQUhRdi8vLy84UFxuZ3lBRklCTitJZ2RDSUloOElpRkNJSWg4SWlKQ0lJaDhJaU5DSUloOEloOUMvLy8vL3crRGZDQU1Rdi8vLy84UGd5QWpRdi8vLy84UFxuZzN3Z0lrTC8vLy8vRDRNZ0lVTC8vLy8vRDRNZ0NrTC8vLy8vRDRNZ0IwTC8vLy8vRDROOElncENJSWg4SUF0Qy8vLy8vdytEZkNJTFxuUWlDSWZDQVFRdi8vLy84UGczd2lFRUlnaUh3aURFSWdpSHdpQjBJZ2lDQUZJQlYrSWlGQy8vLy8vdytESUI1Q0lJaDhJQjlDSUloOFxuSWg1Qy8vLy8vdytEZkNBYVFpQ0lJQWw4SUJsQ0lJZ2dCbndnRVNBQ05RSWNJaEYrSWhsQy8vLy8vdytESUJoQ0lJaDhJQ0JDSUloOFxuSWhoQy8vLy8vdytEZkNJYVF2Ly8vLzhQZ3lBRElCWitJaUpDLy8vLy93K0RJQnhDSUloOElCMUNJSWg4SWh4Qy8vLy8vdytEZkNBTlxuUWlDSWZDSU5Rdi8vLy84UGczd2lIVUwvLy8vL0Q0TjhJaU5DLy8vLy93K0RJQWRDLy8vLy93K0RJQkJDLy8vLy93K0RJQXRDLy8vL1xuL3crRElBcEMvLy8vL3crRElnbEMvLy8vL3c5K0lnWkMvLy8vL3crREloQWdDWHhDSUloOElBWkNJSWdpSUNBUWZDSUdRdi8vLy84UFxuZzN3aUNrSWdpSHdnQmlBR1FpQ0lmQ0lHUXYvLy8vOFBnM3dpQzBJZ2lDQUdRaUNJSUNCOGZDQU1Rdi8vLy84UGczd2lERUlnaUh3aVxuQjBJZ2lId2lIMEwvLy8vL0Q0TWdDQ0FCTlFJTUlnWitJZ1JDSUlnZ0JpQVhmaUlrUXYvLy8vOFBnM3dnQkVMLy8vLy9ENE1nQmlBT1xuZmlJRVFpQ0lmQ0FFUXYvLy8vOFBneUFHSUE5K0lnUkNJSWg4SUFSQy8vLy8vdytESUFZZ0UzNGlCRUlnaUh3aUpVSWdpSHdpSjBJZ1xuaUh3aUprSWdpSHdpS0VMLy8vLy9ENE44SUFkQy8vLy8vdytESUNaQy8vLy8vdytEZkNBblF2Ly8vLzhQZ3lBbFF2Ly8vLzhQZ3lBS1xuUXYvLy8vOFBneUFFUXYvLy8vOFBnM3dpQ2tJZ2lId2dDMEwvLy8vL0Q0TjhJZ3RDSUloOElBeEMvLy8vL3crRGZDSU1RaUNJZkNJSFxuUWlDSWZDSUVRaUNJSUFZZ0ZYNGlKVUwvLy8vL0Q0TWdKRUlnaUh3Z0tFSWdpSHdpSkVMLy8vLy9ENE44SUI5Q0lJZ2dDWHdnQlNBV1xuZmlJZlF2Ly8vLzhQZ3lBaFFpQ0lmQ0FlUWlDSWZDSWVRdi8vLy84UGd5QWpRaUNJZkNBZFFpQ0lJQko4SUJoQ0lJZ2dHVUlnaUh3Z1xuRkh3Z0drSWdpSHdpR0VMLy8vLy9ENE1nQXlBUmZpSVpRdi8vLy84UGd5QWlRaUNJZkNBY1FpQ0lmQ0ljUXYvLy8vOFBnM3dnRFVJZ1xuaUh3aURVTC8vLy8vRDROOElocEMvLy8vL3crRGZDSWRRdi8vLy84UGczd2lJVUwvLy8vL0Q0TjhJaUpDLy8vLy93K0RJQVJDLy8vL1xuL3crRElBeEMvLy8vL3crRElBdEMvLy8vL3crRElBcEMvLy8vL3crREloUkMvLy8vL3c5K0lnTkMvLy8vL3crRElna2dGSHhDSUloOFxuSUFOQ0lJZ2lFaUFKZkNJRFF2Ly8vLzhQZzN3aUNrSWdpSHdnQXlBRFFpQ0lmQ0lEUXYvLy8vOFBnM3dpQzBJZ2lDQURRaUNJSUJKOFxuZkNBSFF2Ly8vLzhQZzN3aURFSWdpSHdpQjBJZ2lId2lJMEwvLy8vL0Q0TWdDQ0FCTlFJUUlnTitJZ1JDSUlnZ0F5QVhmaUluUXYvL1xuLy84UGczd2dCRUwvLy8vL0Q0TWdBeUFPZmlJRVFpQ0lmQ0FFUXYvLy8vOFBneUFESUE5K0lnUkNJSWg4SUFSQy8vLy8vdytESUFNZ1xuRTM0aUJFSWdpSHdpSmtJZ2lId2lLRUlnaUh3aUtVSWdpSHdpS2tMLy8vLy9ENE44SUFkQy8vLy8vdytESUNsQy8vLy8vdytEZkNBb1xuUXYvLy8vOFBneUFtUXYvLy8vOFBneUFLUXYvLy8vOFBneUFFUXYvLy8vOFBnM3dpQ2tJZ2lId2dDMEwvLy8vL0Q0TjhJZ3RDSUloOFxuSUF4Qy8vLy8vdytEZkNJTVFpQ0lmQ0lIUWlDSWZDSUVRaUNJSUFNZ0ZYNGlKa0wvLy8vL0Q0TWdKMElnaUh3Z0trSWdpSHdpSjBML1xuLy8vL0Q0TjhJQ05DSUlnZ0ZId2dCaUFXZmlJalF2Ly8vLzhQZ3lBbFFpQ0lmQ0FrUWlDSWZDSWtRdi8vLy84UGd5QWlRaUNJZkNBaFxuUWlDSUlCQjhJQVVnRVg0aUlVTC8vLy8vRDRNZ0gwSWdpSHdnSGtJZ2lId2lIa0wvLy8vL0Q0TWdIVUlnaUh3Z0drSWdpQ0FiZkNBY1xuUWlDSUlCbENJSWg4SUJoQ0lJaDhJQTFDSUloOEloaEMvLy8vL3crRGZDSVpRdi8vLy84UGczd2lEVUwvLy8vL0Q0TjhJaHhDLy8vL1xuL3crRGZDSWFRdi8vLy84UGczd2lIVUwvLy8vL0Q0TjhJaUpDLy8vLy93K0RJQVJDLy8vLy93K0RJQXhDLy8vLy93K0RJQXRDLy8vL1xuL3crRElBcEMvLy8vL3crREloUkMvLy8vL3c5K0lnVkMvLy8vL3crREloc2dGSHhDSUloOElBVkNJSWdpRUNBYmZDSUZRdi8vLy84UFxuZzN3aUNrSWdpSHdnQlNBRlFpQ0lmQ0lGUXYvLy8vOFBnM3dpQzBJZ2lDQUZRaUNJSUJCOGZDQUhRdi8vLy84UGczd2lERUlnaUh3aVxuQjBJZ2lId2lIMEwvLy8vL0Q0TWdDQ0FCTlFJVUlnVitJZ1JDSUlnZ0JTQVhmaUlsUXYvLy8vOFBnM3dnQkVMLy8vLy9ENE1nQlNBT1xuZmlJRVFpQ0lmQ0FFUXYvLy8vOFBneUFGSUE5K0lnUkNJSWg4SUFSQy8vLy8vdytESUFVZ0UzNGlCRUlnaUh3aUtFSWdpSHdpS1VJZ1xuaUh3aUtrSWdpSHdpSzBMLy8vLy9ENE44SUFkQy8vLy8vdytESUNwQy8vLy8vdytEZkNBcFF2Ly8vLzhQZ3lBb1F2Ly8vLzhQZ3lBS1xuUXYvLy8vOFBneUFFUXYvLy8vOFBnM3dpQ2tJZ2lId2dDMEwvLy8vL0Q0TjhJZ3RDSUloOElBeEMvLy8vL3crRGZDSU1RaUNJZkNJSFxuUWlDSWZDSUVRaUNJSUFVZ0ZYNGlLRUwvLy8vL0Q0TWdKVUlnaUh3Z0swSWdpSHdpSlVMLy8vLy9ENE44SUI5Q0lJZ2dGSHdnQXlBV1xuZmlJZlF2Ly8vLzhQZ3lBbVFpQ0lmQ0FuUWlDSWZDSW5Rdi8vLy84UGd5QWlRaUNJZkNBZFFpQ0lJQWw4SUFZZ0VYNGlIVUwvLy8vL1xuRDRNZ0kwSWdpSHdnSkVJZ2lId2lJa0wvLy8vL0Q0TWdHa0lnaUh3Z0hFSWdpQ0FnZkNBZVFpQ0lJQ0ZDSUloOElCaENJSWg4SUJsQ1xuSUloOElBMUNJSWg4SWhoQy8vLy8vdytEZkNJWlF2Ly8vLzhQZzN3aURVTC8vLy8vRDROOEloeEMvLy8vL3crRGZDSWFRdi8vLy84UFxuZzN3aUhrTC8vLy8vRDROOElpRkMvLy8vL3crRElBUkMvLy8vL3crRElBeEMvLy8vL3crRElBdEMvLy8vL3crRElBcEMvLy8vL3crRFxuSWhSQy8vLy8vdzkrSWdaQy8vLy8vdytESWdrZ0ZIeENJSWg4SUFaQ0lJZ2lJQ0FKZkNJR1F2Ly8vLzhQZzN3aUNrSWdpSHdnQmlBR1xuUWlDSWZDSUdRdi8vLy84UGczd2lDMElnaUNBR1FpQ0lJQ0I4ZkNBSFF2Ly8vLzhQZzN3aURFSWdpSHdpQjBJZ2lId2lJMEwvLy8vL1xuRDRNZ0NDQUJOUUlZSWdaK0lnUkNJSWdnQmlBWGZpSWtRdi8vLy84UGczd2dCRUwvLy8vL0Q0TWdCaUFPZmlJRVFpQ0lmQ0FFUXYvL1xuLy84UGd5QUdJQTkrSWdSQ0lJaDhJQVJDLy8vLy93K0RJQVlnRTM0aUJFSWdpSHdpSmtJZ2lId2lLVUlnaUh3aUtrSWdpSHdpSzBML1xuLy8vL0Q0TjhJQWRDLy8vLy93K0RJQ3BDLy8vLy93K0RmQ0FwUXYvLy8vOFBneUFtUXYvLy8vOFBneUFLUXYvLy8vOFBneUFFUXYvL1xuLy84UGczd2lDa0lnaUh3Z0MwTC8vLy8vRDROOElndENJSWg4SUF4Qy8vLy8vdytEZkNJTVFpQ0lmQ0lIUWlDSWZDSUVRaUNJSUFZZ1xuRlg0aUprTC8vLy8vRDRNZ0pFSWdpSHdnSzBJZ2lId2lKRUwvLy8vL0Q0TjhJQ05DSUlnZ0ZId2dCU0FXZmlJalF2Ly8vLzhQZ3lBb1xuUWlDSWZDQWxRaUNJZkNJbFF2Ly8vLzhQZ3lBaFFpQ0lmQ0FlUWlDSUlCdDhJQU1nRVg0aUhrTC8vLy8vRDRNZ0gwSWdpSHdnSjBJZ1xuaUh3aUlVTC8vLy8vRDRNZ0drSWdpSHdnSEVJZ2lDQVNmQ0FpUWlDSUlCMUNJSWg4SUJoQ0lJaDhJQmxDSUloOElBMUNJSWg4SWhoQ1xuLy8vLy93K0RmQ0laUXYvLy8vOFBnM3dpRFVMLy8vLy9ENE44SWh4Qy8vLy8vdytEZkNJYVF2Ly8vLzhQZzN3aUhVTC8vLy8vRDROOFxuSWlKQy8vLy8vdytESUFSQy8vLy8vdytESUF4Qy8vLy8vdytESUF0Qy8vLy8vdytESUFwQy8vLy8vdytESWhSQy8vLy8vdzkrSWdOQ1xuLy8vLy93K0RJaElnRkh4Q0lJaDhJQU5DSUlnaUd5QVNmQ0lEUXYvLy8vOFBnM3dpQ2tJZ2lId2dBeUFEUWlDSWZDSURRdi8vLy84UFxuZzN3aUMwSWdpQ0FEUWlDSUlCdDhmQ0FIUXYvLy8vOFBnM3dpREVJZ2lId2lCMElnaUh3aUgwTC8vLy8vRDRNZ0NDQUJOUUljSWdOK1xuSWdoQ0lJZ2dBeUFYZmlJWFF2Ly8vLzhQZzN3Z0NFTC8vLy8vRDRNZ0F5QU9maUlJUWlDSWZDQUlRdi8vLy84UGd5QURJQTkrSWdoQ1xuSUloOElBaEMvLy8vL3crRElBTWdFMzRpRTBJZ2lId2lDRUlnaUh3aURrSWdpSHdpRDBJZ2lId2lCRUwvLy8vL0Q0TjhJQWRDLy8vL1xuL3crRElBOUMvLy8vL3crRGZDQU9Rdi8vLy84UGd5QUlRdi8vLy84UGd5QUtRdi8vLy84UGd5QVRRdi8vLy84UGczd2lFMElnaUh3Z1xuQzBMLy8vLy9ENE44SWdoQ0lJaDhJQXhDLy8vLy93K0RmQ0lPUWlDSWZDSUtRaUNJZkNJUFFpQ0lJQU1nRlg0aUMwTC8vLy8vRDRNZ1xuRjBJZ2lId2dCRUlnaUh3aURFTC8vLy8vRDROOElCOUNJSWdnRkh3Z0JpQVdmaUlIUXYvLy8vOFBneUFtUWlDSWZDQWtRaUNJZkNJZlxuUXYvLy8vOFBneUFpUWlDSWZDQWRRaUNJSUFsOElBVWdFWDRpQ1VMLy8vLy9ENE1nSTBJZ2lId2dKVUlnaUh3aUhVTC8vLy8vRDRNZ1xuR2tJZ2lId2dIRUlnaUNBUWZDQWhRaUNJSUI1Q0lJaDhJQmhDSUloOElCbENJSWg4SUExQ0lJaDhJaEJDLy8vLy93K0RmQ0lZUXYvL1xuLy84UGczd2lHVUwvLy8vL0Q0TjhJZzFDLy8vLy93K0RmQ0ljUXYvLy8vOFBnM3dpR2tMLy8vLy9ENE44SWg1Qy8vLy8vdytESUE5Q1xuLy8vLy93K0RJQTVDLy8vLy93K0RJQWhDLy8vLy93K0RJQk5DLy8vLy93K0RJaE5DLy8vLy93OStJZzVDLy8vLy93K0RJZ2dnRTN4Q1xuSUloOElBNUNJSWdpRGlBSWZDSVBRdi8vLy84UGczd2lGMElnaUh3Z0R5QVBRaUNJZkNJVlF2Ly8vLzhQZzN3aUQwSWdpQ0FWUWlDSVxuSUE1OGZDQUtRdi8vLy84UGczd2lGVUlnaUh3aUJVSWdpSHdpRkVJZ2lDQVRmQ0FESUJaK0loWkMvLy8vL3crRElBdENJSWg4SUF4Q1xuSUloOElncEMvLy8vL3crRElCNUNJSWg4SUJwQ0lJZ2dFbndnQmlBUmZpSUdRdi8vLy84UGd5QUhRaUNJZkNBZlFpQ0lmQ0lTUXYvL1xuLy84UGd5QWNRaUNJZkNBTlFpQ0lJQ0I4SUIxQ0lJZ2dDVUlnaUh3Z0VFSWdpSHdnR0VJZ2lId2dHVUlnaUh3aUNVTC8vLy8vRDROOFxuSWhCQy8vLy8vdytEZkNJZ1F2Ly8vLzhQZzN3aUdFTC8vLy8vRDROOElobEMvLy8vL3crRGZDSVRRaUNJSUFoOElBTWdFWDRpQ0VML1xuLy8vL0Q0TWdGa0lnaUh3Z0NrSWdpSHdpRmtMLy8vLy9ENE1nR1VJZ2lId2dHRUlnaUNBYmZDQVNRaUNJSUFaQ0lJaDhJQWxDSUloOFxuSUJCQ0lJaDhJQ0JDSUloOElnTkMvLy8vL3crRGZDSUdRdi8vLy84UGczd2lDVUwvLy8vL0Q0TjhJaEZDSUlnZ0Rud2dGa0lnaUNBSVxuUWlDSWZDQURRaUNJZkNBR1FpQ0lmQ0FKUWlDSWZDSU9Rdi8vLy84UGczd2lDRUlnaUNBT1FpQ0lmRUlBSUFoQy8vLy8vdytEUWdBZ1xuRVVMLy8vLy9ENE1nRTBMLy8vLy9ENE5DQUNBVVF2Ly8vLzhQZzBJQUlBVkMvLy8vL3crRFFnQWdGVUwvLy8vL0Q0TkNBQ0FQUXYvL1xuLy84UGcwSUFJQmRDLy8vLy93K0RRdi8vLy84UGZTSU9RaUNJZlVML0FZTjlRdi8vLy84UGZTSVdRaUNJZlVML0FZTjlRdi8vLy84UFxuZlNJRFFpQ0lmVUwvQVlOOUlnWkNJSWg5UXY4QmczMGlDVUlnaUgxQy93R0RmU0lTUWlDSVFnRjlRb0IraEh3aUcwSWdpSDFDL3dHRFxuZlVMLy8vLy9EMzBpRUVJZ2lIMUMvd0dEZlVJZ2lLZEIvd0Z4R3lJQlFYOXpJUUlnQUNBQ0lCQ25jU0FCSUFpbmNYSTJBaHdnQUNBQ1xuSUJ1bmNTQUJJQkduY1hJMkFoZ2dBQ0FDSUJLbmNTQUJJQk9uY1hJMkFoUWdBQ0FDSUFtbmNTQUJJQlNuY1hJMkFoQWdBQ0FDSUFhblxuY1NBQklBV25jWEkyQWd3Z0FDQUNJQU9uY1NBQklCV25jWEkyQWdnZ0FDQUNJQmFuY1NBQklBK25jWEkyQWdRZ0FDQUNJQTZuY1NBQlxuSUJlbmNYSTJBZ0FMb2lVQ0FYODFma0YvUVFBZ0FUVUNBQ0lGSUFWK0lneEMvLy8vL3crREloUkMvLy8vL3c5K0lnMUNJSWdpQ3lBTlxuUXYvLy8vOFBneUlYZkNJUElBOUNJSWg4SWhCQ0lJZ2dDM3dnQlNBQk5RSU1JZzErSWdOQy8vLy8vdytESWdvZ0JTQUJOUUlJSWc1K1xuSWdsQ0lJZ2lCSHdnQ1VMLy8vLy9ENE1pQ0NBRklBRTFBZ1FpQ1g0aUVVSWdpQ0lIZkNBUlF2Ly8vLzhQZ3lJUklBeENJSWg4SWd4Q1xuSUloOElnWkNJSWg4SWhKQy8vLy8vdytEZkNBR1F2Ly8vLzhQZ3lBTVF2Ly8vLzhQZ3lBVUlCZDhRaUNJZkNBUFF2Ly8vLzhQZzN3aVxuQmtJZ2lId2dFRUwvLy8vL0Q0TjhJaEJDSUloOEloTkNJSWdnQlNBQk5RSVFJZzkrSWhWQy8vLy8vdytESWhrZ0EwSWdpQ0lXZkNBU1xuUWlDSWZDSURRdi8vLy84UGczd2lFa0lnaUNBRklBRTFBaFFpREg0aUdrTC8vLy8vRDRNaUpDQVZRaUNJSWhWOElBTkNJSWg4SWdOQ1xuLy8vLy93K0RmQ0lZUWlDSUlCUjhJQVVnQVRVQ0dDSVVmaUliUXYvLy8vOFBneUl2SUJwQ0lJZ2lHbndnQTBJZ2lId2lIRUwvLy8vL1xuRDROOElpbEMvLy8vL3crRElBa2dESDRpSlVMLy8vLy9ENE1pS2lBSklBOStJZ05DSUlnaUhud2dBMEwvLy8vL0Q0TWlIeUFKSUExK1xuSWdOQ0lJZ2lKbndnQTBMLy8vLy9ENE1pSFNBSklBNStJZ05DSUlnaUozd2dBMEwvLy8vL0Q0TWlJQ0FKSUFsK0lnTkNJSWg4SUFjZ1xuQTBMLy8vLy9ENE44SWdOQ0lJaDhJZ2RDSUloOElpdENJSWg4SWlGQ0lJaDhJaWhDLy8vLy93K0RmQ0FZUXYvLy8vOFBneUFoUXYvL1xuLy84UGczd2dFa0wvLy8vL0Q0TWdLMEwvLy8vL0Q0TjhJQWRDLy8vLy93K0RJQU5DLy8vLy93K0RJQVpDLy8vLy93K0RJQkY4SWdOQ1xuSUloOElCQkMvLy8vL3crRGZDSVFRaUNJZkNBVFF2Ly8vLzhQZzN3aUVVSWdpSHdpQmtJZ2lId2lCMElnaUh3aUVrTC8vLy8vRDRNZ1xuQjBMLy8vLy9ENE1nRVVMLy8vLy9ENE1nRUVMLy8vLy9ENE1nQTBMLy8vLy9ENE1pRUVMLy8vLy9EMzRpRVVMLy8vLy9ENE1pQXlBUVxuZkVJZ2lId2dFVUlnaUNJUklBTjhJZ2RDLy8vLy93K0RmQ0lUUWlDSWZDQUhJQWRDSUloOElnZEMvLy8vL3crRGZDSVlRaUNJSUFkQ1xuSUlnZ0VYeDhJQVpDLy8vLy93K0RmQ0lIUWlDSWZDSUdRaUNJZkNJclF2Ly8vLzhQZ3lBT0lBOStJaUZDLy8vLy93K0RJakFnRFNBT1xuZmlJaVFpQ0lJaXg4SUNKQy8vLy8vdytESWlJZ0RpQU9maUlqUWlDSWZDQWpRdi8vLy84UGd5QW5mQ0FFSUNCOElnUkNJSWg4SWlkQ1xuSUloOElpQkNJSWg4SWlOQy8vLy8vdytEZkNBR1F2Ly8vLzhQZ3lBZ1F2Ly8vLzhQZzN3Z0owTC8vLy8vRDRNZ0JFTC8vLy8vRDRNZ1xuRTBMLy8vLy9ENE1nQ0h3aUJFSWdpSHdnR0VMLy8vLy9ENE44SWdoQ0lJaDhJQWRDLy8vLy93K0RmQ0lIUWlDSWZDSUdRaUNJZkNJVFxuUWlDSUlBd2dEbjRpR0VMLy8vLy9ENE1pSnlBaFFpQ0lJaUI4SUNOQ0lJaDhJaUZDLy8vLy93K0RmQ0FyUWlDSUlCQjhJQ2xDSUlnZ1xuRjN3Z0JTQUJOUUljSWhkK0lpbEMvLy8vL3crRElpc2dHMElnaUNJYmZDQWNRaUNJZkNJY1F2Ly8vLzhQZzN3aUkwTC8vLy8vRDRNZ1xuQ1NBVWZpSXhRdi8vLy84UGd5STFJQ1ZDSUlnaUpYd2dLRUlnaUh3aUtFTC8vLy8vRDROOElCSkNJSWg4SWhKQy8vLy8vdytEZkNJeVxuUXYvLy8vOFBnM3dpTFVMLy8vLy9ENE1nRTBMLy8vLy9ENE1nQjBMLy8vLy9ENE1nQ0VMLy8vLy9ENE1nQkVMLy8vLy9ENE1pQlVML1xuLy8vL0QzNGlCMEwvLy8vL0Q0TWlFQ0FGZkVJZ2lId2dCMElnaUNJSElCQjhJZ1JDLy8vLy93K0RmQ0lJUWlDSWZDQUVJQVJDSUloOFxuSWdSQy8vLy8vdytEZkNJVFFpQ0lJQVJDSUlnZ0IzeDhJQVpDLy8vLy93K0RmQ0lFUWlDSWZDSUdRaUNJZkNJelF2Ly8vLzhQZ3lBTlxuSUE5K0lpNUMvLy8vL3crRElqWWdEU0FOZmlJMFFpQ0lmQ0EwUXYvLy8vOFBneUFzZkNBaUlDWjhJQllnSFh3aUZrSWdpSHdpSmtJZ1xuaUh3aUhVSWdpSHdpSWtMLy8vLy9ENE44SUFaQy8vLy8vdytESUIxQy8vLy8vdytEZkNBbVF2Ly8vLzhQZ3lBV1F2Ly8vLzhQZ3lBSVxuUXYvLy8vOFBneUFLZkNJS1FpQ0lmQ0FUUXYvLy8vOFBnM3dpQ0VJZ2lId2dCRUwvLy8vL0Q0TjhJZ1JDSUloOElnWkNJSWg4SWhOQ1xuSUlnZ0RDQU5maUlXUXYvLy8vOFBneUltSUM1Q0lJZ2lIWHdnSWtJZ2lId2lJa0wvLy8vL0Q0TjhJRE5DSUlnZ0JYd2dEaUFVZmlJc1xuUXYvLy8vOFBneUl6SUJoQ0lJZ2lHSHdnSVVJZ2lId2lJVUwvLy8vL0Q0TWdMVUlnaUh3Z01rSWdpQ0FEZkNBcFFpQ0lJaWtnSEVJZ1xuaUh3Z0Mzd2dJMElnaUh3aUhFTC8vLy8vRDRNZ0NTQVhmaUlqUXYvLy8vOFBneUl5SURGQ0lJZ2lNWHdnS0VJZ2lId2lLRUwvLy8vL1xuRDROOElCSkNJSWg4SWhKQy8vLy8vdytEZkNJdFF2Ly8vLzhQZzN3aUxrTC8vLy8vRDROOElqUkMvLy8vL3crRGZDSTNRdi8vLy84UFxuZ3lBVFF2Ly8vLzhQZ3lBRVF2Ly8vLzhQZ3lBSVF2Ly8vLzhQZ3lBS1F2Ly8vLzhQZ3lJRlF2Ly8vLzhQZmlJTFF2Ly8vLzhQZ3lJSlxuSUFWOFFpQ0lmQ0FMUWlDSUlnc2dDWHdpQTBMLy8vLy9ENE44SWdSQ0lJaDhJQU1nQTBJZ2lId2lBMEwvLy8vL0Q0TjhJZ3BDSUlnZ1xuQTBJZ2lDQUxmSHdnQmtMLy8vLy9ENE44SWdOQ0lJaDhJZ2hDSUloOElnWkMvLy8vL3crRElBOGdEMzRpRTBMLy8vLy9ENE1nSFh3Z1xuSUNBMmZDQWVJREI4SUJVZ0gzd2lGVUlnaUh3aUhrSWdpSHdpSDBJZ2lId2lIVUwvLy8vL0Q0TjhJQWhDLy8vLy93K0RJQjlDLy8vL1xuL3crRGZDQWVRdi8vLy84UGd5QVZRdi8vLy84UGd5QUVRdi8vLy84UGd5QVpmQ0lFUWlDSWZDQUtRdi8vLy84UGczd2lDa0lnaUh3Z1xuQTBMLy8vLy9ENE44SWdOQ0lJaDhJZ2hDSUloOEloVkNJSWdnRENBUGZpSVpRdi8vLy84UGd5SWVJQk5DSUloOElCMUNJSWg4SWhOQ1xuLy8vLy93K0RmQ0FHUWlDSUlBVjhJQTBnRkg0aUJrTC8vLy8vRDRNaUh5QVdRaUNJSWhaOElDSkNJSWg4SWgxQy8vLy8vdytESURkQ1xuSUloOElEUkNJSWdnRUh3Z0RpQVhmaUlnUXYvLy8vOFBneUl3SUN4Q0lJZ2lJbndnSVVJZ2lId2lJVUwvLy8vL0Q0TWdMa0lnaUh3Z1xuTFVJZ2lDQVJmQ0FqUWlDSUloRWdLRUlnaUh3Z0hFSWdpSHdnRWtJZ2lId2lFa0wvLy8vL0Q0TjhJaHhDLy8vLy93K0RmQ0lvUXYvL1xuLy84UGczd2lMRUwvLy8vL0Q0TjhJaU5DLy8vLy93K0RmQ0l0UXYvLy8vOFBnM3dpTGtMLy8vLy9ENE1nRlVMLy8vLy9ENE1nQTBML1xuLy8vL0Q0TWdDa0wvLy8vL0Q0TWdCRUwvLy8vL0Q0TWlCVUwvLy8vL0QzNGlFRUwvLy8vL0Q0TWlEaUFGZkVJZ2lId2dFRUlnaUNJUVxuSUE1OElnTkMvLy8vL3crRGZDSUVRaUNJZkNBRElBTkNJSWg4SWdOQy8vLy8vdytEZkNJS1FpQ0lJQU5DSUlnZ0VIeDhJQWhDLy8vL1xuL3crRGZDSURRaUNJZkNJSVFpQ0lmQ0lWUXYvLy8vOFBneUFXSUI1OElCZ2dKbndnSlNBbmZDQWFJQ3A4SWhaQ0lJaDhJaHBDSUloOFxuSWhoQ0lJaDhJaVZDLy8vLy93K0RmQ0FJUXYvLy8vOFBneUFZUXYvLy8vOFBnM3dnR2tMLy8vLy9ENE1nRmtMLy8vLy9ENE1nQkVML1xuLy8vL0Q0TWdKSHdpQkVJZ2lId2dDa0wvLy8vL0Q0TjhJZ3BDSUloOElBTkMvLy8vL3crRGZDSURRaUNJZkNJSVFpQ0lmQ0lXUWlDSVxuSUJsQ0lJZ2lHU0FNSUF4K0locEMvLy8vL3crRGZDQWxRaUNJZkNJa1F2Ly8vLzhQZzN3Z0ZVSWdpQ0FGZkNBWklBOGdGSDRpRlVML1xuLy8vL0Q0TWlHWHdnRTBJZ2lId2lFMEwvLy8vL0Q0TWdMa0lnaUh3Z0xVSWdpQ0FKZkNBTklCZCtJaGhDLy8vLy93K0RJaVVnQmtJZ1xuaUNJR2ZDQWRRaUNJZkNJcVF2Ly8vLzhQZ3lBalFpQ0lmQ0FzUWlDSUlBZDhJQ0JDSUlnaUJ5QWhRaUNJZkNBU1FpQ0lmQ0FjUWlDSVxuZkNBb1FpQ0lmQ0lTUXYvLy8vOFBnM3dpSEVMLy8vLy9ENE44SWg1Qy8vLy8vdytEZkNJbVF2Ly8vLzhQZzN3aUhVTC8vLy8vRDROOFxuSWlkQy8vLy8vdytEZkNJZ1F2Ly8vLzhQZ3lBV1F2Ly8vLzhQZ3lBRFF2Ly8vLzhQZ3lBS1F2Ly8vLzhQZ3lBRVF2Ly8vLzhQZ3lJRlxuUXYvLy8vOFBmaUlKUXYvLy8vOFBneUlOSUFWOFFpQ0lmQ0FKUWlDSUlna2dEWHdpQTBMLy8vLy9ENE44SWdSQ0lJaDhJQU1nQTBJZ1xuaUh3aUEwTC8vLy8vRDROOElncENJSWdnQTBJZ2lDQUpmSHdnQ0VMLy8vLy9ENE44SWdOQ0lJaDhJZ2hDSUloOEloWkMvLy8vL3crRFxuSUFZZ0dYd2dIeUFpZkNBeElETjhJQnNnTlh3aUJrSWdpSHdpR1VJZ2lId2lHMElnaUh3aUgwTC8vLy8vRDROOElBaEMvLy8vL3crRFxuSUJ0Qy8vLy8vdytEZkNBWlF2Ly8vLzhQZ3lBR1F2Ly8vLzhQZ3lBRVF2Ly8vLzhQZ3lBdmZDSUVRaUNJZkNBS1F2Ly8vLzhQZzN3aVxuQ2tJZ2lId2dBMEwvLy8vL0Q0TjhJZ05DSUloOElnaENJSWg4SWdaQ0lJZ2dEQ0FVZmlJWlF2Ly8vLzhQZ3lJYklCVkNJSWdpRlh3Z1xuSDBJZ2lId2lMMEwvLy8vL0Q0TjhJQlpDSUlnZ0JYd2dHeUFhUWlDSWZDQWtRaUNJZkNJV1F2Ly8vLzhQZ3lBZ1FpQ0lmQ0FuUWlDSVxuSUE1OElCVWdEeUFYZmlJVlF2Ly8vLzhQZ3lJYWZDQVRRaUNJZkNJVFF2Ly8vLzhQZ3lBZFFpQ0lmQ0FtUWlDSUlBdDhJQmhDSUlnaVxuSkNBcVFpQ0lmQ0FTUWlDSWZDQWNRaUNJZkNBZVFpQ0lmQ0lTUXYvLy8vOFBnM3dpR0VMLy8vLy9ENE44SWh0Qy8vLy8vdytEZkNJY1xuUXYvLy8vOFBnM3dpS2tMLy8vLy9ENE44SWg1Qy8vLy8vdytEZkNJZlF2Ly8vLzhQZ3lBR1F2Ly8vLzhQZ3lBRFF2Ly8vLzhQZ3lBS1xuUXYvLy8vOFBneUFFUXYvLy8vOFBneUlGUXYvLy8vOFBmaUlQUXYvLy8vOFBneUlPSUFWOFFpQ0lmQ0FQUWlDSUlnOGdEbndpQzBML1xuLy8vL0Q0TjhJZ05DSUloOElBc2dDMElnaUh3aUMwTC8vLy8vRDROOElnUkNJSWdnQzBJZ2lDQVBmSHdnQ0VMLy8vLy9ENE44SWd0Q1xuSUloOElncENJSWg4SWdoQy8vLy8vdytESUJvZ0pId2dCeUFsZkNBUklEQjhJQ2tnTW53aUVVSWdpSHdpQjBJZ2lId2lCa0lnaUh3aVxuR2tMLy8vLy9ENE44SUFwQy8vLy8vdytESUFaQy8vLy8vdytEZkNBSFF2Ly8vLzhQZ3lBUlF2Ly8vLzhQZ3lBRFF2Ly8vLzhQZ3lBclxuZkNJRFFpQ0lmQ0FFUXYvLy8vOFBnM3dpRVVJZ2lId2dDMEwvLy8vL0Q0TjhJZ3RDSUloOElnZENJSWg4SWdSQ0lJZ2dEQ0FYZmlJS1xuUXYvLy8vOFBneUlNSUJWQ0lJZ2lCbndnR2tJZ2lId2lGVUwvLy8vL0Q0TjhJQWhDSUlnZ0JYd2dHVUlnaUNJRklCUWdGSDRpQ0VML1xuLy8vL0Q0TjhJQzlDSUloOElobEMvLy8vL3crRElCOUNJSWg4SUI1Q0lJZ2dEWHdnQlNBTWZDQVdRaUNJZkNJV1F2Ly8vLzhQZ3lBcVxuUWlDSWZDQWNRaUNJSUJCOElCTkNJSWdnQm53Z0VrSWdpSHdnR0VJZ2lId2dHMElnaUh3aUJrTC8vLy8vRDROOEloSkMvLy8vL3crRFxuZkNJVFF2Ly8vLzhQZzN3aUdrTC8vLy8vRDROOElpUkMvLy8vL3crRGZDSVlRdi8vLy84UGczd2lHMEwvLy8vL0Q0TWdCRUwvLy8vL1xuRDRNZ0MwTC8vLy8vRDRNZ0VVTC8vLy8vRDRNZ0EwTC8vLy8vRDRNaUJVTC8vLy8vRDM0aURFTC8vLy8vRDRNaURTQUZmRUlnaUh3Z1xuREVJZ2lDSU1JQTE4SWd0Qy8vLy8vdytEZkNJUVFpQ0lmQ0FMSUF0Q0lJaDhJZ05DLy8vLy93K0RmQ0lMUWlDSUlBTkNJSWdnREh4OFxuSUFkQy8vLy8vdytEZkNJRFFpQ0lmQ0lSUWlDSWZDSUhRaUNJSUFWOElCUWdGMzRpRkVMLy8vLy9ENE1pQlNBS1FpQ0lJZ1I4SUJWQ1xuSUloOElncEMvLy8vL3crRElCdENJSWg4SUJoQ0lJZ2dEbndnQlNBSVFpQ0lmQ0FaUWlDSWZDSU9Rdi8vLy84UGd5QWtRaUNJZkNBYVxuUWlDSUlBbDhJQlpDSUlnZ0JId2dCa0lnaUh3Z0VrSWdpSHdnRTBJZ2lId2lDVUwvLy8vL0Q0TjhJZ1JDLy8vLy93K0RmQ0lJUXYvL1xuLy84UGczd2lCa0wvLy8vL0Q0TjhJaEpDLy8vLy93K0RmQ0lGUWlDSUlBMThJQlJDSUlnaURTQVhJQmQrSWhSQy8vLy8vdytEZkNBS1xuUWlDSWZDSVhRdi8vLy84UGd5QVNRaUNJZkNBR1FpQ0lJQTk4SUE1Q0lJZ2dEWHdnQ1VJZ2lId2dCRUlnaUh3Z0NFSWdpSHdpRGtML1xuLy8vL0Q0TjhJZ2xDLy8vLy93K0RmQ0lQUXYvLy8vOFBnM3dpRFVJZ2lDQU1mQ0FYUWlDSUlCUkNJSWg4SUE1Q0lJaDhJQWxDSUloOFxuSUE5Q0lJaDhJZ2xDLy8vLy93K0RmQ0lPUWlDSUlBbENJSWg4UWdBZ0RrTC8vLy8vRDROQ0FDQU5Rdi8vLy84UGd5QUZRdi8vLy84UFxuZzBJQUlBZEMvLy8vL3crRFFnQWdFVUwvLy8vL0Q0TkNBQ0FEUXYvLy8vOFBnMElBSUF0Qy8vLy8vdytEUWdBZ0VFTC8vLy8vRDROQ1xuLy8vLy93OTlJZ2xDSUloOVF2OEJnMzFDLy8vLy93OTlJZzlDSUloOVF2OEJnMzFDLy8vLy93OTlJZ3hDSUloOVF2OEJnMzBpRkVJZ1xuaUgxQy93R0RmU0lYUWlDSWZVTC9BWU45SWdSQ0lJaENBWDFDZ0g2RWZDSUtRaUNJZlVML0FZTjlRdi8vLy84UGZTSUlRaUNJZlVML1xuQVlOOVFpQ0lwMEgvQVhFYklnRkJmM01oQWlBQUlBSWdDS2R4SUFFZ0RxZHhjallDSENBQUlBSWdDcWR4SUFFZ0RhZHhjallDR0NBQVxuSUFJZ0JLZHhJQUVnQmFkeGNqWUNGQ0FBSUFJZ0Y2ZHhJQUVnQjZkeGNqWUNFQ0FBSUFJZ0ZLZHhJQUVnRWFkeGNqWUNEQ0FBSUFJZ1xuREtkeElBRWdBNmR4Y2pZQ0NDQUFJQUlnRDZkeElBRWdDNmR4Y2pZQ0JDQUFJQUlnQ2FkeElBRWdFS2R4Y2pZQ0FBdTZLZ0VsZnlNQVxuUVlBQmF5SURKQUFnQTBFQVFjQUEvQXNBSUFFZ0FrRUdkR29oSnlBQUtBSWNJU01nQUNnQ0dDRWtJQUFvQWhRaEh5QUFLQUlRSVNBZ1xuQUNnQ0RDRWxJQUFvQWdnaEppQUFLQUlFSVNFZ0FDZ0NBQ0VpQTBBZ0FTQW5Sa1VFUUVFQUlRSURRQ0FDUWNBQVJrVUVRQ0FDSUFOcVxuSUFFZ0Ftb29BQUFpRDBFWWRDQVBRWUQrQTNGQkNIUnlJQTlCQ0haQmdQNERjU0FQUVJoMmNuSTJBZ0FnQWtFRWFpRUNEQUVGQ3dzZ1xuQXlnQ1BDRVZJQU1vQWpnaEZpQURLQUkwSVIwZ0F5Z0NNQ0VDSUFNb0Fpd2hGeUFES0FJb0lSZ2dBeWdDSkNFWklBTW9BaUFoRUNBRFxuS0FJY0lSb2dBeWdDR0NFYklBTW9BaFFoSENBREtBSVFJUkVnQXlnQ0RDRVBJQU1vQWdnaEVpQURLQUlFSVJNZ0F5Z0NBQ0VVSUFNZ1xuSmpZQ1lDQURJQ1UyQW1RZ0F5QWtOZ0pvSUFNZ0l6WUNiQ0FESUI4MkFud2dBeUFnTmdKNElBTWdJVFlDZENBRElDSTJBbkFnQTBIUVxuQUdvaUNTQURRZUFBYWlJS0lBTkI4QUJxSWdzZ0UwR1JpZDJKQjJvZ0ZFR1kzNmlVQkdvUWJ5QURLQUpRSVFRZ0F5Z0NWQ0VGSUFNb1xuQWxnaEJpQURLQUpjSVFjZ0F5QWZOZ0pzSUFNZ0lEWUNhQ0FESUNFMkFtUWdBeUFpTmdKZ0lBTWdCellDZkNBRElBWTJBbmdnQXlBRlxuTmdKMElBTWdCRFlDY0NBSklBb2dDeUFQUWR2SXFMSUJheUFTUWJHSS9ORUVheEJ2SUFNb0FsQWhDQ0FES0FKVUlRd2dBeWdDV0NFTlxuSUFNb0Fsd2hEaUFESUFjMkFtd2dBeUFHTmdKb0lBTWdCVFlDWkNBRElBUTJBbUFnQXlBT05nSjhJQU1nRFRZQ2VDQURJQXcyQW5RZ1xuQXlBSU5nSndJQWtnQ2lBTElCeEI4YVBFendWcUlCRkIyNFRieWdOcUVHOGdBeWdDVUNFRUlBTW9BbFFoQlNBREtBSllJUVlnQXlnQ1xuWENFSElBTWdEallDYkNBRElBMDJBbWdnQXlBTU5nSmtJQU1nQ0RZQ1lDQURJQWMyQW53Z0F5QUdOZ0o0SUFNZ0JUWUNkQ0FESUFRMlxuQW5BZ0NTQUtJQXNnR2tHcndvNm5CV3NnRzBIYytvSHVCbXNRYnlBREtBSlFJUWdnQXlnQ1ZDRU1JQU1vQWxnaERTQURLQUpjSVE0Z1xuQXlBSE5nSnNJQU1nQmpZQ2FDQURJQVUyQW1RZ0F5QUVOZ0pnSUFNZ0RqWUNmQ0FESUEwMkFuZ2dBeUFNTmdKMElBTWdDRFlDY0NBSlxuSUFvZ0N5QVpRWUcyalpRQmFpQVFRZWlxNGI4Q2F4QnZJQU1vQWxBaEJDQURLQUpVSVFVZ0F5Z0NXQ0VHSUFNb0Fsd2hCeUFESUE0MlxuQW13Z0F5QU5OZ0pvSUFNZ0REWUNaQ0FESUFnMkFtQWdBeUFITmdKOElBTWdCallDZUNBRElBVTJBblFnQXlBRU5nSndJQWtnQ2lBTFxuSUJkQncvdXhxQVZxSUJoQnZvdkdvUUpxRUc4Z0F5Z0NVQ0VJSUFNb0FsUWhEQ0FES0FKWUlRMGdBeWdDWENFT0lBTWdCellDYkNBRFxuSUFZMkFtZ2dBeUFGTmdKa0lBTWdCRFlDWUNBRElBNDJBbndnQXlBTk5nSjRJQU1nRERZQ2RDQURJQWcyQW5BZ0NTQUtJQXNnSFVHQ1xubklYNUIyc2dBa0gwdXZtVkIyb1FieUFES0FKUUlRUWdBeWdDVkNFRklBTW9BbGdoQmlBREtBSmNJUWNnQXlBT05nSnNJQU1nRFRZQ1xuYUNBRElBdzJBbVFnQXlBSU5nSmdJQU1nQnpZQ2ZDQURJQVkyQW5nZ0F5QUZOZ0owSUFNZ0JEWUNjQ0FKSUFvZ0N5QVZRWXlka1BNRFxuYXlBV1FkbnlqNkVHYXhCdklBTW9BbEFoQ0NBREtBSlVJUXdnQXlnQ1dDRU5JQU1vQWx3aERpQURJQlEyQWx3Z0F5QVROZ0pZSUFNZ1xuRWpZQ1ZDQURJQTgyQWxBZ0F5QVFOZ0pzSUFNZ0dUWUNhQ0FESUJnMkFtUWdBeUFYTmdKZ0lBTWdBallDZkNBRElCMDJBbmdnQXlBV1xuTmdKMElBTWdGVFlDY0NBRFFVQnJJaDRnQ1NBUklBb2dDeEJpSUFNb0FrQWhFaUFES0FKRUlSTWdBeWdDU0NFVUlBTW9Ba3doRHlBRFxuSUFjMkFtd2dBeUFHTmdKb0lBTWdCVFlDWkNBRElBUTJBbUFnQXlBT05nSjhJQU1nRFRZQ2VDQURJQXcyQW5RZ0F5QUlOZ0p3SUFrZ1xuQ2lBTElCUkIrdkNHZ2dGcklBOUJ2NnlTMndGckVHOGdBeWdDVUNFRUlBTW9BbFFoQlNBREtBSllJUVlnQXlnQ1hDRUhJQU1nRGpZQ1xuYkNBRElBMDJBbWdnQXlBTU5nSmtJQU1nQ0RZQ1lDQURJQWMyQW53Z0F5QUdOZ0o0SUFNZ0JUWUNkQ0FESUFRMkFuQWdDU0FLSUFzZ1xuRWtITXc3S2dBbW9nRTBIR3U0YitBR29RYnlBREtBSlFJUWdnQXlnQ1ZDRU1JQU1vQWxnaERTQURLQUpjSVE0Z0F5QVJOZ0pjSUFNZ1xuSERZQ1dDQURJQnMyQWxRZ0F5QWFOZ0pRSUFNZ0FqWUNiQ0FESUIwMkFtZ2dBeUFXTmdKa0lBTWdGVFlDWUNBRElBODJBbndnQXlBVVxuTmdKNElBTWdFellDZENBRElCSTJBbkFnSGlBSklCQWdDaUFMRUdJZ0F5Z0NRQ0VhSUFNb0FrUWhHeUFES0FKSUlSd2dBeWdDVENFUlxuSUFNZ0J6WUNiQ0FESUFZMkFtZ2dBeUFGTmdKa0lBTWdCRFlDWUNBRElBNDJBbndnQXlBTk5nSjRJQU1nRERZQ2RDQURJQWcyQW5BZ1xuQ1NBS0lBc2dIRUdxaWRMVEJHb2dFVUh2MktUdkFtb1FieUFES0FKUUlRUWdBeWdDVkNFRklBTW9BbGdoQmlBREtBSmNJUWNnQXlBT1xuTmdKc0lBTWdEVFlDYUNBRElBdzJBbVFnQXlBSU5nSmdJQU1nQnpZQ2ZDQURJQVkyQW5nZ0F5QUZOZ0owSUFNZ0JEWUNjQ0FKSUFvZ1xuQ3lBYVFkcVI1cmNIYWlBYlFkelR3dVVGYWhCdklBTW9BbEFoQ0NBREtBSlVJUXdnQXlnQ1dDRU5JQU1vQWx3aERpQURJQkEyQWx3Z1xuQXlBWk5nSllJQU1nR0RZQ1ZDQURJQmMyQWxBZ0F5QVBOZ0pzSUFNZ0ZEWUNhQ0FESUJNMkFtUWdBeUFTTmdKZ0lBTWdFVFlDZkNBRFxuSUJ3MkFuZ2dBeUFiTmdKMElBTWdHallDY0NBZUlBa2dBaUFLSUFzUVlpQURLQUpBSVJjZ0F5Z0NSQ0VZSUFNb0FrZ2hHU0FES0FKTVxuSVJBZ0F5QUhOZ0pzSUFNZ0JqWUNhQ0FESUFVMkFtUWdBeUFFTmdKZ0lBTWdEallDZkNBRElBMDJBbmdnQXlBTU5nSjBJQU1nQ0RZQ1xuY0NBSklBb2dDeUFaUVpQenVMNEZheUFRUWE3ZGhyNEdheEJ2SUFNb0FsQWhCQ0FES0FKVUlRVWdBeWdDV0NFR0lBTW9BbHdoQnlBRFxuSUE0MkFtd2dBeUFOTmdKb0lBTWdERFlDWkNBRElBZzJBbUFnQXlBSE5nSjhJQU1nQmpZQ2VDQURJQVUyQW5RZ0F5QUVOZ0p3SUFrZ1xuQ2lBTElCZEJ1WUNhaFFScklCaEJ1TER6L3dSckVHOGdBeWdDVUNFSUlBTW9BbFFoRENBREtBSllJUTBnQXlnQ1hDRU9JQU1nQWpZQ1xuWENBRElCMDJBbGdnQXlBV05nSlVJQU1nRlRZQ1VDQURJQkUyQW13Z0F5QWNOZ0pvSUFNZ0d6WUNaQ0FESUJvMkFtQWdBeUFRTmdKOFxuSUFNZ0dUWUNlQ0FESUJnMkFuUWdBeUFYTmdKd0lCNGdDU0FQSUFvZ0N4QmlJQU1vQWtBaEZTQURLQUpFSVJZZ0F5Z0NTQ0VkSUFNb1xuQWt3aEFpQURJQWMyQW13Z0F5QUdOZ0pvSUFNZ0JUWUNaQ0FESUFRMkFtQWdBeUFPTmdKOElBTWdEVFlDZUNBRElBdzJBblFnQXlBSVxuTmdKd0lBa2dDaUFMSUIxQnVkM2gwZ0pySUFKQmplai95QU5yRUc4Z0F5Z0NVQ0VFSUFNb0FsUWhCU0FES0FKWUlRWWdBeWdDWENFSFxuSUFNZ0RqWUNiQ0FESUEwMkFtZ2dBeUFNTmdKa0lBTWdDRFlDWUNBRElBYzJBbndnQXlBR05nSjRJQU1nQlRZQ2RDQURJQVEyQW5BZ1xuQ1NBS0lBc2dGVUhuMHFTaEFXb2dGa0hSeHFrMmFoQnZJQU1vQWxBaENDQURLQUpVSVF3Z0F5Z0NXQ0VOSUFNb0Fsd2hEaUFESUE4MlxuQWx3Z0F5QVVOZ0pZSUFNZ0V6WUNWQ0FESUJJMkFsQWdBeUFRTmdKc0lBTWdHVFlDYUNBRElCZzJBbVFnQXlBWE5nSmdJQU1nQWpZQ1xuZkNBRElCMDJBbmdnQXlBV05nSjBJQU1nRlRZQ2NDQWVJQWtnRVNBS0lBc1FZaUFES0FKQUlSSWdBeWdDUkNFVElBTW9Ba2doRkNBRFxuS0FKTUlROGdBeUFITmdKc0lBTWdCallDYUNBRElBVTJBbVFnQXlBRU5nSmdJQU1nRGpZQ2ZDQURJQTAyQW5nZ0F5QU1OZ0owSUFNZ1xuQ0RZQ2NDQUpJQW9nQ3lBVVFiakM3UEFDYWlBUFFZV1YzTDBDYWhCdklBTW9BbEFoQkNBREtBSlVJUVVnQXlnQ1dDRUdJQU1vQWx3aFxuQnlBRElBNDJBbXdnQXlBTk5nSm9JQU1nRERZQ1pDQURJQWcyQW1BZ0F5QUhOZ0o4SUFNZ0JqWUNlQ0FESUFVMkFuUWdBeUFFTmdKd1xuSUFrZ0NpQUxJQkpCazVyZ21RVnFJQk5CL051eDZRUnFFRzhnQXlnQ1VDRUlJQU1vQWxRaERDQURLQUpZSVEwZ0F5Z0NYQ0VPSUFNZ1xuRVRZQ1hDQURJQncyQWxnZ0F5QWJOZ0pVSUFNZ0dqWUNVQ0FESUFJMkFtd2dBeUFkTmdKb0lBTWdGallDWkNBRElCVTJBbUFnQXlBUFxuTmdKOElBTWdGRFlDZUNBRElCTTJBblFnQXlBU05nSndJQjRnQ1NBUUlBb2dDeEJpSUFNb0FrQWhHaUFES0FKRUlSc2dBeWdDU0NFY1xuSUFNb0Frd2hFU0FESUFjMkFtd2dBeUFHTmdKb0lBTWdCVFlDWkNBRElBUTJBbUFnQXlBT05nSjhJQU1nRFRZQ2VDQURJQXcyQW5RZ1xuQXlBSU5nSndJQWtnQ2lBTElCeEJ1NVdvc3dkcUlCRkIxT2FwcUFacUVHOGdBeWdDVUNFRUlBTW9BbFFoQlNBREtBSllJUVlnQXlnQ1xuWENFSElBTWdEallDYkNBRElBMDJBbWdnQXlBTU5nSmtJQU1nQ0RZQ1lDQURJQWMyQW53Z0F5QUdOZ0o0SUFNZ0JUWUNkQ0FESUFRMlxuQW5BZ0NTQUtJQXNnR2tIN3ByZnNCbXNnRzBIUzdmVHhCMnNRYnlBREtBSlFJUWdnQXlnQ1ZDRU1JQU1vQWxnaERTQURLQUpjSVE0Z1xuQXlBUU5nSmNJQU1nR1RZQ1dDQURJQmcyQWxRZ0F5QVhOZ0pRSUFNZ0R6WUNiQ0FESUJRMkFtZ2dBeUFUTmdKa0lBTWdFallDWUNBRFxuSUJFMkFud2dBeUFjTmdKNElBTWdHellDZENBRElCbzJBbkFnSGlBSklBSWdDaUFMRUdJZ0F5Z0NRQ0VYSUFNb0FrUWhHQ0FES0FKSVxuSVJrZ0F5Z0NUQ0VRSUFNZ0J6WUNiQ0FESUFZMkFtZ2dBeUFGTmdKa0lBTWdCRFlDWUNBRElBNDJBbndnQXlBTk5nSjRJQU1nRERZQ1xuZENBRElBZzJBbkFnQ1NBS0lBc2dHVUcxczVhL0JXc2dFRUhmcm9EcUJXc1FieUFES0FKUUlRUWdBeWdDVkNFRklBTW9BbGdoQmlBRFxuS0FKY0lRY2dBeUFPTmdKc0lBTWdEVFlDYUNBRElBdzJBbVFnQXlBSU5nSmdJQU1nQnpZQ2ZDQURJQVkyQW5nZ0F5QUZOZ0owSUFNZ1xuQkRZQ2NDQUpJQW9nQ3lBWFFkM2N6c1FEYXlBWVFaRHAwZTBEYXhCdklBTW9BbEFoQ0NBREtBSlVJUXdnQXlnQ1dDRU5JQU1vQWx3aFxuRGlBRElBSTJBbHdnQXlBZE5nSllJQU1nRmpZQ1ZDQURJQlUyQWxBZ0F5QVJOZ0pzSUFNZ0hEWUNhQ0FESUJzMkFtUWdBeUFhTmdKZ1xuSUFNZ0VEWUNmQ0FESUJrMkFuZ2dBeUFZTmdKMElBTWdGellDY0NBZUlBa2dEeUFLSUFzUVlpQURLQUpBSVJVZ0F5Z0NSQ0VXSUFNb1xuQWtnaEhTQURLQUpNSVFJZ0F5QUhOZ0pzSUFNZ0JqWUNhQ0FESUFVMkFtUWdBeUFFTmdKZ0lBTWdEallDZkNBRElBMDJBbmdnQXlBTVxuTmdKMElBTWdDRFlDY0NBSklBb2dDeUFkUWR6em04c0NheUFDUWVldnRQTUNheEJ2SUFNb0FsQWhCQ0FES0FKVUlRVWdBeWdDV0NFR1xuSUFNb0Fsd2hCeUFESUE0MkFtd2dBeUFOTmdKb0lBTWdERFlDWkNBRElBZzJBbUFnQXlBSE5nSjhJQU1nQmpZQ2VDQURJQVUyQW5RZ1xuQXlBRU5nSndJQWtnQ2lBTElCVkI4TUNxZ3dGcUlCWkIrNVRIM3dCckVHOGdBeWdDVUNFSUlBTW9BbFFoRENBREtBSllJUTBnQXlnQ1xuWENFT0lBTWdEellDWENBRElCUTJBbGdnQXlBVE5nSlVJQU1nRWpZQ1VDQURJQkEyQW13Z0F5QVpOZ0pvSUFNZ0dEWUNaQ0FESUJjMlxuQW1BZ0F5QUNOZ0o4SUFNZ0hUWUNlQ0FESUJZMkFuUWdBeUFWTmdKd0lCNGdDU0FSSUFvZ0N4QmlJQU1vQWtBaEVpQURLQUpFSVJNZ1xuQXlnQ1NDRVVJQU1vQWt3aER5QURJQWMyQW13Z0F5QUdOZ0pvSUFNZ0JUWUNaQ0FESUFRMkFtQWdBeUFPTmdKOElBTWdEVFlDZUNBRFxuSUF3MkFuUWdBeUFJTmdKd0lBa2dDaUFMSUJSQmlOamQ4UUZxSUE5QmxvS1R6UUZxRUc4Z0F5Z0NVQ0VFSUFNb0FsUWhCU0FES0FKWVxuSVFZZ0F5Z0NYQ0VISUFNZ0RqWUNiQ0FESUEwMkFtZ2dBeUFNTmdKa0lBTWdDRFlDWUNBRElBYzJBbndnQXlBR05nSjRJQU1nQlRZQ1xuZENBRElBUTJBbkFnQ1NBS0lBc2dFa0cxK2NLbEEyb2dFMEhNN3FHNkFtb1FieUFES0FKUUlRZ2dBeWdDVkNFTUlBTW9BbGdoRFNBRFxuS0FKY0lRNGdBeUFSTmdKY0lBTWdIRFlDV0NBRElCczJBbFFnQXlBYU5nSlFJQU1nQWpZQ2JDQURJQjAyQW1nZ0F5QVdOZ0prSUFNZ1xuRlRZQ1lDQURJQTgyQW53Z0F5QVVOZ0o0SUFNZ0V6WUNkQ0FESUJJMkFuQWdIaUFKSUJBZ0NpQUxFR0lnQXlnQ1FDRVJJQU1vQWtRaFxuR2lBREtBSklJUnNnQXlnQ1RDRWNJQU1nQnpZQ2JDQURJQVkyQW1nZ0F5QUZOZ0prSUFNZ0JEWUNZQ0FESUE0MkFud2dBeUFOTmdKNFxuSUFNZ0REWUNkQ0FESUFnMkFuQWdDU0FLSUFzZ0cwSEsxT0wyQkdvZ0hFR3ptZkRJQTJvUWJ5QURLQUpRSVFRZ0F5Z0NWQ0VGSUFNb1xuQWxnaEJpQURLQUpjSVFjZ0F5QU9OZ0pzSUFNZ0RUWUNhQ0FESUF3MkFtUWdBeUFJTmdKZ0lBTWdCellDZkNBRElBWTJBbmdnQXlBRlxuTmdKMElBTWdCRFlDY0NBSklBb2dDeUFSUWZQZnVjRUdhaUFhUWMrVTg5d0ZhaEJ2SUFNb0FsQWhDQ0FES0FKVUlRd2dBeWdDV0NFTlxuSUFNb0Fsd2hEaUFESUJBMkFsd2dBeUFaTmdKWUlBTWdHRFlDVkNBRElCYzJBbEFnQXlBUE5nSnNJQU1nRkRZQ2FDQURJQk0yQW1RZ1xuQXlBU05nSmdJQU1nSERZQ2ZDQURJQnMyQW5nZ0F5QWFOZ0owSUFNZ0VUWUNjQ0FlSUFrZ0FpQUtJQXNRWWlBREtBSkFJUkFnQXlnQ1xuUkNFU0lBTW9Ba2doRXlBREtBSk1JUlFnQXlBSE5nSnNJQU1nQmpZQ2FDQURJQVUyQW1RZ0F5QUVOZ0pnSUFNZ0RqWUNmQ0FESUEwMlxuQW5nZ0F5QU1OZ0owSUFNZ0NEWUNjQ0FKSUFvZ0N5QVRRZS9HbGNVSGFpQVVRZTZGdnFRSGFoQnZJQU1vQWxBaEZ5QURLQUpVSVJnZ1xuQXlnQ1dDRVpJQU1vQWx3aEJDQURJQTQyQW13Z0F5QU5OZ0pvSUFNZ0REWUNaQ0FESUFnMkFtQWdBeUFFTmdKOElBTWdHVFlDZUNBRFxuSUJnMkFuUWdBeUFYTmdKd0lBa2dDaUFMSUJCQitQdmptUWRySUJKQjdJL2UyUWRyRUc4Z0F5Z0NVQ0VGSUFNb0FsUWhCaUFES0FKWVxuSVFjZ0F5Z0NYQ0VJSUFNZ0FqWUNYQ0FESUIwMkFsZ2dBeUFXTmdKVUlBTWdGVFlDVUNBRElCdzJBbXdnQXlBYk5nSm9JQU1nR2pZQ1xuWkNBRElCRTJBbUFnQXlBVU5nSjhJQU1nRXpZQ2VDQURJQkkyQW5RZ0F5QVFOZ0p3SUI0Z0NTQVBJQW9nQ3hCaUlBTW9Ba0FoRlNBRFxuS0FKRUlSWWdBeWdDU0NFQ0lBTW9Ba3doRHlBRElBUTJBbXdnQXlBWk5nSm9JQU1nR0RZQ1pDQURJQmMyQW1BZ0F5QUlOZ0o4SUFNZ1xuQnpZQ2VDQURJQVkyQW5RZ0F5QUZOZ0p3SUFrZ0NpQUxJQUpCbGFhKzNRVnJJQTlCaG9DRStnWnJFRzhnQXlnQ1VDRUNJQU1vQWxRaFxuRHlBREtBSllJUkVnQXlnQ1hDRVFJQU1nQ0RZQ2JDQURJQWMyQW1nZ0F5QUdOZ0prSUFNZ0JUWUNZQ0FESUJBMkFud2dBeUFSTmdKNFxuSUFNZ0R6WUNkQ0FESUFJMkFuQWdDU0FLSUFzZ0ZVR09qcnJNQTJzZ0ZrR0p1Sm1JQkdzUWJ5QUJRVUJySVFFZ0VDQWphaUVqSUJFZ1xuSkdvaEpDQVBJQ1ZxSVNVZ0FpQW1haUVtSUFNb0Fsd2dIMm9oSHlBREtBSllJQ0JxSVNBZ0F5Z0NWQ0FoYWlFaElBTW9BbEFnSW1vaFxuSWd3QkJRc0xJQUFnSXpZQ0hDQUFJQ1EyQWhnZ0FDQWZOZ0lVSUFBZ0lEWUNFQ0FBSUNVMkFnd2dBQ0FtTmdJSUlBQWdJVFlDQkNBQVxuSUNJMkFnQWdBMEdBQVdva0FBdUJLZ0lEZnlKK0l3QkJzQUZySWdNa0FDQURRUUJCZ0FIOEN3QWdBU0FDUVFkMGFpRUZJQUFwQXpnaFxuSmlBQUtRTXdJU1FnQUNrREtDRWlJQUFwQXlBaEh5QUFLUU1ZSVNjZ0FDa0RFQ0VsSUFBcEF3Z2hJeUFBS1FNQUlTQURRQ0FCSUFWSFxuQkVBZ0FVR0FBV3BCQUNFQ0EwQWdBa0dBQVVjRVFDQUNJQU5xSUFFZ0Ftb3BBQUFpRDBJNGhpQVBRb0QrQTROQ0tJYUVJQTlDZ0lEOFxuQjROQ0dJWWdEMEtBZ0lENEQ0TkNDSWFFaENBUFFnaUlRb0NBZ1BnUGd5QVBRaGlJUW9DQS9BZURoQ0FQUWlpSVFvRCtBNE1nRDBJNFxuaUlTRWhEY0RBQ0FDUVFocUlRSU1BUVVMQ3lBREtRTVlJUXdnQXlrREVDRU9JQU1wQXdnaEdpQURRYUFCYWlJQklDQWdIeUFqSUNJZ1xuSlNBa0lDY2dKaUFES1FNQUlpRkNvdHlpdVkzemk4WENBSHdRc2dFZ0FTQURLUU9nQVNJUElBTXBBNmdCSWdzZ0lDQWZJQ01nSWlBbFxuSUNRZ0drTE55NzJma3BMUm0vRUFmQkN5QVNBQklBTXBBNkFCSWhBZ0F5a0RxQUVpRVNBUElBc2dJQ0FmSUNNZ0lpQU9RdEdKeTUyQlxuaHNHZnlnQjlFTElCSUFFZ0F5a0RvQUVpQmlBREtRT29BU0lUSUJBZ0VTQVBJQXNnSUNBZklBeEN4TWpZODZlTGlhVVdmUkN5QVNBRFxuS1FNNElSY2dBeWtETUNFWUlBTXBBeWdoSENBQklBTXBBNkFCSWhzZ0F5a0RxQUVpRFNBR0lCTWdFQ0FSSUE4Z0N5QURLUU1nSWgxQ1xudU9xaW1yL0xzS3M1ZkJDeUFTQUJJQU1wQTZBQklnOGdBeWtEcUFFaUN5QWJJQTBnQmlBVElCQWdFU0FjUXBtZ2w3Q2J2c1Q0MlFCOFxuRUxJQklBRWdBeWtEb0FFaUVTQURLUU9vQVNJU0lBOGdDeUFiSUEwZ0JpQVRJQmhDNWVDYWg3V3JuK0R0QUgwUXNnRWdBU0FES1FPZ1xuQVNJR0lBTXBBNmdCSWhNZ0VTQVNJQThnQ3lBYklBMGdGMExvL2Ntc29xWG84ZFFBZlJDeUFTQURLUU5ZSVJzZ0F5a0RVQ0VRSUFNcFxuQTBnaERTQUJJQU1wQTZBQkloVWdBeWtEcUFFaUZDQUdJQk1nRVNBU0lBOGdDeUFES1FOQUloNUN2dnZ6NS9Xc2xmd25mUkN5QVNBQlxuSUFNcEE2QUJJZ3NnQXlrRHFBRWlHU0FWSUJRZ0JpQVRJQkVnRWlBTlFyN2Z3YXVVNE5iQkVud1FzZ0VnQVNBREtRT2dBU0lTSUFNcFxuQTZnQklnY2dDeUFaSUJVZ0ZDQUdJQk1nRUVLTTVaTDM1TGZobUNSOEVMSUJJQUVnQXlrRG9BRWlCaUFES1FPb0FTSVRJQklnQnlBTFxuSUJrZ0ZTQVVJQnRDNHVuK3I3MjRuNGJWQUh3UXNnRWdBeWtEZUNFUklBTXBBM0FoRHlBREtRTm9JUlVnQVNBREtRT2dBU0lVSUFNcFxuQTZnQkloWWdCaUFUSUJJZ0J5QUxJQmtnQXlrRFlDSVpRdStTN3BQUHJwZmY4Z0I4RUxJQklBRWdBeWtEb0FFaUNTQURLUU9vQVNJSVxuSUJRZ0ZpQUdJQk1nRWlBSElCVkN6OUtscDV6QTA1RC9BSDBRc2dFZ0FTQURLUU9nQVNJU0lBTXBBNmdCSWdjZ0NTQUlJQlFnRmlBR1xuSUJNZ0QwTEwyK1BSamF2K2tlUUFmUkN5QVNBQklBTXBBNkFCSWhNZ0F5a0RxQUVpQ2lBU0lBY2dDU0FJSUJRZ0ZpQVJRdXl5MjRTelxuMFlPeVBuMFFzZ0VnQXlrRHFBRWhDeUFES1FPZ0FTRUdJQU5CZ0FGcUlnSWdHaUFoSUE0Z0VDQU5JQkVnRHhDbUFTQURRWkFCYWlJRVxuSUF3Z0RpQWRJQmtnR3lBREtRT0FBU0loSUFNcEE0Z0JJaG9RcGdFZ0F5a0RrQUVoRkNBREtRT1lBU0VXSUFFZ0JpQUxJQk1nQ2lBU1xuSUFjZ0NTQUlJQnBDcnVxNmlPYkhwYkliZlJDeUFTQUJJQU1wQTZBQklna2dBeWtEcUFFaUNDQUdJQXNnRXlBS0lCSWdCeUFoUXAyMFxudzcyY2orNmdFSDBRc2dFZ0FTQURLUU9nQVNJU0lBTXBBNmdCSWdjZ0NTQUlJQVlnQ3lBVElBb2dGa0sxcTdQYzZMam40QTk4RUxJQlxuSUFFZ0F5a0RvQUVpQ2lBREtRT29BU0lNSUJJZ0J5QUpJQWdnQmlBTElCUkM1Yml5dmNlNXFJWWtmQkN5QVNBREtRT29BU0VHSUFNcFxuQTZBQklRNGdBU0FjSUIwZ0dDQVBJQlVnRkNBV0VLWUJJQUVnRnlBWUlCNGdHaUFSSUFNcEE2QUJJaG9nQXlrRHFBRWlFeENtQVNBRFxuS1FPZ0FTRVlJQU1wQTZnQklRc2dBU0FPSUFZZ0NpQU1JQklnQnlBSklBZ2dFMEwxaEt6SjlZM0w5QzE4RUxJQklBRWdBeWtEb0FFaVxuQ1NBREtRT29BU0lJSUE0Z0JpQUtJQXdnRWlBSElCcENnOG1iOWFhVm9icktBSHdRc2dFZ0FTQURLUU9nQVNJU0lBTXBBNmdCSWdjZ1xuQ1NBSUlBNGdCaUFLSUF3Z0MwTFU5NGZxeTd1cTJOd0FmQkN5QVNBQklBTXBBNkFCSWdvZ0F5a0RxQUVpRENBU0lBY2dDU0FJSUE0Z1xuQmlBWVFyV254WmlvbStMODlnQjhFTElCSUFNcEE2Z0JJUVlnQXlrRG9BRWhEaUFCSUEwZ0hpQVFJQllnSVNBWUlBc1FwZ0VnQVNBYlxuSUJBZ0dTQVRJQlFnQXlrRG9BRWlGaUFES1FPb0FTSWJFS1lCSUFNcEE2QUJJUTBnQXlrRHFBRWhFQ0FCSUE0Z0JpQUtJQXdnRWlBSFxuSUFrZ0NDQWJRdFhBNUl6UjFldmc1d0I5RUxJQklBRWdBeWtEb0FFaUZDQURLUU9vQVNJSklBNGdCaUFLSUF3Z0VpQUhJQlpDOEp1dlxua3EyeWp1ZlhBSDBRc2dFZ0FTQURLUU9nQVNJSElBTXBBNmdCSWdnZ0ZDQUpJQTRnQmlBS0lBd2dFRUxCdlpPNDlvYTIvczhBZlJDeVxuQVNBQklBTXBBNkFCSWdvZ0F5a0RxQUVpRENBSElBZ2dGQ0FKSUE0Z0JpQU5RcHppdzRpRWg2RFR3QUI5RUxJQklBTXBBNmdCSVFZZ1xuQXlrRG9BRWhEaUFCSUJVZ0dTQVBJQXNnR2lBTklCQVFwZ0VnQVNBUklBOGdBeWtEaUFFaUVTQWJJQmdnQXlrRG9BRWlGeUFES1FPb1xuQVNJU0VLWUJJQU1wQTZBQklSVWdBeWtEcUFFaER5QUJJQTRnQmlBS0lBd2dCeUFJSUJRZ0NTQVNRcjdnM1pMTWdmMlBPWDBRc2dFZ1xuQVNBREtRT2dBU0lKSUFNcEE2Z0JJaHdnRGlBR0lBb2dEQ0FISUFnZ0YwTGJzZFhuaHRlYnJDcDlFTElCSUFFZ0F5a0RvQUVpQnlBRFxuS1FPb0FTSUlJQWtnSENBT0lBWWdDaUFNSUE5Qzc0U09nSjdxbU9VR2ZCQ3lBU0FCSUFNcEE2QUJJZ29nQXlrRHFBRWlEQ0FISUFnZ1xuQ1NBY0lBNGdCaUFWUXZEY3VkRHdyTXFVRkh3UXNnRWdBeWtEcUFFaEJpQURLUU9nQVNFT0lBRWdBeWtEZ0FFZ0VTQURLUU9ZQVNJUlxuSUJBZ0ZpQVZJQThRcGdFZ0FTQURLUU9RQVNBUklCTWdFaUFOSUFNcEE2QUJJaDBnQXlrRHFBRWlGQkNtQVNBREtRT2dBU0VaSUFNcFxuQTZnQklSRWdBU0FPSUFZZ0NpQU1JQWNnQ0NBSklCd2dGRUw4MzhpMjFOREMyeWQ4RUxJQklBRWdBeWtEb0FFaUNTQURLUU9vQVNJY1xuSUE0Z0JpQUtJQXdnQnlBSUlCMUNwcEtiNFlXbnlJMHVmQkN5QVNBQklBTXBBNkFCSWdjZ0F5a0RxQUVpQ0NBSklCd2dEaUFHSUFvZ1xuRENBUlF1M1ZrTmJGdjV1V3pRQjhFTElCSUFFZ0F5a0RvQUVpQ2lBREtRT29BU0lNSUFjZ0NDQUpJQndnRGlBR0lCbEMzK2ZXN0xtaVxuZzV6VEFId1FzZ0VnQXlrRHFBRWhCaUFES1FPZ0FTRU9JQUlnR2lBVElBc2dEeUFYSUJrZ0VSQ21BU0FFSUJnZ0N5QWJJQlFnRlNBRFxuS1FPQUFTSWhJQU1wQTRnQklnc1FwZ0VnQXlrRGtBRWhHaUFES1FPWUFTRWVJQUVnRGlBR0lBb2dEQ0FISUFnZ0NTQWNJQXRDM3NlOVxuM2NqcW5JWGxBSHdRc2dFZ0FTQURLUU9nQVNJSklBTXBBNmdCSWh3Z0RpQUdJQW9nRENBSElBZ2dJVUtvNWQ3anM5ZUN0ZllBZkJDeVxuQVNBQklBTXBBNkFCSWdjZ0F5a0RxQUVpQ0NBSklCd2dEaUFHSUFvZ0RDQWVRcHFpeWNDYjJzMmUvZ0I5RUxJQklBRWdBeWtEb0FFaVxuQ2lBREtRT29BU0lNSUFjZ0NDQUpJQndnRGlBR0lCcEN4WlgzMjY3djlNYnRBSDBRc2dFZ0F5a0RxQUVoQmlBREtRT2dBU0VPSUFFZ1xuRmlBYklCQWdFU0FkSUJvZ0hoQ21BU0FCSUEwZ0VDQVNJQXNnR1NBREtRT2dBU0lXSUFNcEE2Z0JJaE1RcGdFZ0F5a0RvQUVoR0NBRFxuS1FPb0FTRUxJQUVnRGlBR0lBb2dEQ0FISUFnZ0NTQWNJQk5DblBtN21PdnJoYURkQUgwUXNnRWdBU0FES1FPZ0FTSU5JQU1wQTZnQlxuSWdrZ0RpQUdJQW9nRENBSElBZ2dGa0wvbi9lZHhMYm04dGNBZlJDeUFTQUJJQU1wQTZBQklnY2dBeWtEcUFFaUNDQU5JQWtnRGlBR1xuSUFvZ0RDQUxRdS9RbmZqeWtaM2FQWDBRc2dFZ0FTQURLUU9nQVNJS0lBTXBBNmdCSWd3Z0J5QUlJQTBnQ1NBT0lBWWdHRUxRZzYzTlxuejh2cnlUaDlFTElCSUFNcEE2Z0JJUkFnQXlrRG9BRWhCaUFCSUJjZ0VpQVBJQjRnSVNBWUlBc1FwZ0VnQVNBVklBOGdGQ0FUSUJvZ1xuQXlrRG9BRWlHaUFES1FPb0FTSU9FS1lCSUFNcEE2QUJJUnNnQXlrRHFBRWhEeUFCSUFZZ0VDQUtJQXdnQnlBSUlBMGdDU0FPUXVqYlxud3NqaS9NVzJMbjBRc2dFZ0FTQURLUU9nQVNJSklBTXBBNmdCSWhjZ0JpQVFJQW9nRENBSElBZ2dHa0x3cmVuVXVydStzeWw5RUxJQlxuSUFFZ0F5a0RvQUVpQnlBREtRT29BU0lJSUFrZ0Z5QUdJQkFnQ2lBTUlBOUMxcis3eEtyUDh2Z0xmUkN5QVNBQklBTXBBNkFCSWdvZ1xuQXlrRHFBRWlEQ0FISUFnZ0NTQVhJQVlnRUNBYlFyaWo3NVdEanFpMUVId1FzZ0VnQXlrRHFBRWhCaUFES1FPZ0FTRU5JQUVnSFNBVVxuSUJFZ0N5QVdJQnNnRHhDbUFTQUJJQmtnRVNBREtRT0lBU0lSSUE0Z0dDQURLUU9nQVNJY0lBTXBBNmdCSWhJUXBnRWdBeWtEb0FFaFxuRlNBREtRT29BU0VRSUFFZ0RTQUdJQW9nRENBSElBZ2dDU0FYSUJKQ3lLSEx4dXVpc05JWmZCQ3lBU0FCSUFNcEE2QUJJZ2tnQXlrRFxucUFFaUZ5QU5JQVlnQ2lBTUlBY2dDQ0FjUXRQV2hvcUZnZHViSG53UXNnRWdBU0FES1FPZ0FTSUhJQU1wQTZnQklnZ2dDU0FYSUEwZ1xuQmlBS0lBd2dFRUtaMTd2OHplbWRwQ2Q4RUxJQklBRWdBeWtEb0FFaUNpQURLUU9vQVNJTUlBY2dDQ0FKSUJjZ0RTQUdJQlZDcUpIdFxuak42V3I5ZzBmQkN5QVNBREtRT29BU0VHSUFNcEE2QUJJUTBnQVNBREtRT0FBU0FSSUFNcEE1Z0JJaEVnRHlBYUlCVWdFQkNtQVNBQlxuSUFNcEE1QUJJQkVnRXlBU0lCc2dBeWtEb0FFaUhTQURLUU9vQVNJVUVLWUJJQU1wQTZBQklSa2dBeWtEcUFFaEVTQUJJQTBnQmlBS1xuSUF3Z0J5QUlJQWtnRnlBVVF1TzBwYTY4bG9PT09Yd1FzZ0VnQVNBREtRT2dBU0lKSUFNcEE2Z0JJaGNnRFNBR0lBb2dEQ0FISUFnZ1xuSFVMTGxZYWFyc21xN000QWZCQ3lBU0FCSUFNcEE2QUJJZ2NnQXlrRHFBRWlDQ0FKSUJjZ0RTQUdJQW9nRENBUlF2UEdqN3YzeWJMT1xuMndCOEVMSUJJQUVnQXlrRG9BRWlDaUFES1FPb0FTSU1JQWNnQ0NBSklCY2dEU0FHSUJsQ28vSEt0YjMrbTVmb0FId1FzZ0VnQXlrRFxucUFFaEJpQURLUU9nQVNFTklBSWdGaUFUSUFzZ0VDQWNJQmtnRVJDbUFTQUVJQmdnQ3lBT0lCUWdGU0FES1FPQUFTSWVJQU1wQTRnQlxuSWhNUXBnRWdBeWtEa0FFaEdDQURLUU9ZQVNFV0lBRWdEU0FHSUFvZ0RDQUhJQWdnQ1NBWElCTkMvT1crNytYZDRNZjBBSHdRc2dFZ1xuQVNBREtRT2dBU0lKSUFNcEE2Z0JJaGNnRFNBR0lBb2dEQ0FISUFnZ0hrTGczdHlZOU8zWTB2Z0FmQkN5QVNBQklBTXBBNkFCSWdjZ1xuQXlrRHFBRWlDQ0FKSUJjZ0RTQUdJQW9nRENBV1FvNnB2ZkMxL2VHYit3QjlFTElCSUFFZ0F5a0RvQUVpQ2lBREtRT29BU0lNSUFjZ1xuQ0NBSklCY2dEU0FHSUJoQ2xJenZyUDYrdjV6ekFIMFFzZ0VnQXlrRHFBRWhDeUFES1FPZ0FTRUdJQUVnR2lBT0lBOGdFU0FkSUJnZ1xuRmhDbUFTQUJJQnNnRHlBU0lCTWdHU0FES1FPZ0FTSWJJQU1wQTZnQklnNFFwZ0VnQXlrRG9BRWhFeUFES1FPb0FTRVBJQUVnQmlBTFxuSUFvZ0RDQUhJQWdnQ1NBWElBNUMyTVB6NU4yQXdLRHZBSDBRc2dFZ0FTQURLUU9nQVNJTklBTXBBNmdCSWdrZ0JpQUxJQW9nRENBSFxuSUFnZ0cwS1hoUFdMd3VMazE5c0FmUkN5QVNBQklBTXBBNkFCSWdjZ0F5a0RxQUVpQ0NBTklBa2dCaUFMSUFvZ0RDQVBRdXVONXVtRVxuZ1plRHdRQjlFTElCSUFFZ0F5a0RvQUVpQ2lBREtRT29BU0lNSUFjZ0NDQU5JQWtnQmlBTElCTkMxZG0yNU5IaG9jYzVmUkN5QVNBRFxuS1FPb0FTRUxJQU1wQTZBQklRWWdBU0FjSUJJZ0VDQVdJQjRnRXlBUEVLWUJJQUVnRlNBUUlCUWdEaUFZSUFNcEE2QUJJaG9nQXlrRFxucUFFaUdCQ21BU0FES1FPZ0FTRVNJQU1wQTZnQklSVWdBU0FHSUFzZ0NpQU1JQWNnQ0NBTklBa2dHRUxrdk9hdWthYXc3RFY5RUxJQlxuSUFFZ0F5a0RvQUVpRFNBREtRT29BU0lXSUFZZ0N5QUtJQXdnQnlBSUlCcEMrZnY4OFkzbjBid3VmUkN5QVNBQklBTXBBNkFCSWdjZ1xuQXlrRHFBRWlDU0FOSUJZZ0JpQUxJQW9nRENBVlF1S3AvSkNUeGVDU0ZYMFFzZ0VnQVNBREtRT2dBU0lJSUFNcEE2Z0JJZ29nQnlBSlxuSUEwZ0ZpQUdJQXNnRWtLSTNjU01nWkNzd1FwOUVMSUJJQU1wQTZnQklRc2dBeWtEb0FFaEVDQUJJQjBnRkNBUklBOGdHeUFTSUJVUVxucGdFZ0FTQVpJQkVnQXlrRGlBRWlIQ0FZSUJNZ0F5a0RvQUVpRENBREtRT29BU0lYRUtZQklBTXBBNkFCSVJFZ0F5a0RxQUVoQmlBQlxuSUJBZ0N5QUlJQW9nQnlBSklBMGdGaUFYUXJyZjNaQ245Wm40Qm53UXNnRWdBU0FES1FPZ0FTSU5JQU1wQTZnQkloUWdFQ0FMSUFnZ1xuQ2lBSElBa2dERUttc2FLVzJyamZzUXA4RUxJQklBRWdBeWtEb0FFaUdTQURLUU9vQVNJSElBMGdGQ0FRSUFzZ0NDQUtJQVpDcnB2a1xuOTh1QTVwOFJmQkN5QVNBQklBTXBBNkFCSWhZZ0F5a0RxQUVpQ1NBWklBY2dEU0FVSUJBZ0N5QVJRcHVPOFpqUjVzSzRHM3dRc2dFZ1xuQXlrRHFBRWhDeUFES1FPZ0FTRVFJQUVnQXlrRGdBRWdIQ0FES1FPWUFTSUlJQlVnR2lBUklBWVFwZ0VnQVNBREtRT1FBU0FJSUE0Z1xuRnlBU0lBTXBBNkFCSWhVZ0F5a0RxQUVpQ0JDbUFTQURLUU9nQVNFS0lBTXBBNmdCSVJvZ0FTQVFJQXNnRmlBSklCa2dCeUFOSUJRZ1xuQ0VLRSs1R1kwdjdkN1NoOEVMSUJJQUVnQXlrRG9BRWlEU0FES1FPb0FTSVNJQkFnQ3lBV0lBa2dHU0FISUJWQ2s4bWNoclR2cXVVeVxuZkJDeUFTQUJJQU1wQTZBQkloVWdBeWtEcUFFaUZDQU5JQklnRUNBTElCWWdDU0FhUXJ6OXBxNmh3YS9QUEh3UXNnRWdBU0FES1FPZ1xuQVNJWklBTXBBNmdCSWdjZ0ZTQVVJQTBnRWlBUUlBc2dDa0xNbXNEZ3lmalpqc01BZkJDeUFTQURLUU9vQVNFTElBTXBBNkFCSVJBZ1xuQWlBYklBNGdEeUFHSUF3Z0NpQWFFS1lCSUFRZ0V5QVBJQmdnQ0NBUklBTXBBNEFCSWdZZ0F5a0RpQUVpRHhDbUFTQURLUU9RQVNFVFxuSUFNcEE1Z0JJUmdnQVNBUUlBc2dHU0FISUJVZ0ZDQU5JQklnRDBLMmhmblo3SmYxNHN3QWZCQ3lBU0FCSUFNcEE2QUJJZzhnQXlrRFxucUFFaUVTQVFJQXNnR1NBSElCVWdGQ0FHUXFyOGxlUFBzOHEvMlFCOEVMSUJJQUVnQXlrRG9BRWlCaUFES1FPb0FTSU9JQThnRVNBUVxuSUFzZ0dTQUhJQmhDN1BYYjFyUDEyK1hmQUh3UXNnRWdBU0FES1FPZ0FTSVlJQU1wQTZnQkloc2dCaUFPSUE4Z0VTQVFJQXNnRTBLWFxuc0ozU3hMR0dvdXdBZkJDeUFTQVJJQ1o4SVNZZ0R5QW5mQ0VuSUE0Z0pId2hKQ0FHSUNWOElTVWdHeUFpZkNFaUlCZ2dJM3doSXlBZlxuSUFNcEE2Z0JmQ0VmSUNBZ0F5a0RvQUY4SVNBaEFRd0JCUXNMSUFBZ0pqY0RPQ0FBSUNRM0F6QWdBQ0FpTndNb0lBQWdIemNESUNBQVxuSUNjM0F4Z2dBQ0FsTndNUUlBQWdJemNEQ0NBQUlDQTNBd0FnQTBHd0FXb2tBQXV2SXdJSWZ3RitBa0FDUUFKQUFrQUNRQUpBQWtBZ1xuQUVIMUFVOEVRQ0FBUWN6L2Uwc05CU0FBUVF0cUlnRkJlSEVoQlVHTStNQUFLQUlBSWdoRkRRUkJIeUVIUVFBZ0JXc2hCQ0FBUWZUL1xuL3dkTkJFQWdCVUVHSUFGQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2FpRUhCUXNnQjBFQ2RFSHc5TUFBYWlnQ0FDSUNSUVJBUVFBaFxuQUVFQUlRRU1BZ1VMUVFBaEFDQUZRUUJCR1NBSFFRRjJheUFIUVI5R0czUWhBMEVBSVFFRFFBSkFJQUlvQWdSQmVIRWlCaUFGU1EwQVxuSUFZZ0JXc2lCaUFFVHcwQUlBSWhBU0FHSWdRTkFFRUFJUVFnQWlFQURBUUxJQUlvQWhRaUJpQUFJQVlnQWlBRFFSMTJRUVJ4YWlnQ1xuRUNJQ1J4c2dBQ0FHR3lFQUlBTkJBWFFoQXlBQ0RRQUxEQUVGQzBHSStNQUFLQUlBSWdKQkVDQUFRUXRxUWZnRGNTQUFRUXRKR3lJRlxuUVFOMklnQjJJZ0ZCQTNFRVFBSkFJQUZCZjNOQkFYRWdBR29pQlVFRGRDSUFRWUQyd0FCcUlnTWdBRUdJOXNBQWFpZ0NBQ0lCS0FJSVxuSWdSSEJFQWdCQ0FETmdJTUlBTWdCRFlDQ0F3QkJRdEJpUGpBQUNBQ1FYNGdCWGR4TmdJQUN5QUJJQUJCQTNJMkFnUWdBQ0FCYWlJQVxuSUFBb0FnUkJBWEkyQWdRZ0FVRUlhZzhGQ3lBRlFaRDR3QUFvQWdCTkRRTUNRQUpBSUFGRkJFQkJqUGpBQUNnQ0FDSUFSUTBHSUFCb1xuUVFKMFFmRDB3QUJxS0FJQUlnRW9BZ1JCZUhFZ0JXc2hCQ0FCSVFJRFFBSkFJQUVvQWhBaUFBMEFJQUVvQWhRaUFBMEFJQUlvQWhnaFxuQndKQUFrQWdBaUFDS0FJTUlnQkdCRUFnQWtFVVFSQWdBaWdDRkNJQUcyb29BZ0FpQVEwQlFRQWhBQXdDQlFzZ0FpZ0NDQ0lCSUFBMlxuQWd3Z0FDQUJOZ0lJREFFTElBSkJGR29nQWtFUWFpQUFHeUVEQTBBZ0F5RUdJQUVpQUVFVWFpQUFRUkJxSUFBb0FoUWlBUnNoQXlBQVxuUVJSQkVDQUJHMm9vQWdBaUFRMEFDeUFHUVFBMkFnQUxJQWRGRFFRQ1FDQUNLQUljUVFKMFFmRDB3QUJxSWdFb0FnQWdBa2NFUUNBQ1xuSUFjb0FoQkhCRUFnQnlBQU5nSVVJQUFOQWd3SEJRc2dCeUFBTmdJUUlBQU5BUXdHQlFzZ0FTQUFOZ0lBSUFCRkRRUUxJQUFnQnpZQ1xuR0NBQ0tBSVFJZ0VFUUNBQUlBRTJBaEFnQVNBQU5nSVlCUXNnQWlnQ0ZDSUJSUTBFSUFBZ0FUWUNGQ0FCSUFBMkFoZ01CQXNnQUNnQ1xuQkVGNGNTQUZheUlCSUFRZ0FTQUVTU0lCR3lFRUlBQWdBaUFCR3lFQ0lBQWhBUXdBQ3dBRkN3SkFRUUlnQUhRaUEwRUFJQU5yY2lBQlxuSUFCMGNXZ2lCa0VEZENJQVFZRDJ3QUJxSWdNZ0FFR0k5c0FBYWlnQ0FDSUJLQUlJSWdSSEJFQWdCQ0FETmdJTUlBTWdCRFlDQ0F3QlxuQlF0QmlQakFBQ0FDUVg0Z0JuZHhOZ0lBQ3lBQklBVkJBM0kyQWdRZ0FTQUZhaUlHSUFBZ0JXc2lCRUVCY2pZQ0JDQUFJQUZxSUFRMlxuQWdCQmtQakFBQ2dDQUNJQ0JFQWdBa0Y0Y1VHQTlzQUFhaUVBUVpqNHdBQW9BZ0FoQXdKL1FZajR3QUFvQWdBaUJVRUJJQUpCQTNaMFxuSWdKeFJRUkFRWWo0d0FBZ0FpQUZjallDQUNBQURBRUZDeUFBS0FJSUN5RUNJQUFnQXpZQ0NDQUNJQU0yQWd3Z0F5QUFOZ0lNSUFNZ1xuQWpZQ0NBVUxRWmo0d0FBZ0JqWUNBRUdRK01BQUlBUTJBZ0FnQVVFSWFnOExRWXo0d0FCQmpQakFBQ2dDQUVGK0lBSW9BaHgzY1RZQ1xuQUFzQ1FBSkFJQVJCRUU4RVFDQUNJQVZCQTNJMkFnUWdBaUFGYWlJRklBUkJBWEkyQWdRZ0JDQUZhaUFFTmdJQVFaRDR3QUFvQWdBaVxuQTBVTkFTQURRWGh4UVlEMndBQnFJUUJCbVBqQUFDZ0NBQ0VCQW45QmlQakFBQ2dDQUNJR1FRRWdBMEVEZG5RaUEzRkZCRUJCaVBqQVxuQUNBRElBWnlOZ0lBSUFBTUFRVUxJQUFvQWdnTElRTWdBQ0FCTmdJSUlBTWdBVFlDRENBQklBQTJBZ3dnQVNBRE5nSUlEQUVGQ3lBQ1xuSUFRZ0JXb2lBRUVEY2pZQ0JDQUFJQUpxSWdBZ0FDZ0NCRUVCY2pZQ0JBd0JDMEdZK01BQUlBVTJBZ0JCa1BqQUFDQUVOZ0lBQ3lBQ1xuUVFocUR3c2dBQ0FCY2tVRVFFRUFJUUZCQWlBSGRDSUFRUUFnQUd0eUlBaHhJZ0JGRFFNZ0FHaEJBblJCOFBUQUFHb29BZ0FoQUFVTFxuSUFCRkRRRUxBMEFnQUNBQklBQW9BZ1JCZUhFaUF5QUZheUlHSUFSSklnY2JJUWdnQUNnQ0VDSUNSUVJBSUFBb0FoUWhBZ1VMSUFFZ1xuQ0NBRElBVkpJZ0FiSVFFZ0JDQUdJQVFnQnhzZ0FCc2hCQ0FDSWdBTkFBc0xJQUZGRFFBZ0JVR1ErTUFBS0FJQUlnQk5JQVFnQUNBRlxuYTA5eERRQWdBU2dDR0NFSEFrQUNRQ0FCSUFFb0Fnd2lBRVlFUUNBQlFSUkJFQ0FCS0FJVUlnQWJhaWdDQUNJQ0RRRkJBQ0VBREFJRlxuQ3lBQktBSUlJZ0lnQURZQ0RDQUFJQUkyQWdnTUFRc2dBVUVVYWlBQlFSQnFJQUFiSVFNRFFDQURJUVlnQWlJQVFSUnFJQUJCRUdvZ1xuQUNnQ0ZDSUNHeUVESUFCQkZFRVFJQUliYWlnQ0FDSUNEUUFMSUFaQkFEWUNBQXNnQjBVTkF3SkFJQUVvQWh4QkFuUkI4UFRBQUdvaVxuQWlnQ0FDQUJSd1JBSUFFZ0J5Z0NFRWNFUUNBSElBQTJBaFFnQUEwQ0RBWUZDeUFISUFBMkFoQWdBQTBCREFVRkN5QUNJQUEyQWdBZ1xuQUVVTkF3c2dBQ0FITmdJWUlBRW9BaEFpQWdSQUlBQWdBallDRUNBQ0lBQTJBaGdGQ3lBQktBSVVJZ0pGRFFNZ0FDQUNOZ0lVSUFJZ1xuQURZQ0dBd0RDd0pBQWtBQ1FBSkFBa0FnQlVHUStNQUFLQUlBSWdGTEJFQWdCVUdVK01BQUtBSUFJZ0JQQkVCQkFDRUVJQVZCcjRBRVxuYWlJQVFSQjJRQUFpQVVGL1JpSUREUWNnQVVFUWRDSUNSUTBIUWFENHdBQkJBQ0FBUVlDQWZIRWdBeHNpQkVHZytNQUFLQUlBYWlJQVxuTmdJQVFhVDR3QUFnQUVHaytNQUFLQUlBSWdFZ0FDQUJTeHMyQWdBQ1FBSkFRWno0d0FBb0FnQWlBd1JBUWZEMXdBQWhBQU5BSUFBb1xuQWdBaUFTQUFLQUlFSWdacUlBSkdEUUlnQUNnQ0NDSUFEUUFMREFJRkMwR3MrTUFBS0FJQUlnQkJBQ0FBSUFKTkcwVUVRRUdzK01BQVxuSUFJMkFnQUZDMEd3K01BQVFmOGZOZ0lBUWZUMXdBQWdCRFlDQUVIdzljQUFJQUkyQWdCQmpQYkFBRUdBOXNBQU5nSUFRWlQyd0FCQlxuaVBiQUFEWUNBRUdJOXNBQVFZRDJ3QUEyQWdCQm5QYkFBRUdROXNBQU5nSUFRWkQyd0FCQmlQYkFBRFlDQUVHazlzQUFRWmoyd0FBMlxuQWdCQm1QYkFBRUdROXNBQU5nSUFRYXoyd0FCQm9QYkFBRFlDQUVHZzlzQUFRWmoyd0FBMkFnQkJ0UGJBQUVHbzlzQUFOZ0lBUWFqMlxud0FCQm9QYkFBRFlDQUVHODlzQUFRYkQyd0FBMkFnQkJzUGJBQUVHbzlzQUFOZ0lBUWNUMndBQkJ1UGJBQURZQ0FFRzQ5c0FBUWJEMlxud0FBMkFnQkIvUFhBQUVFQU5nSUFRY3oyd0FCQndQYkFBRFlDQUVIQTlzQUFRYmoyd0FBMkFnQkJ5UGJBQUVIQTlzQUFOZ0lBUWRUMlxud0FCQnlQYkFBRFlDQUVIUTlzQUFRY2oyd0FBMkFnQkIzUGJBQUVIUTlzQUFOZ0lBUWRqMndBQkIwUGJBQURZQ0FFSGs5c0FBUWRqMlxud0FBMkFnQkI0UGJBQUVIWTlzQUFOZ0lBUWV6MndBQkI0UGJBQURZQ0FFSG85c0FBUWVEMndBQTJBZ0JCOVBiQUFFSG85c0FBTmdJQVxuUWZEMndBQkI2UGJBQURZQ0FFSDg5c0FBUWZEMndBQTJBZ0JCK1BiQUFFSHc5c0FBTmdJQVFZVDN3QUJCK1BiQUFEWUNBRUdBOThBQVxuUWZqMndBQTJBZ0JCalBmQUFFR0E5OEFBTmdJQVFaVDN3QUJCaVBmQUFEWUNBRUdJOThBQVFZRDN3QUEyQWdCQm5QZkFBRUdROThBQVxuTmdJQVFaRDN3QUJCaVBmQUFEWUNBRUdrOThBQVFaajN3QUEyQWdCQm1QZkFBRUdROThBQU5nSUFRYXozd0FCQm9QZkFBRFlDQUVHZ1xuOThBQVFaajN3QUEyQWdCQnRQZkFBRUdvOThBQU5nSUFRYWozd0FCQm9QZkFBRFlDQUVHODk4QUFRYkQzd0FBMkFnQkJzUGZBQUVHb1xuOThBQU5nSUFRY1Qzd0FCQnVQZkFBRFlDQUVHNDk4QUFRYkQzd0FBMkFnQkJ6UGZBQUVIQTk4QUFOZ0lBUWNEM3dBQkJ1UGZBQURZQ1xuQUVIVTk4QUFRY2ozd0FBMkFnQkJ5UGZBQUVIQTk4QUFOZ0lBUWR6M3dBQkIwUGZBQURZQ0FFSFE5OEFBUWNqM3dBQTJBZ0JCNVBmQVxuQUVIWTk4QUFOZ0lBUWRqM3dBQkIwUGZBQURZQ0FFSHM5OEFBUWVEM3dBQTJBZ0JCNFBmQUFFSFk5OEFBTmdJQVFmVDN3QUJCNlBmQVxuQURZQ0FFSG85OEFBUWVEM3dBQTJBZ0JCL1BmQUFFSHc5OEFBTmdJQVFmRDN3QUJCNlBmQUFEWUNBRUdFK01BQVFmajN3QUEyQWdCQlxuK1BmQUFFSHc5OEFBTmdJQVFaejR3QUFnQWpZQ0FFR0ErTUFBUWZqM3dBQTJBZ0JCbFBqQUFDQUVRU2hySWdBMkFnQWdBaUFBUVFGeVxuTmdJRUlBQWdBbXBCS0RZQ0JFR28rTUFBUVlDQWdBRTJBZ0FNQ0FzZ0FpQURUU0FCSUFOTGNnMEFJQUFvQWd4RkRRTUxRYXo0d0FCQlxuclBqQUFDZ0NBQ0lBSUFJZ0FDQUNTUnMyQWdBZ0FpQUVhaUVCUWZEMXdBQWhBQUpBQWtBRFFDQUJJQUFvQWdBaUJrY0VRQ0FBS0FJSVxuSWdBTkFRd0NCUXNMSUFBb0FneEZEUUVMUWZEMXdBQWhBQU5BQWtBZ0F5QUFLQUlBSWdGUEJFQWdBeUFCSUFBb0FnUnFJZ1pKRFFFRlxuQ3lBQUtBSUlJUUFNQVFzTFFaejR3QUFnQWpZQ0FFR1UrTUFBSUFSQktHc2lBRFlDQUNBQ0lBQkJBWEkyQWdRZ0FDQUNha0VvTmdJRVxuUWFqNHdBQkJnSUNBQVRZQ0FDQURJQVpCSUd0QmVIRkJDR3NpQUNBQUlBTkJFR3BKR3lJQlFSczJBZ1JCOFBYQUFDa0NBQ0VKSUFGQlxuRUdwQitQWEFBQ2tDQURjQ0FDQUJJQWszQWdoQjlQWEFBQ0FFTmdJQVFmRDF3QUFnQWpZQ0FFSDQ5Y0FBSUFGQkNHbzJBZ0JCL1BYQVxuQUVFQU5nSUFJQUZCSEdvaEFBTkFJQUJCQnpZQ0FDQUFRUVJxSWdBZ0Jra05BQXNnQVNBRFJnMEhJQUVnQVNnQ0JFRitjVFlDQkNBRFxuSUFFZ0Eyc2lBRUVCY2pZQ0JDQUJJQUEyQWdBZ0FFR0FBazhFUUNBRElBQVFWUXdJQlFzZ0FFSDRBWEZCZ1BiQUFHb2hBUUovUVlqNFxud0FBb0FnQWlBa0VCSUFCQkEzWjBJZ0J4UlFSQVFZajR3QUFnQUNBQ2NqWUNBQ0FCREFFRkN5QUJLQUlJQ3lFQUlBRWdBellDQ0NBQVxuSUFNMkFnd2dBeUFCTmdJTUlBTWdBRFlDQ0F3SEN5QUFJQUkyQWdBZ0FDQUFLQUlFSUFScU5nSUVJQUlnQlVFRGNqWUNCQ0FHUVE5cVxuUVhoeFFRaHJJZ1FnQWlBRmFpSURheUVGSUFSQm5QakFBQ2dDQUVZTkF5QUVRWmo0d0FBb0FnQkdEUVFnQkNnQ0JDSUJRUU54UVFGR1xuQkVBZ0JDQUJRWGh4SWdBUVR5QUFJQVZxSVFVZ0FDQUVhaUlFS0FJRUlRRUZDeUFFSUFGQmZuRTJBZ1FnQXlBRlFRRnlOZ0lFSUFNZ1xuQldvZ0JUWUNBQ0FGUVlBQ1R3UkFJQU1nQlJCVkRBWUZDeUFGUWZnQmNVR0E5c0FBYWlFQUFuOUJpUGpBQUNnQ0FDSUJRUUVnQlVFRFxuZG5RaUJIRkZCRUJCaVBqQUFDQUJJQVJ5TmdJQUlBQU1BUVVMSUFBb0FnZ0xJUVVnQUNBRE5nSUlJQVVnQXpZQ0RDQURJQUEyQWd3Z1xuQXlBRk5nSUlEQVVGQzBHVStNQUFJQUFnQldzaUFUWUNBRUdjK01BQVFaejR3QUFvQWdBaUFDQUZhaUlDTmdJQUlBSWdBVUVCY2pZQ1xuQkNBQUlBVkJBM0kyQWdRZ0FFRUlhaUVFREFZRkMwR1krTUFBS0FJQUlRQUNRQ0FCSUFWcklnSkJEMDBFUUVHWStNQUFRUUEyQWdCQlxua1BqQUFFRUFOZ0lBSUFBZ0FVRURjallDQkNBQUlBRnFJZ0VnQVNnQ0JFRUJjallDQkF3QkJRdEJrUGpBQUNBQ05nSUFRWmo0d0FBZ1xuQUNBRmFpSUROZ0lBSUFNZ0FrRUJjallDQkNBQUlBRnFJQUkyQWdBZ0FDQUZRUU55TmdJRUN5QUFRUWhxRHdzZ0FDQUVJQVpxTmdJRVxuUVp6NHdBQkJuUGpBQUNnQ0FDSUFRUTlxUVhoeElnRkJDR3NpQWpZQ0FFR1UrTUFBUVpUNHdBQW9BZ0FnQkdvaUF5QUFJQUZyYWtFSVxuYWlJQk5nSUFJQUlnQVVFQmNqWUNCQ0FBSUFOcVFTZzJBZ1JCcVBqQUFFR0FnSUFCTmdJQURBTUxRWno0d0FBZ0F6WUNBRUdVK01BQVxuUVpUNHdBQW9BZ0FnQldvaUFEWUNBQ0FESUFCQkFYSTJBZ1FNQVF0Qm1QakFBQ0FETmdJQVFaRDR3QUJCa1BqQUFDZ0NBQ0FGYWlJQVxuTmdJQUlBTWdBRUVCY2pZQ0JDQUFJQU5xSUFBMkFnQUxJQUpCQ0dvUEMwRUFJUVJCbFBqQUFDZ0NBQ0lBSUFWTkRRQkJsUGpBQUNBQVxuSUFWcklnRTJBZ0JCblBqQUFFR2MrTUFBS0FJQUlnQWdCV29pQWpZQ0FDQUNJQUZCQVhJMkFnUWdBQ0FGUVFOeU5nSUVJQUJCQ0dvUFxuQ3lBRUR3dEJqUGpBQUVHTStNQUFLQUlBUVg0Z0FTZ0NISGR4TmdJQUN3SkFJQVJCRUU4RVFDQUJJQVZCQTNJMkFnUWdBU0FGYWlJQ1xuSUFSQkFYSTJBZ1FnQWlBRWFpQUVOZ0lBSUFSQmdBSlBCRUFnQWlBRUVGVU1BZ1VMSUFSQitBRnhRWUQyd0FCcUlRQUNmMEdJK01BQVxuS0FJQUlnTkJBU0FFUVFOMmRDSUVjVVVFUUVHSStNQUFJQU1nQkhJMkFnQWdBQXdCQlFzZ0FDZ0NDQXNoQkNBQUlBSTJBZ2dnQkNBQ1xuTmdJTUlBSWdBRFlDRENBQ0lBUTJBZ2dNQVFVTElBRWdCQ0FGYWlJQVFRTnlOZ0lFSUFBZ0FXb2lBQ0FBS0FJRVFRRnlOZ0lFQ3lBQlxuUVFocUM1c1dBZ2wvQlg0akFFR1FDbXNpQnlRQUlBZEJBRFlDMUFrZ0J5QUNOZ0xRQ1NBSElBRTJBc3dKSUFkQmlBRnFJQWRCekFscVxuUVRBUVl3Si9Ba0FnQnlnQ2lBRWlBa1VOQUNBSEtBS01BU0VCSUFkQkFEWUN3QUVnQnlBQ05nSzRBU0FISUFFMkFyd0JJQWRCZ0FGcVxuSUFkQnVBRnFFSmtCSUFjb0FvQUJJZ0ZGRFFBZ0J5Z0NoQUVoQWlBSFFmZ0FhaUFIUWJnQmFoQ1pBU0FIS0FKNElnNUZEUUFnQnlnQ1xud0FFZ0J5Z0N2QUZIRFFBZ0J5Z0MxQWtnQnlnQzBBbEhJQUpCZ1FoclFZeDRTWElOQUNBQkxRQUFSUTBBSUFjb0Fud2hDeUFBS0FJSVxuSVFvZ0IwSHdBR29nQWtFRGFrRUNkaENQQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFFZ0FpQUhLQUp3SWdrZ1xuQnlnQ2RDSUlFRzFGQkVBZ0NFVU5EaUFKS0FJQVFRRnhFTDRDRFFFZ0IwRUFPZ0NZQVNBSElBZzJBcFFCSUFkQkFUWUNrQUVDUUFOQVxuSUFkQjZBQnFJQWRCa0FGcUVOMEJJQWNvQW1oQkFYRkZEUUVnQnlnQ2JFRUJheUlOSUFoUERRZ2dDU0FOUVFKMGFpZ0NBQ0VDSUFkQlxuQURvQTFBa2dCMEtCZ0lDQWdBUTNBc3dKQTBBZ0IwSGdBR29nQjBITUNXb1EzUUVnQnlnQ1lFRUJjVVVOQVNBQ0lBY29BbVFpQVVFQlxuYTNaRkRRQUxDeUFCSUExQkJYUnFJUXdMSUFsRkRRNGdDa0gvQjAwTkJ5QU1RUU4ySUF4QkIzRkJBRWRxSWdGQmdJQ0FnQUpQRFFnZ1xuQVVFRGRDQUtTU0FNUVlEQUFFdHlEUVVnQ0E0Q0FnTUVCUXNnQ0VVTkRRc2dDU0FJUVFKMEVNd0JEQXdMUVFCQkFFSE13Y0FBRU1NQlxuQUF0QkFVRUJRZHpCd0FBUXd3RUFDeUFKS1FJQUlSTkJ3QUFoQVVJQklSSURmaUFCQkg1Q0FDQVNRZ0dEZlNJUVFvQ0FnSUNBZ0lDQVxuZ0grRElCUkNBWWlFSVJRZ0VDQVRneUlRSUJLRlFnR0lJQkFnRW9OOElSSWdBVUVCYXlFQkRBRUZJQlFMQ3lFUUlBY2dERFlDb0FFZ1xuQnlBUU53S1lBU0FISUFnMkFwUUJJQWNnQ1RZQ2tBRWdCMEhZQUdvZ0NCQ1BBU0FIS0FKWUlRSWdCeWdDWENFQklBY2dDRFlDeUFrZ1xuQnlBQk5nSzRDU0FCSUFoSERRUkJBQ0VCSUFnaENnTkFJQW9FUUNBQklBSnFJQUVnQ1dvb0FnQkJmM00yQWdBZ0NrRUJheUVLSUFGQlxuQkdvaEFRd0JCUXNMSUFJZ0FpZ0NBRUVCY2pZQ0FDQUlRUVYwSWdvZ0RFWU5CaUFDSUFoQkFuUnFRUVJySWdGRkRRVWdBU0FCS0FJQVxuUVg4Z0NpQU1hM1p4TmdJQUlBd2dDbXNoQVFOQUlBRkZEUWNnQWlBSUlBa2dDQkNlQWcwSUlBRkJBV29oQVF3QUN3QUxJQWtnQ0VFQ1xuZEJETUFRd0lDeUFOSUFoQmtLYkFBQkREQVFBTFFaQzZ3QUJCSmtHY3U4QUFFT3dCQUF0Qmp0REFBRUVySUFkQnpBbHFRZGk0d0FCQlxuckx2QUFCQ3ZBUUFMSUFkQkFEWUN6QWtnQjBISUNXb2dCMEc0Q1dvZ0IwSE1DV3BCN01IQUFCRFFBZ0FMUWNhS3dBQkJLMEg4d2NBQVxuRU93QkFBdEJmeUVCQTBBZ0FVRUJhaUlCSUFoR0JFQkJCU0VCSUFnaENnTkFJQUZGRFFRZ0IwSFFBR29nQWlBS0lBZEJrQUZxRUtVQlxuSUFGQkFXc2hBU0FIS0FKVUlRb2dCeWdDVUNFQ0RBQUxBQVVMSUFJZ0NDQUpJQWdRbmdKRkRRQUxDMEhRdzhBQVFTaEIyTExBQUJEc1xuQVFBTElBbEZEUUFnQnlBS05nTFFBU0FISUFJMkFzd0JJQWNnRURjQ3hBRWdCeUFNTmdMQUFTQUhJQWcyQXJ3QklBY2dDVFlDdUFFQ1xuUUFKQUlBdEJCbXRCZTBrTkFDQU9MUUFBUlEwQUlBZEJ3QUZxSVFFRFFDQVJRZ2lHSWhNZ0RqRUFBQ0lRaENFUklBNUJBV29oRGlBTFxuUVFGcklnc05BQXNnRVVJRFZDQVRRdi8vLy84ZlZuSU5BQ0FRUWdHRHB3MEJDeUFIUWJnQmFoQzhBZ3dCQ3lBSFFiQUJhaUFCUVJCcVxuS0FJQU5nSUFJQWRCcUFGcUlBRkJDR29wQWdBM0F3QWdCeUFCS1FJQU53T2dBU0FISUFnMkFwd0JJQWNnQ1RZQ21BRWdCeUFSTndPUVxuQVNBSFFiZ0Jha0VBUVlBSS9Bc0FJQWRCbUFGcUlRNENRQUpBSUFZZ0J5Z0NvQUVpQVVFRGRpQUJRUWR4UVFCSGFrY05BQ0FIUWNnQVxuYWlBSUVJOEJBa0FnQlNBR0lBY29Ba2dpQ2lBSEtBSk1JZ0VRYlNBSVJYSWdBU0FJUjNKRkJFQWdDaUFKSUFnUXB3RU5BUVVMSUFGRlxuRFFFZ0NpQUJRUUowRU13QkRBRUxRUUFoQVNBS0lRSWdDQ0VHQTBBZ0FpZ0NBQ0FCY2lFQklBSkJCR29oQWlBR1FRRnJJZ1lOQUFzQ1xuUUNBQkVMNENCRUJCQUNFTERBRUZDeUFIUVVCcklBZ1Fqd0VDZndKQUlBY3BBNUFCUW42REloQlFSUVJBSUFjb0FrUWhBaUFIS0FKQVxuSVFZZ0J5QUhLQUtnQVRZQzNBa2dCeUFIS1FLa0FUY0MxQWtnQnlBSEtBS2NBU0lCTmdMUUNTQUhJQWNvQXBnQk5nTE1DU0FIUVRocVxuSUFFUWp3RWdCMEhVQ1dvaENTQUhLQUk4SVFFZ0J5Z0NPQ0VQSUFjb0F0QUpJZ1ZCQkVrTkFTQUZRWUFDVFFSQVFRRWhEQUpBSUFjb1xuQXJBQklnc2dCVWNOQUNBQklBdEhCRUFnQVNFTERBRUZDeUFCSUFoSEJFQWdDQ0VMREFFRkN5QVBJQW9nQnlnQ3JBRWdCeWdDekFrZ1xuQ1NBSUVDdEJBQ0VNQ3lBSFFUQnFJQXdnQ3hDNEFpQUhLQUl3REFNRkN5QUhRU2hxSUFVUTF3SWdCeWdDS0F3Q0JRdEJqdERBQUVFclxuSUFkQnpBbHFRZGl1d0FCQjJLL0FBQkN2QVFBTElBZEJJR29nQlJEWUFpQUhLQUlnQ3hEMUFTQUJJQUpHQkVBZ0FrRUNkQ0lOQkVBZ1xuQmlBUElBMzhDZ0FBQlF0Q0FTQVFlVUkvaFlZaEVTQUhLQUxRQ1NFTElBY29Bc3dKSVFFZ0FpRUZBMEFnRVVJQldBUkFJQUlFUUNBUFxuSUEwUXpBRUZDeUFISUFnMkFzUUpJQWNnQ2pZQ3dBa2dCeUFGTmdLOENTQUhJQVkyQXJnSklBZEJ1QWxxSUFjb0Fzd0pJQWNvQXRBSlxuSUFrUWx3RVE5UUVDUUFKQUlBY29BcUFCSWdGQkEzWWdBVUVIY1VFQVIyb2lERUVEYWtIOC8vLy9CM0VpQ1VHQkNFa0VRQ0FISUFrMlxuQXNnSklBY2dCVUVDZENJQk5nSzRDU0FCSUFsSERRRWdCMEVBTmdLSUNpQUhRZ0EzQW9BS0lBZEJBRFlDM0FrZ0IwRUFOZ0xNQ1NBSFxuSUFrMkF2UUpJQWNnQjBHNEFXb2lEU0FKYWlJQ05nTDhDU0FISUFZMkF1d0pJQWNnQVNBR2FqWUM4QWtnQjBIY0NXb2hDd05BQWtBZ1xuQWlBTlJnMEFJQWNnRFVFQmFqWUMrQWtDUUFKQUEwQWdCMEVZYWlBSFFjd0phaERVQVNBSExRQVlCRUFnQnkwQUdTRUJRUUVoQWd3Q1xuQlFzQ1FDQUhLQUxzQ1NJQ1JRMEFJQUlnQnlnQzhBa2lBVVlOQUNBSFFRUTJBdFFKSUFkQ0FUY0N6QWtnQnlBQlFRUnJJZ0UyQXZBSlxuSUFjZ0FTZ0NBQ0lCUVJoMElBRkJnUDREY1VFSWRISWdBVUVJZGtHQS9nTnhJQUZCR0haeWNqWUMyQWtNQVFzTElBZEJFR29nQ3hEVVxuQVNBSExRQVJJUUVnQnkwQUVDSUNSUTBCQ3lBSElBY29BdlFKUVFGck5nTDBDUXNnQWtFQmNVVU5BQ0FOSUFFNkFBQWdCeWdDL0FraFxuQWlBSEtBTDRDU0VOREFFTEN5QUpJQXhKRFFJZ0NTQU1heUlDSUFkQnVBRnFJZ0ZxSVFzQ1FBTkFJQUpGRFFFZ0FrRUJheUVDSUFFdFxuQUFBZ0FVRUJhaUVCUlEwQUMwR0lzTUFBUVRGQnZMREFBQkRzQVFBTElBWWdCUkRNQWd3R0JRc2dDVUdBQ0VIb3I4QUFFT0lDQUFzZ1xuQjBFQU5nTE1DU0FIUWNnSmFpQUhRYmdKYWlBSFFjd0pha0dncHNBQUVOQUNBQXNnQjBFQU5nTGNDU0FIUVFFMkF0QUpJQWRCNkxUQVxuQURZQ3pBa2dCMElFTndMVUNTQUhRY3dKYWtINHI4QUFFSHNBQlFzZ0IwRUlhaUFHSUFVZ0IwSE1DV29RcFFFZ0J5Z0NEQ0VGSUFjb1xuQWdnaEJpQVJRZ0dJSWhFZ0VJTlFEUUFnQnlBQ05nTEVDU0FISUE4MkFzQUpJQWNnQlRZQ3ZBa2dCeUFHTmdLNENTQUhRYmdKYWlBQlxuSUFzZ0NSQ1hBUkQxQVF3QUN3QUZDeUFDSUFGQnlMTEFBQkRFQVFBTElBb2dDQkRNQWlBTERRRUxJQTRRdkFJTUFRc2dCMEhNQ1dvaVxuQWlBQUtBSUFJZ0VnQUNnQ0JDSUFLQUlRRVFNQUlBTWdCQkFWSUFkQkFEWUN3QWtnQnlBTU5nSzhDU0FISUFzMkFyZ0pJQUVnQWlBSFxuUWJnSmFpQUhLQUtnQVNBQUtBSVVFUWtBSUFjb0FzQUpJUUVnQnlnQ3ZBa2dEaEM4QWlBQlIzSU1BUXRCQVFzZ0IwR1FDbW9rQUF1elxuRHdJQmZ4ZCtJd0JCNEFOcklnUWtBQ0FFUWVBQ2FpQUNLUU1BSWd3Z0RFSS9oeUlVSUFBcEF3QWlCaUFHUWorSElnZ1Fvd0VnQkVHQVxuQTJvZ0Fpa0RDQ0lOSUExQ1A0Y2lGU0FCS1FNQUlna2dDVUkvaHlJRkVLTUJJQVJCOEFKcUlBSXBBeEFpRUNBUVFqK0hJaGtnQmlBSVxuRUtNQklBUkJrQU5xSUFJcEF4Z2lFU0FSUWorSElob2dDU0FGRUtNQklBUkJ3QUpxSUEwZ0FTa0RJQ0lXUWorSElnaURJQXdnQUNrRFxuSUNJWFFqK0hJZ1dEZkNJR0lBWWdBeWtES0NJT0lBUXBBNEFESWdvZ0JDa0Q0QUo4SWdsK2ZFTC8vLy8vLy8vLy96K0RmU0lQSUE5Q1xuUDRjaUdDQURLUU1BSWdZZ0JrSS9oeUlIRUtNQklBUkIwQUpxSUFnZ0VZTWdCU0FRZzN3aUJTQUZJQTRnQkNrRGtBTWlFaUFFS1FQd1xuQW53aUNINThRdi8vLy8vLy8vLy9QNE45SWc0Z0RrSS9oeUliSUFZZ0J4Q2pBU0FFUWFBRGFpQU1JQlFnQUNrRENDSUdJQVpDUDRjaVxuQnhDakFTQUVRY0FEYWlBTklCVWdBU2tEQ0NJRklBVkNQNGNpQ3hDakFTQUVRYkFEYWlBUUlCa2dCaUFIRUtNQklBUkIwQU5xSUJFZ1xuR2lBRklBc1Fvd0VnQkNrRDBBTWlCU0FFS1FPd0Ezd2lCaUFGVkswZ0JFSFlBMm9wQXdBZ0JFRzRBMm9wQXdCOGZDQUVLUVBRQWlJRlxuSUFoOElnY2dCVlN0SUFSQjJBSnFLUU1BSUFnZ0VsU3RJQVJCbUFOcUtRTUFJQVJCK0FKcUtRTUFmSHg4ZkNJSVFqNkhmQ0FHSUFZZ1xuQ0VJQ2hpQUhRajZJaEh3aUJsYXRmQ0VJSUFRcEE4QURJZ2NnQkNrRG9BTjhJZ1VnQjFTdElBUkJ5QU5xS1FNQUlBUkJxQU5xS1FNQVxuZkh3Z0JDa0R3QUlpQnlBSmZDSVNJQWRVclNBRVFjZ0NhaWtEQUNBSklBcFVyU0FFUVlnRGFpa0RBQ0FFUWVnQ2Fpa0RBSHg4Zkh3aVxuQ1VJK2gzd2dCU0FKUWdLR0lCSkNQb2lFZkNJSklBVlVyWHdoQlNBQktRTVlJUW9nQVNrREVDRUhJQUFwQXhnaEVpQUFLUU1RSVFzZ1xuQXlrRENDSVRVRVVFUUNBRVFiQUNhaUFQSUJnZ0V5QVRRaitISWhnUW93RWdCRUdnQW1vZ0RpQWJJQk1nR0JDakFTQUdJQVlnQkNrRFxub0FKOElnWldyU0FJSUFSQnFBSnFLUU1BZkh3aENDQUpJQWtnQkNrRHNBSjhJZ2xXclNBRklBUkJ1QUpxS1FNQWZId2hCUVVMSUFBZ1xuQ1VMLy8vLy8vLy8vL3orRE53TUFJQUVnQmtMLy8vLy8vLy8vL3orRE53TUFJQVJCa0FKcUlBd2dGQ0FMSUF0Q1A0Y2lFeENqQVNBRVxuUWZBQmFpQU5JQlVnQnlBSFFqK0hJaFFRb3dFZ0JFR0FBbW9nRUNBWklBc2dFeENqQVNBRVFlQUJhaUFSSUJvZ0J5QVVFS01CSUFRcFxuQStBQklnc2dCQ2tEZ0FKOElnY2dDMVN0SUFSQjZBRnFLUU1BSUFSQmlBSnFLUU1BZkh3Z0NFSStoM3dnQnlBSVFnS0dJQVpDUG9pRVxuZkNJSUlBZFVyWHdoQmlBRUtRUHdBU0lMSUFRcEE1QUNmQ0lISUF0VXJTQUVRZmdCYWlrREFDQUVRWmdDYWlrREFIeDhJQVZDUG9kOFxuSUFjZ0JVSUNoaUFKUWo2SWhId2lCU0FIVksxOElRa2dBeWtERUNJSFVFVUVRQ0FFUWRBQmFpQUhJQWRDUDRjaUN5QVBJQTlDUDRjUVxub3dFZ0JFSEFBV29nQnlBTElBNGdEa0kvaHhDakFTQUVLUVBBQVNJSElBaDhJZ2dnQjFTdElBUkJ5QUZxS1FNQUlBWjhmQ0VHSUFRcFxuQTlBQklnY2dCWHdpQlNBSFZLMGdCRUhZQVdvcEF3QWdDWHg4SVFrRkN5QUFJQVZDLy8vLy8vLy8vLzgvZ3pjRENDQUJJQWhDLy8vL1xuLy8vLy8vOC9nemNEQ0NBRVFiQUJhaUFNSUF4Q1A0Y2lCeUFTSUJKQ1A0Y2lDeENqQVNBRVFaQUJhaUFOSUExQ1A0Y2lFeUFLSUFwQ1xuUDRjaUZCQ2pBU0FFUWFBQmFpQVFJQkJDUDRjaUZTQVNJQXNRb3dFZ0JFR0FBV29nRVNBUlFqK0hJaElnQ2lBVUVLTUJJQVFwQTRBQlxuSWdzZ0JDa0RvQUY4SWdvZ0MxU3RJQVJCaUFGcUtRTUFJQVJCcUFGcUtRTUFmSHdnQmtJK2gzd2dDaUFHUWdLR0lBaENQb2lFZkNJSVxuSUFwVXJYd2hCaUFFS1FPUUFTSUxJQVFwQTdBQmZDSUtJQXRVclNBRVFaZ0JhaWtEQUNBRVFiZ0JhaWtEQUh4OElBbENQb2Q4SUFvZ1xuQ1VJQ2hpQUZRajZJaEh3aUJTQUtWSzE4SVFrZ0F5a0RHQ0lLVUVVRVFDQUVRZkFBYWlBS0lBcENQNGNpQ3lBUElBOUNQNGNRb3dFZ1xuQkVIZ0FHb2dDaUFMSUE0Z0RrSS9oeENqQVNBRUtRTmdJZ29nQ0h3aUNDQUtWSzBnQkVIb0FHb3BBd0FnQm54OElRWWdCQ2tEY0NJS1xuSUFWOElnVWdDbFN0SUFSQitBQnFLUU1BSUFsOGZDRUpCUXNnQUNBRlF2Ly8vLy8vLy8vL1A0TTNBeEFnQVNBSVF2Ly8vLy8vLy8vL1xuUDRNM0F4QWdCRUhRQUdvZ0RDQUhJQmNnRjBJL2h5SU1FS01CSUFSQk1Hb2dEU0FUSUJZZ0ZrSS9oeUlORUtNQklBUkJRR3NnRUNBVlxuSUJjZ0RCQ2pBU0FFUVNCcUlCRWdFaUFXSUEwUW93RWdCQ0FES1FNZ0lnd2dERUkvaHlJTklBOGdEMEkvaHhDakFTQUVRUkJxSUF3Z1xuRFNBT0lBNUNQNGNRb3dFZ0FDQUVLUU13SWhBZ0JDa0RVSHdpRHlBSlFnS0dJQVZDUG9pRWZDSUZJQVFwQXdCOElnNUMvLy8vLy8vL1xuLy84L2d6Y0RHQ0FCSUFRcEF5QWlFU0FFS1FOQWZDSU1JQVpDQW9ZZ0NFSStpSVI4SWdnZ0JDa0RFSHdpRFVMLy8vLy8vLy8vL3orRFxuTndNWUlBQWdCU0FPVnEwZ0JFRUlhaWtEQUNBRklBOVVyU0FQSUJCVXJTQUVRVGhxS1FNQUlBUkIyQUJxS1FNQWZId2dDVUkraDN4OFxuZkh4Q0FvWWdEa0kraUlRM0F5QWdBU0FJSUExV3JTQUVRUmhxS1FNQUlBZ2dERlN0SUF3Z0VWU3RJQVJCS0dvcEF3QWdCRUhJQUdvcFxuQXdCOGZDQUdRajZIZkh4OGZFSUNoaUFOUWo2SWhEY0RJQ0FFUWVBRGFpUUFDK0VQQVF4L0l3QkJnTVFOYXlJRkpBQWdCVUVBTmdMZ1xuQWlBRlFxdXpqL3lSbzdQdzJ3QTNBNWdDSUFWQy82UzVpTVdSMm9LYmZ6Y0RrQUlnQlVMeTVydmpvNmY5cDZWL053T0lBaUFGUXVmTVxucDlEVzBPdXp1MzgzQTRBQ0lBVkJnQUpxSWdaQjArckFBRUUvRUFJZ0JpQUZRZENEQ0dvaUJoQnBBbjlCSUNFRFFlRHV3QUFoQkFOQVxuUVFBZ0EwVU5BUm9nQTBFQmF5RURJQVF0QUFBaENTQUdMUUFBSUFSQkFXb2hCQ0FHUVFGcUlRWWdDV3NpQ1VVTkFBc2dDUXNFUUVIQ1xuNnNBQVFRQVE1UUlGQ3lBQkVJSUNCRUFnQUVFQU5nSUlJQUJDQURjQ0FDQUFRY2p0d0FBcEF3QTNBN2dCSUFCQmlPckFBQ2tEQURjRFxuc0FFZ0FFSFFBV29oQmlBQlFZQUVjUVJBSUFCQkNHb2lDU0FHTmdJQUlBVkJnSU1JYWlJR1FZRHZ3QUJCS0JBcEdpQUZRYWlEQ0dwQlxucU8vQUFFRW9FQ2thSUFWQjBJTUlhaUlDUWVEdndBQVFSUm9nQlVHQUFtb2lBeUFDUVFBUXFRRWFJQVVnQlNnQzBBSTJBdmlDQ0NBRlxuUVlDQ0NHb2lBaUFEUVNnUUtSb2dCVUdvZ2docUlBVkJxQUpxUVNnUUtSb2dCVUhZZ2docVFnQTNBd0FnQlVIZ2dnaHFRZ0EzQXdBZ1xuQlVIb2dnaHFRZ0EzQXdBZ0JVSHdnZ2hxUWdBM0F3QWdCVUlCTndQUWdnZ2dBaUFDUVlEdndBQkJBQkFrSUFWQmdBRnFJQVpCMEFBUVxuS1JvZ0JVSUJOd1BRQVNBRlFkZ0Jha0VrRUVNYUlBVWdBa0dBQVJBcElnUkJnQUpxSVFoQkFDRURBMEFnQTBIQUFFY0VRQ0FFUVlBQ1xuYWlBRFFRdDBhaUFFUVlBQkVDa2FRUUFoQWdOQUlBSkJnQTlHQkVCQkJDRUNBMEFnQWdSQUlBUkJnQUZxSWdZZ0JrRUFFRElnQWtFQlxuYXlFQ0RBRUZDd3NnQkNBRVFRQVFNaUFEUVQ1R0JFQWdCQ0FFRU9RQklBUWdCQ0FFUVlDQ0NHb1FMZ1VMSUFoQmdCQnFJUWdnQTBFQlxuYWlFRERBTUZJQUlnQ0dvaUJrR0FBV29nQmlBRVFZQUJhaEF1SUFKQmdBRnFJUUlNQVFzQUN3QUZDd3NnQkVIUUFtb2hCMEVBSVFJZ1xuQkVIUWd3aHFJUWhCZnlFR0EwQWdBa0dBQ0VjRVFDQUhRU2hxS0FJQVJRUkFBa0FnQmtGL1JnUkFJQWdnQjBFb0VDa2FEQUVGQ3lBSVxuSUFSQjBJTUlhaUFHUWRnQWJHb2dCeEFPQ3lBQ0lRWUZDeUFJUWRnQWFpRUlJQWRCZ0FGcUlRY2dBa0VCYWlFQ0RBRUZDd3NDUUNBR1xuUVg5R0RRQWdCRUhZd3cxcUlBUkIwSU1JYWlBR1FkZ0FiR29ROEFFZ0JFSDRBV29oQXdOQVFRQWdCbXNoQnlBRElBWkJCM1FpQ21vaFxuQWlBR1FkZ0FiQ0lMSUFSQjBJTUlhbW9oQ0FKQUEwQWdCMEVCYWlJSFFRRkdEUUVnQ0VIWUFHc2hDQ0FDS0FJQUlBSkJnQUZySVFJTlxuQUFzZ0JFSFFnd2hxSUF0cUlBZ2dCRUhZd3cxcUlnSVFEaUFDSUFJZ0JDQUtha0hRQW1vUURrRUFJQWRySVFZTUFRc0xJQVJCMElNSVxuYWlBR1FkZ0FiR29nQkVIWXd3MXFRU2dRS1JvZ0JFR0FBbW9oQjBFQUlRSURRQ0FDUVlEQUJVWU5BU0FFUWRDRENHb2dBbW9pQmtIUVxuQUdvZ0IwSDRBR29vQWdBaUF6WUNBQ0FEUlFSQUlBWWdCeUFHRU40QkJRc2dBa0hZQUdvaEFpQUhRWUFCYWlFSERBQUxBQXNnQUVIUVxuZ1FScUlRWWdCRUhRZ3docUlRTkJBQ0VIUVFBaENBTkFJQWhCd0FCSEJFQkJBQ0VDSUFNaEJBTkFJQUpCZ0FoSEJFQWdDU2dDQUNBSFxuYWlBQ2FpQUVFTmNCSUFKQlFHc2hBaUFFUWRnQWFpRUVEQUVGQ3dzZ0IwR0FDR29oQnlBRFFZQUxhaUVESUFoQkFXb2hDQXdCQlFzTFxuSXdCQmdBTnJJZ01rQUNBRFFUaHFRZ0EzQXdBZ0EwRXdha0lBTndNQUlBTkJLR3BDQURjREFDQURRZ0EzQXlBZ0NTSUNRYUFCYWtFQVxuTmdJQUlBSkJLR29pQ0VHQTc4QUFRU2dRS1NFRUlBSkIwQUJxUWFqdndBQkJLQkFwR2lBQ1FZQUJha0lBTndNQUlBSkIrQUJxUWdFM1xuQXdBZ0FrR0lBV3BDQURjREFDQUNRWkFCYWtJQU53TUFJQUpCbUFGcVFnQTNBd0FnQkNBRUVPUUJJQUpCRUdwQ0FEY0RBQ0FDUWdFM1xuQXdnZ0FrRVlha0lBTndNQUlBSkJJR3BDQURjREFDQURRWkFCYWlJRUlBSkJDR29pQ1JCT0lBTkJHR29nQTBHb0FXb2lDeWtEQURjRFxuQUNBRFFSQnFJQU5Cb0FGcUlnd3BBd0EzQXdBZ0F5QURLUU9ZQVRjRENDQURJQU1wQTVBQk53TUFJQU5CeUFCcUlnb2dBMEVnRUhZZ1xuQ2lBRUVJb0JJQU5CdUFGcUlnZEI2UEhBQUNBSElBUVFSVVVnQXlrRDJBRWdBeWtEMEFFZ0F5a0R5QUVnQXlrRHdBRWdBeWtEdUFHRVxuaElTRVVISVFtQUVnQ0NBSEVOZ0JJQWNRb2dJZ0NpQUVFSW9CSUFOQjRBSnFJZ2NnQkVFQUVFSWdCMEdZN3NBQUlBTkIrQUpxSWdRcFxuQXdBZ0EwSHdBbW9pQ2lrREFDQURRZWdDYWlJTktRTUFJQU1wQStBQ2hJU0VVQkNvQVNBTFFnQTNBd0FnREVJQU53TUFJQU5DQURjRFxubUFFZ0EwSUFOd09RQVNBQ0lBTkI0QUZxSWdJZ0J4QVRJQWNnQnhDUkFTQUpRUmhxSUFRcEF3QTNBd0FnQ1VFUWFpQUtLUU1BTndNQVxuSUFsQkNHb2dEU2tEQURjREFDQUpJQU1wQStBQ053TUFJQWdnQWtHQUFSQXBHaUFDRUxBQ0lBTkJnQU5xSkFBRkN3SkFJQUZCZ0FKeFxuUlEwQUlBQW9BZ0FOQUNBRlFRQTJBdmdDSUFWQmdBSnFJZ05CZ08vQUFFRW9FQ2thSUFWQnFBSnFRYWp2d0FCQktCQXBHaUFGUWRnQ1xuYWtJQU53TUFJQVZCNEFKcVFnQTNBd0FnQlVIb0FtcENBRGNEQUNBRlFmQUNha0lBTndNQUlBQWdCallDQUNBRlFnRTNBOUFDSUFZZ1xuQXhBOElBQWdCa0dBZ0NCcU5nSUVRWUFCSVFJZ0JVSFFnd2hxSUFOQmdBRVFLUm9EUUNBQ0JFQWdCVUhRZ3docUlnWWdCa0VBRURJZ1xuQWtFQmF5RUNEQUVGQ3dzZ0FDZ0NCQ0FGUWRDRENHb1FQQXNnQUNBQlFRcDJRUUZ4TmdMQUFTQUFJUUlGQ3lBRlFZREVEV29rQUNBQ1xuQzZNUEFnbC9BWDRqQUVIZ0Ftc2lCaVFBSUFaQkdHb2dBUkQ5QVNBR0tBSWNJUTBnQmlnQ0dDRUlJQVpCRUdvZ0FpQURFT2dCSUFZb1xuQWhRaENpQUdLQUlRSVFzZ0JrRUlhaUFFSUFVUTZBRWdDZ1JBSUFZb0Fnd2hEQ0FHS0FJSUlRVWdCa0VBSUFzdEFBQWlBVUVmYXlJQ1xuSUFFZ0Fra2JJZ0k2QURNQ1FBSkFJQUpCQkVrTkFDQUdRUUUyQXBRQ0lBWkIvSVBBQURZQ2tBSWdCa0lCTndLY0FpQUdRUWMyQXB3QlxuSUFZZ0JrR1lBV28yQXBnQ0lBWWdCa0V6YWpZQ21BRWdCa0UwYWlBR1FaQUNhaEJVSUFZdEFEZ2hBaUFHS0FJMElnRkJnSUNBZ0hoR1xuRFFBZ0JrRXNhaUFHUVR4cUtBQUFOZ0FBSUFZZ0JpZ0FPVFlBS1NBR0lBSTZBQ2dnQmlBQk5nSWtJQVpCQVRZQ0lBd0JDd0pBQWtBZ1xuQ2tFQmF5SUJSUTBBSUFaQmtBSnFRUUJCd1FEOEN3QWdBVUhBQUVjTkFFSGs5TUFBS0FJQUlRa2dCa0dRQW1vaEF5QUxRUUZxSVFkQlxuQUNFRUl3QkIwQUJySWdFa0FDQUJRUUEyQWd3Q1FDQUNRZjhCY1NJQ1FRUlBCRUJCMit2QUFDQUpRYlFCYWlnQ0FDQUpLQUt3QVJFRVxuQUF3QkJRc2dBVUV3YWlBSElBRkJER29pQkJCQ0lBRW9BZ3dnQVVFUWFpQUhRU0JxSUFRUVFpQUJLQUlNY2tVRVFDQURJQUVwQXpBM1xuQUFBZ0F5QUJLUU1RTndBZ0lBTWdBam9BUUNBRFFSaHFJQUZCeUFCcUtRTUFOd0FBSUFOQkVHb2dBVUZBYXlrREFEY0FBQ0FEUVFocVxuSUFGQk9Hb3BBd0EzQUFBZ0EwRW9haUFCUVJocUtRTUFOd0FBSUFOQk1Hb2dBVUVnYWlrREFEY0FBQ0FEUVRocUlBRkJLR29wQXdBM1xuQUFCQkFTRUVEQUVGQzBFQUlRUWdBMEhCQUJCREdnc2dBVUhRQUdva0FDQUVRUUZHRFFFTElBWkJKR3BCaElUQUFFRVlFTFVCSUFaQlxuQVRZQ0lBd0JDeUFHUVRacUlBWkJrZ0pxTFFBQU9nQUFJQVlnQmk4QWtBSTdBVFFnQmlrQWt3SWhEeUFHUVpnQmFpSUJJQVpCbXdKcVxuUVRiOENnQUFJQVpCUDJvZ0FVRTIvQW9BQUNBR0lBODNBRGNnREVFZ1J3UkFJQVpCQVRZQzNBRWdCa0d3aE1BQU5nTFlBU0FHUWdFM1xuQXVRQklBWkJCallDMkFJZ0JpQU1OZ0xjQWlBR0lBWkIxQUpxTmdMZ0FTQUdJQVpCM0FKcU5nTFVBaUFHUVpRQ2FpQUdRZGdCYWhCVVxuSUFaQkxHb2dCa0djQW1vb0FnQTJBZ0FnQmlBR0tRS1VBaUlQTndDYkFTQUdRUUUyQWlBZ0JpQVBOd0lrREFFRkN5QUdRWUFCYWlBRlxuUVFocUtRQUFOd01BSUFaQmlBRnFJQVZCRUdvcEFBQTNBd0FnQmtHUUFXb2dCVUVZYWlrQUFEY0RBQ0FHSUFVcEFBQTNBM2dnQ0NnQ1xuQUNFRElBWkJrQUpxSWdsQkFFSEFBUHdMQUNBR1FUUnFJUUVnQmtINEFHb2hCQ01BUWNBRmF5SUNKQUFDZnlBREtBSUFSUVJBUWZUclxud0FBZ0EwRzBBV29vQWdBZ0F5Z0NzQUVSQkFCQkFBd0JCUXNnQWtIZ0FHb2lCeUFCUVJocUtRQUFOd01BSUFKQjJBQnFJZ2dnQVVFUVxuYWlrQUFEY0RBQ0FDUWRBQWFpSU9JQUZCQ0dvcEFBQTNBd0FnQWtFd2FpQUJRU2hxS1FBQU53TUFJQUpCT0dvZ0FVRXdhaWtBQURjRFxuQUNBQ1FVQnJJQUZCT0dvcEFBQTNBd0FnQWlBQktRQUFOd05JSUFJZ0FTa0FJRGNES0NBQkxRQkFJUUVnQWtFSWFpQUVRUUFRUWdKQVxuSUFjcEF3QWdDQ2tEQUNBT0tRTUFJQUlwQTBpRWhJUlFEUUFnQWlrRFFDQUNLUU00SUFJcEF6QWdBaWtES0lTRWhGQU5BQ0FDUWFBRlxuYWlJRUlBSkJ5QUJxRUU0Z0FrSDRCR29nQkJCRkdpQUJRUUp4QkVBZ0FrSDRCR29RMVFGQkFFNE5BU0FDUWZnRWFrR0k4Y0FBRU44QlxuQlFzZ0FrR2dCR29nQWtINEJHb2dBVUVCY1JDcEFVVU5BQ0FDSUFJb0F2QUVOZ0tZQkNBQ1FhQURhaUlISUFKQm9BUnFRU2dRS1JvZ1xuQWtISUEyb2dBa0hJQkdwQktCQXBHaUFDUWZnRGFrSUFOd01BSUFKQmdBUnFRZ0EzQXdBZ0FrR0lCR3BDQURjREFDQUNRWkFFYWtJQVxuTndNQUlBSkNBVGNEOEFNZ0FrR0FBMm9pQVNBQ1FjZ0FhaENWQVNBQ1FlQUNhaUlFSUFFZ0FrRUlhaEFiSUFRZ0JCQ1JBU0FDUWNBQ1xuYWlJSUlBRWdBa0VvYWhBYklBTWdBa0hBQVdvaUFTQUhJQWdnQkJBTkl3QkIwQUJySWdNa0FDQUNRZWdBYWlJSUlBRW9BbmdpQkRZQ1xuVUNBRVJRUkFJQUZCMEFCcUlnUWdCQkR3QVNBRFFTaHFJZ2NnQkJBWElBTWdCQ0FIRUE0Z0FTQUJJQWNRRGlBQlFTaHFJZ1FnQkNBRFxuRUE0Z0FVSFlBR3BDQURjREFDQUJRZ0UzQTFBZ0FVSGdBR3BDQURjREFDQUJRZWdBYWtJQU53TUFJQUZCOEFCcVFnQTNBd0FnQ0NBQlxuUVNnUUtVRW9haUFFUVNnUUtSb0ZDeUFEUWRBQWFpUUFJQUlvQXJnQ0RRQWdDU0FDUWVnQWFoQ2NBa0VCREFFTElBbEJ3QUFRUXhwQlxuQUFzZ0FrSEFCV29rQUVFQlJ3UkFJQVpCSkdwQnVJVEFBRUVaRUxVQklBWkJBVFlDSUF3QkJRc2dCa0dhQVdvZ0JrR1NBbW90QUFBNlxuQUFBZ0JpQUdMd0NRQWpzQm1BRWdCaWtBa3dJaER5QUdRZGdCYWlJQklBWkJtd0pxUVRYOENnQUFJQVpCb3dGcUlBRkJOZndLQUFBZ1xuQmlBUE53Q2JBU0FHUVpBQ2FpSUJJQVpCbUFGcUVJY0JJQVpCSkdvZ0FVRWhFTFVCSUFaQkFEWUNJQXNnQlNBTUVOOENJQXNnQ2hEZlxuQWlBTklBMG9BZ0JCQVdzMkFnQWdCa0dRQW1vZ0JrRWdhaENpQVNBR0tBS1VBaUVCQW44Z0JpZ0NrQUlFUUVFQklRTkJBQ0VFUVFBTVxuQVFVTFFRQWhBeUFCSVFSQkFDRUJJQVlvQXBnQ0N5RUNJQUFnQXpZQ0RDQUFJQUUyQWdnZ0FDQUNOZ0lFSUFBZ0JEWUNBQ0FHUWVBQ1xuYWlRQUR3VUxRUUJCQUVIVWc4QUFFTU1CQUF2R0R3RU5meU1BUVlBb2F5SUZKQUFnQlVIQUJXb2hCa0VCSVFjRFFBSkFJQWRCQVhGRlxuRFFBZ0F4QzFBZzBBSUFJb0FuZ05BRUVBSVFjZ0JVRUFOZ0tRRGlNQVFVQnFJZ2drQUNBSVFTQnFJZ3dnQTBIQTg4QUFFR2dnQ0NBRFxuUWVEendBQVFhQ0FNSUF4QmdQUEFBQkFiSUFnZ0NFR2c4OEFBRUJzZ0JrRWdhaUlLSUF3Z0NCQ09BU0FHSUFwQmdQVEFBQkFiSUFZZ1xuQmhDUkFTQUdJQVlnQXhDT0FTQUlRVUJySkFBZ0JTQUdRVUJySUFaQkJSQk5OZ0tJRGlBRklBWkJ4QVJxSUFwQkJSQk5JZ3cyQW93T1xuSUF3Z0JTZ0NpQTRpRHlBSklBa2dEMGdiSWdrZ0NTQU1TQnNoQ1NBR1FkZ0lhaUVHSUF0QkNHb2hDeUFOUVFGcUlRME1BUXNMQWtBZ1xuRFFSQUlBMUJBV3NoQXlBRlFhQVdhaUlHSUFWQjRCTnFJQUlnQlNnQ2tBNUJCM1JxSWdJUWVTQUNRZEFBYWlFS0lBVkJvQjVxSVFjRFxuUUNBREJFQWdCVUdnRG1vaUNDQUNRWUFCRUNrYUlBZ2dCMEV3YXhEWUFTQUhJQVlnQ0JCNUlBWWdCaUFLRUE0Z0EwRUJheUVESUFkQlxuZ0FocUlRY2dCa0hBQW1vaEJnd0JCUXNMSUFWQm9BNXFJUWdnQlVHQUoyb2hCeUFGUWFBV2FpRUtJQVZCNEJOcUlRNGpBRUV3YXlJQ1xuSkFBQ1FDQUxSUTBBSUFnZ0MwRUJheUlHUWRnQWJHb2dDaUFHUVFkMGFpSURRU2dRS1NJUlFTaHFJQU5CS0dwQktCQXBFS29CSUFjZ1xuQTBIUUFHcEJLQkFwR2tFQUlRTWdFVUVBTmdKUUlBSkJDR29nRGlBR1FTaHNhaUlIUVNnUUtSb2dDQ0FMUVFKcklnNUIyQUJzYWlFTFxuSUFvZ0RrRUhkR29oQ0FOQUlBTWdCa1lOQVNBREJFQWdBa0VJYWlJS0lBb2dCeEFPQlFzZ0N5QUlJQUpCQ0dvUTNnRWdDMEhZQUdzaFxuQ3lBSVFZQUJheUVJSUFkQktHc2hCeUFEUVFGcUlRTU1BQXNBQ3lBQ1FUQnFKQUFNQVFVTElBVkJrQ2RxUWdBM0F3QWdCVUdZSjJwQ1xuQURjREFDQUZRYUFuYWtJQU53TUFJQVZDQURjRGlDY2dCVUlCTndPQUp3dEJBQ0VMSUFWQm9BNXFJUWNnQlNFREEwQWdDeUFOUndSQVxuUVFBaEJnTkFJQVpCd0FWSEJFQWdBeUFHYWlBR0lBZHFRZGdBRUNraUFpQUNRYUQwd0FBUURpQUdRZGdBYWlFR0RBRUZDd3NnQTBIQVxuQldvaEF5QUhRY0FGYWlFSElBdEJBV29oQ3d3QkJRc0xBa0FnQkVVRVFFRUFJUWdNQVFVTElBVkIrQ1pxUWdBM0F3QWdCVUhZSm1wQ1xuQURjREFDQUZRZ0EzQS9BbUlBVkNBRGNEMENZZ0JTQUVLUU1BTndQZ0ppQUZJQVFwQXdnM0ErZ21JQVVnQkNrREVEY0R3Q1lnQlNBRVxuS1FNWU53UElKaUFGUWJBaWFpQUZRZUFtYWtFUEVFMGhDQ0FGUWFBZWFpQUZRY0FtYWtFUEVFMGlFQ0FJSUFrZ0NDQUpTaHNpQWlBQ1xuSUJCSUd5RUpDeUFCRUxJQ0lBbEJBblFnQldwQmdBcHFJUUlEUUNBSlFRQktCRUFnQ1VFQmF5RUVJQUVnQVVFQUVESWdCU0VESUFWQlxub0E1cUlRc2dEU0VHSUFJaEJ3TkFJQVlFUUFKQUlBa2dEMG9OQUNBSFFZUUVheWdDQUNJS1JRMEFBa0FnQ2tFQVNnUkFJQVZCcUNkcVxuSUFzZ0NrRUJhMEVCZGtIWUFHeHFRZGdBRUNrYURBRUZDeUFGUWFnbmFpQUxJQXBCZjNOQkFtMUIyQUJzYWtIWUFCQXBHaUFGUXJ6aFxuLy8rLy8vOGZJQVVwQTlBbmZUY0QwQ2NnQlVMOC8vLy8vLy8vSHlBRktRUFlKMzAzQTlnbklBVkMvUC8vLy8vLy94OGdCU2tENENkOVxuTndQZ0p5QUZRdnovLy8vLy8vOGZJQVVwQStnbmZUY0Q2Q2NnQlVMOC8vLy8vLy8vQVNBRktRUHdKMzAzQS9BbkN5QUJJQUVnQlVHb1xuSjJwQkFCQWtDd0pBSUFrZ0RFb05BQ0FIS0FJQUlncEZEUUFDUUNBS1FRQktCRUFnQlVHb0oyb2dBeUFLUVFGclFRRjJRZGdBYkdwQlxuMkFBUUtSb01BUVVMSUFWQnFDZHFJQU1nQ2tGL2MwRUNiVUhZQUd4cVFkZ0FFQ2thSUFWQ3ZPSC8vNy8vL3g4Z0JTa0QwQ2Q5TndQUVxuSnlBRlF2ei8vLy8vLy84ZklBVXBBOWduZlRjRDJDY2dCVUw4Ly8vLy8vLy9IeUFGS1FQZ0ozMDNBK0FuSUFWQy9QLy8vLy8vL3g4Z1xuQlNrRDZDZDlOd1BvSnlBRlF2ei8vLy8vLy84QklBVXBBL0FuZlRjRDhDY0xJQUVnQVNBRlFhZ25ha0VBRUNRTElBWkJBV3NoQmlBTFxuUWNBRmFpRUxJQU5Cd0FWcUlRTWdCMEhZQ0dvaEJ3d0JCUXNMQWtBZ0NDQUpTQTBBSUFWQnNDSnFJQVJCQW5ScUtBSUFJZ05GRFFBZ1xuQUNnQ0FDRUdBa0FnQTBFQVNnUkFJQVZCcUNkcUlBWWdBMEVGZEVFZ2EwRkFjV29Rc1FJTUFRVUxJQVZCcUNkcUlBWWdBMEYvYzBFQ1xuYlVFR2RHb1FzUUlnQlVLODRmLy92Ly8vSHlBRktRUFFKMzAzQTlBbklBVkMvUC8vLy8vLy94OGdCU2tEMkNkOU53UFlKeUFGUXZ6L1xuLy8vLy8vOGZJQVVwQStBbmZUY0Q0Q2NnQlVMOC8vLy8vLy8vSHlBRktRUG9KMzAzQStnbklBVkMvUC8vLy8vLy93RWdCU2tEOENkOVxuTndQd0p3c2dBU0FCSUFWQnFDZHFJQVZCZ0NkcUVDWUxBa0FnQ1NBUVNnMEFJQVZCb0I1cUlBUkJBblJxS0FJQUlnTkZEUUFnQUNnQ1xuQkNFSkFrQWdBMEVBU2dSQUlBVkJxQ2RxSUFrZ0EwRUZkRUVnYTBGQWNXb1FzUUlNQVFVTElBVkJxQ2RxSUFrZ0EwRi9jMEVDYlVFR1xuZEdvUXNRSWdCVUs4NGYvL3YvLy9IeUFGS1FQUUozMDNBOUFuSUFWQy9QLy8vLy8vL3g4Z0JTa0QyQ2Q5TndQWUp5QUZRdnovLy8vL1xuLy84ZklBVXBBK0FuZlRjRDRDY2dCVUw4Ly8vLy8vLy9IeUFGS1FQb0ozMDNBK2duSUFWQy9QLy8vLy8vL3dFZ0JTa0Q4Q2Q5TndQd1xuSndzZ0FTQUJJQVZCcUNkcUlBVkJnQ2RxRUNZTElBSkJCR3NoQWlBRUlRa01BUVVMQ3lBQktBSjRSUVJBSUFGQjBBQnFJZ0FnQUNBRlxuUVlBbmFoQU9CUXNnQlVHQUtHb2tBQXVZRFFJQmZ4bCtJd0JCOEFOcklnTWtBQ0FEUVVCcklBSXBBeGdpQkVJQUlBRXBBd0FpQlVJQVxuRUtNQklBTkIwQUZxSUFJcEF4QWlCa0lBSUFFcEF3Z2lDMElBRUtNQklBTkJ3QUpxSUFJcEF3Z2lERUlBSUFFcEF4QWlEVUlBRUtNQlxuSUFOQmtBTnFJQUlwQXdBaUIwSUFJQUVwQXhnaUQwSUFFS01CSUFOQjRBTnFJQUlwQXlBaUVFSUFJQUVwQXlBaUVVSUFFS01CSUFOQlxuMEFOcUlBTXBBK0FESWdoQy8vLy8vLy8vL3dlRFFnQkNrUHFBZ0lBQ1FnQVFvd0VnQTBIUUFHb2dFRUlBSUFWQ0FCQ2pBU0FEUVpBQlxuYWlBRVFnQWdDMElBRUtNQklBTkJrQUpxSUFaQ0FDQU5RZ0FRb3dFZ0EwSHdBbW9nREVJQUlBOUNBQkNqQVNBRFFiQURhaUFIUWdBZ1xuRVVJQUVLTUJJQU5Cd0FOcUlBTkI2QU5xS1FNQUlnNUNESVlnQ0VJMGlJUWdEa0kwaUVLUStvQ0FnQUpDQUJDakFTQURRZUFBYWlBSFxuUWdBZ0JVSUFFS01CSUFOQjRBRnFJQkJDQUNBTFFnQVFvd0VnQTBHZ0FXb2dCRUlBSUExQ0FCQ2pBU0FEUWFBQ2FpQUdRZ0FnRDBJQVxuRUtNQklBTkJnQU5xSUF4Q0FDQVJRZ0FRb3dFZ0F5QURLUU9nQWlJWklBTXBBNkFCZkNJT0lBTXBBNEFEZkNJVElBTXBBK0FCZkNJVVxuSUFNcEE1QUNJaHNnQXlrRGtBRjhJZ2tnQXlrRDhBSjhJaFVnQXlrRHNBTjhJaFlnQXlrRFVId2lGeUFES1FQQUEzd2lFaUFES1FQUVxuQVNJY0lBTXBBMEI4SWdnZ0F5a0R3QUo4SWdvZ0F5a0RrQU44SWhnZ0F5a0QwQU44SWhwQ05JZ2dHQ0FhVnEwZ0EwSFlBMm9wQXdBZ1xuQ2lBWVZxMGdBMEdZQTJvcEF3QWdDQ0FLVnEwZ0EwSElBbW9wQXdBZ0NDQWNWSzBnQTBIWUFXb3BBd0FnQTBISUFHb3BBd0I4Zkh4OFxuZkh4OGZDSUtRZ3lHaEh3aUNFSTBpQ0FJSUJKVXJTQVNJQmRVclNBRFFjZ0RhaWtEQUNBV0lCZFdyU0FEUWRnQWFpa0RBQ0FWSUJaV1xuclNBRFFiZ0RhaWtEQUNBSklCVldyU0FEUWZnQ2Fpa0RBQ0FKSUJ0VXJTQURRWmdDYWlrREFDQURRWmdCYWlrREFIeDhmSHg4Zkh4OFxuZkh3Z0NrSTBpSHg4SWhKQ0RJYUVmQ0lKUWdTR1F2RC8vLy8vLy8vL0FJTWdDRUl3aUVJUGc0UkNBRUxSaDRDQUVFSUFFS01CSUFBZ1xuQXlrREFDSUtJQU1wQTJCOEloVkMvLy8vLy8vLy93ZUROd01BSUFOQjhBQnFJQXhDQUNBRlFnQVFvd0VnQTBId0FXb2dCMElBSUF0Q1xuQUJDakFTQURRZEFDYWlBUVFnQWdEVUlBRUtNQklBTkJzQUZxSUFSQ0FDQVBRZ0FRb3dFZ0EwR3dBbW9nQmtJQUlCRkNBQkNqQVNBRFxuUVRCcUlBTXBBN0FDSWhnZ0F5a0RzQUY4SWhZZ0F5a0QwQUo4SWhjZ0NTQVVWSzBnRXlBVVZxMGdBMEhvQVdvcEF3QWdEaUFUVnEwZ1xuQTBHSUEyb3BBd0FnRGlBWlZLMGdBMEdvQW1vcEF3QWdBMEdvQVdvcEF3QjhmSHg4Zkh3Z0VrSTBpSHg4SWhKQ0RJWWdDVUkwaUlSOFxuSWc1Qy8vLy8vLy8vL3dlRFFnQkNrUHFBZ0lBQ1FnQVFvd0VnQUNBREtRUHdBU0laSUFNcEEzQjhJaE1nQXlrRE1Id2lGQ0FLSUJWV1xuclNBRFFRaHFLUU1BSUFOQjZBQnFLUU1BZkh3aUNrSU1oaUFWUWpTSWhId2lDVUwvLy8vLy8vLy9CNE0zQXdnZ0EwR0FBV29nQmtJQVxuSUFWQ0FCQ2pBU0FEUVlBQ2FpQU1RZ0FnQzBJQUVLTUJJQU5CNEFKcUlBZENBQ0FOUWdBUW93RWdBMEdnQTJvZ0VFSUFJQTlDQUJDalxuQVNBRFFjQUJhaUFFUWdBZ0VVSUFFS01CSUFOQklHb2dBeWtEb0FNaUJ5QURLUVBBQVh3aUJDQU9JQmRVclNBV0lCZFdyU0FEUWRnQ1xuYWlrREFDQVdJQmhVclNBRFFiZ0NhaWtEQUNBRFFiZ0JhaWtEQUh4OGZId2dFa0kwaUh4OElnOUNESVlnRGtJMGlJUjhJZ1ZDLy8vL1xuLy8vLy93ZURRZ0JDa1BxQWdJQUNRZ0FRb3dFZ0FDQURLUU9BQWlJUUlBTXBBNEFCZkNJR0lBTXBBK0FDZkNJTElBTXBBeUI4SWd3Z1xuQ1NBVVZLMGdFeUFVVnEwZ0EwRTRhaWtEQUNBVElCbFVyU0FEUWZnQmFpa0RBQ0FEUWZnQWFpa0RBSHg4Zkh3Z0NrSTBpSHg4SWhGQ1xuRElZZ0NVSTBpSVI4SWcxQy8vLy8vLy8vL3dlRE53TVFJQU5CRUdvZ0JDQUZWcTBnQkNBSFZLMGdBMEdvQTJvcEF3QWdBMEhJQVdvcFxuQXdCOGZDQVBRalNJZkh3aUJFSU1oaUFGUWpTSWhDQUVRalNJUXBENmdJQ0FBa0lBRUtNQklBQWdBeWtERUNJSElCcEMvLy8vLy8vL1xuL3dlRGZDSUVJQXdnRFZhdElBc2dERmF0SUFOQktHb3BBd0FnQmlBTFZxMGdBMEhvQW1vcEF3QWdCaUFRVkswZ0EwR0lBbW9wQXdBZ1xuQTBHSUFXb3BBd0I4Zkh4OGZId2dFVUkwaUh4OElnWkNESVlnRFVJMGlJUjhJZ1ZDLy8vLy8vLy8vd2VETndNWUlBQWdDRUwvLy8vL1xuLy84L2d5QUVJQVZXclNBRFFSaHFLUU1BSUFRZ0IxU3RmQ0FHUWpTSWZIeENESVlnQlVJMGlJUjhOd01nSUFOQjhBTnFKQUFMaVE0Q1xuQ1g4QmZpTUFRYUFLYXlJSEpBQWdCMEhNQUdvZ0FDZ0NCQ0FESUFRUUZTQUhLQUpNUWRFQWFpMEFBQ0VESUFBb0FnQWlDeWdDQUNnQ1xuQUNJSUxRRDRBU0VFSUFkQmpBTnFJZ3BCQUVFdy9Bc0FBbjhDUUFKQUlBZEIwQUJxSUFOQk1FRWdJQVFiSWdrZ0F5QUpTUnNnQ2tFTVxuUVFnZ0JCc2lBeEJ0UlFSQUlBZEJqQU5xSWdvaUJDQUlRZWdBYWlJSUlBTVFwd0VoQ1NBRUlBUTFBZ0FnQ1VGL2N5SUpJQWdvQWdCeFxuclgwaUVENENBQ0FJUVFScUlRZ2dCRUVFYWlFRUlBTkJBU0FEUVFGTEcwRUJheUVEQTBBZ0F3UkFJQVFnQkRVQ0FDQUlLQUlBSUFseFxuclNBUVFpQ0lRZ0dEZkgwaUVENENBQ0FJUVFScUlRZ2dCRUVFYWlFRUlBTkJBV3NoQXd3QkJRc0xJQWRCSEdvZ0NrRXcvQW9BQUNBTFxuS0FJQUlRZ2dCeUFMS0FJRUtBSUFJZ00yQXBRQklBY2dBeTBBK0FFaUJEb0FtQUVnQnlBRFFRaHFJZ28yQXBBQklBZ29BZ0FpRGkwQVxuK0FFaENTQUhJQUkyQXBBR0lBY2dBVFlDakFZZ0FrVU5BaUFIUVFFMkFwUUdJQUV0QUFCQkJFY05BaUFIUWV3SmFpQURJQW9nQkNBSFxuUVl3R2FoQlhJQWNvQXV3SlFRRkdEUUlnQjBHOENXb2dCMEh3Q1dwQk1Qd0tBQUFnQjBIc0NXb2dBeUFLSUFRZ0IwR01CbW9RVnlBSFxuS0FMc0NVRUJSZzBDSUFkQnZBTnFJQWRCOEFscVFURDhDZ0FBSUFkQmpBTnFJQWRCdkFscVFURDhDZ0FBSUFjb0FwUUdJQWNvQXBBR1xuUncwQ0lBZEJuQWRxSWd3Z0IwR01BMm9pRDBIZ0FQd0tBQUFnQjBHOEJtb2lEU0FNUWVBQS9Bb0FBQ0FIUWR3SWFpQU5RVEQ4Q2dBQVxuSUFkQmpBbHFJQWRCN0FacUlnRkJNUHdLQUFBZ0IwRzhDV29pQWlBTlFURDhDZ0FBSUFkQjdBbHFJZzBnQVVFdy9Bb0FBQ0FNSWdFZ1xuQTBHWUFXb1E4Z0VnRHlBRFFjZ0JhaER5QVNBSFFaQUJhaUFDSUEwZ0FTQVBFSUFCRFFJZ0IwSDhCMm9pQVNBSFFkd0lha0V3L0FvQVxuQUNBSFFhd0lhaUFIUVl3SmFrRXcvQW9BQUNBSFFad0hhaUFCUWVBQS9Bb0FBQ0FBS0FJSUlRQWdCMEVBTmdMRUJpQUhJQVkyQXNBR1xuSUFjZ0JUWUN2QVlnQjBHTUEyb2dDQ0FIUWJ3R2FpQUFFUVlBSUFjb0Fvd0RJZ0JGRFFJZ0J5Z0N4QVlnQnlnQ3dBWkhEUUlnQnlnQ1xubUFNaEFTQUhLQUtVQXlFQ0lBZEJqQU5xSUE1QjZBQnFJZ1VnQ1NBQUlBY29BcEFERU5BQlFRRWdCeWdDakFOQkFVWU5BeG9nQjBHY1xuQVdvZ0IwR1FBMnBCTVB3S0FBQWdCMEdNQTJvZ0JTQUpJQUlnQVJEUUFVRUJJQWNvQW93RFFRRkdEUU1hSUFkQnpBRnFJZ0FnQjBHUVxuQTJwQk1Qd0tBQUFnQjBIOEFXb2lBU0FBSUF0QkRHb29BZ0FSQkFBZ0NDZ0NCQ0VDSUFkQmpBTnFJZ0JCQUVFdy9Bc0FJQUFnQjBFY1xuYWlBQklBSVJCZ0FnQjBHc0Ftb2lBaUFBUVREOENnQUFJQWdvQWdRaEJTQUFRUUJCTVB3TEFDQUFJQWRCbkFGcUlBRWdCUkVHQUNBSFxuUWR3Q2FpSUJJQUJCTVB3S0FBQWdBQ0FDSUFFZ0IwR2NCMm9nQ3lnQ0NCRUlBQ0FIUWJ3R2FpSUNRUUJCTVB3TEFDQUhRUkJxSUFCQlxuREVFSUlBUkJBWEViSWdGQkFYUWlBQ0FCUVFOc1FiRER3QUFRbndFZ0FpQUJJQWNvQWhBZ0J5Z0NGRUhBdzhBQUVKTUNJQWRCekFScVxuSWdVZ0FrRXcvQW9BQUNBRlFReEJDQ0FETFFENEFSc1Ftd0lOQWlBSFFmd0VhaUlNSUFRZ0IwR01BMm9pQlJES0FTQUhRYndHYWlJQ1xuUVFCQk1Qd0xBQ0FIUVFocUlBVWdBU0FBUVpERHdBQVFud0VnQWlJQUlBRWdCeWdDQ0NBSEtBSU1RYUREd0FBUWt3SWdCMEdzQldvaVxuQ0NBQVFURDhDZ0FBSUFNb0FnUWhBaUFBUVFCQk1Qd0xBQ0FBSUFkQnpBUnFJQUlSQkFBZ0IwSGNCV29pQlNBQVFURDhDZ0FBSUFNb1xuQWdRaEFpQUFRUUJCTVB3TEFDQUFJQVVnQWhFRUFDQUhRWXdHYWlJR0lBQkJNUHdLQUFBZ0IwSHNDV29pQWlBRFFaZ0JhaER5QVNBRFxuS0FJQUlRa2dBRUVBUVREOEN3QWdBQ0FHSUFJZ0NSRUdBQ0FIUWR3SWFpSUpJQUJCTVB3S0FBQWdBeWdDQUNFT0lBQkJBRUV3L0FzQVxuSUFBZ0JpQUZJQTRSQmdBZ0IwR01DV29pQlNBQVFURDhDZ0FBSUFJZ0EwSElBV29ROGdFZ0F5Z0NBQ0VHSUFCQkFFRXcvQXNBSUFBZ1xuQlNBQ0lBWVJCZ0FnQjBHOENXb2lBaUFBUVREOENnQUFJQWRCa0FGcUlBd2dDQ0FKSUFJUWdBRU5BaUFIUVp3RWFpSUZJQWRCM0FWcVxuUVREOENnQUFJQWRCakFscUlnQWdCQ0FIUVl3RGFoREtBU0FIUWJ3SmFpSUNJQWRCbkFGcVFURDhDZ0FBSUFNZ0JDQUNJQUFnQlJDR1xuQVVVRVFDQUhRYndKYWlBTFFSQnFJQUVRcHdGRkRRTWdDeWdDQUNnQ0FFSG9BR29oQWtFQUlRQURRQ0FBUVRCSEJFQWdCMEc4Qm1vZ1xuQUdvZ0FDQUNhaWdDQURZQ0FDQUFRUVJxSVFBTUFRVUxDeUFIUWV3SmFpSUFJQWRCdkFacVFURDhDZ0FBSUFkQnZBbHFJQUVnQUNBQlxuSUFvZ0FSQ1VBZzBDSUFNZ0JDQUhRYndKYWlBSFFZd0phaUFIUVp3RWFoQ0dBVVVOQXdVTFFRQU1Bd1VMUVk3UXdBQkJLeUFIUVl3RFxuYWtHd3BzQUFRYlNud0FBUXJ3RUFDeERtQWdBTFFRRUxJQWRCb0FwcUpBQUx3QXdDQTM4VmZpTUFRY0FEYXlJQ0pBQWdBa0dJQTJwQlxuS0JCREdpQUNRWUFEYWtJQU53TUFJQUpCK0FKcVFnQTNBd0FnQWtId0FtcENBRGNEQUNBQ1FnQTNBK2dDSUFKQ0FUY0Q0QUlnQUNrRFxuSUNFVklBQXBBeGdoRVNBQUtRTVFJUThnQUNrRENDRVFJQUFwQXdBaEJpQUJLUU1nSVE0Z0FTa0RHQ0VTSUFFcEF4QWhGaUFCS1FNSVxuSVJjZ0FTa0RBQ0VLUW44aEdBTkFJQU5CQ2taRkJFQkNBQ0VIUWdnaENFRTdJUVFnQ2lFTElBWWhEVUlBSVF4Q0NDRUpBMEFnQkFSQVxuSUFJZ0dFSS9oemNEdUFNZ0Fpa0R1QU1oQlNBQ0lBMUNBWU0zQTdBRFFnQWdBaWtEc0FOOUloTWdCU0FMaFNBRmZZTWdEWHdpR1VJQlxuaUNFTklCa2dCU0FUZ3lJVWd5QUxmQ0VMSUFVZ0RJVWdCWDBnRTRNZ0NId2lDQ0FVZ3lBTWZFSUJoaUVNSUFVZ0NZVWdCWDBnRTRNZ1xuQjN3aUJ5QVVneUFKZkVJQmhpRUpJQVJCQVdzaEJDQVVJQmlGUWdGOUlSZ01BUVVMQ3lBQ0lBZzNBOWdDSUFJZ0J6Y0QwQUlnQWlBTVxuTndQSUFpQUNJQWszQThBQ0lBSkJpQU5xSUFKQjRBSnFJQUpCd0FKcUlBRVFDaUFDUWJBQ2FpQUpJQWxDUDRjaUN5QUtJQXBDUDRjaVxuRXhDakFTQUNRWkFDYWlBTUlBeENQNGNpRFNBR0lBWkNQNGNpRkJDakFTQUNRYUFDYWlBSElBZENQNGNpQlNBS0lCTVFvd0VnQWtHQVxuQW1vZ0NDQUlRaitISWdvZ0JpQVVFS01CSUFKQjhBRnFJQWtnQ3lBWElCZENQNGNpQmhDakFTQUNRZEFCYWlBTUlBMGdFQ0FRUWorSFxuSWhNUW93RWdBa0hnQVdvZ0J5QUZJQmNnQmhDakFTQUNRY0FCYWlBSUlBb2dFQ0FURUtNQklBSkJzQUZxSUFrZ0N5QVdJQlpDUDRjaVxuQmhDakFTQUNRWkFCYWlBTUlBMGdEeUFQUWorSEloQVFvd0VnQWtHZ0FXb2dCeUFGSUJZZ0JoQ2pBU0FDUVlBQmFpQUlJQW9nRHlBUVxuRUtNQklBSkI4QUJxSUFrZ0N5QVNJQkpDUDRjaUJoQ2pBU0FDUWRBQWFpQU1JQTBnRVNBUlFqK0hJZzhRb3dFZ0FrSGdBR29nQnlBRlxuSUJJZ0JoQ2pBU0FDUVVCcklBZ2dDaUFSSUE4UW93RWdBa0V3YWlBSklBc2dEaUFPUWorSElnWVFvd0VnQWtFUWFpQU1JQTBnRlNBVlxuUWorSElnc1Fvd0VnQWtFZ2FpQUhJQVVnRGlBR0VLTUJJQUlnQ0NBS0lCVWdDeENqQVNBQ0tRTWdJZ2tnQWlrREFId2lCaUFDS1FOZ1xuSWdjZ0Fpa0RRSHdpQ2lBQ0tRT2dBU0lJSUFJcEE0QUJmQ0lMSUFJcEErQUJJZ1VnQWlrRHdBRjhJZzBnQWlrRG9BSWlEQ0FDS1FPQVxuQW53aURrSStpQ0FNSUE1V3JTQUNRYWdDYWlrREFDQUNRWWdDYWlrREFIeDhJZzVDQW9hRWZDSU1RajZJSUF3Z0RWU3RJQVVnRFZhdFxuSUFKQjZBRnFLUU1BSUFKQnlBRnFLUU1BZkh3Z0RrSStoM3g4SWdWQ0FvYUVmQ0lOUWo2SUlBc2dEVmF0SUFnZ0MxYXRJQUpCcUFGcVxuS1FNQUlBSkJpQUZxS1FNQWZId2dCVUkraDN4OElnaENBb2FFZkNJTFFqNklJQW9nQzFhdElBY2dDbGF0SUFKQjZBQnFLUU1BSUFKQlxueUFCcUtRTUFmSHdnQ0VJK2gzeDhJZ2RDQW9hRWZDSUtRajZJSUFZZ0NsYXRJQVlnQ1ZTdElBSkJLR29wQXdBZ0FrRUlhaWtEQUh4OFxuSUFkQ1BvZDhmRUlDaG9RaEZTQUNLUU13SWc0Z0Fpa0RFSHdpQmlBQ0tRTndJaEVnQWlrRFVId2lDU0FDS1FPd0FTSVBJQUlwQTVBQlxuZkNJSElBSXBBL0FCSWhBZ0Fpa0QwQUY4SWdnZ0Fpa0RzQUlpQlNBQ0tRT1FBbndpRWtJK2lDQUZJQkpXclNBQ1FiZ0NhaWtEQUNBQ1xuUVpnQ2Fpa0RBSHg4SWhKQ0FvYUVmQ0lGUWo2SUlBVWdDRlN0SUFnZ0VGU3RJQUpCK0FGcUtRTUFJQUpCMkFGcUtRTUFmSHdnRWtJK1xuaDN4OEloQkNBb2FFZkNJSVFqNklJQWNnQ0ZhdElBY2dEMVN0SUFKQnVBRnFLUU1BSUFKQm1BRnFLUU1BZkh3Z0VFSStoM3g4SWc5Q1xuQW9hRWZDSUhRajZJSUFjZ0NWU3RJQWtnRVZTdElBSkIrQUJxS1FNQUlBSkIyQUJxS1FNQWZId2dEMEkraDN4OEloRkNBb2FFZkNJSlxuUWo2SUlBWWdDVmF0SUFZZ0RsU3RJQUpCT0dvcEF3QWdBa0VZYWlrREFIeDhJQkZDUG9kOGZFSUNob1FoRGlBS1F2Ly8vLy8vLy8vL1xuUDRNaEVTQUpRdi8vLy8vLy8vLy9QNE1oRWlBTFF2Ly8vLy8vLy8vL1A0TWhEeUFIUXYvLy8vLy8vLy8vUDRNaEZpQU5Rdi8vLy8vL1xuLy8vL1A0TWhFQ0FJUXYvLy8vLy8vLy8vUDRNaEZ5QU1Rdi8vLy8vLy8vLy9QNE1oQmlBRlF2Ly8vLy8vLy8vL1A0TWhDaUFEUVFGcVxuSVFNTUFRVUxDeUFDUVlnRGFpSURJQTRnQVJCQklBQWdBMEVvRUNrYUlBSkJ3QU5xSkFBTHlnc0NCMzhCZmlNQVFhQURheUlJSkFBZ1xuQ0VFb2FpQUJFUDBCSUFnb0Fpd2hDaUFJS0FJb0lRa2dDRUVnYWlBQ0lBTVE2QUVnQ0NnQ0pDRUNJQWdvQWlBaEF5QUlRUmhxSUFRZ1xuQlJEb0FTQUlLQUljSVFzZ0NDZ0NHQ0VNSUFoQkVHb2dCaUFIRU9nQklBZ29BaFFoRFNBSUtBSVFJUTRnQ0VIa0FXb2dEQ0FMRUxNQlxuQWtBZ0NDMEE1QUZCQVVZRVFDQUlRVGhxSUFoQjhBRnFLQUlBTmdJQUlBZ2dDQ2tDNkFFM0F6QU1BUVVMSUFoQnlBQnFJQWhCN1FGcVxuS1FBQU53TUFJQWhCMEFCcUlBaEI5UUZxS1FBQU53TUFJQWhCMkFCcUlBaEIvUUZxS1FBQU53TUFJQWdnQ0NrQTVRRTNBMEFDUUNBQ1xuQkVBZ0NFSGdBbW9pQVVFQVFjQUEvQXNBUWVUMHdBQW9BZ0FhSXdCQjBBQnJJZ1FrQUFKL0FrQWdBa1VOQUNBRUlBTkJBV28yQWt3Z1xuQXkwQUFFRXdSdzBBSUFSQnlBQnFJQVJCekFCcUlBSWdBMm9pQlJDQ0FVVU5BQ0FFS0FKSUlBVWdCQ2dDVEd0SERRQWdCRUVvYWlBRVxuUWN3QWFpQUZFRXRGRFFBZ0JFRUlhaUFFUWN3QWFpQUZFRXRGRFFBZ0JDZ0NUQ0FGUncwQUlBRWdCQ2tES0RjQUFDQUJJQVFwQXdnM1xuQUNBZ0FVRVlhaUFFUVVCcktRTUFOd0FBSUFGQkVHb2dCRUU0YWlrREFEY0FBQ0FCUVFocUlBUkJNR29wQXdBM0FBQWdBVUVvYWlBRVxuUVJCcUtRTUFOd0FBSUFGQk1Hb2dCRUVZYWlrREFEY0FBQ0FCUVRocUlBUkJJR29wQXdBM0FBQkJBUXdCQ3lBQlFjQUFFRU1hUVFBTFxuSUFSQjBBQnFKQUJCQVVZTkFRVUxJQWhCNkFGcVFRY2dDQkEySUFoQk9Hb2dDRUh3QVdvb0FnQTJBZ0FnQ0NBSUtRTG9BU0lQTndDblxuQVNBSUlBODNBekFNQVFzZ0NDQUlMd0RnQWpzQTVRRWdDQ0FJUWVJQ2FpMEFBRG9BNXdFZ0NDa0E0d0loRHlBSVFhZ0NhaUlCSUFoQlxuNndKcVFUWDhDZ0FBSUFoQjhBRnFJQUZCTmZ3S0FBQWdDQ0FQTndMb0FTQUlRYVFCYWlJQklBaEI1QUZxSWdSQkFYSkJ3QUQ4Q2dBQVxuSUFoQjVBQnFJQUZCd0FEOENnQUFJQVFnRGlBTkVGZ2dDQzBBNUFGQkFVWUVRQ0FJUVRocUlBaEI4QUZxS0FJQU5nSUFJQWdnQ0NrQ1xuNkFFM0F6QU1BUVVMSUFoQjRBSnFJZ1FnQ0VIa0FXcEJBWEpCd0FEOENnQUFJQWhCcEFGcUlnRWdCRUhBQVB3S0FBQWdDU2dDQUNFR1xuSUFoQjVBQnFJUVVnQ0VGQWF5RUpRUUFoQnlNQVFlQUVheUlFSkFBQ1FDQUdLQUlBUlFSQVFmVHJ3QUFnQmtHMEFXb29BZ0FnQmlnQ1xuc0FFUkJBQU1BUVVMSUFRZ0NVRUFFRUlnQkVIWUFHb2dCVUVZYWlrQUFEY0RBQ0FFUWRBQWFpQUZRUkJxS1FBQU53TUFJQVJCeUFCcVxuSUFWQkNHb3BBQUEzQXdBZ0JFRW9haUFGUVNocUtRQUFOd01BSUFSQk1Hb2dCVUV3YWlrQUFEY0RBQ0FFUVRocUlBVkJPR29wQUFBM1xuQXdBZ0JDQUZLUUFBTndOQUlBUWdCU2tBSURjRElDQUVRU0JxRU1zQkRRQWdCaUFFUWVBQWFpQUJFTWNCUlEwQUlBUXBBMWdnQkNrRFxuVUNBRUtRTklJQVFwQTBDRWhJUlFEUUFnQkNrRE9DQUVLUU13SUFRcEF5Z2dCQ2tESUlTRWhGQU5BQ0FFUWFBRWFpSUJJQVJCSUdvUVxubFFFZ0JFR0FCR29pQlNBQklBUVFHeUFFUWVBRGFpSUpJQUVnQkVGQWF4QWJJQVFnQkNnQ3NBRTJBckFESUFSQnVBSnFJZ0VnQkVIZ1xuQUdwQktCQXBHaUFFUWVBQ2FpQUVRWWdCYWtFb0VDa2FJQVJCa0FOcVFnQTNBd0FnQkVHWUEycENBRGNEQUNBRVFhQURha0lBTndNQVxuSUFSQnFBTnFRZ0EzQXdBZ0JFSUJOd09JQXlBR0lBUkJ1QUZxSUFFZ0NTQUZFQTBnQkNnQ3NBSU5BQ0FFUWNBRWFpSUJJQVJCUUdzUVxuVGlBRVFiZ0RhaUlGSUFFUVJScEJBU0VISUFVZ0JFRzRBV29RdGdFTkFFRUFJUWNnQkVHNEEyb1ExUUZCQUU0TkFDQUVRYmdEYWlJQlxuUVlqeHdBQVEzd0VnQVNBRVFiZ0JhaEMyQVVFQVJ5RUhDeUFFUWVBRWFpUUFJQWRGQkVBZ0NFRXdha0VKSUFnUU5nd0JCUXNnQ0VHQVxuZ0lDQWVEWUNNQXNnRGlBTkVOOENJQXdnQ3hEZkFpQURJQUlRM3dJZ0NpQUtLQUlBUVFGck5nSUFJQWhCQ0dvZ0NFRXdhaENhQWlBSVxuS0FJTUlRRWdBQ0FJS0FJSUlnSTJBZ1FnQUNBQlFRQWdBa0VCY1JzMkFnQWdDRUdnQTJva0FBdllDd0VMZnlNQVFlQUNheUlHSkFBZ1xuQmtFWWFpQUJFUDBCSUFZb0Fod2hDaUFHS0FJWUlRRWdCa0VRYWlBQ0lBTVE2QUVnQmlnQ0ZDRUxJQVlvQWhBaERDQUdRUWhxSUFRZ1xuQlJEb0FTQUdLQUlNSVEwZ0JpZ0NDQ0VPSUFaQnRBRnFJQXdnQ3hCbUFrQUNRQUpBSUFZdEFMUUJRUUZHQkVBZ0JrRXNhaUFHUWNBQlxuYWlnQ0FEWUNBQ0FHSUFZcEFyZ0JOd0lrSUFaQkFUWUNJQXdCQlFzZ0JrRTRhaUFHUWIwQmFpSUNLUUFBTndNQUlBWkJRR3NnQmtIRlxuQVdvaUF5a0FBRGNEQUNBR1FjZ0FhaUFHUWMwQmFpSUVLUUFBTndNQUlBWWdCaWtBdFFFM0F6QWdCa0cwQVdvZ0RpQU5FTE1CSUFZdFxuQUxRQlFRRkdCRUFnQmtFc2FpQUdRY0FCYWlnQ0FEWUNBQ0FHSUFZcEFyZ0JOd0lrSUFaQkFUWUNJQXdCQlFzZ0JrSFlBR29nQWlrQVxuQURjREFDQUdRZUFBYWlBREtRQUFOd01BSUFaQjZBQnFJQVFwQUFBM0F3QWdCaUFHS1FDMUFUY0RVQ0FCS0FJQUlRSWdCa0cwQVdvaVxuQVVFQVFjQUEvQXNBSUFaQjBBQnFJUVVnQmtFd2FpRUlRZER0d0FBb0FnQWhDVUVBSVFRakFFSGdBR3NpQXlRQUlBTkJFR3BCOE8zQVxuQUMwQUFEb0FBQ0FEUWVqdHdBQXBBd0EzQXdnZ0EwSGc3Y0FBS1FNQU53TUFBa0FnQWlnQ0NFVUVRRUdvN01BQUlBSkJ0QUZxS0FJQVxuSUFJb0FyQUJFUVFBREFFRkN5QUNJQU5CUUdzZ0EwRWdha0VBSUFVZ0NDQUpJQU1RTHlFRUlBRkJHR29nQTBIWUFHb3BBd0EzQUFBZ1xuQVVFUWFpQURRZEFBYWlrREFEY0FBQ0FCUVFocUlBTkJ5QUJxS1FNQU53QUFJQUVnQXlrRFFEY0FBQ0FCSUFNcEF5QTNBQ0FnQVVFb1xuYWlBRFFTaHFLUU1BTndBQUlBRkJNR29nQTBFd2Fpa0RBRGNBQUNBQlFUaHFJQU5CT0dvcEF3QTNBQUFMSUFOQjRBQnFKQUFnQmlBRVxuSWdFMkFuUWdBVUVCUncwQklBWkI5QUJxSWdFZ0JrRzBBV3BCd0FEOENnQUFJQVpCZ0FKcUlnUkJBRUhJQVB3TEFDQUdRY2dBTmdMSVxuQWtIazlNQUFLQUlBR2lBR1FjZ0NhaUVQSXdCQm9BRnJJZ2NrQUNBSFFTaHFJQUZCQ0dvcEFBQTNBd0FnQjBFd2FpQUJRUkJxS1FBQVxuTndNQUlBZEJPR29nQVVFWWFpa0FBRGNEQUNBSFFRaHFJQUZCS0dvcEFBQTNBd0FnQjBFUWFpQUJRVEJxS1FBQU53TUFJQWRCR0dvZ1xuQVVFNGFpa0FBRGNEQUNBSElBRXBBQUEzQXlBZ0J5QUJLUUFnTndNQVFTRWhBaUFIUWZBQWFpSUJRU0VRUXhvZ0IwRkFheUlEUVNFUVxuUXhwQkFTRUZJQUZCQVhJZ0IwRWdhaEJPSUFOQkFYSWdCeEJPSUFkQmtBRnFJUWtDUUFOQUlBSkJBa2tOQVFKQUlBRXRBQUFOQUNBQlxuUVFGcUlnTXNBQUJCQUVnTkFDQUNRUUZySVFJZ0F5RUJEQUVMQ3lBQklRa2dBaUVGQ3lBSFFlQUFhaUVRUVNFaEFpQUhRVUJySVFGQlxuQVNFSUFrQURRQ0FDUVFKSkRRRUNRQ0FCTFFBQURRQWdBVUVCYWlJRExBQUFRUUJJRFFBZ0FrRUJheUVDSUFNaEFRd0JDd3NnQVNFUVxuSUFJaENBc2dEeWdDQUNBUElBVWdDR3BCQm1vaUFqWUNBQ0FDVHdSQUlBUWdCVG9BQXlBRVFRSTZBQUlnQkVFd09nQUFJQVFnQ0NBRlxuUVFScUlnRnFPZ0FCSUFSQkJHb2dDU0FGRUNrYUlBUWdCV29pQWtFRmFpQUlPZ0FBSUFFZ0JHcEJBam9BQUNBQ1FRWnFJQkFnQ0JBcFxuR2dVTElBZEJvQUZxSkFBZ0JpQUdLQUxJQWlJQk5nTE1BaUFCUWNrQVR3MENJQVpCdEFGcUlnSWdCa0dBQW1wQnlBRDhDZ0FBSUFZZ1xuQVRZQy9BRWdCa0VrYWlBQ0lBRVF0UUVnQmtFQU5nSWdDeUFPSUEwUTN3SWdEQ0FMRU44Q0lBb2dDaWdDQUVFQmF6WUNBQ0FHUWJRQlxuYWlBR1FTQnFFS0lCSUFZb0FyZ0JJUUVDZnlBR0tBSzBBUVJBUVFFaEEwRUFJUVJCQUF3QkJRdEJBQ0VESUFFaEJFRUFJUUVnQmlnQ1xudkFFTElRSWdBQ0FETmdJTUlBQWdBVFlDQ0NBQUlBSTJBZ1FnQUNBRU5nSUFJQVpCNEFKcUpBQVBDeUFHUVFBMkFvQUNJQVpCOUFCcVxuUWRDaXdBQWdCa0dBQW1wQjhKSEFBQkRSQWdBTElBWkJBallDdUFFZ0JrSDBnTUFBTmdLMEFTQUdRZ0kzQXNBQklBWkJCallDM0FJZ1xuQmtIQWdNQUFOZ0xZQWlBR1FRWTJBdFFDSUFZZ0JrSFFBbW8yQXJ3QklBWWdCa0hNQW1vMkF0QUNJQVpCdEFGcVFZU0J3QUFRZXdBTFxuNkFzQ0RuOEhmaU1BUWNBQmF5SUdKQUFnQmtFb2FrSEFBQkJER2lBQklBQkJLR3BCZ0FFUUtTRUhJQVpCQ0dvZ0FpQUFRUWhxRUk0QlxuSUFaQkFEWUN1QUZCQUNFQkEwQWdBVUhBQUVjRVFDQUdRUWhxSUFGQkFYWkIrUC8vL3dkeGFpa0RBQ0FCUVFKMFFUeHhyWWluUVE5eFxuUVFaMElRaEJBQ0VDQTBBZ0FrR0FDRWNFUUNBR1FTaHFJZzBnQUNnQ0FDQVFhaUFDYWlJRklBSWdDRVlpQkJDb0FTQU5RU0JxSUFWQlxuSUdvZ0JCQ29BU0FDUVVCcklRSU1BUVVMQ3lBR1FlZ0FhaUlDSUFaQktHb1FzUUlqQUVHUUJHc2lBeVFBSUFOQjZBTnFJZ1VnQjBIUVxuQUdvaUNSQVhJQU5Cd0FOcUlnc2dCMEVvRUNrYUlBc1FxZ0VnQTBHWUEyb2dBaUFGRUE0Z0EwSHdBbW9pRGlBSFFTaHFRU2dRS1JvZ1xuRGhDcUFTQURRY2dDYWlJRUlBSkJLR29pRFNBRkVBNGdCQ0FFSUFrUURpQURRYUFDYWlJS0lBdEJLQkFwR2lBRElBTXBBNWdESWhZZ1xuQXlrRG9BSjhOd09nQWlBRElBTXBBNkFESWhjZ0F5a0RxQUo4TndPb0FpQURJQU1wQTZnREloRWdBeWtEc0FKOE53T3dBaUFESUFNcFxuQTdBREloSWdBeWtEdUFKOE53TzRBaUFESUFNcEE3Z0RJaE1nQXlrRHdBSjhOd1BBQWlBRFFkQUJhaUlNSUE1QktCQXBHaUFESUFNcFxuQTlBQklBTXBBOGdDZkRjRDBBRWdBeUFES1FQWUFTQURLUVBRQW53M0E5Z0JJQU1nQXlrRDRBRWdBeWtEMkFKOE53UGdBU0FESUFNcFxuQStnQklBTXBBK0FDZkRjRDZBRWdBeUFES1FQd0FTQURLUVBvQW53M0EvQUJJQU5CMkFCcUlnZ2dDaEFYSUFOQy9QLy8vLy8vL3dFZ1xuRTMwaUZEY0RVQ0FEUXZ6Ly8vLy8vLzhmSUJKOUloVTNBMGdnQTBMOC8vLy8vLy8vSHlBUmZTSVJOd05BSUFOQy9QLy8vLy8vL3g4Z1xuRjMwaUVqY0RPQ0FEUXJ6aC8vKy8vLzhmSUJaOUloTTNBekFnQTBINEFXb2dDeUFEUVRCcUlnOFFEaUFESUFNcEExZ2dBeWtEK0FGOFxuTndOWUlBTWdBeWtEWUNBREtRT0FBbnczQTJBZ0F5QURLUU5vSUFNcEE0Z0NmRGNEYUNBRElBTXBBM0FnQXlrRGtBSjhOd053SUFNZ1xuQXlrRGVDQURLUU9ZQW53M0EzZ2dEQkNkQVNFRklBZ1FuUUVoQkNBRFFRaHFJZ3NnRGtFb0VDa2FJQU1nQXlrRENFSUJoamNEQ0NBRFxuSUFNcEF4QkNBWVkzQXhBZ0F5QURLUU1ZUWdHR053TVlJQU1nQXlrRElFSUJoamNESUNBRElBTXBBeWhDQVlZM0F5Z2dBeUFES1FQQVxuQXlBVGZEY0RNQ0FESUFNcEE4Z0RJQko4TndNNElBTWdBeWtEMEFNZ0VYdzNBMEFnQXlBREtRUFlBeUFWZkRjRFNDQURJQU1wQStBRFxuSUJSOE53TlFJQXNnQ0NBRUlBVnhJZ1ZGSWdRUW1BRWdEeUFNSUFRUW1BRWdBMEdvQVdvaUJDQVBFQmNnQTBHQUFXb2dCQ0FLRUE0Z1xuQkNBRUVCY2dCQ0FNSUFVUW1BRWdDaUFMRUJjZ0NTSU1JQWtnRHhBT0lBd1FuUUVoQlNBSEtBSjRJUVFnREVFQ0VPVUJJQU5Ddk9IL1xuLzcvLy94OGdBeWtEZ0FGOUloUWdBeWtEb0FKOE53T2dBaUFEUXZ6Ly8vLy8vLzhmSUFNcEE0Z0JmU0lWSUFNcEE2Z0NmRGNEcUFJZ1xuQTBMOC8vLy8vLy8vSHlBREtRT1FBWDBpRVNBREtRT3dBbnczQTdBQ0lBTkMvUC8vLy8vLy94OGdBeWtEbUFGOUloSWdBeWtEdUFKOFxuTndPNEFpQURRdnovLy8vLy8vOEJJQU1wQTZBQmZTSVRJQU1wQThBQ2ZEY0R3QUlnQ2hDcUFTQUhJQXBCS0JBcElRa2dBeUFUSUFNcFxuQThBQ1FnR0dmRGNEd0FJZ0F5QVNJQU1wQTdnQ1FnR0dmRGNEdUFJZ0F5QVJJQU1wQTdBQ1FnR0dmRGNEc0FJZ0F5QVZJQU1wQTZnQ1xuUWdHR2ZEY0RxQUlnQXlBVUlBTXBBNkFDUWdHR2ZEY0RvQUlnQ2lBS0lBc1FEaUFESUFNcEE2QUNJQU1wQTZnQmZEY0RvQUlnQXlBRFxuS1FPb0FpQURLUU93QVh3M0E2Z0NJQU1nQXlrRHNBSWdBeWtEdUFGOE53T3dBaUFESUFNcEE3Z0NJQU1wQThBQmZEY0R1QUlnQXlBRFxuS1FQQUFpQURLUVBJQVh3M0E4QUNJQWxCS0dvaUNDQUtRUU1RendFZ0NCQ3FBU0FKUVFRUTVRRWdDRUVFRU9VQklBa2dBaUFIS0FKNFxuRUpnQklBZ2dEU0FIS0FKNEVKZ0JJQXhCa1BMQUFDQUhLQUo0RUpnQklBa2dCU0FFUVg5emNUWUNlQ0FEUVpBRWFpUUFJQkJCZ0FocVxuSVJBZ0FVRUJhaUVCREFFRkN3c2dCa0hvQUdvUXZ3SWdCa0hBQVdva0FBdmpDUUlLZndsK0l3QkJ3QTVySWdRa0FDQUVRZUFCYWtIZ1xuREJDbkFpQUVRY0FDYWlJSklBSVFsZ0lnQkVIZ0Ftb2lDaUFERUpZQ0lBUkJnQU5xSWd4QmtObkFBQkQ4QWtFQ0lRWkJBQ0VDQTBBZ1xuQWtHZ0MwWUVRQ0FFUVlBQmFrSGdBQkJER2lBRVFVQnJJUW9nQkVFZ2FpRUhJQVJCd0FGcUlRZ2dCRUdnQVdvaENVRUFJUU5CL3dFaFxuQWdVZ0JFSGdBV29nQW1vaUEwR0FBbW9oQlNBRFFlQUJhaUVISUFOQndBRnFJUWdDUUNBR1FRRnhCRUFnQ0NBSElBVWdDU0FLSUF4QlxuQUNBRFFlQUFhaUFEUVlBQmFpQURRYUFCYWhBb0RBRUZDeUFJSUFjZ0JTQUVRZUFCYWlBR1FRRjJRZUFBYkdvaUF5QURRU0JxSUFOQlxuUUdzUWNBc2dBa0hnQUdvaEFpQUdRUUZxSVFZTUFRc0xBMEFnQWtHQUFra0VRQ0FEUVFGeElnd0VRQ0FFUVlBQmFpSUZJQWtnQ0NBRlxuSUFrZ0NCQndCUXNnQWtIL0FYRkJCWEFFUUNBQ1FRRnJJUUlNQWdVQ2Z3SkFJQUpCK3dGTkJFQWdBa0VEYWlFR0lBRWdBa0VFYWlJRFxuUVFOMlFmei8vLzhCY1dvb0FnQWdBM1pCQlhSQklIRWhBd3dCQlF0QkFDRURRZjhCSVFaQkFDQUNRZndCUncwQkdnc2dBU0FHUVFOMlxuUWZ6Ly8vOEJjV29vQWdBZ0JuWkJBWEVMUVFSMElBTnlJUXRCQUNFR1FRQWhCU0FDUWYwQlRRUkFJQUVnQWtFQ2FpSUZRUU4yUWZ6L1xuLy84QmNXb29BZ0FnQlhaQkFYRWhCUVVMSUFFZ0FrRURka0g4Ly8vL0FYRnFLQUlBSUFKMlFRRjBRUUp4SUFzZ0JVRURkSElnQWtIK1xuQVUwRWZ5QUJJQUpCQVdvaUJrRURka0g4Ly8vL0FYRnFLQUlBSUFaMlFRRnhCVUVBQzBFQ2RISnlJUXRCQUNFR1FRQWhCU0FDUVFGclxuSWdKQi93Rk5CRUFnQVNBQ1FRTjJRZnovLy84QmNXb29BZ0FnQW5aQkFYRWhCUVVMSUFSQjRBQVFwd0pCQUNBRFFRVjJJZ05ySWcxQlxuUHlBRklBdHlJZ1ZyY1NBRklBTkJBV3R4Y2lJRFFRRjJJQU5CQVhGcUlRc2dCRUhnQVdvaEF3TkFJQVpCRVVaRkJFQWdCQ0FHSUF0elxuSWdVZ0F5QUVFRzRnQnlBRklBTkJJR29nQnhCdUlBb2dCU0FEUVVCcklBb1FiaUFEUWVBQWFpRURJQVpCQVdvaEJnd0JCUXNMSUFSQlxuZjBFQVFnQWdCRFVDUEVJQVFnQWdCRFVDT0VJQVFnQWdCRFVDTkVJQVFnQWdCRFVDTUVJQVFnQWdCRFVDTEVJQVFnQWdCRFVDS0VJQVxuUWdBZ0JEVUNKRUlBUWdBZ0JEVUNJSDBpRDBJZ2lIMUMvd0dEZkgwaUVFSWdpSDFDL3dHRGZIMGlFVUlnaUgxQy93R0RmSDBpRWtJZ1xuaUgxQy93R0RmSDBpRTBJZ2lIMUMvd0dEZkgwaUZFSWdpSDFDL3dHRGZIMGlGVUlnaUgxQy93R0RmQ0lXZlVLQWdJQ0E4QitEUWdCU1xuR3lJRHJTSU9JQTlDLy8vLy93K0RmQ0lQUGdKZ0lBUWdFRUwvLy8vL0Q0TWdEbndnRDBJZ2lId2lEejRDWkNBRUlCRkMvLy8vL3crRFxuSUE1OElBOUNJSWg4SWc0K0FtZ2dCQ0FTUXYvLy8vOFBneUFPUWlDSWZDSU9QZ0pzSUFRZ0UwTC8vLy8vRDRNZ0RrSWdpSHdpRGo0Q1xuY0NBRUlCUkMvLy8vL3crRElBNUNJSWg4SWc0K0FuUWdCQ0FEUVFGeHJTQVZRdi8vLy84UGczd2dEa0lnaUh3aURqNENlQ0FFSUFNZ1xuRGtJZ2lDQVdmYWRxTmdKOElBY2dEVUVCY1NBSElBUkI0QUJxRUc0Q1FDQU1SUVJBSUFSQmdBRnFJQVFRL0FJZ0NTQUhFUHdDSUFnZ1xuQ2hEOEFnd0JCUXNnQkVHQUFXb2lBeUFKSUFnZ0F5QUpJQWhCQUNBRUlBY2dDaEFvQzBFQklRTU1BZ3NBQlFzTElBQWdCRUdBQVdvUVxubGdJZ0FFRWdhaUFKRUpZQ0lBQkJRR3NnQ0JDV0FpQUVRY0FPYWlRQUM4d0tBZ1YvQTM0akFFR0FCbXNpQkNRQVFRRWhCUUpBSUFFb1xuQWdCQkFVWUVRQ0FFUVlnQ2FpQUJRUnhxS1FJQU53TUFJQVJCZ0FKcUlBRkJGR29wQWdBM0F3QWdCRUg0QVdvZ0FVRU1haWtDQURjRFxuQUNBRUlBRXBBZ1EzQS9BQkRBRUZDeUFFUWZRQmFpQUJRUWhxUWNBQS9Bb0FBRUVBSVFVTElBUkI2QUJxSWdkQkFFR0FBZndMQUNBRVxuSUFVMkFoQWdCRUVRYWlJRlFRUnlJQVJCOEFGcUlnWkJ4QUQ4Q2dBQUlBUkJBRFlDNkFFZ0JFSUFOd05ZSUFRZ0FUWUNZQ0FCTFFCU1xuSVFnakFFRVFheUlCSkFBZ0FVRUVhaUFGSUFJZ0F5QUZLQUpRS0FKSUVRZ0FJQUVwQWdnaENTQUZRbjhnQlNrRFNDSUtJQUUxQWdSOFxuSWdzZ0NpQUxWaHMzQTBnZ0JFRUlhaUFKTndNQUlBRkJFR29rQUNBSElBZ2dCQ2dDQ0NBRUtBSU1JZ0VROFFFZ0JDQUJOZ0xvQVNBR1xuSUFWQjRBSDhDZ0FBSUFSQm1BUnFJQVZCMkFEOENnQUFBa0FDUUFKQUFuNGdCRUd3QldvaEFRSkFJQVFwQStBRUlna2dCQ2dDeUFNaVxuQXExOElnb2dDVm9FUUNBS1F2Ly8vLy8vLy8vL0gxZ05BU0FLSVFrRkN5QUJRUUEyQWdBZ0FTQUpOd01JSUFRb0FyQUZJZ0ZCQWtjTlxuQWlBRUtRTzRCUXdCQ3lBS1FnT0dDeUVKUVFBZ0JFSElBbW9pQXlBQ2FpSUhJQVFvQXVnRUlnWXRBRklpQVNBQ1NTSUlHeUVGSUFoQlxuQVNBQklBSnJJZ0liQkVBZ0JFSFlBMm9pQUVFQk5nSUFJQUFnQWtFQUlBVWJOZ0lFREFJRkN5QUZRWUFCT2dBQUlBZEJBV29oQlNBQ1xuUVFGcklnSkJDRUVRSUFGQndBQkdHMGtFUUNBRklBSVFwUUlnQkVHd0JXb2dCRUdZQkdvZ0F5QUJJQVlvQWtnUkNBQWdBeUVGSUFFaFxuQWdVTElBVWdBa0VJYXlJQ0VLVUNJQUlnQldvZ0NVSTRoaUFKUW9EK0E0TkNLSWFFSUFsQ2dJRDhCNE5DR0lZZ0NVS0FnSUQ0RDROQ1xuQ0lhRWhDQUpRZ2lJUW9DQWdQZ1BneUFKUWhpSVFvQ0EvQWVEaENBSlFpaUlRb0QrQTRNZ0NVSTRpSVNFaERjQUFDQUVRYkFGYWlBRVxuUVpnRWFpQURJQUVnQkNnQzZBUW9Ba2dSQ0FBZ0JDZ0M2QVFoQXlBRVFkZ0RhaUVISUFRb0FwZ0VRUUZ4QkVBZ0JFR0lCV29nQkVHMFxuQkdvcEFnQTNBd0FnQkVHQUJXb2dCRUdzQkdvcEFnQTNBd0FnQkVINEJHb2dCRUdrQkdvcEFnQTNBd0FnQkNBRUtRS2NCRGNEOEFSQlxuQUNFQklBUkJzQVZxUVFCQndBRDhDd0JCQkJDZkFpSUNRUWdnQWtFSVNSdEJBblFoQlFOQUlBRWdCVWNFUUNBRUlBUkI4QVJxSUFGcVxuS0FJQUlnSkJHSFFnQWtHQS9nTnhRUWgwY2lBQ1FRaDJRWUQrQTNFZ0FrRVlkbkp5TmdMd0JTQUVRYkFGYWlBQmFrRUVJQVJCOEFWcVxuUVFRUW9BSWdBVUVFYWlFQkRBRUZDd3NNQXdVTFFjQUFJUUVnQkVId0JHb2lBaUFFUWFBRWFrSEFBUHdLQUFBZ0JFR3dCV29pQlVFQVxuUWNBQS9Bc0FRUWdRbndJaUJrRUlJQVpCQ0VrYlFRTjBJUVlEUUNBQklBWnFRY0FBUndSQUlBUWdBaWtEQUNJSlFqaUdJQWxDZ1A0RFxuZzBJb2hvUWdDVUtBZ1B3SGcwSVloaUFKUW9DQWdQZ1BnMElJaG9TRUlBbENDSWhDZ0lDQStBK0RJQWxDR0loQ2dJRDhCNE9FSUFsQ1xuS0loQ2dQNERneUFKUWppSWhJU0VOd1B3QlNBRklBRkJDQ0FCUVFoSkd5QUVRZkFGYWtFSUVLQUNJQUpCQ0dvaEFpQUZRUWhxSVFVZ1xuQVVFSWF5RUJEQUVGQ3dzTUFnc2dCQ0FFS1FPNEJUY0Q0QU1nQkNBRUtBSzBCVFlDM0FNZ0JDQUJOZ0xZQXdzZ0JDZ0MyQU5CQVhGRlxuQkVCQmp0REFBRUVySUFSQi93VnFRWml6d0FCQnVMUEFBQkN2QVFBRkMwSFF3OEFBUVNoQnFMUEFBQkRzQVFBTElBY2dCRUd3QldwQlxud0FEOENnQUFJQVFnQXpZQzFBTWdCQ2tEMkFNaENTQUVRWmdFYWlJQklBUkI0QU5xUVRqOENnQUFJQUFnQ1RjQ0JDQUFJQU0yQWdBZ1xuQUVFTWFpQUJRVGo4Q2dBQUlBUkJnQVpxSkFBTHBBa0NDWDhTZmlNQVFjQUNheUlDSkFBZ0FrR1lBbXBCS0JCREdpQUNRWkFDYWtJQVxuTndNQUlBSkJpQUpxUWdBM0F3QWdBa0dBQW1wQ0FEY0RBQ0FDUWdBM0EvZ0JJQUpDQVRjRDhBRWdBa0hJQVdvZ0FVRW9FQ2thSUFKQlxub0FGcUlBQkJLQkFwR2lBQ1FhZ0JhaUVLUVFVaEJrSi9JUllEUUVFK0lRTkNBQ0VQUWdBaEUwSUJJUlFnQWlrRHlBRWlEQ0VOSUFJcFxuQTZBQkloQWhGVUlCSVJFRFFDQVdRbjhnQTYyR0lCV0VlaUlMZlNFV0lBOGdDNFloRHlBUklBdUdJUkVnQXlBTHAyc2lBd1JBSUJVZ1xuQzRnaEN3SkFJQlpDQUZNRVFDQUxJQXQrUWdKOUlBdENBQ0FOZlNJWGZuNUNmMEhBQUNBRFFnQWdGbjBpRnFkQkFXb2lCQ0FESUFSSVxuRzJ1dGlJTkNQNE1oRGtJQUlBOTlJUmxDQUNBUmZTRVNJQlFoRHlBTElRMGdFeUVSREFFRkMwSUFJQXNnRFNBTlFnR0dRZ0o4UWdpRFxuZkg1OVFuOUJ3QUFnQXlBV3AwRUJhaUlFSUFNZ0JFZ2JhNjJJZzBJUGd5RU9JQk1oRWlBVUlSa2dDeUVYQ3lBT0lBOStJQmw4SVJRZ1xuRGlBUmZpQVNmQ0VUSUEwZ0RuNGdGM3doRlF3QkJRc0xJQUlnRkRjRG1BRWdBaUFUTndPUUFTQUNJQTgzQTRnQklBSWdFVGNEZ0FFZ1xuQWtHWUFtb2dBa0h3QVdvZ0FrR0FBV29nQVJBS0lBSkI4QUJxSUJFZ0VVSS9oeUlhSUF3Z0RFSS9oeUlTRUtNQklBSkIwQUJxSUE4Z1xuRDBJL2h5SWJJQkFnRUVJL2h5SUxFS01CSUFKQjRBQnFJQk1nRTBJL2h5SWNJQXdnRWhDakFTQUNRVUJySUJRZ0ZFSS9oeUlaSUJBZ1xuQ3hDakFTQUNLUU5BSWdzZ0Fpa0RZSHdpRGlBTFZLMGdBa0hJQUdvcEF3QWdBa0hvQUdvcEF3QjhmQ0VWSUFJcEExQWlDeUFDS1FOd1xuZkNJTklBdFVyU0FDUWRnQWFpa0RBQ0FDUWZnQWFpa0RBSHg4SVJjZ0FrR2dBV29oQ0NBQ1FjZ0JhaUVISUFaQkFTQUdRUUZLRzBFQlxuYXlJSklRTURRQ0FYUWdLR0lBMUNQb2lFSVF3Z0ZVSUNoaUFPUWo2SWhDRVlJQU1FUUNBQ0lBZEJDR29pQlNrREFDSVFJQkJDUDRjaVxuRWlBUklCb1Fvd0VnQWtFUWFpQUlRUWhxSWdRcEF3QWlEU0FOUWorSElnc2dEeUFiRUtNQklBSkJJR29nRUNBU0lCTWdIQkNqQVNBQ1xuUVRCcUlBMGdDeUFVSUJrUW93RWdCeUFDS1FNQUloSWdESHdpRENBQ0tRTVFmQ0lOUXYvLy8vLy8vLy8vUDRNM0F3QWdDQ0FDS1FNZ1xuSWdzZ0dId2lFQ0FDS1FNd2ZDSU9Rdi8vLy8vLy8vLy9QNE0zQXdBZ0RpQVFWSzBnQWtFNGFpa0RBQ0FMSUJCV3JTQUNRU2hxS1FNQVxuSUJWQ1BvZDhmSHg4SVJVZ0RDQU5WcTBnQWtFWWFpa0RBQ0FNSUJKVXJTQUNRUWhxS1FNQUlCZENQb2Q4Zkh4OElSY2dBMEVCYXlFRFxuSUFVaEJ5QUVJUWdNQVFVTEN5QUdRUUZySWdSQkEzUWlCU0FDUWFBQmFtb2dHRGNEQUNBQ1FjZ0JhaUFGYWlBTU53TUFBa0FnQWlrRFxub0FGUUJFQkNBQ0VPSUFvaEF3TkFJQWtFUUNBSlFRRnJJUWtnQXlrREFDQU9oQ0VPSUFOQkNHb2hBd3dCQlFzTElBNVFEUUVGQ3lBTVxuUWorSElBeUZJQWFzUWdKOVFqK0hoQ0FZUWorSElCaUZoRUlBVWcwQklBWkJBM1JCRUdzaUJ5QUNRY2dCYW1vaUJTQUZLUU1BSUF4Q1xuUG9hRU53TUFJQUpCb0FGcUlBZHFJZ1VnQlNrREFDQVlRajZHaERjREFDQUVJUVlNQVFzTElBSkJtQUpxSWdRZ0RDQUJFRUVnQUNBRVxuUVNnUUtSb2dBa0hBQW1va0FBdmpDUUlCZnc5K0l3QkIwQUpySWdJa0FDQUNRVUJySUFFcEF4Z2lCRUlBSUFFcEF3QWlCMElCaGlJS1xuUWdBUW93RWdBa0dRQW1vZ0FTa0RDQ0lJUWdHR0lnVkNBQ0FCS1FNUUlnWkNBQkNqQVNBQ1FlQUJhaUFCS1FNZ0lnbENBQ0FKUWdBUVxub3dFZ0FrSFFBV29nQWlrRDRBRWlBMEwvLy8vLy8vLy9CNE5DQUVLUStvQ0FnQUpDQUJDakFTQUNRYkFCYWlBSlFnR0dJZ2xDQUNBSFxuUWdBUW93RWdBa0hRQUdvZ0JFSUFJQVZDQUJDakFTQUNRWUFDYWlBR1FnQWdCa0lBRUtNQklBSkJ3QUZxSUFKQjZBRnFLUU1BSWdWQ1xuRElZZ0EwSTBpSVFnQlVJMGlFS1Erb0NBZ0FKQ0FCQ2pBU0FDUWNBQ2FpQUhRZ0FnQjBJQUVLTUJJQUpCb0FGcUlBbENBQ0FJUWdBUVxub3dFZ0FrSGdBR29nQmtJQmhrSUFJQVJDQUJDakFTQUNJQUlwQTZBQklnOGdBaWtEWUh3aUJTQUNLUU5RSWc0Z0Fpa0RnQUo4SWdNZ1xuQWlrRHNBRjhJZ3NnQWlrRHdBRjhJZ3dnQWlrRFFDSU5JQUlwQTVBQ2ZDSUhJQUlwQTlBQmZDSVFRalNJSUFjZ0VGYXRJQUpCMkFGcVxuS1FNQUlBY2dEVlN0SUFKQnlBQnFLUU1BSUFKQm1BSnFLUU1BZkh4OGZDSU5RZ3lHaEh3aUIwSTBpQ0FISUF4VXJTQUxJQXhXclNBQ1xuUWNnQmFpa0RBQ0FESUF0V3JTQUNRYmdCYWlrREFDQURJQTVVclNBQ1FkZ0FhaWtEQUNBQ1FZZ0NhaWtEQUh4OGZIeDhmQ0FOUWpTSVxuZkh3aURrSU1ob1I4SWdOQ0JJWkM4UC8vLy8vLy8vOEFneUFIUWpDSVFnK0RoRUlBUXRHSGdJQVFRZ0FRb3dFZ0FDQUNLUU1BSWcwZ1xuQWlrRHdBSjhJZ3RDLy8vLy8vLy8vd2VETndNQUlBSkJzQUpxSUFwQ0FDQUlRZ0FRb3dFZ0FrR1FBV29nQ1VJQUlBWkNBQkNqQVNBQ1xuUWZBQWFpQUVRZ0FnQkVJQUVLTUJJQUpCTUdvZ0Fpa0RrQUVpRVNBQ0tRTndmQ0lNSUFNZ0JWU3RJQVVnRDFTdElBSkJxQUZxS1FNQVxuSUFKQjZBQnFLUU1BZkh3Z0RrSTBpSHg4SWc5Q0RJWWdBMEkwaUlSOElnVkMvLy8vLy8vLy93ZURRZ0JDa1BxQWdJQUNRZ0FRb3dFZ1xuQUNBQ0tRTXdJZzRnQWlrRHNBSjhJZ01nQ3lBTlZLMGdBa0VJYWlrREFDQUNRY2dDYWlrREFIeDhJZzFDRElZZ0MwSTBpSVI4SWd0Q1xuLy8vLy8vLy8vd2VETndNSUlBSkI4QUZxSUFaQ0FDQUtRZ0FRb3dFZ0FrR2dBbW9nQ0VJQUlBaENBQkNqQVNBQ1FZQUJhaUFKUWdBZ1xuQkVJQUVLTUJJQUpCSUdvZ0JTQU1WSzBnRENBUlZLMGdBa0dZQVdvcEF3QWdBa0g0QUdvcEF3QjhmQ0FQUWpTSWZId2lDa0lNaGlBRlxuUWpTSWhDSUZJQUlwQTRBQmZDSUVRdi8vLy8vLy8vOEhnMElBUXBENmdJQ0FBa0lBRUtNQklBQWdBaWtEOEFFaURDQUNLUU9nQW53aVxuQmlBQ0tRTWdmQ0lJSUFNZ0MxYXRJQU1nRGxTdElBSkJPR29wQXdBZ0FrRzRBbW9wQXdCOGZDQU5RalNJZkh3aUEwSU1oaUFMUWpTSVxuaEh3aUNVTC8vLy8vLy8vL0I0TTNBeEFnQWtFUWFpQUVJQVZVclNBQ1FZZ0JhaWtEQUNBS1FqU0lmSHdpQ2tJTWhpQUVRalNJaENBS1xuUWpTSVFwRDZnSUNBQWtJQUVLTUJJQUFnQWlrREVDSUtJQkJDL3YvLy8vLy8vd2VEZkNJRUlBZ2dDVmF0SUFZZ0NGYXRJQUpCS0dvcFxuQXdBZ0JpQU1WSzBnQWtINEFXb3BBd0FnQWtHb0Ftb3BBd0I4Zkh4OElBTkNOSWg4ZkNJSVFneUdJQWxDTklpRWZDSUdRdi8vLy8vL1xuLy84SGd6Y0RHQ0FBSUFkQy8vLy8vLy8vUDRNZ0JDQUdWcTBnQWtFWWFpa0RBQ0FFSUFwVXJYd2dDRUkwaUh4OFFneUdJQVpDTklpRVxuZkRjRElDQUNRZEFDYWlRQUM1Z0pBUWwvSXdCQjhBRnJJZ1lrQUNBR1FSQnFJQUVRL1FFZ0JpZ0NGQ0VMSUFZb0FoQWhBU0FHUVFocVxuSUFJZ0F4RG9BU0FHS0FJTUlRd2dCaWdDQ0NFTklBWWdCQ0FGRU9nQklBWW9BZ1FoQkNBR0tBSUFJUVVnQmtHc0FXb2dEU0FNRUdZQ1xuUUFKQUlBWXRBS3dCUVFGR0JFQWdCa0VrYWlBR1FiZ0JhaWdDQURZQ0FDQUdJQVlwQXJBQk53SWNJQVpCQVRZQ0dBd0JCUXNnQmtFd1xuYWlBR1FiVUJhaUlDS1FBQU53TUFJQVpCT0dvZ0JrRzlBV29pQXlrQUFEY0RBQ0FHUVVCcklBWkJ4UUZxSWdvcEFBQTNBd0FnQmlBR1xuS1FDdEFUY0RLQ0FHUWF3QmFpQUZJQVFRc3dFZ0JpMEFyQUZCQVVZRVFDQUdRU1JxSUFaQnVBRnFLQUlBTmdJQUlBWWdCaWtDc0FFM1xuQWh3Z0JrRUJOZ0lZREFFRkN5QUdRZEFBYWlBQ0tRQUFOd01BSUFaQjJBQnFJQU1wQUFBM0F3QWdCa0hnQUdvZ0Npa0FBRGNEQUNBR1xuSUFZcEFLMEJOd05JSUFFb0FnQWhBU0FHUWF3QmFpSUNRUUJCd0FEOEN3QWdCa0hJQUdvaENpQUdRU2hxSVFkQjFPM0FBQ2dDQUNFSVxuSXdCQjRBUnJJZ01rQUFKQUlBRW9BZ2hGQkVCQnFPekFBQ0FCUWJRQmFpZ0NBQ0FCS0FLd0FSRUVBQXdCQlFzZ0FTQURRZUFBYWlBSFxuRUg5RkRRQWdBU0FEUVFocUlBTkI0QUJxRU1jQlJRMEFJQU5Cb0FGcUlna2dCeUFEUVFScUVFSWdBeUFES0FJRUlBTXBBN2dCSUFNcFxuQTdBQklBTXBBNmdCSUFNcEE2QUJoSVNFVUhJaUJ6WUNCQ0FKUVpqdXdBQWdCeENvQVFKL0FrQWdBVUVJYWlJSEtBSUFSUVJBUWFqc1xud0FBZ0FVRzBBV29vQWdBZ0FTZ0NzQUVSQkFBTUFRVUxRUUFoQVNBRFFaQUVha0hnOU1BQUxRQUFPZ0FBSUFOQjJQVEFBQ2tEQURjRFxuaUFRZ0EwSFE5TUFBS1FNQU53T0FCQ0FJUWRBQUlBZ2JJUWdnQTBHZ0JHb2dBMEdnQVdvUVRpQURRWmdDYWlFSklBTkJpQUpxSVE0RFxuUUNBRFFjQUVhaUFLSUFOQm9BUnFJQU5CZ0FScVFRQWdBU0FJRVEwQVJRMEJJQU5CZ0FKcUlBTkJ3QVJxSUFOQi9BTnFFRUlnQXlnQ1xuL0FNZ0F5a0RtQUlnQXlrRGtBSWdBeWtEaUFJZ0F5a0RnQUtFaElSUWNnUkFJQWxDQURjREFDQURRWkFDYWtJQU53TUFJQTVDQURjRFxuQUNBRFFnQTNBNEFDSUFGQkFXb2hBUXdCQlFzTElBY2dBMEdnQW1vaUNDQURRWUFDYWlJSEVCTWdBMEdnQTJvaUFTQUlFSWtCSUFjZ1xuQTBISUEyb1FyZ0pGRUgwZ0FSQnpJQUlnQVJCRUlBTkI0QUZxSWdnZ0FpQURRUWhxSUFvUXBBRWdBMEhBQVdvaUFTQUlJQU5Cb0FGcVxuRUJzZ0FTQUJJQWNRamdFZ0FrRWdhaUFCRUU1QkFRd0JDeUFDUWNBQUVFTWFRUUFMSUFNb0FnUkZjU0VKQ3lBRFFlQUVhaVFBSUFZZ1xuQ1NJQk5nTHNBU0FCUVFGSERRRWdCa0hvQUdvaUFTQUdRYXdCYWtIQUFQd0tBQUFnQmtFY2FpQUJRY0FBRUxVQklBWkJBRFlDR0FzZ1xuQlNBRUVOOENJQTBnREJEZkFpQUxJQXNvQWdCQkFXczJBZ0FnQmtHc0FXb2dCa0VZYWhDaUFTQUdLQUt3QVNFQkFuOGdCaWdDckFFRVxuUUVFQklRTkJBQ0VFUVFBTUFRVUxRUUFoQXlBQklRUkJBQ0VCSUFZb0FyUUJDeUVDSUFBZ0F6WUNEQ0FBSUFFMkFnZ2dBQ0FDTmdJRVxuSUFBZ0JEWUNBQ0FHUWZBQmFpUUFEd3NnQmtFQU5nSm9RZENpd0FBZ0JrSHNBV29nQmtIb0FHcEJzSkhBQUJEUkFnQUxtUWtDQ0g4RlxuZmlNQVFjQUNheUlHSkFBZ0JrRVlhaUFCRVAwQklBWW9BaHdoQ0NBR0tBSVlJUUVnQmtFUWFpQUNJQU1RNkFFZ0JpZ0NGQ0VKSUFZb1xuQWhBaENpQUdRUWhxSUFRZ0JSRG9BU0FHS0FJTUlRUWdCaWdDQ0NFRklBWkIvQUZxSUFvZ0NSQm1Ba0FDUUNBR0xRRDhBVUVCUmdSQVxuSUFaQkxHb2dCa0dJQW1vb0FnQTJBZ0FnQmlBR0tRS0FBamNDSkNBR1FRRTJBaUFNQVFVTElBWkJPR29nQmtHRkFtb2lBaWtBQURjRFxuQUNBR1FVQnJJQVpCalFKcUlnTXBBQUEzQXdBZ0JrSElBR29nQmtHVkFtb2lCeWtBQURjREFDQUdJQVlwQVAwQk53TXdJQVpCL0FGcVxuSUFVZ0JCQ3pBU0FHTFFEOEFVRUJSZ1JBSUFaQkxHb2dCa0dJQW1vb0FnQTJBZ0FnQmlBR0tRS0FBamNDSkNBR1FRRTJBaUFNQVFVTFxuSUFaQjJBQnFJQUlwQUFBM0F3QWdCa0hnQUdvZ0F5a0FBRGNEQUNBR1FlZ0FhaUFIS1FBQU53TUFJQVlnQmlrQS9RRTNBMUFnQVNnQ1xuQUNFQ0lBWkIvQUZxSWdGQkFFSEJBUHdMQUNBR1FkQUFhaUVMSUFaQk1Hb2hERUhRN2NBQUtBSUFJUTFCQUNFSEl3QkI0QUJySWdNa1xuQUNBRFFSQnFRZER1d0FBdEFBQTZBQUFnQTBISTdzQUFLUU1BTndNSUlBTkJ3TzdBQUNrREFEY0RBQUpBSUFJb0FnaEZCRUJCcU96QVxuQUNBQ1FiUUJhaWdDQUNBQ0tBS3dBUkVFQUF3QkJRc2dBaUFEUVVCcklBTkJJR29nQTBFY2FpQUxJQXdnRFNBREVDOGhCeUFCSUFNcFxuQTBBM0FBQWdBVUVJYWlBRFFjZ0FhaWtEQURjQUFDQUJRUkJxSUFOQjBBQnFLUU1BTndBQUlBRkJHR29nQTBIWUFHb3BBd0EzQUFBZ1xuQVNBREtRTWdOd0FnSUFGQktHb2dBMEVvYWlrREFEY0FBQ0FCUVRCcUlBTkJNR29wQXdBM0FBQWdBVUU0YWlBRFFUaHFLUU1BTndBQVxuSUFFZ0F5Z0NIRG9BUUFzZ0EwSGdBR29rQUNBR0lBY2lBVFlDdUFFZ0FVRUJSdzBCSUFaQjhBQnFJZ0VnQmtIOEFXcEJ3UUQ4Q2dBQVxuSUFaQnVBRnFJZ05CQUVIQUFQd0xBQ0FHUVFBMkF2Z0JRZVQwd0FBb0FnQWFJd0JCUUdvaUFpUUFJQUpCS0dvZ0FVRUlhaWtBQURjRFxuQUNBQ1FUQnFJQUZCRUdvcEFBQTNBd0FnQWtFNGFpQUJRUmhxS1FBQU53TUFJQUZCT0dvcEFBQWhEaUFCUVRCcUtRQUFJUThnQVVFb1xuYWlrQUFDRVFJQUVwQUNBaEVTQUJLUUFBSVJJZ0JrSDRBV29nQVMwQVFEWUNBQ0FDUVFocUlCQTNBd0FnQWtFUWFpQVBOd01BSUFKQlxuR0dvZ0RqY0RBQ0FDSUJJM0F5QWdBaUFSTndNQUlBTWdBa0VnYWhCT0lBTkJJR29nQWhCT0lBSkJRR3NrQUFKQUlBWW9BdmdCSWdGQlxuQkVrTkFDQUdRUVkyQXZ3QlFaU0J3QUJCSUNBR1Fmd0Jha0h3Z2NBQVFiU0J3QUFRcndFQUN5QUdRZjBCYWlBR1FiZ0Jha0hBQVB3S1xuQUFBZ0JpQUJRUjlxT2dEOEFTQUdRU1JxSUFaQi9BRnFRY0VBRUxVQklBWkJBRFlDSUFzZ0JTQUVFTjhDSUFvZ0NSRGZBaUFJSUFnb1xuQWdCQkFXczJBZ0FnQmtIOEFXb2dCa0VnYWhDaUFTQUdLQUtBQWlFQkFuOGdCaWdDL0FFRVFFRUJJUU5CQUNFRVFRQU1BUVVMUVFBaFxuQXlBQklRUkJBQ0VCSUFZb0FvUUNDeUVDSUFBZ0F6WUNEQ0FBSUFFMkFnZ2dBQ0FDTmdJRUlBQWdCRFlDQUNBR1FjQUNhaVFBRHdzZ1xuQmtFQU5nSndJQVpCdUFGcVFkQ2l3QUFnQmtId0FHcEJ0SkxBQUJEUkFnQUx5Z2NCQ244Q1FBSkFJQUFvQWdnaUNrR0FnSURBQVhGRlxuRFFBQ1FBSkFJQXBCZ0lDQWdBRnhSUVJBSUFKQkVFa05BU0FDSUFFZ0FVRURha0Y4Y1NJSWF5SUphaUlIUVFOeElRWWdBU0FJUndSQVxuSUFFaEF3TkFJQVVnQXl3QUFFRy9mMHBxSVFVZ0EwRUJhaUVESUFsQkFXb2lDUTBBQ3dVTElBWUVRQ0FJSUFkQmZIRnFJUU1EUUNBRVxuSUFNc0FBQkJ2MzlLYWlFRUlBTkJBV29oQXlBR1FRRnJJZ1lOQUFzRkN5QUhRUUoySVFrZ0JDQUZhaUVGQTBBZ0NDRUhJQWxGRFFNZ1xuQ1VIQUFTQUpRY0FCU1JzaUMwRURjU0VHSUF0QkFuUWhDRUVBSVFRZ0NVRUVUd1JBSUFjZ0NFSHdCM0ZxSVF3Z0J5RURBMEFnQkNBRFxuS0FJQUlnUkJmM05CQjNZZ0JFRUdkbkpCZ1lLRUNIRnFJQU5CQkdvb0FnQWlCRUYvYzBFSGRpQUVRUVoyY2tHQmdvUUljV29nQTBFSVxuYWlnQ0FDSUVRWDl6UVFkMklBUkJCblp5UVlHQ2hBaHhhaUFEUVF4cUtBSUFJZ1JCZjNOQkIzWWdCRUVHZG5KQmdZS0VDSEZxSVFRZ1xuQTBFUWFpSURJQXhIRFFBTEJRc2dDU0FMYXlFSklBY2dDR29oQ0NBRVFRaDJRZitCL0FkeElBUkIvNEg4QjNGcVFZR0FCR3hCRUhZZ1xuQldvaEJTQUdSUTBBQ3lBR1FRSjBJUVlnQnlBTFFmd0JjVUVDZEdvaEEwRUFJUVFEUUNBRUlBTW9BZ0FpQkVGL2MwRUhkaUFFUVFaMlxuY2tHQmdvUUljV29oQkNBRFFRUnFJUU1nQmtFRWF5SUdEUUFMSUFSQkNIWkIvNEg4QjNFZ0JFSC9nZndIY1dwQmdZQUViRUVRZGlBRlxuYWlFRkRBSUZDeUFBTHdFT0lnVkZCRUJCQUNFQ0RBSUZDeUFCSUFKcUlRZEJBQ0VDSUFFaEJBSkFBMEFnQkNJRElBZEdEUUVDZnlBRFxuUVFGcUlBTXNBQUFpQkVFQVRnMEFHaUFEUVFKcUlBUkJZRWtOQUJvZ0EwRURhaUFFUVhCSkRRQWFJQU5CQkdvTElnUWdBMnNnQW1vaFxuQWlBRklBWkJBV29pQmtjTkFBc01BZ3NnQmlFRkRBRUxJQUpGQkVCQkFDRUNEQUVGQ3dOQUlBVWdBU0FEYWl3QUFFRy9mMHBxSVFVZ1xuQWlBRFFRRnFJZ05IRFFBTEN5QUZJQUF2QVF3aUEwOE5BQ0FESUFWcklRZEJBQ0VEUVFBaEJRSkFBa0FDUUNBS1FSMTJRUU54UVFGclxuRGdJQUFRSUxJQWNoQlF3QkN5QUhRZjcvQTNGQkFYWWhCUXNnQ2tILy8vOEFjU0VJSUFBb0FnUWhCaUFBS0FJQUlRQURRQ0FEUWYvL1xuQTNFZ0JVSC8vd054U1FSQVFRRWhCQ0FEUVFGcUlRTWdBQ0FJSUFZb0FoQVJCUUJGRFFFTUF3VUxDMEVCSVFRZ0FDQUJJQUlnQmlnQ1xuREJFSEFBMEJJQWNnQld0Qi8vOERjU0VCUVFBaEF3TkFJQUVnQTBILy93TnhUUVJBUVFBUEJRc2dBMEVCYWlFRElBQWdDQ0FHS0FJUVxuRVFVQVJRMEFDd3dCQ3lBQUtBSUFJQUVnQWlBQUtBSUVLQUlNRVFjQUlRUUxJQVFMbHdnQ0FYOEpmaU1BUWFBQ2F5SURKQUFnQTBIZ1xuQVdvZ0FTQUNFQndnQTBIUUFXb2dBeWtEZ0FJaUJFSUFRci85cHY2eXJ1aVd3QUJDQUJDakFTQURRYkFCYWlBREtRT0lBaUlIUWdCQ1xudi8ybS9yS3U2SmJBQUVJQUVLTUJJQU5Cd0FGcUlBUkNBRUxFdjkyRmxlUElxTVVBUWdBUW93RWdBMEdRQVdvZ0F5a0RrQUlpQ1VJQVxuUXIvOXB2NnlydWlXd0FCQ0FCQ2pBU0FEUWFBQmFpQUhRZ0JDeEwvZGhaWGp5S2pGQUVJQUVLTUJJQU5COEFCcUlBTXBBNWdDSWdWQ1xuQUVLLy9hYitzcTdvbHNBQVFnQVFvd0VnQTBHQUFXb2dDVUlBUXNTLzNZV1Y0OGlveFFCQ0FCQ2pBU0FEUWVBQWFpQUZRZ0JDeEwvZFxuaFpYanlLakZBRUlBRUtNQklBTkIwQUJxSUFrZ0F5a0Q0QUVpQ0NBREtRUFFBWHdpQ2lBSVZLMGdBeWtENkFFaUJpQURRZGdCYWlrRFxuQUh4OElnZ2dCbFN0SUFNcEEvQUJJZ3NnQTBHNEFXb3BBd0FnQTBISUFXb3BBd0I4Zkh3Z0NDQUlJQU1wQTdBQmZDSUlWcTE4SUFnZ1xuQ0NBREtRUEFBWHdpQ0ZhdGZDSUdJQXRVclNBREtRUDRBU0lMSUFOQm1BRnFLUU1BSUFOQnFBRnFLUU1BZkh4OElBWWdCaUFES1FPUVxuQVh3aUJsYXRmQ0FHSUFZZ0F5a0RvQUY4SWdaV3JYd2dCaUFFSUFaOElnWldyWHdpQkNBTFZLMGdBMEg0QUdvcEF3QWdBeWtEWUNJTVxuSUFOQmlBRnFLUU1BZkh4OElBUWdCQ0FES1FOd2ZDSUVWcTE4SUFRZ0JDQURLUU9BQVh3aUJGYXRmQ0FFSUFkOElnc2dCRlN0ZkNJSFxuZkNJRVFnQkN2LzJtL3JLdTZKYkFBRUlBRUtNQklBTkJNR29nQkNBSFZLMGdCeUFNVkswZ0JTQURRZWdBYWlrREFIeDhmQ0lIUWdCQ1xudi8ybS9yS3U2SmJBQUVJQUVLTUJJQU5CUUdzZ0JFSUFRc1MvM1lXVjQ4aW94UUJDQUJDakFTQURRU0JxSUFkQ0FFTEV2OTJGbGVQSVxucU1VQVFnQVFvd0VnQTBFUWFpQUtJQW9nQXlrRFVId2lDbGF0SUFnZ0EwSFlBR29wQXdCOGZDSUpJQWhVclNBRFFUaHFLUU1BSUFZZ1xuQTBISUFHb3BBd0I4Zkh3Z0NTQUpJQU1wQXpCOElnbFdyWHdnQ1NBREtRTkFmQ0lJSUFsVXJYd2lDU0FHVkswZ0N5QURRU2hxS1FNQVxuZkh3Z0NVSy8vYWIrc3E3b2xzQUFRZ0FnQlNBSFZpSUJHM3dpQlNBSlZLMThJQVVnQlNBREtRTWdmQ0lGVnExOElBUWdCWHdpQ1NBRlxuVksxOElnVWdDMVFnQVdvZ0JTQUZRc1MvM1lXVjQ4aW94UUJDQUNBQkczd2lCVlpxSUFVZ0Izd2lCaUFGVkdxdElnVkNBRUsvL2FiK1xuc3E3b2xzQUFRZ0FRb3dFZ0FDQURLUU1RSWdjZ0Nud2lDamNEQUNBRElBVkNBRUxFdjkyRmxlUElxTVVBUWdBUW93RWdBQ0FJSUFNcFxuQXdBaUNId2lCQ0FEUVJocUtRTUFJQWNnQ2xhdGZId2lDamNEQ0NBQUlBVWdDWHdpQnlBRUlBcFdyU0FEUVFocUtRTUFJQVFnQ0ZTdFxuZkh4OElnUTNBeEFnQUNBRklBZFdyU0FFSUFkVXJYd2lCU0FHZkNJRU53TVlJQUFnQUJEVEFTQUVJQVZVYWhDZUFSb2dBMEdnQW1va1xuQUF1dUJ3SUJmd2wrSXdCQmdBSnJJZ01rQUNBRFFmQUJhaUFDS1FNQVFnQWdBU2tEQUVJQUVLTUJJQUFnQXlrRDhBRTNBd0FnQTBIUVxuQVdvZ0Fpa0RDRUlBSUFFcEF3QkNBQkNqQVNBRFFlQUJhaUFDS1FNQVFnQWdBU2tEQ0VJQUVLTUJJQUFnQXlrRDBBRWlCU0FEUWZnQlxuYWlrREFId2lCQ0FES1FQZ0FYd2lCamNEQ0NBRFFhQUJhaUFDS1FNUVFnQWdBU2tEQUVJQUVLTUJJQU5Cc0FGcUlBSXBBd2hDQUNBQlxuS1FNSVFnQVFvd0VnQTBIQUFXb2dBaWtEQUVJQUlBRXBBeEJDQUJDakFTQUFJQU5CMkFGcUtRTUFJQVFnQlZTdGZDSUhJQU5CNkFGcVxuS1FNQUlBUWdCbGF0Zkh3aUJDQURLUU9nQVh3aUJTQURLUU93QVh3aUJpQURLUVBBQVh3aUNEY0RFQ0FEUWVBQWFpQUNLUU1ZUWdBZ1xuQVNrREFFSUFFS01CSUFOQjhBQnFJQUlwQXhCQ0FDQUJLUU1JUWdBUW93RWdBMEdBQVdvZ0Fpa0RDRUlBSUFFcEF4QkNBQkNqQVNBRFxuUVpBQmFpQUNLUU1BUWdBZ0FTa0RHRUlBRUtNQklBQWdBMEdvQVdvcEF3QWdCQ0FGVnExOElnb2dCQ0FIVksxOElnUWdBMEc0QVdvcFxuQXdBZ0JTQUdWcTE4ZkNJRklBTkJ5QUZxS1FNQUlBWWdDRmF0Zkh3aUJpQURLUU5nZkNJSElBTXBBM0I4SWdnZ0F5a0RnQUY4SWdrZ1xuQXlrRGtBRjhJZ3MzQXhnZ0EwRXdhaUFDS1FNWVFnQWdBU2tEQ0VJQUVLTUJJQU5CUUdzZ0Fpa0RFRUlBSUFFcEF4QkNBQkNqQVNBRFxuUWRBQWFpQUNLUU1JUWdBZ0FTa0RHRUlBRUtNQklBQWdBMEdZQVdvcEF3QWdDU0FMVnExOElnc2dCU0FHVnEwZ0JDQUZWcTBnQkNBS1xuVksxOGZDSUtJQU5CNkFCcUtRTUFJQVlnQjFhdGZId2lCQ0FEUWZnQWFpa0RBQ0FISUFoV3JYeDhJZ1VnQTBHSUFXb3BBd0FnQ0NBSlxuVnExOGZDSUpmQ0lHSUFNcEF6QjhJZ2NnQXlrRFFId2lDQ0FES1FOUWZDSU1Od01nSUFOQkVHb2dBaWtER0VJQUlBRXBBeEJDQUJDalxuQVNBRFFTQnFJQUlwQXhCQ0FDQUJLUU1ZUWdBUW93RWdBQ0FHSUF0VXJTQUZJQWxXclNBRUlBVldyU0FFSUFwVXJYeDhmQ0lKSUFOQlxuT0dvcEF3QWdCaUFIVnExOGZDSUVJQU5CeUFCcUtRTUFJQWNnQ0ZhdGZId2lCU0FEUWRnQWFpa0RBQ0FJSUF4V3JYeDhJZ1lnQXlrRFxuRUh3aUJ5QURLUU1nZkNJSU53TW9JQU1nQWlrREdFSUFJQUVwQXhoQ0FCQ2pBU0FBSUFVZ0JsYXRJQVFnQlZhdElBUWdDVlN0Zkh3aVxuQ1NBRFFSaHFLUU1BSUFZZ0IxYXRmSHdpQkNBRFFTaHFLUU1BSUFjZ0NGYXRmSHdpQlNBREtRTUFmQ0lHTndNd0lBQWdCU0FHVnEwZ1xuQkNBRlZxMGdBMEVJYWlrREFDQUVJQWxVclh4OGZEY0RPQ0FEUVlBQ2FpUUFDNFVJQVFSL0l3QkI0QU5ySWdRa0FDQUVRYkFEYWtFQVxuUVREOEN3QWdCRUd3QTJvaUF5QUNFSmNDSUFSQmdBTnFJZ1VnQTBFdy9Bb0FBQ0FEUVFCQk1Qd0xBQ0FESUFVZ0FoRDdBU0FFSUFOQlxuTVB3S0FBQWdBMEVBUVREOEN3QWdBeUFFRUpjQ0lBVWdBMEV3L0FvQUFDQURRUUJCTVB3TEFDQURJQVVnQWhEN0FTQUVRVEJxSWdZZ1xuQTBFdy9Bb0FBQ0FEUVFCQk1Qd0xBQ0FESUFZUWx3SWdCU0FEUVREOENnQUFRUUloQXdOQUlBTUVRQ0FEUVFGcklRTWdCRUdBQTJvaVxuQlNBRkVKY0NEQUVGQ3dzZ0JFR3dBMnBCQUVFdy9Bc0FJQVJCc0FOcUlnTWdCRUdBQTJvaUJTQUVRVEJxRVBzQklBUkI0QUJxSWdZZ1xuQTBFdy9Bb0FBQ0FEUVFCQk1Qd0xBQ0FESUFZUWx3SWdCU0FEUVREOENnQUFRUVVoQXdOQUlBTUVRQ0FEUVFGcklRTWdCRUdBQTJvaVxuQlNBRkVKY0NEQUVGQ3dzZ0JFR3dBMnBCQUVFdy9Bc0FJQVJCc0FOcUlnTWdCRUdBQTJvaUJTQUVRZUFBYWhEN0FTQUVRWkFCYWlJR1xuSUFOQk1Qd0tBQUFnQTBFQVFURDhDd0FnQXlBR0VKY0NJQVVnQTBFdy9Bb0FBRUVDSVFNRFFDQURCRUFnQTBFQmF5RURJQVJCZ0FOcVxuSWdVZ0JSQ1hBZ3dCQlFzTElBUkJzQU5xUVFCQk1Qd0xBQ0FFUWJBRGFpSURJQVJCZ0FOcUlnVWdCRUV3YWhEN0FTQUVRY0FCYWlJR1xuSUFOQk1Qd0tBQUFnQTBFQVFURDhDd0FnQXlBR0VKY0NJQVVnQTBFdy9Bb0FBRUVPSVFNRFFDQURCRUFnQTBFQmF5RURJQVJCZ0FOcVxuSWdVZ0JSQ1hBZ3dCQlFzTElBUkJzQU5xUVFCQk1Qd0xBQ0FFUWJBRGFpSURJQVJCZ0FOcUlnVWdCRUhBQVdvUSt3RWdCRUh3QVdvaVxuQmlBRFFURDhDZ0FBSUFOQkFFRXcvQXNBSUFNZ0JoQ1hBaUFGSUFOQk1Qd0tBQUJCQVNFREEwQWdBd1JBSUFOQkFXc2hBeUFFUVlBRFxuYWlJRklBVVFsd0lNQVFVTEN5QUVRYkFEYWtFQVFURDhDd0FnQkVHd0Eyb2lBeUFFUVlBRGFpSUZJQVFRK3dFZ0JFR2dBbW9pQmlBRFxuUVREOENnQUFJQU5CQUVFdy9Bc0FJQU1nQmhDWEFpQUZJQU5CTVB3S0FBQkJIeUVEQTBBZ0F3UkFJQU5CQVdzaEF5QUVRWUFEYWlJRlxuSUFVUWx3SU1BUVVMQ3lBRVFiQURha0VBUVREOEN3QWdCRUd3QTJvaUF5QUVRWUFEYWlBQ0VQc0JJQVJCMEFKcUlBTkJNUHdLQUFCQlxuZ0FFaEF3TkFJQU1FUUNBRFFRRnJJUU1nQkVIUUFtb2lBaUFDRUpjQ0RBRUZDd3NnQkVIUUFtb2lBaUFDSUFSQm9BSnFFUHNCUVNBaFxuQXdOQUlBTUVRQ0FEUVFGcklRTWdCRUhRQW1vaUFpQUNFSmNDREFFRkN3c2dCRUhRQW1vaUFpQUNJQVJCb0FKcUVQc0JRUjRoQXdOQVxuSUFNRVFDQURRUUZySVFNZ0JFSFFBbW9pQWlBQ0VKY0NEQUVGQ3dzZ0JFSFFBbW9pQWlBQ0lBUkI4QUZxRVBzQklBSWdBaUFCS0FJRVxuSWdFb0FnUVJCQUFnQWlBQ0lBRW9BZ1FSQkFBZ0FDQUNRVEQ4Q2dBQUlBUkI0QU5xSkFBTHZ3Y0NCMzhCZmlNQVFlQUNheUlJSkFBZ1xuQ0VFZ2FpQUJFUDBCSUFnb0FpUWhDeUFJS0FJZ0lRa2dDRUVZYWlBQ0lBTVE2QUVnQ0NnQ0hDRUtJQWdvQWhnaEF5QUlRUkJxSUFRZ1xuQlJEb0FTQUlLQUlVSVF3Z0NDZ0NFQ0VOSUFoQkNHb2dCaUFIRU9nQklBZ29BZ3doQnlBSUtBSUlJUTRnQ0VHY0Ftb2dEU0FNRUxNQlxuQWtBZ0NDMEFuQUpCQVVZRVFDQUlRVEJxSUFoQnFBSnFLQUlBTmdJQUlBZ2dDQ2tDb0FJM0F5Z01BUVVMSUFoQlFHc2dDRUdsQW1vcFxuQUFBM0F3QWdDRUhJQUdvZ0NFR3RBbW9wQUFBM0F3QWdDRUhRQUdvZ0NFRzFBbW9wQUFBM0F3QWdDQ0FJS1FDZEFqY0RPQ0FLUWNBQVxuUndSQUlBaEJvQUpxUVFnZ0NoQTJJQWhCTUdvZ0NFR29BbW9vQWdBMkFnQWdDQ0FJS1FLZ0FpSVBOd0RiQVNBSUlBODNBeWdNQVFVTFxuSUFnZ0EwRUNhaTBBQURvQW53SWdDQ0FETHdBQU93Q2RBaUFES1FBRElROGdDRUdvQW1vZ0EwRUxha0UxL0FvQUFDQUlJQTgzQXFBQ1xuSUFoQjJBRnFJZ0VnQ0VHY0Ftb2lBa0VCY2tIQUFQd0tBQUFnQ0VIWUFHb2dBVUhBQVB3S0FBQWdBaUFPSUFjUVdDQUlMUUNjQWtFQlxuUmdSQUlBaEJNR29nQ0VHb0Ftb29BZ0EyQWdBZ0NDQUlLUUtnQWpjREtBd0JCUXNnQ0VIWUFXb2lBaUFJUVp3Q2FrRUJja0hBQVB3S1xuQUFBZ0NFR1lBV29pQVNBQ1FjQUEvQW9BQUNBSktBSUFJUVFnQ0VIWUFHb2hCU0FJUVRocUlRa2pBRUh3QTJzaUFpUUFBa0FDUUFKQVxuSUFRb0FnQkZCRUJCOU92QUFDQUVRYlFCYWlnQ0FDQUVLQUt3QVJFRUFBd0JCUXNnQkNBQ0lBRVF4d0VOQVF0QkFDRUJEQUVMUVFBaFxuQVNBQ1FRQTJBbHdnQWtIZ0FHb2dCVUVnYWlBQ1Fkd0FhaEJDSUFJb0Fsd05BQ0FDUWFBQmFpQUZFRVZGRFFBZ0FrR0FBV29pQmlBRlxuSUFJZ0NSQ2tBU0FHSUFZUWtRRWdBaUFDS0FKUU5nTEFBeUFDUWNnQ2FpSUZJQUpCS0JBcEdpQUNRZkFDYWlBQ1FTaHFRU2dRS1JvZ1xuQWtHZ0EycENBRGNEQUNBQ1FhZ0Rha0lBTndNQUlBSkJzQU5xUWdBM0F3QWdBa0c0QTJwQ0FEY0RBQ0FDUWdFM0E1Z0RJQVFnQWtISVxuQVdvZ0JTQUdJQUpCNEFCcUVBMGdBaWdDd0FJTkFDQUNRYUFCYWlBQ1FjZ0JhaEMyQVVVTkFDQUNRY2dEYWlJQklBSkI4QUZxSUFKQlxubUFKcUVBNGdBUkN1QWtFQVJ5RUJDeUFDUWZBRGFpUUFJQUZCQVVjRVFDQUlRU2hxUVFrZ0NCQTJEQUVGQ3lBSVFZQ0FnSUI0TmdJb1xuQ3lBT0lBY1Ezd0lnRFNBTUVOOENJQU1nQ2hEZkFpQUxJQXNvQWdCQkFXczJBZ0FnQ0NBSVFTaHFFSm9DSUFnb0FnUWhBU0FBSUFnb1xuQWdBaUFqWUNCQ0FBSUFGQkFDQUNRUUZ4R3pZQ0FDQUlRZUFDYWlRQUMvRUdBUVYvQWtBQ1FBSkFBa0FDUUNBQVFRUnJJZ1VvQWdBaVxuQjBGNGNTSUVRUVJCQ0NBSFFRTnhJZ1liSUFGcVR3UkFJQVpCQUNBQlFTZHFJZ2dnQkVrYkRRRUNRQUpBSUFKQkNVOEVRQ0FDSUFNUVxuUnlJQ0RRRkJBQThGQzBFQUlRSWdBMEhNLzN0TERRRkJFQ0FEUVF0cVFYaHhJQU5CQzBrYklRRUNRQ0FHUlFSQUlBRkJnQUpKSUFRZ1xuQVVFRWNrbHlJQVFnQVd0QmdZQUlUM0lOQVF3SkJRc2dBRUVJYXlJR0lBUnFJUWdDUUFKQUFrQUNRQ0FCSUFSTEJFQWdDRUdjK01BQVxuS0FJQVJnMEVJQWhCbVBqQUFDZ0NBRVlOQWlBSUtBSUVJZ2RCQW5FTkJTQUhRWGh4SWdjZ0JHb2lCQ0FCU1EwRklBZ2dCeEJQSUFRZ1xuQVdzaUFrRVFTUTBCSUFVZ0FTQUZLQUlBUVFGeGNrRUNjallDQUNBQklBWnFJZ0VnQWtFRGNqWUNCQ0FFSUFacUlnTWdBeWdDQkVFQlxuY2pZQ0JDQUJJQUlRUUF3TkJRc2dCQ0FCYXlJQ1FROUxEUUlNREFzZ0JTQUVJQVVvQWdCQkFYRnlRUUp5TmdJQUlBUWdCbW9pQVNBQlxuS0FJRVFRRnlOZ0lFREFzTFFaRDR3QUFvQWdBZ0JHb2lCQ0FCU1EwQ0FrQWdCQ0FCYXlJRFFROU5CRUFnQlNBSFFRRnhJQVJ5UVFKeVxuTmdJQUlBUWdCbW9pQVNBQktBSUVRUUZ5TmdJRVFRQWhBMEVBSVFFTUFRVUxJQVVnQVNBSFFRRnhja0VDY2pZQ0FDQUJJQVpxSWdFZ1xuQTBFQmNqWUNCQ0FFSUFacUlnSWdBellDQUNBQ0lBSW9BZ1JCZm5FMkFnUUxRWmo0d0FBZ0FUWUNBRUdRK01BQUlBTTJBZ0FNQ2dzZ1xuQlNBQklBZEJBWEZ5UVFKeU5nSUFJQUVnQm1vaUFTQUNRUU55TmdJRUlBZ2dDQ2dDQkVFQmNqWUNCQ0FCSUFJUVFBd0pDMEdVK01BQVxuS0FJQUlBUnFJZ1FnQVVzTkJ3c2dBeEFJSWdGRkRRRWdBMEY4UVhnZ0JTZ0NBQ0lDUVFOeEd5QUNRWGh4YWlJQ0lBSWdBMHNiSWdJRVxuUUNBQklBQWdBdndLQUFBRkN5QUFFQ29nQVE4TElBTWdBU0FCSUFOTEd5SURCRUFnQWlBQUlBUDhDZ0FBQlFzZ0JTZ0NBQ0lEUVhoeFxuSWdVZ0FVRUVRUWdnQTBFRGNTSUJHMnBKRFFNZ0FVRUFJQVVnQ0VzYkRRUWdBQkFxQ3lBQ0R3VUxRYkhTd0FCQkxrSGcwc0FBRU93QlxuQUF0QjhOTEFBRUV1UWFEVHdBQVE3QUVBQzBHeDBzQUFRUzVCNE5MQUFCRHNBUUFMUWZEU3dBQkJMa0dnMDhBQUVPd0JBQXNnQlNBQlxuSUFkQkFYRnlRUUp5TmdJQUlBRWdCbW9pQWlBRUlBRnJJZ0ZCQVhJMkFnUkJsUGpBQUNBQk5nSUFRWno0d0FBZ0FqWUNBQ0FBRHdzZ1xuQUF1Q0J3RURmeU1BUVpBRWF5SURKQUFnQTBIQUEyb2lBaUFCRUJjZ0FpQUNJQUVRRGlBRFFaZ0RhaUlFSUFJUUZ5QUVJQVFnQVJBT1xuSUFOQjhBSnFJQVJCS0JBcEdrRURJUUlEUUNBQ0JFQWdBa0VCYXlFQ0lBTkI4QUpxSWdRZ0JCQVhEQUVGQ3dzZ0EwSHdBbW9pQWlBQ1xuSUFOQm1BTnFFQTRnQTBISUFtb2dBa0VvRUNrYVFRTWhBZ05BSUFJRVFDQUNRUUZySVFJZ0EwSElBbW9pQkNBRUVCY01BUVVMQ3lBRFxuUWNnQ2FpSUNJQUlnQTBHWUEyb1FEaUFEUWFBQ2FpQUNRU2dRS1JwQkFpRUNBMEFnQWdSQUlBSkJBV3NoQWlBRFFhQUNhaUlFSUFRUVxuRnd3QkJRc0xJQU5Cb0FKcUlnSWdBaUFEUWNBRGFoQU9JQU5CK0FGcUlBSkJLQkFwR2tFTElRSURRQ0FDQkVBZ0FrRUJheUVDSUFOQlxuK0FGcUlnUWdCQkFYREFFRkN3c2dBMEg0QVdvaUFpQUNJQU5Cb0FKcUVBNGdBMEhRQVdvZ0FrRW9FQ2thUVJZaEFnTkFJQUlFUUNBQ1xuUVFGcklRSWdBMEhRQVdvaUJDQUVFQmNNQVFVTEN5QURRZEFCYWlJQ0lBSWdBMEg0QVdvUURpQURRYWdCYWlBQ1FTZ1FLUnBCTENFQ1xuQTBBZ0FnUkFJQUpCQVdzaEFpQURRYWdCYWlJRUlBUVFGd3dCQlFzTElBTkJxQUZxSWdJZ0FpQURRZEFCYWhBT0lBTkJnQUZxSUFKQlxuS0JBcEdrSFlBQ0VDQTBBZ0FnUkFJQUpCQVdzaEFpQURRWUFCYWlJRUlBUVFGd3dCQlFzTElBTkJnQUZxSWdJZ0FpQURRYWdCYWhBT1xuSUFOQjJBQnFJQUpCS0JBcEdrRXNJUUlEUUNBQ0JFQWdBa0VCYXlFQ0lBTkIyQUJxSWdRZ0JCQVhEQUVGQ3dzZ0EwSFlBR29pQWlBQ1xuSUFOQjBBRnFFQTRnQTBFd2FpQUNRU2dRS1JwQkF5RUNBMEFnQWdSQUlBSkJBV3NoQWlBRFFUQnFJZ1FnQkJBWERBRUZDd3NnQTBFd1xuYWlJQ0lBSWdBMEdZQTJvUURpQURRUWhxSUFKQktCQXBHa0VYSVFJRFFDQUNCRUFnQWtFQmF5RUNJQU5CQ0dvaUJDQUVFQmNNQVFVTFxuQ3lBRFFRaHFJZ0lnQWlBRFFmZ0JhaEFPUVFZaEFnTkFJQUlFUUNBQ1FRRnJJUUlnQTBFSWFpSUVJQVFRRnd3QkJRc0xJQU5CQ0dvaVxuQWlBQ0lBTkJ3QU5xRUE0Z0FpQUNFQmNnQUNBQ0VCY2dBaUFBRUJjZ0EwSzg0Zi8vdi8vL0h5QURLUU1JZlRjRDZBTWdBMEw4Ly8vL1xuLy8vL0h5QURLUU1RZlRjRDhBTWdBMEw4Ly8vLy8vLy9IeUFES1FNWWZUY0QrQU1nQTBMOC8vLy8vLy8vSHlBREtRTWdmVGNEZ0FRZ1xuQTBMOC8vLy8vLy8vQVNBREtRTW9mVGNEaUFRZ0EwSG9BMm9pQUNBQkVOOEJJQUFRblFFZ0EwR1FCR29rQUF1U0J3SUpmd0YrSXdCQlxua0FKcklnWWtBQ0FHUVJCcUlBRVEvUUVnQmlnQ0ZDRUlJQVlvQWhBaEFTQUdRUWhxSUFJZ0F4RG9BU0FHS0FJTUlRa2dCaWdDQ0NFS1xuSUFZZ0JDQUZFT2dCSUFZb0FnUWhCU0FHS0FJQUlRc2dCa0hzQUdvZ0NpQUpFRmdDUUNBR0xRQnNRUUZHQkVBZ0JrRWthaUFHUWZnQVxuYWlnQ0FEWUNBQ0FHSUFZcEFuQTNBaHdnQmtFQk5nSVlEQUVGQ3lBR1FTaHFJZ0lnQmtIc0FHb2lBMEVCY2tIQUFQd0tBQUFnQmtHd1xuQVdvZ0FrSEFBUHdLQUFBZ0F5QUxJQVVRYXlBR0xRQnNRUUZHQkVBZ0JrRWthaUFHUWZnQWFpZ0NBRFlDQUNBR0lBWXBBbkEzQWh3Z1xuQmtFQk5nSVlEQUVGQ3lBR1FmZ0JhaUFHUWZVQWFpa0FBRGNEQUNBR1FZQUNhaUFHUWYwQWFpa0FBRGNEQUNBR1FZZ0NhaUFHUVlVQlxuYWlrQUFEY0RBQ0FHSUFZcEFHMDNBL0FCSUFFb0FnQWhBU0FHUWJBQmFpRUNJQVpCOEFGcUlRd2pBRUhnQUdzaUF5UUFBa0FnQVNnQ1xuQUVVRVFFSDA2OEFBSUFGQnRBRnFLQUlBSUFFb0FyQUJFUVFBREFFRkN5QUJJQU5CQ0dvZ0FoREhBU0FDUWNBQUVFTWhEVVVOQUNBRFxuUVFocUlRUWpBRUhRQVdzaUFpUUFJQUpCQURZQ0RDQUNRUkJxSUF3Z0FrRU1haEJDSUFJb0FneEZCRUFnQWlBRUtBSlFOZ0xJQVNBQ1xuUWRBQWFpSUhJQVJCS0JBcEdpQUNRZmdBYWlBRVFTaHFRU2dRS1JvZ0FrR29BV3BDQURjREFDQUNRYkFCYWtJQU53TUFJQUpCdUFGcVxuUWdBM0F3QWdBa0hBQVdwQ0FEY0RBQ0FDUVVCclFnQTNBd0FnQWtISUFHcENBRGNEQUNBQ1FnRTNBNkFCSUFKQ0FEY0RPQ0FDUWdFM1xuQXpBZ0FTQUhJQWNnQWtFd2FpQUNRUkJxRUEwZ0FpZ0N5QUVpQVVVRVFDQUVJQUpCMEFCcUVJa0JCUXNnQVVVaEJ3VUxJQUpCMEFGcVxuSkFBZ0IwVU5BQ0FOSUFOQkNHb1FuQUpCQVNFT0N5QURRZUFBYWlRQUlBNUZCRUFnQmtFY2FrRURJQVlRTmlBR1FRRTJBaGdNQVFVTFxuSUFaQjdnQnFJQVpCc2dGcUxRQUFPZ0FBSUFZZ0JpOEFzQUU3QVd3Z0Jpa0Fzd0VoRHlBR1FmY0FhaUFHUWJzQmFrRTEvQW9BQUNBR1xuSUE4M0FHOGdCa0VvYWlJQklBWkI3QUJxRUljQklBWkJIR29nQVVFaEVMVUJJQVpCQURZQ0dBc2dDeUFGRU44Q0lBb2dDUkRmQWlBSVxuSUFnb0FnQkJBV3MyQWdBZ0JrSHNBR29nQmtFWWFoQ2lBU0FHS0FKd0lRRWdBQUovSUFZb0Ftd0VRRUVBSVFKQkFDRUZRUUVNQVFVTFxuSUFZb0FuUWhCU0FCSVFKQkFDRUJRUUFMTmdJTUlBQWdBVFlDQ0NBQUlBVTJBZ1FnQUNBQ05nSUFJQVpCa0FKcUpBQUxuZ1lCRW44alxuQUVIQUFtc2lCaVFBQWtBZ0FTZ0NBRUVCUmdSQUlBWWdBaUFESUFOQlFIRVEyUUlnQmlnQ0JDSVNRVUJ4SVE4Z0JpZ0NEQ0VUSUFZb1xuQWdnaEZDQUdLQUlBSVJBZ0FTZ0NGQ0VLSUFFb0FoQWhDeUFCS0FJTUlRd2dBU2dDQ0NFTklBRW9BZ1FoRGdOQUlBOUZEUUpCQUNFRFxuSUFaQkFFSEFBdndMQUFOQUlBTkJ3QUJHQkVCQkFDRUNBMEFnQWtHQUFrWUVRRUVBSVFRZ0NpRUlJQXNoQXlBTUlRSWdEU0VGSUE0aFxuQndOQUlBUkIwQUJHQkVCQjBBQWhCQU5BSUFSQm9BRkdCRUJCb0FFaEJBTkFJQVJCOEFGR0JFQkI4QUVoQkFOQUlBUkJ3QUpHUlFSQVxuSUFnZ0FpQURjeUFGYzJvaENTQUVJQVpxSUFSQkJHb2hCQ0FESVFnZ0FpRURJQVZCSG5jaEFpZ0NBQ0FKSUFjaUJVRUZkMnBxUWFyOFxuOUt3RGF5RUhEQUVGQ3dzZ0NDQUthaUVLSUFNZ0Myb2hDeUFDSUF4cUlRd2dCU0FOYWlFTklBY2dEbW9oRGlBUFFVQnFJUThnRUVGQVxuYXlFUURBb0ZJQUlnQTNFaEZTQUNJQU55SUFWeElSRWdDQ0FIUVFWM2FpRUpJQVFnQm1vZ0JFRUVhaUVFSUFNaENDQUNJUU1nQlVFZVxuZHlFQ0lBY2hCU2dDQUNBSklCRWdGWEpxYWtHa2hwR0hCMnNoQnd3QkN3QUxBQVVnQ0NBQ0lBTnpJQVZ6YWlFSklBUWdCbW9nQkVFRVxuYWlFRUlBTWhDQ0FDSVFNZ0JVRWVkeUVDS0FJQUlBa2dCeUlGUVFWM2FtcEJvZGZuOWdacUlRY01BUXNBQ3dBRklBTWdCVUYvYzNFaFxuRVNBSUlBSWdCWEZxSVFrZ0JDQUdhaUFFUVFScUlRUWdBeUVJSUFJaEF5QUZRUjUzSVFJb0FnQWdDU0FSYWlBSElnVkJCWGRxYWtHWlxuODRuVUJXb2hCd3dCQ3dBTEFBVWdBaUFHYWlJRFFVQnJJQU1vQWdBZ0EwRTBhaWdDQUNBRFFTQnFLQUlBSUFOQkNHb29BZ0J6YzNOQlxuQVhjMkFnQWdBa0VFYWlFQ0RBRUxBQXNBQlNBRElBWnFJQU1nRUdvb0FBQWlBa0VZZENBQ1FZRCtBM0ZCQ0hSeUlBSkJDSFpCZ1A0RFxuY1NBQ1FSaDJjbkkyQWdBZ0EwRUVhaUVEREFFTEFBc0FDd0FGQzBIUXc4QUFRU2hCNExiQUFCRHNBUUFMSUFFZ0NqWUNGQ0FCSUFzMlxuQWhBZ0FTQU1OZ0lNSUFFZ0RUWUNDQ0FCSUE0MkFnUWdBQ0FUTmdJSUlBQWdGRFlDQkNBQUlCSTJBZ0FnQmtIQUFtb2tBQXUwQ0FFQlxuZndKQUFrQUNRQUpBSUFORkRRQWdBeUFFUWRtVHdBQkJEQkM3QWtVRVFDQURJQVJCNVpQQUFFRVRFTHNDRFFGQkFTRUZJQU1nQkVINFxuazhBQVFRd1F1d0lOQVNBRElBUkJoSlRBQUVFTUVMc0NSUVJBSUFCQkF6WUNBQThGQ3lBQVFRbzJBZ2dnQUVHUWxNQUFOZ0lFREFJRlxuQ3lBQVFRbzJBZ2dnQUVHYWxNQUFOZ0lFREFFTEFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQVxuQWtBZ0FTQUNRYVNVd0FCQkVSQzdBa1VFUUNBQklBSkJ0WlRBQUVFUkVMc0NEUUVnQVNBQ1FjYVV3QUJCRVJDN0FnMENJQUVnQWtIWFxubE1BQVFSUVF1d0lOQXlBQklBSkI2NVRBQUVFVUVMc0NEUVFnQVNBQ1FmK1V3QUJCRkJDN0FnMEZJQUVnQWtHVGxjQUFRUlFRdXdJTlxuQmlBQklBSkJwNVhBQUVFVUVMc0NEUWNnQVNBQ1FidVZ3QUJCRlJDN0FnMElJQUVnQWtIUWxjQUFRUlVRdXdJTkNTQUJJQUpCNVpYQVxuQUVFVkVMc0NEUW9nQVNBQ1FmcVZ3QUJCRlJDN0FnMExJQUVnQWtHUGxzQUFRUllRdXdJTkRDQUJJQUpCcFpiQUFFRVdFTHNDRFEwZ1xuQVNBQ1FidVd3QUJCRnhDN0FnME9JQUVnQWtIU2xzQUFRUkVRdXdJTkR5QUJJQUpCNDViQUFFRVJFTHNDRFJBZ0FTQUNRZlNXd0FCQlxuRXhDN0FnMFJJQUVnQWtHSGw4QUFRUk1RdXdKRkJFQWdBU0FDUVpxWHdBQkJFeEM3QWtVRVFDQUJJQUpCclpmQUFFRVRFTHNDUlFSQVxuSUFCQkF6WUNBQThGQ3lBQVFRODJBZ2dnQUVIQWw4QUFOZ0lFREJZRkN5QURSUTBUSUFVRVFDQUFRZENYd0FBMkFnZ2dBRUg0enNBQVxuTmdJRURCY0ZDeUFBUWRDWHdBQTJBZ2dnQUVIWXpzQUFOZ0lFREJZRkN5QURSUTBUSUFVRVFDQUFRZENYd0FBMkFnZ2dBRUhvenNBQVxuTmdJRURCWUZDeUFBUWRDWHdBQTJBZ2dnQUVISXpzQUFOZ0lFREJVRkN5QUFRUU0yQWdnZ0FFR3NtY0FBTmdJRURCVUxJQUJCQ0RZQ1xuQ0NBQVFhU1p3QUEyQWdRTUZBc2dBRUVMTmdJSUlBQkJtWm5BQURZQ0JBd1RDeUFBUVEwMkFnZ2dBRUdNbWNBQU5nSUVEQkFMSUFCQlxuRkRZQ0NDQUFRZmlZd0FBMkFnUU1FUXNnQUVFVU5nSUlJQUJCNUpqQUFEWUNCQXdRQ3lBQVFSUTJBZ2dnQUVIUW1NQUFOZ0lFREE4TFxuSUFCQnZKakFBRFlDQ0NBQVFaQ3h3QUEyQWdRTURRc2dBRUc4bU1BQU5nSUlJQUJCcUxIQUFEWUNCQXdNQ3lBQVFieVl3QUEyQWdnZ1xuQUVIQXNjQUFOZ0lFREFzTElBQkJ2SmpBQURZQ0NDQUFRZGl4d0FBMkFnUU1DZ3NnQUVFWE5nSUlJQUJCbzVqQUFEWUNCQXdJQ3lBQVxuUVFnMkFnZ2dBRUdibU1BQU5nSUVEQWNMSUFCQkNEWUNDQ0FBUVpPWXdBQTJBZ1FNQmdzZ0FFRUlOZ0lJSUFCQmk1akFBRFlDQkF3RlxuQ3lBQVFRczJBZ2dnQUVHQW1NQUFOZ0lFREFRTElBQkJEVFlDQ0NBQVFmT1h3QUEyQWdRTUJRc2dBRUVQTmdJSUlBQkI1SmZBQURZQ1xuQkF3Q0N5QUFRUUkyQWdBUEN5QUFRUUkyQWdBUEN5QUFRUUUyQWdBUEN5QUFRUVUyQWdBUEN5QUFRUUEyQWdBTHZ3Y0NCSDhFZmlNQVxuUWNBRGF5SUVKQUFnQWlnQ1VDRUdBa0FnQVNnQ2VBUkFJQUFnQmpZQ2VDQUFJQUpCS0JBcElnQkJLR29nQWtFb2FrRW9FQ2thSUFCQlxuMkFCcVFnQTNBd0FnQUVJQk53TlFJQUJCNEFCcVFnQTNBd0FnQUVIb0FHcENBRGNEQUNBQVFmQUFha0lBTndNQURBRUZDeUFHQkVBZ1xuQXdSQUlBTkNBRGNEQ0NBRFFnRTNBd0FnQTBFUWFrSUFOd01BSUFOQkdHcENBRGNEQUNBRFFTQnFRZ0EzQXdBRkN5QUFJQUZCZ0FFUVxuS1JvTUFRVUxJQUJCQURZQ2VDQUVRWmdEYWlJSElBRkIwQUJxSWdZUUZ5QUVRZkFDYWlJRklBRkJLQkFwR2lBRkVLb0JJQVJCeUFKcVxuSUFJZ0J4QU9JQVJCb0FKcUlnVWdBVUVvYWtFb0VDa2FJQVVRcWdFZ0JFSDRBV29pQlNBQ1FTaHFJQWNRRGlBRklBVWdCaEFPSUFRZ1xuQkNrRHlBSWdCQ2tEOEFKOVFyemgvLysvLy84ZmZEY0QwQUVnQkNBRUtRUFFBaUFFS1FQNEFuMUMvUC8vLy8vLy94OThOd1BZQVNBRVxuSUFRcEE5Z0NJQVFwQTRBRGZVTDgvLy8vLy8vL0gzdzNBK0FCSUFRZ0JDa0Q0QUlnQkNrRGlBTjlRdnovLy8vLy8vOGZmRGNENkFFZ1xuQkNBRUtRUG9BaUFFS1FPUUEzMUMvUC8vLy8vLy93RjhOd1B3QVNBRUtRUEFBaUVJSUFRcEE3Z0NJUWtnQkNrRHNBSWhDaUFFS1FPb1xuQWlFTElBUWdCQ2tEK0FFZ0JDa0RvQUo5UXJ6aC8vKy8vLzhmZkRjRHFBRWdCQ0FFS1FPQUFpQUxmVUw4Ly8vLy8vLy9IM3czQTdBQlxuSUFRZ0JDa0RpQUlnQ24xQy9QLy8vLy8vL3g5OE53TzRBU0FFSUFRcEE1QUNJQWw5UXZ6Ly8vLy8vLzhmZkRjRHdBRWdCQ0FFS1FPWVxuQWlBSWZVTDgvLy8vLy8vL0FYdzNBOGdCSUFSQjBBRnFFSXNCQkVBZ0JFR29BV29RaXdFRVFDQUFJQUVnQXhBeURBSUZDeUFEQkVBZ1xuQTBFb0VFTWFCUXNnQUJDeUFnd0JCUXNnQkVHQUFXb2dCRUdvQVdvUUZ5QUVRZGdBYWlJQklBUkIwQUZxSWdJUUZ5QUVRVEJxSUFJZ1xuQVJBT0lBTUVRQ0FESUFSQjBBRnFRU2dRS1JvRkN5QUFRZEFBYWlBR0lBUkIwQUZxRUE0Z0JFRUlhaUlESUFSQjhBSnFJQVJCMkFCcVxuRUE0Z0FDQURRU2dRS1NJQVFRSVE1UUVnQUNBRVFUQnFJZ0lRM3dFZ0FDQUFRUU1RendFZ0FDQUVRWUFCYWhEZkFTQUFRU2hxSWdFZ1xuQUVFRkVNOEJJQUVnQXhEZkFTQUJJQUVnQkVHb0FXb1FEaUFDSUFJZ0JFR2dBbW9RRGlBRVFyemgvLysvLy84ZklBUXBBekI5TndNd1xuSUFSQy9QLy8vLy8vL3g4Z0JDa0RPSDAzQXpnZ0JFTDgvLy8vLy8vL0h5QUVLUU5BZlRjRFFDQUVRdnovLy8vLy8vOGZJQVFwQTBoOVxuTndOSUlBUkMvUC8vLy8vLy93RWdCQ2tEVUgwM0ExQWdBU0FDRU44QkN5QUVRY0FEYWlRQUMvQUZBZ1ovRVg0akFFR0FCV3NpQkNRQVxuQWtBZ0FTZ0NBRUVCUndSQUlBUWdBaUFESUFOQmdIOXhFTmtDSUFRb0Fnd2hCeUFFS0FJSUlRZ2dCQ2dDQUNFRklBRXBBMEFoRGlBQlxuS1FNNElROGdBU2tETUNFUUlBRXBBeWdoRVNBQktRTWdJUklnQVNrREdDRVRJQUVwQXhBaEZDQUJLUU1JSVJVZ0JDZ0NCRUdBZjNFaVxuQ1NFR0EwQWdCa1VOQWtFQUlRTWdCRUVBUVlBRi9Bc0FBMEFnQTBHQUFVWUVRRUVBSVFJRFFDQUNRWUFFUmdSQVFRQWhBeUFSSVJvZ1xuRWlFWElCTWhDaUFVSVFzZ0ZTRVlJQkFoRENBUElSWWdEaUVOQTBBZ0ZpRVpJQXdoRmlBYUlRd2dBMEdBQlVaRkJFQWdDaUFMZ3lBS1xuSUF1RUlBTWdCR29wQXdBZ0EwSFl1OEFBYWlrREFDQU5JQXhDTG9rZ0RFSXlpWVVnREVJWGlZVjhJQmtnREVKL2hZTWdEQ0FXZzRSOFxuZkh3aURTQVhmQ0VhSUFOQkNHb2hBeUFLSVJjZ0N5RUtJQmdpQzRPRUlBdENIb2tnQzBJa2lZVWdDMElaaVlWOElBMThJUmdnR1NFTlxuREFFRkN3c2dEU0FPZkNFT0lBOGdHWHdoRHlBUUlCWjhJUkFnRENBUmZDRVJJQklnRjN3aEVpQUtJQk44SVJNZ0N5QVVmQ0VVSUJVZ1xuR0h3aEZTQUdRWUFCYXlFR0lBVkJnQUZxSVFVTUJBVWdBaUFFYWlJRFFZQUJhaUFES1FNQUlBTkJ5QUJxS1FNQUlBTkJDR29wQXdBaVxuQ2tJNGlTQUtRaitKaFNBS1FnZUloWHg4SUFOQjhBQnFLUU1BSWdwQ0E0a2dDa0l0aVlVZ0NrSUdpSVY4TndNQUlBSkJDR29oQWd3QlxuQ3dBTEFBVWdBeUFFYWlBRElBVnFLUUFBSWdwQ09JWWdDa0tBL2dPRFFpaUdoQ0FLUW9DQS9BZURRaGlHSUFwQ2dJQ0ErQStEUWdpR1xuaElRZ0NrSUlpRUtBZ0lENEQ0TWdDa0lZaUVLQWdQd0hnNFFnQ2tJb2lFS0EvZ09ESUFwQ09JaUVoSVEzQXdBZ0EwRUlhaUVEREFFTFxuQUFzQUN3QUZDMEhRdzhBQVFTaEJnTGZBQUJEc0FRQUxJQUVnRGpjRFFDQUJJQTgzQXpnZ0FTQVFOd013SUFFZ0VUY0RLQ0FCSUJJM1xuQXlBZ0FTQVROd01ZSUFFZ0ZEY0RFQ0FCSUJVM0F3Z2dBQ0FITmdJSUlBQWdDRFlDQkNBQUlBazJBZ0FnQkVHQUJXb2tBQXVFQndJRlxuZndSK0l3QkI0QU5ySWdRa0FBSkFJQUlvQWxBRVFDQUFJQUZCZ0FFUUtSb01BUVVMSUFFb0FuZ0VRQ0FBUVFBMkFuZ2dCRUc0QTJvaVxuQVNBREVCY2dCRUdRQTJvaUJpQUJJQU1RRGlBQUlBSWdBUkFPSUFCQktHb2dBa0VvYWlBR0VBNGdBRUhZQUdwQ0FEY0RBQ0FBUWdFM1xuQTFBZ0FFSGdBR3BDQURjREFDQUFRZWdBYWtJQU53TUFJQUJCOEFCcVFnQTNBd0FNQVFVTElBQkJBRFlDZUNBRVFiZ0RhaUlHSUFGQlxuMEFCcUlnY2dBeEFPSUFSQmtBTnFJZ01nQmhBWElBUkI2QUpxSWdVZ0FVRW9FQ2thSUFVUXFnRWdCRUhBQW1vZ0FpQURFQTRnQkVHWVxuQW1vaUJTQUJRU2hxUVNnUUtSb2dCUkNxQVNBRVFmQUJhaUlGSUFKQktHb2dBeEFPSUFVZ0JTQUdFQTRnQkNBRUtRUEFBaUFFS1FQb1xuQW4xQ3ZPSC8vNy8vL3g5OE53UElBU0FFSUFRcEE4Z0NJQVFwQS9BQ2ZVTDgvLy8vLy8vL0gzdzNBOUFCSUFRZ0JDa0QwQUlnQkNrRFxuK0FKOVF2ei8vLy8vLy84ZmZEY0QyQUVnQkNBRUtRUFlBaUFFS1FPQUEzMUMvUC8vLy8vLy94OThOd1BnQVNBRUlBUXBBK0FDSUFRcFxuQTRnRGZVTDgvLy8vLy8vL0FYdzNBK2dCSUFRcEE3Z0NJUWtnQkNrRHNBSWhDaUFFS1FPb0FpRUxJQVFwQTZBQ0lRd2dCQ0FFS1FQd1xuQVNBRUtRT1lBbjFDdk9ILy83Ly8veDk4TndPZ0FTQUVJQVFwQS9nQklBeDlRdnovLy8vLy8vOGZmRGNEcUFFZ0JDQUVLUU9BQWlBTFxuZlVMOC8vLy8vLy8vSDN3M0E3QUJJQVFnQkNrRGlBSWdDbjFDL1AvLy8vLy8veDk4TndPNEFTQUVJQVFwQTVBQ0lBbDlRdnovLy8vL1xuLy84QmZEY0R3QUVnQkVISUFXb1Fpd0VFUUNBRVFhQUJhaENMQVFSQUlBQWdBVUVBRURJTUFnVUxJQUFRc2dJTUFRVUxJQVJCK0FCcVxuSWdVZ0JFR2dBV29pQ0JBWElBUkIwQUJxSWdNZ0JFSElBV29pQmhBWElBUkJLR29pQWlBR0lBTVFEaUFBUWRBQWFpQUhRU2dRS1NJQlxuSUFFZ0JoQU9JQVFnQkVIb0Ftb2dBeEFPSUFBZ0JFRW9FQ2tpQUVFQ0VPVUJJQUFnQWhEZkFTQUFJQUJCQXhEUEFTQUFJQVVRM3dFZ1xuQUVFb2FpSUJJQUJCQlJEUEFTQUJJQVFRM3dFZ0FTQUJJQWdRRGlBQ0lBSWdCRUdZQW1vUURpQUVRcnpoLy8rLy8vOGZJQVFwQXloOVxuTndNb0lBUkMvUC8vLy8vLy94OGdCQ2tETUgwM0F6QWdCRUw4Ly8vLy8vLy9IeUFFS1FNNGZUY0RPQ0FFUXZ6Ly8vLy8vLzhmSUFRcFxuQTBCOU53TkFJQVJDL1AvLy8vLy8vd0VnQkNrRFNIMDNBMGdnQVNBQ0VOOEJDeUFFUWVBRGFpUUFDN1VGQVJaL0l3QkJnQUpySWdRa1xuQUFKQUlBRW9BZ0JCQVVZRVFDQUVJQUlnQXlBRFFVQnhFTmtDSUFRb0Fnd2hGeUFFS0FJSUlSZ2dCQ2dDQUNFU0lBRW9BaUFoQ1NBQlxuS0FJY0lRb2dBU2dDR0NFTElBRW9BaFFoRENBQktBSVFJUTBnQVNnQ0RDRU9JQUVvQWdnaER5QUJLQUlFSVJBZ0JDZ0NCRUZBY1NJWlxuSVJNRFFDQVRSUTBDUVFBaEF5QUVRUUJCZ0FMOEN3QURRQ0FEUWNBQVJnUkFRUUFoQWdOQUlBSkJ3QUZHQkVCQkFDRUdJQXdoRmlBTlxuSVJRZ0RpRUZJQThoQnlBUUlRSWdDeUVESUFvaEVTQUpJUWdEUUNBUklSVWdBeUVSSUJZaEF5QUdRWUFDUmtVRVFDQUZJQWR4SUFVZ1xuQjNJZ0JDQUdhaWdDQUNBR1FkaXN3QUJxS0FJQUlBZ2dBMEVWZHlBRFFScDNjeUFEUVFkM2Myb2dGU0FEUVg5emNTQURJQkZ4Y21wcVxuYWlJSUlCUnFJUllnQmtFRWFpRUdJQVVoRkNBSElRVWdBaUlIY1hJZ0FrRVRkeUFDUVI1M2N5QUNRUXAzYzJvZ0NHb2hBaUFWSVFnTVxuQVFVTEN5QUlJQWxxSVFrZ0NpQVZhaUVLSUFzZ0VXb2hDeUFESUF4cUlRd2dEU0FVYWlFTklBVWdEbW9oRGlBSElBOXFJUThnQWlBUVxuYWlFUUlCTkJRR29oRXlBU1FVQnJJUklNQkFVZ0FpQUVhaUlEUVVCcklBTW9BZ0FnQTBFa2FpZ0NBQ0FEUVFScUtBSUFJZ1ZCRG5jZ1xuQlVFWmQzTWdCVUVEZG5OcWFpQURRVGhxS0FJQUlnTkJEWGNnQTBFUGQzTWdBMEVLZG5OcU5nSUFJQUpCQkdvaEFnd0JDd0FMQUFVZ1xuQXlBRWFpQURJQkpxS0FBQUlnSkJHSFFnQWtHQS9nTnhRUWgwY2lBQ1FRaDJRWUQrQTNFZ0FrRVlkbkp5TmdJQUlBTkJCR29oQXd3QlxuQ3dBTEFBc0FCUXRCME1QQUFFRW9RZkMyd0FBUTdBRUFDeUFCSUFrMkFpQWdBU0FLTmdJY0lBRWdDellDR0NBQklBdzJBaFFnQVNBTlxuTmdJUUlBRWdEallDRENBQklBODJBZ2dnQVNBUU5nSUVJQUFnRnpZQ0NDQUFJQmcyQWdRZ0FDQVpOZ0lBSUFSQmdBSnFKQUFMdWdVQlxuRFg4akFFR0FCR3NpQ2lRQUlBVVFnUUloRFNBSkVJRUNJUTRnQ2tHQUEyb2dCUkFGQWtBZ0JrVUVRQ0FLUWVBRGFpSUxJQWtRQlNBS1xuUWVBQ2FpQURJQXNRQkNBS1FhQUNhaUlHSUFVZ0NSQTZJQVlnQmhBRklBWWdCaUFLUVlBRGFoQkdJQVlnQmlBTEVFWWdDa0hBQW1vaVxuQmlBSklBc1FCQ0FHSUFZZ0JCQUVEQUVGQ3lBS1FlQUNhaUFERVB3Q0lBcEJvQUpxSUFVZ0JSQTZJQXBCd0FKcUlBUVEvQUlMSUFwQlxuZ0FKcUlnWWdCeUFLUVlBRGFpSUxFQVFnQ2tIZ0FXb2lEQ0FHSUFwQjRBSnFFRVlnQ2lnQy9BRWhCaUFLS0FMNEFTRVBJQW9vQXZRQlxuSVJBZ0NpZ0M4QUVoRVNBS0tBTHNBU0VTSUFvb0F1Z0JJUk1nQ2lnQzVBRWhGQ0FLS0FMZ0FTRVZJQXBCb0FOcUlBd2dDa0dnQW1vUVxuQkNBS1FjQUJhaUlNSUFVZ0N4QUVJQXBCb0FGcUloWWdDQ0FNRUFRZ0NrR0FBV29pQ3lBV0lBcEJ3QUpxRUVZZ0N5QUxJQXNRT2dKQVxuUVFBZ0RrRUJheUFPUVg5emNTQU5RUUZySUExQmYzTnhja0VmZFVGL2N5QUtLQUtjQVNBS0tBS1lBU0FLS0FLVUFTQUtLQUtRQVNBS1xuS0FLTUFTQUtLQUtJQVNBS0tBS0VBU0FLS0FLQUFTQUdJQThnRUNBUklCSWdFeUFVSUJWeWNuSnljbkp5Y25KeWNuSnljbkliQkVBZ1xuQUNBQklBSWdBeUFFSUFVUWNBd0JCUXNnQ2tIZ0FHb2lCaUFLUWVBQmFpSUxJQXNRT2lBR0lBWVFCU0FLUVVCcklnOGdDeUFHRUFRZ1xuQ2tFZ2FpSU1JQXBCNEFKcUlBWVFCQ0FLUWVBRGFpSUdJQXBCZ0FGcUloQVFCU0FHSUFZZ0R4QkdJQVlnQmlBTUVFWWdCaUFHSUF3UVxuUmlBS1FjQURhaUlMSUF3Z0JoQkdJQXNnQ3lBUUVBUWdDaUFLUWNBQ2FpQVBFQVFnQ3lBTElBb1FSaUFMSUFzZ0NoQkdJQVlnRFNBSFxuSUFZUWJpQUFJQTRnQXlBR0VHNGdDeUFOSUFnZ0N4QnVJQUVnRGlBRUlBc1FiaUFLUWFBRGFpSUFJQTBnQ1NBQUVHNGdBaUFPSUFVZ1xuQUJCdUN5QUtRWUFFYWlRQUM1QUZBUWgvQWtBZ0FrRVFTUVJBSUFBaEF3d0JCUXNDUUNBQUlBQkJBQ0FBYTBFRGNTSUdhaUlGVHcwQVxuSUFBaEF5QUJJUVFnQmdSQUlBWWhCd05BSUFNZ0JDMEFBRG9BQUNBRVFRRnFJUVFnQTBFQmFpRURJQWRCQVdzaUJ3MEFDd1VMSUFaQlxuQVd0QkIwa05BQU5BSUFNZ0JDMEFBRG9BQUNBRFFRRnFJQVJCQVdvdEFBQTZBQUFnQTBFQ2FpQUVRUUpxTFFBQU9nQUFJQU5CQTJvZ1xuQkVFRGFpMEFBRG9BQUNBRFFRUnFJQVJCQkdvdEFBQTZBQUFnQTBFRmFpQUVRUVZxTFFBQU9nQUFJQU5CQm1vZ0JFRUdhaTBBQURvQVxuQUNBRFFRZHFJQVJCQjJvdEFBQTZBQUFnQkVFSWFpRUVJQU5CQ0dvaUF5QUZSdzBBQ3dzZ0JTQUNJQVpySWdkQmZIRWlDR29oQXdKQVxuSUFFZ0Jtb2lCRUVEY1VVRVFDQURJQVZORFFFZ0JDRUJBMEFnQlNBQktBSUFOZ0lBSUFGQkJHb2hBU0FGUVFScUlnVWdBMGtOQUFzTVxuQVFVTElBTWdCVTBOQUNBRVFRTjBJZ0pCR0hFaEJpQUVRWHh4SWdsQkJHb2hBVUVBSUFKclFSaHhJUW9nQ1NnQ0FDRUNBMEFnQlNBQ1xuSUFaMklBRW9BZ0FpQWlBS2RISTJBZ0FnQVVFRWFpRUJJQVZCQkdvaUJTQURTUTBBQ3dzZ0IwRURjU0VDSUFRZ0NHb2hBUXNDUUNBRFxuSUFJZ0Eyb2lCazhOQUNBQ1FRZHhJZ1FFUUFOQUlBTWdBUzBBQURvQUFDQUJRUUZxSVFFZ0EwRUJhaUVESUFSQkFXc2lCQTBBQ3dVTFxuSUFKQkFXdEJCMGtOQUFOQUlBTWdBUzBBQURvQUFDQURRUUZxSUFGQkFXb3RBQUE2QUFBZ0EwRUNhaUFCUVFKcUxRQUFPZ0FBSUFOQlxuQTJvZ0FVRURhaTBBQURvQUFDQURRUVJxSUFGQkJHb3RBQUE2QUFBZ0EwRUZhaUFCUVFWcUxRQUFPZ0FBSUFOQkJtb2dBVUVHYWkwQVxuQURvQUFDQURRUWRxSUFGQkIyb3RBQUE2QUFBZ0FVRUlhaUVCSUFOQkNHb2lBeUFHUncwQUN3c2dBQXVGQmdFRmZ5QUFRUWhySWdFZ1xuQUVFRWF5Z0NBQ0lEUVhoeElnQnFJUUlDUUFKQUlBTkJBWEVOQUNBRFFRSnhSUTBCSUFFb0FnQWlBeUFBYWlFQUlBRWdBMnNpQVVHWVxuK01BQUtBSUFSZ1JBSUFJb0FnUkJBM0ZCQTBjTkFVR1ErTUFBSUFBMkFnQWdBaUFDS0FJRVFYNXhOZ0lFSUFFZ0FFRUJjallDQkNBQ1xuSUFBMkFnQVBCUXNnQVNBREVFOExBa0FDUUFKQUFrQUNRQ0FDS0FJRUlnTkJBbkZGQkVBZ0FrR2MrTUFBS0FJQVJnMENJQUpCbVBqQVxuQUNnQ0FFWU5BeUFDSUFOQmVIRWlBaEJQSUFFZ0FDQUNhaUlBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQ0FCUVpqNHdBQW9BZ0JIRFFGQlxua1BqQUFDQUFOZ0lBRHdVTElBSWdBMEYrY1RZQ0JDQUJJQUJCQVhJMkFnUWdBQ0FCYWlBQU5nSUFDeUFBUVlBQ1NRMENJQUVnQUJCVlxuUVFBaEFVR3crTUFBUWJENHdBQW9BZ0JCQVdzaUFEWUNBQ0FBRFFSQitQWEFBQ2dDQUNJQUJFQURRQ0FCUVFGcUlRRWdBQ2dDQ0NJQVxuRFFBTEJRdEJzUGpBQUNBQlFmOGZJQUZCL3g5TEd6WUNBQThMUVp6NHdBQWdBVFlDQUVHVStNQUFRWlQ0d0FBb0FnQWdBR29pQURZQ1xuQUNBQklBQkJBWEkyQWdSQm1QakFBQ2dDQUNBQlJnUkFRWkQ0d0FCQkFEWUNBRUdZK01BQVFRQTJBZ0FGQ3lBQVFhajR3QUFvQWdBaVxuQTAwTkEwR2MrTUFBS0FJQUlnSkZEUU5CQUNFQVFaVDR3QUFvQWdBaUJFRXBTUTBDUWZEMXdBQWhBUU5BSUFJZ0FTZ0NBQ0lGVHdSQVxuSUFJZ0JTQUJLQUlFYWtrTkJBVUxJQUVvQWdnaEFRd0FDd0FMUVpqNHdBQWdBVFlDQUVHUStNQUFRWkQ0d0FBb0FnQWdBR29pQURZQ1xuQUNBQklBQkJBWEkyQWdRZ0FDQUJhaUFBTmdJQUR3c2dBRUg0QVhGQmdQYkFBR29oQWdKL1FZajR3QUFvQWdBaUEwRUJJQUJCQTNaMFxuSWdCeFJRUkFRWWo0d0FBZ0FDQURjallDQUNBQ0RBRUZDeUFDS0FJSUN5RUFJQUlnQVRZQ0NDQUFJQUUyQWd3Z0FTQUNOZ0lNSUFFZ1xuQURZQ0NBOExRZmoxd0FBb0FnQWlBUVJBQTBBZ0FFRUJhaUVBSUFFb0FnZ2lBUTBBQ3dVTFFiRDR3QUFnQUVIL0h5QUFRZjhmU3hzMlxuQWdBZ0F5QUVUdzBBUWFqNHdBQkJmellDQUFzTG5nVUNDbjhCZmlNQVFhQVFheUlJSkFBZ0NFRWNhaUlHUVFCQmdCRDhDd0FnQ0VFUVxuYWlBRlFRRjBJQVpCZ0FSQnZMdkFBQkNqQWlBSVFRaHFJQVVnQ0NnQ0VDSUtJQWdvQWhRaUNVSGd1Y0FBRUtNQ0lBZ29BZ3hCQW5RaFxuQnlBSUtBSUlJUVlEUUNBSEJFQWdCa0VBTmdJQUlBZEJCR3NoQnlBR1FRUnFJUVlNQVFVTEN5QUpJQVVnQlNBSlN4c2hEQ0FLSUFWQlxuQW5RaURtb2hEMEVBSVFjZ0JTRUxJQWtoQmdKQUEwQWdCeUFPUmcwQklBSWdCMm9vQWdBaERTQUlJQVVnQnlBS2FpQUdRZkM1d0FBUVxub3dJZ0NDZ0NBQ0FCSUEwZ0JSQ3VBU0VOSUFZZ0RFY0VRQ0FISUE5cUlBMDJBZ0FnQzBFQmFpRUxJQVpCQVdzaEJpQUhRUVJxSVFjTVxuQVFVTEN5QUxJQWxCZ0xyQUFCRERBUUFMSUFBaEJpQUtJUUFnQlVVZ0JVRUJkQ0FKUjNJRWYwRUFCU0FGUVFKMElRa2dCQ2dDQUNFS1xuSUFBaEFTQUZJUUpCQUNFRUEwQWdBZ1JBSUFFZ0NXb2lDeUFCSUFNZ0FTZ0NBQ0FLYkNBRkVLNEJJQVJxSWdjZ0N5Z0NBQ0lMYWlJTVxuTmdJQUlBUWdCMEVBUjNJZ0N5QU1UM0VoQkNBQlFRUnFJUUVnQWtFQmF5RUNEQUVGQWtBZ0JpQUFJQVZCQW5ScUlnRTFBZ0FnQXpVQ1xuQUgwaUVENENBQ0FHUVFScUlRQWdBMEVFYWlFRElBVkJBU0FGUVFGTEcwRUJheUVDSUFGQkJHb2hDUU5BSUJCQ0lJaW5RUUZ4SVFvZ1xuQWtVTkFTQUFJQWsxQWdBZ0F6VUNBQ0FLclh4OUloQStBZ0FnQWtFQmF5RUNJQUJCQkdvaEFDQUpRUVJxSVFrZ0EwRUVhaUVEREFBTFxuQUFzTEN5QUVJQXBySWdCQmYzTWhBZ04vSUFVRWZ5QUdJQUFnQVNnQ0FIRWdCaWdDQUNBQ2NYSTJBZ0FnQVVFQU5nSUFJQVpCQkdvaFxuQmlBQlFRUnFJUUVnQlVFQmF5RUZEQUVGUVFFTEN3dEJBVWNFUUVHTzBNQUFRU3NnQ0VHZkVHcEIyTGpBQUVIUXVjQUFFSzhCQUFVTFxuSUFoQm9CQnFKQUFMeUFVQkJuOGpBRUd3QVdzaUJpUUFJQVpCRUdvZ0FSRDlBU0FHS0FJVUlRa2dCa0VJYWlBQ0lBTVE2QUVnQmlnQ1xuRENFRElBWW9BZ2doQ2lBR0lBUWdCUkRvQVNBR0tBSUVJUVFnQmlnQ0FDRUZJQVpCakFGcUlBb2dBeEJtQWtBZ0JpMEFqQUZCQVVZRVxuUUNBR1FTUnFJQVpCbUFGcUtBSUFOZ0lBSUFZZ0Jpa0NrQUUzQWh3Z0JrRUJOZ0lZREFFRkN5QUdRVEJxSUFaQmxRRnFJZ0VwQUFBM1xuQXdBZ0JrRTRhaUFHUVowQmFpSUNLUUFBTndNQUlBWkJRR3NnQmtHbEFXb2lCeWtBQURjREFDQUdJQVlwQUkwQk53TW9JQVpCakFGcVxuSUFVZ0JCQnJJQVl0QUl3QlFRRkdCRUFnQmtFa2FpQUdRWmdCYWlnQ0FEWUNBQ0FHSUFZcEFwQUJOd0ljSUFaQkFUWUNHQXdCQlFzZ1xuQmtIUUFHb2dBU2tBQURjREFDQUdRZGdBYWlBQ0tRQUFOd01BSUFaQjRBQnFJQWNwQUFBM0F3QWdCaUFHS1FDTkFUY0RTRUhrOU1BQVxuS0FJQUdpTUFRU0JySWdFa0FDQUJRZmp0d0FBZ0FTQUdRU2hxSWdjUWd3SWpBRUV3YXlJQ0pBQWdBa0VBTmdJTUlBSkJFR29pQ0NBR1xuUWNnQWFpQUNRUXhxRUVJZ0FpZ0NEQ0VMSUFFZ0FTQUlFSTRCSUFFUXRRSWdBa0V3YWlRQUlBdHlSWEVpQWtVUXFBRWdCeUFCRUU0Z1xuQVVFZ2FpUUFJQUpCQVVjRVFDQUdRUnhxUVFFZ0JoQTJJQVpCQVRZQ0dBd0JCUXNnQmtHT0FXb2dCaTBBS2pvQUFDQUdRWjhCYWlBR1xuUVR0cUtRQUFOd0FBSUFaQnBBRnFJQVpCUUdzcEFBQTNBQUFnQmlBR0x3RW9Pd0dNQVNBR0lBWXBBRE0zQUpjQklBWWdCaWtBS3pjQVxuandFZ0JrRWNhaUFHUVl3QmFrRWdFTFVCSUFaQkFEWUNHQXNnQlNBRUVOOENJQW9nQXhEZkFpQUpJQWtvQWdCQkFXczJBZ0FnQmtHTVxuQVdvZ0JrRVlhaENpQVNBR0tBS1FBU0VCSUFBQ2Z5QUdLQUtNQVFSQVFRQWhBa0VBSVFWQkFRd0JCUXNnQmlnQ2xBRWhCU0FCSVFKQlxuQUNFQlFRQUxOZ0lNSUFBZ0FUWUNDQ0FBSUFVMkFnUWdBQ0FDTmdJQUlBWkJzQUZxSkFBTGtnVUNCWDhFZmlNQVFaQUNheUlDSkFBZ1xuQWtFUWFrRUFRY0FBL0FzQUlBSkIwQUJxUVFCQndBRDhDd0FnQVVIUUFHb2lCU0FCTFFEUUFTSUVha0dBQVRvQUFDQUJLUU5JSVFrZ1xuQVNrRFFDRUhJQUpCQ0dvZ0JFRUJhaUFGUVlBQlFhQ2N3QUFRa2dJZ0FpZ0NEQ0VESUFJb0FnZ2hCZ05BSUFNRVFDQUdRUUE2QUFBZ1xuQTBFQmF5RURJQVpCQVdvaEJnd0JCUXNMSUFTdFFqdUdJQWRDQ29ZaUNpQUVRUU4wcllRaUNFS0EvZ09EUWlpR2hDQUlRb0NBL0FlRFxuUWhpR0lBaENnSUNBK0ErRFFnaUdoSVFnQjBJQ2hrS0FnSUQ0RDRNZ0IwSU9pRUtBZ1B3SGc0UWdCMEllaUVLQS9nT0RJQXBDT0lpRVxuaElRaENDQUhRamFJSWdkQ09JWWdDVUlLaGlJS0lBZUVJZ2RDZ1A0RGcwSW9ob1FnQjBLQWdQd0hnMElZaGlBSFFvQ0FnUGdQZzBJSVxuaG9TRUlBbENBb1pDZ0lDQStBK0RJQWxDRG9oQ2dJRDhCNE9FSUFsQ0hvaENnUDREZ3lBS1FqaUloSVNFSVFjQ1FDQUVRZkFBY1VId1xuQUVjRVFDQUJJQWMzQThBQklBRWdDRGNEeUFFZ0FTQUZFUEFDREFFRkN5QUJJQVVROEFJZ0FrR1FBV29pQTBFQVFmQUEvQXNBSUFJZ1xuQ0RjQWlBSWdBaUFITndDQUFpQUJJQU1ROEFJTFFRQWhBeUFCUVFBNkFOQUJRY0FBUVFnUXZRSWlCRUVJSUFSQkNFa2JRUU4wSVFRRFxuUUNBRElBUkdSUVJBSUFJZ0FTQURhaWtEQUNJSFFqaUdJQWRDZ1A0RGcwSW9ob1FnQjBLQWdQd0hnMElZaGlBSFFvQ0FnUGdQZzBJSVxuaG9TRUlBZENDSWhDZ0lDQStBK0RJQWRDR0loQ2dJRDhCNE9FSUFkQ0tJaENnUDREZ3lBSFFqaUloSVNFTndPUUFTQUNRZEFBYWlBRFxuYWtFSUlBSkJrQUZxUVFoQnVKN0FBQkNkQWlBRFFRaHFJUU1NQVFVTEN5QUNRUkJxSUFKQjBBQnFRY0FBL0FvQUFDQUFJQUpCRUdwQlxud0FEOENnQUFJQUpCa0FKcUpBQUxvZ1lDQm44RWZpTUFRZUFEYXlJREpBQUNRQ0FCS0FKNEJFQWdBQ0FDUVlBQkVDa2FEQUVGQ3lBQ1xuS0FKNEJFQWdBQ0FCUVlBQkVDa2FEQUVGQ3lBQVFRQTJBbmdnQTBHNEEyb2lCQ0FDUWRBQWFpSUhFQmNnQTBHUUEyb2lCU0FCUWRBQVxuYWlJSUVCY2dBMEhvQW1vZ0FTQUVFQTRnQTBIQUFtb2dBaUFGRUE0Z0EwR1lBbW9pQmlBQlFTaHFJQVFRRGlBR0lBWWdCeEFPSUFOQlxuOEFGcUlnUWdBa0VvYWlBRkVBNGdCQ0FFSUFnUURpQURJQU1wQThBQ0lBTXBBK2dDZlVLODRmLy92Ly8vSDN3M0E4Z0JJQU1nQXlrRFxueUFJZ0F5a0Q4QUo5UXZ6Ly8vLy8vLzhmZkRjRDBBRWdBeUFES1FQUUFpQURLUVA0QW4xQy9QLy8vLy8vL3g5OE53UFlBU0FESUFNcFxuQTlnQ0lBTXBBNEFEZlVMOC8vLy8vLy8vSDN3M0ErQUJJQU1nQXlrRDRBSWdBeWtEaUFOOVF2ei8vLy8vLy84QmZEY0Q2QUVnQXlrRFxudUFJaENTQURLUU93QWlFS0lBTXBBNmdDSVFzZ0F5a0RvQUloRENBRElBTXBBL0FCSUFNcEE1Z0NmVUs4NGYvL3YvLy9IM3czQTZBQlxuSUFNZ0F5a0QrQUVnREgxQy9QLy8vLy8vL3g5OE53T29BU0FESUFNcEE0QUNJQXQ5UXZ6Ly8vLy8vLzhmZkRjRHNBRWdBeUFES1FPSVxuQWlBS2ZVTDgvLy8vLy8vL0gzdzNBN2dCSUFNZ0F5a0RrQUlnQ1gxQy9QLy8vLy8vL3dGOE53UEFBU0FEUWNnQmFoQ0xBUVJBSUFOQlxub0FGcUVJc0JCRUFnQUNBQlFRQVFNZ3dDQlFzZ0FCQ3lBZ3dCQlFzZ0EwSDRBR29pQlNBRFFhQUJhaUlHRUJjZ0EwSFFBR29pQkNBRFxuUWNnQmFpSUJFQmNnQTBFb2FpSUNJQUVnQkJBT0lBRWdBU0FIRUE0Z0FFSFFBR29nQ0NBQkVBNGdBeUFEUWVnQ2FpQUVFQTRnQUNBRFxuUVNnUUtTSUFRUUlRNVFFZ0FDQUNFTjhCSUFBZ0FFRURFTThCSUFBZ0JSRGZBU0FBUVNocUlnRWdBRUVGRU04QklBRWdBeERmQVNBQlxuSUFFZ0JoQU9JQUlnQWlBRFFaZ0NhaEFPSUFOQ3ZPSC8vNy8vL3g4Z0F5a0RLSDAzQXlnZ0EwTDgvLy8vLy8vL0h5QURLUU13ZlRjRFxuTUNBRFF2ei8vLy8vLy84ZklBTXBBemg5TndNNElBTkMvUC8vLy8vLy94OGdBeWtEUUgwM0EwQWdBMEw4Ly8vLy8vLy9BU0FES1FOSVxuZlRjRFNDQUJJQUlRM3dFTElBTkI0QU5xSkFBTHRRVUNCMzhDZmlNQVFkQURheUlJSkFBZ0FVRVlha0lBTndNQUlBRkJFR3BDQURjRFxuQUNBQlFRaHFRZ0EzQXdBZ0FVSUFOd01BSUFKQkdHcENBRGNEQUNBQ1FSQnFRZ0EzQXdBZ0FrRUlha0lBTndNQUlBSkNBRGNEQUNBRFxuQkVBZ0EwRUFOZ0lBQlFzZ0NFSGdBR29pQ1VHWTdzQUFJQWtnQlJDREFpSUxSUkNvQVVFQUlRa2dDRUVnYWlBRVFRQVFRaUFBUVFocVxuSVF3Z0JrSFFBQ0FHR3lFTklBaEIwQUZxSVE1QkFDRUdBMEFDUUNBSUlBUWdCU0FIUVFBZ0JpQU5FUTBBQkVBZ0NFRkFheUFJRUlNQ1xuUlEwQklBaEJBRFlDaEFFZ0RDQUlRWUFDYWlJS0lBaEJRR3NRRXlBSVFhZ0JhaUlBSUFvUWlRRWdBQkJ6SUE0UWN5QUlRWUFEYWlJS1xuSUFBUVJDQUJJQW9nQ0VHRUFXb1FRaUFEQkVBZ0F5QUlLQUxRQVVFQmNTQUlLQUtFQVVFQmRISTJBZ0FGQ3lBSVFZZ0JhaUlBSUFFZ1xuQ0VIZ0FHb1FHeUFBSUFBZ0NFRWdhaENPQVNBSUlBZ3BBMWdpRDBJNGlEY0R5QU1nQ0NBSUtRTkFJaEJDLy8vLy8vLy8vLzgvZ3pjRFxucUFNZ0NDQVBRZ2FHSUFncEExQWlEMEk2aUlSQy8vLy8vLy8vLy84L2d6Y0R3QU1nQ0NBUFFnU0dJQWdwQTBnaUQwSThpSVJDLy8vL1xuLy8vLy8vOC9nemNEdUFNZ0NDQVBRZ0tHSUJCQ1BvaUVRdi8vLy8vLy8vLy9QNE0zQTdBRElBaEJxQU5xSWdwQnNQSEFBQkFRSUFJZ1xuQ2hEQ0FTQUNJQUlnQUJBYklBaEJnQUpxRUxBQ0lBaEJxQUZxRUw4Q0lBSWdBaERMQVNJQUVIMGdBd1JBSUFNZ0F5Z0NBQ0FBY3pZQ1xuQUFVTElBRVF0UUlnQWhDMUFuSU5BVUVCSVFrRkN5QUlRUmhxUWdBM0F3QWdDRUVRYWtJQU53TUFJQWhDQURjRENDQUlRZ0EzQXdBZ1xuQVVINDdjQUFJQWtnQzNFaUFVVWlBQkNvQVNBQ1FmanR3QUFnQUJDb0FTQURCRUFnQ0NBQU5nS0FBaUFESUFNb0FnQWdDQ2dDZ0FKQlxuQVd0eE5nSUFCUXNnQ0VIUUEyb2tBQ0FCRHdzZ0JrRUJhaUVHREFBTEFBdnBCQUVJZnlNQVFZQUJheUlFSkFBZ0FDZ0NBQ0VBQW44Q1xuUUFKQUFrQWdBU2dDQ0NJQ1FZQ0FnQkJ4UlFSQUlBSkJnSUNBSUhFTkFrRUtJUU1nQUNnQ0FDSUdJQVpCSDNVaUFITWdBR3NpQUVIb1xuQjA4TkFTQUFJUUlNQXdVTElBQW9BZ0FoQUVHQkFTRUNBMEFnQWlBRWFrRUNheUFBUVE5eElnTkJNSElnQTBIWEFHb2dBMEVLU1JzNlxuQUFBZ0FrRUJheUVDSUFCQkQwc2dBRUVFZGlFQURRQUxJQUZCQVVHT2pjQUFRUUlnQWlBRWFrRUJhMEdCQVNBQ2F4QTNEQU1MQTBBZ1xuQXlBRWFpSUZRUU5ySUFBZ0FFR1F6Z0J1SWdKQmtNNEFiR3NpQjBILy93TnhRZVFBYmlJSVFRRjBJZ2xCa1kzQUFHb3RBQUE2QUFBZ1xuQlVFRWF5QUpRWkNOd0FCcUxRQUFPZ0FBSUFWQkFXc2dCeUFJUWVRQWJHdEIvLzhEY1VFQmRDSUhRWkdOd0FCcUxRQUFPZ0FBSUFWQlxuQW1zZ0IwR1FqY0FBYWkwQUFEb0FBQ0FEUVFScklRTWdBRUgvck9JRVN5QUNJUUFOQUFzTUFRc2dBQ2dDQUNFQVFZRUJJUUlEUUNBQ1xuSUFScVFRSnJJQUJCRDNFaUEwRXdjaUFEUVRkcUlBTkJDa2tiT2dBQUlBSkJBV3NoQWlBQVFROUxJQUJCQkhZaEFBMEFDeUFCUVFGQlxuam8zQUFFRUNJQUlnQkdwQkFXdEJnUUVnQW1zUU53d0JDd0pBSUFKQkNVMEVRQ0FDSVFBTUFRVUxJQU1nQkdwQkFXc2dBaUFDUWYvL1xuQTNGQjVBQnVJZ0JCNUFCc2EwSC8vd054UVFGMElnSkJrWTNBQUdvdEFBQTZBQUFnQkNBRFFRSnJJZ05xSUFKQmtJM0FBR290QUFBNlxuQUFBTFFRQWdCaUFBRzBVRVFDQUVJQU5CQVdzaUEyb2dBRUVCZEVFZWNVR1JqY0FBYWkwQUFEb0FBQVVMSUFFZ0JrRi9jMEVmZGtFQlxuUVFBZ0F5QUVha0VLSUFOckVEY0xJQVJCZ0FGcUpBQUwwd1FDQlg4RWZpTUFRWkFCYXlJQ0pBQWdBa0VvYWtJQU53TUFJQUpCSUdwQ1xuQURjREFDQUNRUmhxUWdBM0F3QWdBa0lBTndNUUlBSkJ5QUJxUWdBM0F3QWdBa0ZBYTBJQU53TUFJQUpCT0dwQ0FEY0RBQ0FCUVNocVxuSWdVZ0FTMEFhQ0lEYWtHQUFUb0FBQ0FDUWdBM0F6QWdBU2tESUNFSElBSkJDR29nQTBFQmFpQUZRY0FBUWFDY3dBQVFrZ0lnQWlnQ1xuRENFRUlBSW9BZ2doQmdOQUlBUUVRQ0FHUVFBNkFBQWdCRUVCYXlFRUlBWkJBV29oQmd3QkJRc0xJQU90UWp1R0lBZENDWVlpQ1NBRFxuUVFOMHJZUWlDRUtBL2dPRFFpaUdoQ0FJUW9DQS9BZURRaGlHSUFoQ2dJQ0ErQStEUWdpR2hJUWdCMElCaGtLQWdJRDRENE1nQjBJUFxuaUVLQWdQd0hnNFFnQjBJZmlFS0EvZ09ESUFsQ09JaUVoSVFoQndKQUlBTkJPSEZCT0VjRVFDQUJJQWMzQTJBZ0FTQUZFUEVDREFFRlxuQ3lBQklBVVE4UUlnQWtIUUFHb2lBMEVBUVRqOEN3QWdBaUFITndDSUFTQUJJQU1ROFFJTFFRQWhCQ0FCUVFBNkFHaEJJRUVFRUwwQ1xuSWdOQkNDQURRUWhKRzBFQ2RDRUZBMEFnQkNBRlJrVUVRQ0FDSUFFZ0JHb29BZ0FpQTBFWWRDQURRWUQrQTNGQkNIUnlJQU5CQ0haQlxuZ1A0RGNTQURRUmgyY25JMkFsQWdBa0V3YWlBRWFrRUVJQUpCMEFCcVFRUkJpSjdBQUJDZEFpQUVRUVJxSVFRTUFRVUxDeUFDUVNocVxuSUFKQnlBQnFLUU1BSWdjM0F3QWdBa0VnYWlBQ1FVQnJLUU1BSWdnM0F3QWdBa0VZYWlBQ1FUaHFLUU1BSWdrM0F3QWdBaUFDS1FNd1xuSWdvM0F4QWdBRUVZYWlBSE53QUFJQUJCRUdvZ0NEY0FBQ0FBUVFocUlBazNBQUFnQUNBS053QUFJQUpCa0FGcUpBQUxxQVVDQkg4RlxuZmdKQUlBRW9BbmdFUUNBQVFRRTJBbmdnQWtVTkFTQUNRZ0EzQXdnZ0FrSUJOd01BSUFKQkVHcENBRGNEQUNBQ1FSaHFRZ0EzQXdBZ1xuQWtFZ2FrSUFOd01BRHdVTElBSUVRQ0FDSUFGQktHcEJLQkFwSWdJUXFnRWdBa0VDRU9VQkJRc2pBRUdnQVdzaUFpUUFJQUFnQVNnQ1xuZURZQ2VDQUFRZEFBYWlJRElBRkIwQUJxSUFGQktHb2lCaEFPSUFOQkFoRGxBU0FDUWZnQWFpSUVJQUVRRnlBQ0lBSXBBM2hDQTM0M1xuQTNnZ0FpQUNLUU9BQVVJRGZqY0RnQUVnQWlBQ0tRT0lBVUlEZmpjRGlBRWdBaUFDS1FPUUFVSURmamNEa0FFZ0FpQUNLUU9ZQVVJRFxuZmpjRG1BRWdBa0hRQUdvaUJTQUVFQmNnQWtFb2FpSURJQVlRRnlBQ0lBSXBBeWhDQVlZM0F5Z2dBaUFDS1FNd1FnR0dOd013SUFJZ1xuQWlrRE9FSUJoamNET0NBQ0lBSXBBMEJDQVlZM0EwQWdBaUFDS1FOSVFnR0dOd05JSUFJZ0F4QVhJQUlwQXdBaEJ5QUNLUU1JSVFnZ1xuQWlrREVDRUpJQUlwQXhnaENpQUNLUU1nSVFzZ0F5QURJQUVRRGlBQUlBTkJLQkFwSWdCQkJCRGxBU0FBSUFCQkJCRFBBU0FBSUFVUVxuM3dFZ0FpQUNLUU5JUWdaK0lBSXBBM0I5UXZ6Ly8vLy8vLzhCZkRjRFNDQUNJQUlwQTBCQ0JuNGdBaWtEYUgxQy9QLy8vLy8vL3g5OFxuTndOQUlBSWdBaWtET0VJR2ZpQUNLUU5nZlVMOC8vLy8vLy8vSDN3M0F6Z2dBaUFDS1FNd1FnWitJQUlwQTFoOVF2ei8vLy8vLy84ZlxuZkRjRE1DQUNJQUlwQXloQ0JuNGdBaWtEVUgxQ3ZPSC8vNy8vL3g5OE53TW9JQUJCS0dvaUFDQUVJQU1RRGlBQ1F2ci8vLy8vLy84Q1xuSUF0Q0FZWjlOd053SUFKQyt2Ly8vLy8vL3k4Z0NrSUJobjAzQTJnZ0FrTDYvLy8vLy8vL0x5QUpRZ0dHZlRjRFlDQUNRdnIvLy8vL1xuLy84dklBaENBWVo5TndOWUlBSkNtdEwvLzUvLy95OGdCMElCaG4wM0ExQWdBQ0FGRU44QklBSkJvQUZxSkFBTEM3VUZBUU4vSXdCQlxuSUdzaUFDUUFJQUJCc09qQUFDMEFBQ0lCTmdJRUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FCUVFSR0JFQWdBRUd4Nk1BQVxuTFFBQUlnRTJBZ1FnQVVFRVJ3MEJJQUJCc3VqQUFDMEFBQ0lCTmdJRUlBRkJCRWNOQWlBQVFiUG93QUF0QUFBaUFUWUNCQ0FCUVFSSFxuRFFNZ0FFRzA2TUFBTFFBQUlnRTJBZ1FnQVVFRVJ3MEVJQUJCdGVqQUFDMEFBQ0lCTmdJRUlBRkJCRWNOQlNBQVFiYm93QUF0QUFBaVxuQVRZQ0JDQUJRUUZIRFFZZ0FFRzM2TUFBTFFBQUlnRTJBZ1FnQVVFQlJ3MEhJQUJCdU9qQUFDMEFBQ0lCTmdJRUlBRkJCRWNOQ0NBQVxuUWJub3dBQXRBQUFpQVRZQ0JDQUJRUVJIRFFsQmdRWVFnZ0lpQVVIeC8vLy9CMDhOQ2tIVStNQUFMUUFBR2lBQlFSQVF1Z0lpQVVVTlxuQ3lBQlFZRUdFQXNoQWtIVStNQUFMUUFBR2tFSUVBZ2lBVVVOQ3lBQklBSTJBZ1FnQVVFQU5nSUFJQUJCSUdva0FDQUJEd1VMSUFCQlxuQURZQ0NFRzBvY0FBSUFCQkJHb2dBRUVJYWtId29jQUFFTkFDQUFzZ0FFRUFOZ0lJUWJTaHdBQWdBRUVFYWlBQVFRaHFRWUNpd0FBUVxuMEFJQUN5QUFRUUEyQWdoQnRLSEFBQ0FBUVFScUlBQkJDR3BCa0tMQUFCRFFBZ0FMSUFCQkFEWUNDRUcwb2NBQUlBQkJCR29nQUVFSVxuYWtHZ29zQUFFTkFDQUFzZ0FFRUFOZ0lJUWJTaHdBQWdBRUVFYWlBQVFRaHFRYkNpd0FBUTBBSUFDeUFBUVFBMkFnaEJ0S0hBQUNBQVxuUVFScUlBQkJDR3BCd0tMQUFCRFFBZ0FMSUFCQkFEWUNDRUhRb3NBQUlBQkJCR29nQUVFSWFrSFVvc0FBRU5BQ0FBc2dBRUVBTmdJSVxuUWRDaXdBQWdBRUVFYWlBQVFRaHFRZVNpd0FBUTBBSUFDeUFBUVFBMkFnaEJ0S0hBQUNBQVFRUnFJQUJCQ0dwQjlLTEFBQkRRQWdBTFxuSUFCQkFEWUNDRUcwb2NBQUlBQkJCR29nQUVFSWFrR0VvOEFBRU5BQ0FBdEJqdERBQUVFcklBQkJDR3BCb0tEQUFFSFlvTUFBRUs4QlxuQ3dBTGlRVUNCWDhCZmlNQVFhQURheUlESkFBZ0EwRW9haUFCSUFJUTZBRWdBMEZBYXlJRUlBTW9BaWdpQmlBREtBSXNJZ2NRclFFZ1xuQTBHQUFXb2lBVUVBUWNFQS9Bc0FJQU5COEFCcUlnSkJ1SnpBQUNrREFEY0RBQ0FEUWZnQWFpSUZRY0Njd0FBb0FnQTJBZ0FnQTBJQVxuTndOZ0lBTkJzSnpBQUNrREFEY0RhQ0FEUVNCcVFRQWdBVUhBQUVId204QUFFSklDSUFOQkdHcEJJQ0FES0FJZ0lBTW9BaVJCZ0p6QVxuQUJDakFpQURLQUlZSUFNb0Fod2dCRUVnUVpDY3dBQVFuUUlnQTBFZ09nREFBU0FEUWNnQmFpQURRZUFBYWtIb0FQd0tBQUFnQTBIQVxuQW1wQkFEWUNBQ0FEUWJnQ2FrSUFOd01BSUFOQ0FEY0RzQUlnQXlrRHlBRWhDQ0FETFFDb0FpRUVJQU5CMkFKcUlBVW9BZ0EyQWdBZ1xuQTBIUUFtb2dBaWtEQURjREFDQUVJQU5CNkFGcUlnVnFRWUFCT2dBQUlBTWdBeWtEYURjRHlBSWdBMEVRYWlBRVFRRnFJQVZCd0FCQlxub0p6QUFCQ1NBaUFES0FJVUlRSWdBeWdDRUNFQkEwQWdBZ1JBSUFGQkFEb0FBQ0FDUVFGcklRSWdBVUVCYWlFQkRBRUZDd3NnQkVFRFxuZEswZ0NFSUpob1FoQ0FKQUlBUkJPSEZCT0VjRVFDQURJQWczQTZBQ0lBTkJ5QUpxSUFVUUF3d0JCUXNnQTBISUFtb2lBU0FGRUFNZ1xuQTBIZ0Ftb2lBa0VBUVRqOEN3QWdBeUFJTndDWUF5QUJJQUlRQXd0QkFDRUNJQU5CQURvQXFBSkJGRUVFRUwwQ0lnRkJCU0FCUVFWSlxuRzBFQ2RDRUJBMEFnQVNBQ1JrVUVRQ0FESUFOQnlBSnFJQUpxS0FJQU5nTGdBaUFEUWJBQ2FpQUNha0VFSUFOQjRBSnFRUVJCbkozQVxuQUJDZEFpQUNRUVJxSVFJTUFRVUxDeUFEUVRScUlnRWdBMEd3QW1wQkZCQzFBU0FHSUFjUTN3SWdBMEVJYWlBQkVQa0JJQU1vQWd3aFxuQVNBQUlBTW9BZ2cyQWdBZ0FDQUJOZ0lFSUFOQm9BTnFKQUFMc0FRQkRIOGdBVUVCYXlFT0lBQW9BZ1FoQ2lBQUtBSUFJUXNnQUNnQ1xuQ0NFTUFrQURRQ0FGRFFFQ2Z3SkFJQUlnQTBrTkFBTkFJQUVnQTJvaEJRSkFBa0FDUUNBQ0lBTnJJZ2RCQjAwRVFDQUNJQU5IRFFFZ1xuQWlFRERBVUZDd0pBSUFWQkEycEJmSEVpQmlBRmF5SUVCRUJCQUNFQUEwQWdBQ0FGYWkwQUFFRUtSZzBGSUFRZ0FFRUJhaUlBUncwQVxuQ3lBRUlBZEJDR3NpQUUwTkFRd0RCUXNnQjBFSWF5RUFDd05BUVlDQ2hBZ2dCaWdDQUNJSlFZcVVxTkFBYzJzZ0NYSkJnSUtFQ0NBR1xuUVFScUtBSUFJZ2xCaXBTbzBBQnpheUFKY25GQmdJR0NoSGh4UVlDQmdvUjRSdzBDSUFaQkNHb2hCaUFFUVFocUlnUWdBRTBOQUFzTVxuQVF0QkFDRUFBMEFnQUNBRmFpMEFBRUVLUmcwQ0lBY2dBRUVCYWlJQVJ3MEFDeUFDSVFNTUF3c2dCQ0FIUmdSQUlBSWhBd3dEQlFzZ1xuQkNBRmFpRUdJQUlnQkdzZ0Eyc2hCMEVBSVFBQ1FBTkFJQUFnQm1vdEFBQkJDa1lOQVNBSElBQkJBV29pQUVjTkFBc2dBaUVEREFNTFxuSUFBZ0JHb2hBQXNnQUNBRGFpSUVRUUZxSVFNQ1FDQUNJQVJORFFBZ0FDQUZhaTBBQUVFS1J3MEFRUUFoQlNBRElnUU1Bd3NnQWlBRFxuVHcwQUN3c2dBaUFJUmcwQ1FRRWhCU0FJSVFRZ0Fnc2hBQUpBSUF3dEFBQUVRQ0FMUWZpTXdBQkJCQ0FLS0FJTUVRY0FEUUVGQzBFQVxuSVFZZ0FDQUlSd1JBSUFBZ0Rtb3RBQUJCQ2tZaEJnVUxJQUFnQ0dzaEFDQUJJQWhxSVFjZ0RDQUdPZ0FBSUFRaENDQUxJQWNnQUNBS1xuS0FJTUVRY0FSUTBCQ3d0QkFTRU5DeUFOQzRzRkFRRi9Jd0JCUUdvaUF5UUFJQU1nQWpZQ0RDQURJQUUyQWdnZ0EwRUFOZ0lZSUFOQ1xuZ0lDQWdCQTNBaEFnQTBFTWFpRUNBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRkJBV3NPQ1FvQUFRSURCQVVHQndnTFxuSUFNZ0FqWUNIQ0FEUVFFMkFpUWdBMEhraGNBQU5nSWdJQU5DQVRjQ0xDQURRUVUyQWp3Z0F5QURRVGhxTmdJb0lBTWdBMEVjYWpZQ1xuT0NBRFFSQnFRY1NTd0FBZ0EwRWdhaEE0RFFnTUNnc2dBMEVRYWtIc2hjQUFRWTZHd0FBUVp3d0pDeUFESUFJMkFod2dBMEVCTmdJa1xuSUFOQndJYkFBRFlDSUNBRFFnRTNBaXdnQTBFRk5nSThJQU1nQTBFNGFqWUNLQ0FESUFOQkhHbzJBamdnQTBFUWFrSEVrc0FBSUFOQlxuSUdvUU9BMEdEQWdMSUFOQkVHcEJ5SWJBQUVIbWhzQUFFR2NNQndzZ0F5QUNOZ0ljSUFOQkFUWUNKQ0FEUVppSHdBQTJBaUFnQTBJQlxuTndJc0lBTkJCVFlDUENBRElBTkJPR28yQWlnZ0F5QURRUnhxTmdJNElBTkJFR3BCeEpMQUFDQURRU0JxRURnTkJBd0dDeUFEUVJCcVxuUWFDSHdBQkJ2SWZBQUJCbkRBVUxJQU1nQWpZQ0hDQURRUUUyQWlRZ0EwSDRoOEFBTmdJZ0lBTkNBVGNDTENBRFFRVTJBandnQXlBRFxuUVRocU5nSW9JQU1nQTBFY2FqWUNPQ0FEUVJCcVFjU1N3QUFnQTBFZ2FoQTREUUlNQkFzZ0EwRVFha0dBaU1BQVFaT0l3QUFRWnd3RFxuQ3lBRElBSTJBaHdnQTBFQk5nSWtJQU5CaElYQUFEWUNJQ0FEUWdFM0Fpd2dBMEVGTmdJOElBTWdBMEU0YWpZQ0tDQURJQU5CSEdvMlxuQWpnZ0EwRVFha0hFa3NBQUlBTkJJR29RT0VVTkFndEI3SkxBQUVFM0lBTkJJR3BCM0pMQUFFR2trOEFBRUs4QkFBc2dBMEVRYWtHTVxuaGNBQVFhNkZ3QUFRWndzZ0FDQURLUUlRTndJQUlBQkJDR29nQTBFWWFpZ0NBRFlDQUNBRFFVQnJKQUFMendRQ0JuOEJmZ0ovSUFGRlxuQkVBZ0FDZ0NDQ0VHUVMwaEN5QUZRUUZxREFFRkMwRXJRWUNBeEFBZ0FDZ0NDQ0lHUVlDQWdBRnhJZ0ViSVFzZ0FVRVZkaUFGYWdzaFxuQ1FKQUlBWkJnSUNBQkhGRkJFQkJBQ0VDREFFRkN5QURCRUFnQWlFQklBTWhDQU5BSUFjZ0FTd0FBRUcvZjBwcUlRY2dBVUVCYWlFQlxuSUFoQkFXc2lDQTBBQ3dVTElBY2dDV29oQ1FzQ1FDQUFMd0VNSWdnZ0NVc0VRQUpBQWtBZ0JrR0FnSUFJY1VVRVFDQUlJQWxySVFsQlxuQUNFQlFRQWhDQUpBQWtBQ1FDQUdRUjEyUVFOeFFRRnJEZ01BQVFBQ0N5QUpJUWdNQVFzZ0NVSCsvd054UVFGMklRZ0xJQVpCLy8vL1xuQUhFaENpQUFLQUlFSVFZZ0FDZ0NBQ0VBQTBBZ0FVSC8vd054SUFoQi8vOERjVThOQWtFQklRY2dBVUVCYWlFQklBQWdDaUFHS0FJUVxuRVFVQVJRMEFDd3dFQlFzZ0FDQUFLUUlJSWd5blFZQ0FnUDk1Y1VHd2dJQ0FBbkkyQWdoQkFTRUhJQUFvQWdBaUJpQUFLQUlFSWdvZ1xuQ3lBQ0lBTVErQUVOQTBFQUlRRWdDQ0FKYTBILy93TnhJUUlEUUNBQlFmLy9BM0VnQWs4TkFpQUJRUUZxSVFFZ0JrRXdJQW9vQWhBUlxuQlFCRkRRQUxEQU1MUVFFaEJ5QUFJQVlnQ3lBQ0lBTVErQUVOQWlBQUlBUWdCU0FHS0FJTUVRY0FEUUlnQ1NBSWEwSC8vd054SVFKQlxuQUNFQkEwQWdBaUFCUWYvL0EzRk5CRUJCQUE4RkN5QUJRUUZxSVFFZ0FDQUtJQVlvQWhBUkJRQkZEUUFMREFJTElBWWdCQ0FGSUFvb1xuQWd3UkJ3QU5BU0FBSUF3M0FnaEJBQThGQzBFQklRY2dBQ2dDQUNJQklBQW9BZ1FpQUNBTElBSWdBeEQ0QVEwQUlBRWdCQ0FGSUFBb1xuQWd3UkJ3QWhCd3NnQnd1K0JBRUlmeU1BUVJCcklnTWtBQ0FESUFFMkFnUWdBeUFBTmdJQUlBTkNvSUNBZ0E0M0FnZ0Nmd0pBQWtBQ1xuUUNBQ0tBSVFJZ2tFUUNBQ0tBSVVJZ0FOQVF3Q0JRc2dBaWdDRENJQVJRMEJJQUlvQWdnaUFTQUFRUU4wYWlFRUlBQkJBV3RCLy8vL1xuL3dGeFFRRnFJUVlnQWlnQ0FDRUFBMEFDUUNBQVFRUnFLQUlBSWdWRkRRQWdBeWdDQUNBQUtBSUFJQVVnQXlnQ0JDZ0NEQkVIQUVVTlxuQUVFQkRBVUxRUUVnQVNnQ0FDQURJQUZCQkdvb0FnQVJCUUFOQkJvZ0FFRUlhaUVBSUFRZ0FVRUlhaUlCUncwQUN3d0NDeUFBUVJoc1xuSVFvZ0FFRUJhMEgvLy8vL0FYRkJBV29oQmlBQ0tBSUlJUVFnQWlnQ0FDRUFBMEFDUUNBQVFRUnFLQUlBSWdGRkRRQWdBeWdDQUNBQVxuS0FJQUlBRWdBeWdDQkNnQ0RCRUhBRVVOQUVFQkRBUUxRUUFoQjBFQUlRZ0NRQUpBQWtBZ0JTQUphaUlCUVFocUx3RUFRUUZyRGdJQlxuQWdBTElBRkJDbW92QVFBaENBd0JDeUFFSUFGQkRHb29BZ0JCQTNScUx3RUVJUWdMQWtBQ1FBSkFJQUV2QVFCQkFXc09BZ0VDQUFzZ1xuQVVFQ2FpOEJBQ0VIREFFTElBUWdBVUVFYWlnQ0FFRURkR292QVFRaEJ3c2dBeUFIT3dFT0lBTWdDRHNCRENBRElBRkJGR29vQWdBMlxuQWdoQkFTQUVJQUZCRUdvb0FnQkJBM1JxSWdFb0FnQWdBeUFCUVFScUtBSUFFUVVBRFFNYUlBQkJDR29oQUNBRlFSaHFJZ1VnQ2tjTlxuQUFzTUFRc0xBa0FnQmlBQ0tBSUVUdzBBSUFNb0FnQWdBaWdDQUNBR1FRTjBhaUlBS0FJQUlBQW9BZ1FnQXlnQ0JDZ0NEQkVIQUVVTlxuQUVFQkRBRUxRUUFMSUFOQkVHb2tBQXVpQkFFS2Z5TUFRWkFCYXlJSEpBQWdCMEVBUVpBQi9Bc0FJd0JCd0FGcklnSWtBQ0FDUWVBQVxuYWtIZ0FCQkRHaUFDUVVCcklRa2dBa0VnYWlFS0lBSkJvQUZxSVFVZ0FrR0FBV29oQmtIL0FTRUVBMEFnQkVIZ0FXc2lBMEVnU1FSQVxuSUFnRVFDQUNRZUFBYWlJTElBWWdCU0FMSUFZZ0JSQndCUXNnQVNBRVFjQUJhMEVEZGtIOC8vLy9BWEZxS0FJQUlBTjJRUUZ4SUFFZ1xuQkVHQUFXdEJBM1pCL1AvLy93RnhhaWdDQUNBRGRrRUJkRUVDY1NBQklBUkJRR3BCQTNaQi9QLy8vd0Z4YWlnQ0FDQURka0VDZEVFRVxuY1NBQklBUkJBM1pCL1AvLy93RnhhaWdDQUNBRGRrRURkRUVJY1hKeWNrSHc0TUFBSUFJUXZBRUNRQ0FJQkVBZ0FrSGdBR29pQ0NBR1xuSUFVZ0NDQUdJQVZCQVNBQ0lBb2dDUkFvREFFRkN5QUNRZUFBYWlBQ0VQd0NJQVlnQ2hEOEFpQUZJQWtRL0FJTFFRRWhDQ0FCSUFOQlxuQTNaQi9QLy8vd0Z4YWlnQ0FDQURka0VCY1NBQklBUkJvQUZyUVFOMlFmei8vLzhCY1dvb0FnQWdBM1pCQVhSQkFuRWdBU0FFUWVBQVxuYTBFRGRrSDgvLy8vQVhGcUtBSUFJQU4yUVFKMFFRUnhJQUVnQkVFZ2EwRURka0g4Ly8vL0FYRnFLQUlBSUFOMlFRTjBRUWh4Y25KeVxuUWJEWndBQWdBaEM4QVNBQ1FlQUFhaUlESUFZZ0JTQURJQVlnQlVFQklBSWdDaUFKRUNnZ0JFRUJheUVFREFFRkN3c2dCeUFDUWVBQVxuYWhDV0FpQUhRU0JxSUFZUWxnSWdCMEZBYXlBRkVKWUNJQUpCd0FGcUpBQWdBQ0FIUVpBQi9Bb0FBQ0FIUVpBQmFpUUFDL3NEQVJCK1xuUVg5QkFDQUNOUUljSUFFMUFoeDhJQUkxQWhnZ0FUVUNHSHdnQWpVQ0ZDQUJOUUlVZkNBQ05RSVFJQUUxQWhCOElBSTFBZ3dnQVRVQ1xuREh3Z0FqVUNDQ0FCTlFJSWZDQUNOUUlFSUFFMUFnUWdBalVDQUNBQk5RSUFmQ0lEUWlDSWZId2lCRUlnaUh3aUJVSWdpSHdpQmtJZ1xuaUh3aUIwSWdpSHdpQ0VJZ2lId2lDVUlnaUh3aUNrSWdpRUlBSUFwQy8vLy8vdytEUWdBZ0NVTC8vLy8vRDRNZ0NFTC8vLy8vRDROQ1xuQUNBSFF2Ly8vLzhQZzBJQUlBWkMvLy8vL3crRFFnQWdCVUwvLy8vL0Q0TkNBQ0FFUXYvLy8vOFBnMElBSUFOQy8vLy8vdytEUXYvL1xuLy84UGZTSUxRaUNJZlVML0FZTjlRdi8vLy84UGZTSU1RaUNJZlVML0FZTjlRdi8vLy84UGZTSU5RaUNJZlVML0FZTjlJZzVDSUloOVxuUXY4QmczMGlEMElnaUgxQy93R0RmU0lRUWlDSVFnRjlRb0IraEh3aUVVSWdpSDFDL3dHRGZVTC8vLy8vRDMwaUVrSWdpSDFDL3dHRFxuZlVJZ2lLZEIvd0Z4R3lJQlFYOXpJUUlnQUNBQ0lCS25jU0FCSUFxbmNYSTJBaHdnQUNBQ0lCR25jU0FCSUFtbmNYSTJBaGdnQUNBQ1xuSUJDbmNTQUJJQWluY1hJMkFoUWdBQ0FDSUErbmNTQUJJQWVuY1hJMkFoQWdBQ0FDSUE2bmNTQUJJQWFuY1hJMkFnd2dBQ0FDSUEyblxuY1NBQklBV25jWEkyQWdnZ0FDQUNJQXluY1NBQklBU25jWEkyQWdRZ0FDQUNJQXVuY1NBQklBT25jWEkyQWdBTG5RUUJCSDhqQUNJRVxuSUFSQmdCUnJRVUJ4SWdRa0FDQUVRY0FUYWlFR0EwQWdCVUV3VHdSQVFRQkJNU0FGYXlJQklBRkJNVXNiSVFFZ0JTQUdhaUVGQTBBZ1xuQVFSQUlBVkJBRG9BQUNBRlFRRnFJUVVnQVVFQmF5RUJEQUVGQ3dzRklBVWdCbW9nQVNBRmFpZ0NBRFlBQUNBRlFRUnFJUVVNQVFzTFxuSUFSQndBRnFJZ0VnQWhENkFpQUJRVEJ5SUFNUStnSWdCRUdnQW1wQjROakFBQkQ2QWlBRVFkQUNhaUlDSUFFUVNpQUVRZUFEYWlJRlxuSUFJZ0FSQStJQVJCOEFScUlnTWdBaEJLSUFSQmtBZHFJZ0lnQlJCS0lBUkJzQWxxSWdVZ0F4QktJQVJCOEExcUlnWWdBaEJLSUFSQlxuZ0FacUlnY2dBeUFCRUQ0Z0JFR2dDR29pQXlBQ0lBRVFQaUFFUWNBS2FpQUZJQUVRUGlBRVFZQVBhaUFHSUFFUVBpQUVRWkFRYWlJQ1xuSUFNUVNpQUVRZEFMYWlJRElBY1FTaUFFUWFBUmFpQUNJQUVRUGlBRVFlQU1haUFESUFFUVBpQUVRYkFTYWlBRkVFb2dCRUc4QVdvZ1xuQkVHNEFXb2dCQzBBN3hOQkEzWVE0Z0VnQkNBQklBUW9BcmdCRUY5Qit3SWhBd05BSUFOQkFXcEJCVThFUUNBRFFmc0NSd1JBSUFRZ1xuQkVIQUUyb2dBMEVEZG1vdkFBQWdBMEVIY1haQlAzRWdCRUhBQVdvUWR3VUxJQU5CQldzaEF5QUVJQVFRU2lBRUlBUVFTaUFFSUFRUVxuU2lBRUlBUVFTaUFFSUFRUVNnd0JCUXNMSUFRZ0JDMEF3Qk5CQVhSQlBuRWdCRUhBQVdvUWR5QUFJQVFRK2dJZ0FFRXdhaUFFUVRCeVxuRVBvQ0lBQkI0QUJxSUFSQjRBQnFFUG9DSkFBTHl3UUNCMzhGZmlNQVFZQUZheUlDSkFBZ0FrR0FCR29pQkNBQlFRQVFNaUFDUWFnRFxuYWlBRVFTZ1FLUm9nQWtIUUEyb2dBa0dvQkdwQktCQXBHaUFDUVFBMkF2Z0RJQUpCMEFKcUlnVWdBU0FDUWRBRWFpSUVFTjRCSUFKQlxuMEFGcUlBVkJLQkFwR2lBQ1FmZ0JhaUFDUWZnQ2FpSUlRU2dRS1NFRklBSkJvQUpxSUFGQjBBQnFRU2dRS1NFQklBSkJBRFlDeUFJRFxuUUNBRFFjRC9IMFpGQkVBZ0JSQnFJQUFnQTJvaUIwRWdhaUFGRU00QklBSkIwQUZxSWdZZ0JpQUNRYWdEYWlBQ1FZQUJhaUlHRUNRZ1xuQmhCcUlBY2dCaERPQVNBRFFVQnJJUU1NQVFVTEN5QUNRYWdCYWlJRElBRWdCQkFPSUFNZ0F4RHdBU0FDUWRBQ2FpSUZJQUpCMEFGcVxuSUFNUTNnRWdBRUhBL3g5cUlBVVExd0VnQkNBRElBRVFEaUFDUWRnQWFpSUJJQVFRRnlBQklBRWdBa0dBQkdvUURrR0EveDhoQXlBQ1xuS1FONElRa2dBaWtEY0NFS0lBSXBBMmdoQ3lBQ0tRTmdJUXdnQWlrRFdDRU5BMEFnQTBGQVJrVUVRQ0FDUWRBQ2FpSUVJQUFnQTJvaVxuQVJDeEFpQUNRYWdCYWlJRklBVWdCQkFPSUFKQk1Hb2lCaUFGRUJjZ0FrRUlhaUlISUFZZ0JSQU9JQVFnQkNBR0VBNGdBaUFKSUFJcFxuQS9BQ2ZVTDgvLy8vLy8vL0FYdzNBL0FDSUFJZ0NpQUNLUVBvQW4xQy9QLy8vLy8vL3g5OE53UG9BaUFDSUFzZ0Fpa0Q0QUo5UXZ6L1xuLy8vLy8vOGZmRGNENEFJZ0FpQU1JQUlwQTlnQ2ZVTDgvLy8vLy8vL0gzdzNBOWdDSUFJZ0RTQUNLUVBRQW4xQ3ZPSC8vNy8vL3g5OFxuTndQUUFpQUlJQWdnQnhBT0lBRWdCQkRYQVNBRFFVQnFJUU1NQVFVTEN5QUNRWUFGYWlRQUM2b0VBUWgvSXdCQm9BaHJJZ1FrQUNBRVxuUVFwcVFRQkIvZ2Y4Q3dBQ1FBSkFBa0FDUUFKQUlBTkJBM1lpQ0NBRFFRZHhRUUJISWdOcUlnVkJnUWhKQkVBZ0JTQUFLQUlJSWdZZ1xuQUNnQ0FFSFJBR290QUFBaUNtb2lCMEVMYWtrTkFTQUZSUTBDSUFSQkFEb0FDQ0FGUVFGR0RRTWdCU0FIYXlFSklBUkJBVG9BQ1VFQVxuSUFWcklRc2dCeUFJYXlBRGEwRURhaUVJUVFJaEF3SkFBa0FEUUNBRElBaHFRUUpIQkVBZ0F5QUxha1VOQWlBRVFRaHFJQU5xUWY4QlxuT2dBQUlBTkJBV29oQXd3QkJRc0xJQVVnQ1VFQmF5SURTd1JBSUFSQkNHb2dBMnBCQURvQUFDQUZJQWRKRFFjZ0JpQUhUUTBDSUFSQlxuQURZQ21BZ2dCRUVCTmdLTUNDQUVRZWkwd0FBMkFvZ0lJQVJDQkRjQ2tBZ2dCRUdJQ0dwQmlLdkFBQkI3QUFVTElBTWdCVUhvcXNBQVxuRU1NQkFBc2dBeUFGUWJpcndBQVF3d0VBQ3lBRVFRaHFJQWxxSWdNZ0JpQUFLQUlFSUFaQm1LdkFBQkNkQWlBRElBWnFJQW9nQVVFRVxuYWlBQktBSUFRZEVBYWkwQUFFR29xOEFBRUowQ0lBUWdBaUFDS0FJRUlBSW9BZ2hyRU9FQklBUW9BZ0FpQUVVTkJVRUJJUU1nQlNBRVxuS0FJRVJnUkFJQUFnQkVFSWFpQUZFT1lCUVFCSElRTUZDeUFFUWFBSWFpUUFJQU1QQlFzZ0JVR0FDRUg0cWNBQUVPSUNBQXRCaUtyQVxuQUVFdFFiaXF3QUFRN0FFQUMwRUFRUUJCeUtyQUFCRERBUUFMUVFGQkFVSFlxc0FBRU1NQkFBc2dDU0FGUWZpcXdBQVE0UUlBQzBHT1xuME1BQVFTc2dCRUdJQ0dwQmpLakFBRUdFcWNBQUVLOEJBQXYrQXdFTmZ5TUFRYUFGYXlJREpBQWdBVUhnQUdvaUNCRHZBU0VKSUFKQlxuNEFCcUlnb1E3d0VoQ3lBRFFZQURhaUlISUFvUSt3SWdBMEd3QTJvaUJpQUlFUHNDSUFOQjRBTnFJZ1FnQnlBS0VOd0NJQU5Cd0FScVxuSWdVZ0JpQUlFTndDSUFRZ0JDQUJRVEJxSWd3UTNBSWdCU0FGSUFKQk1Hb2lEUkRjQWlBRFFhQUNhaUFGSUFRUWZDQURRWkFFYWlJRVxuSUFFZ0J4RGNBaUFEUWZBRWFpSUZJQUlnQmhEY0FpQURRZEFDYWlBRklBUVFmQUpBSUFRZ0JSRGFBU0FKSUF0eVFYOXpjUVJBSUFOQlxuNEFOcUlBTkJ3QVJxRU5vQkJFQWdBQ0FCRUVvTUFnVUxJQUFRcGdJZ0FFRXdhaENtQWlBQVFlQUFhaENtQWd3QkJRc2dBMEhBQVdvaVxuRGlBRFFhQUNhaUlQRVBzQ0lBTWdBMEhRQW1vaUJTQUlFTndDSUFOQjhBRnFJZ1FnQlJEN0FpQURJQU1nQ2hEY0FpQURRWkFCYWlJSFxuSUFRZ0JSRGNBaUFEUWZBRWFpSUdJQU5Ca0FScUlBUVEzQUlnQkNBR0VPZ0NJQU5CNEFCcUlnVWdEaUFFRUh3Z0JTQUZJQWNRZkNBRFxuUVRCcUlnUWdCaUFGRUh3Z0EwSEFCR29pQmlBRFFlQURhaUFIRU53Q0lBUWdEeUFFRU53Q0lBUWdCQ0FHRUh3Z0JTQUNJQWtRNmdFZ1xuQkNBTklBa1E2Z0VnQXlBS0lBa1E2Z0VnQlNBQklBc1E2Z0VnQkNBTUlBc1E2Z0VnQXlBSUlBc1E2Z0VnQUNBRkVQb0NJQUJCTUdvZ1xuQkJENkFpQUFRZUFBYWlBREVQb0NDeUFEUWFBRmFpUUFDNE1FQVE1L0l3QkI4QWRySWdNa0FDQURJQUVRakFJZ0EwRXdhaUlDSUFNUVxuakFJZ0EwSGdBR29pQmlBQ0lBRVFqUUlnQTBHUUFXb2lCU0FHSUFNUWpRSWdBMEhBQVdvaUJDQUNFSXdDSUFOQjhBRnFJZ2NnQkJDTVxuQWlBRFFhQUNhaUlFSUFjUWpBSWdBMEhRQW1vaUNTQUZJQVFRalFJZ0EwR0FBMm9pQnlBQ0lBa1FqUUlnQTBHd0Eyb2lDQ0FDSUFjUVxualFJZ0EwSGdBMm9pQ2lBRUlBZ1FqUUlnQTBHUUJHb2lBaUFIRUl3Q0lBTkJ3QVJxSWdzZ0JpQUNFSTBDSUFOQjhBUnFJZ0lnQVNBTFxuRUkwQ0lBTkJvQVZxSWd3Z0JTQUNFSTBDSUFOQjBBVnFJZzBnQWlBTUVJMENJQU5CZ0FacUlnNGdCQ0FORUkwQ0lBTkJzQVpxSWdJZ1xuQkNBT0VJMENJQU5CNEFacUlnOGdBa0VJSUFJUWpnSWdBMEdRQjJvaUJDQVBRUkFnRHhDT0FpQURRY0FIYWlJQ0lBUkJ3QUFnQkJDT1xuQWlBQ1FTQWdCQkRGQWlBQ1FRWWdDQkRGQWlBQ1FRVWdCUkRGQWlBQ1FRb2dEaERGQWlBQ1FRUWdCaERGQWlBQ1FRZ2dDeERGQWlBQ1xuUVFjZ0NSREZBaUFDUVFrZ0NCREZBaUFDUVFVZ0JSREZBaUFDUVFNZ0JoREZBaUFDUVFzZ0NoREZBaUFDUVFVZ0JSREZBaUFDUVFRZ1xuQlJERkFpQUNRUVVnQlJERkFpQUNRUWdnQnhERkFpQUNRUXdnRFJERkFpQUNRUW9nREJERkFpQUNRUU1nQVJERkFpQUNRUVVnQmhERlxuQWlBQ1FRZ2dDaERGQWlBQUlBSkJNUHdLQUFBZ0EwSHdCMm9rQUF2OUF3RUNmeUFBSUFGcUlRSUNRQUpBSUFBb0FnUWlBMEVCY1EwQVxuSUFOQkFuRkZEUUVnQUNnQ0FDSURJQUZxSVFFZ0FDQURheUlBUVpqNHdBQW9BZ0JHQkVBZ0FpZ0NCRUVEY1VFRFJ3MEJRWkQ0d0FBZ1xuQVRZQ0FDQUNJQUlvQWdSQmZuRTJBZ1FnQUNBQlFRRnlOZ0lFSUFJZ0FUWUNBQXdDQlFzZ0FDQURFRThMQWtBQ1FBSkFJQUlvQWdRaVxuQTBFQ2NVVUVRQ0FDUVp6NHdBQW9BZ0JHRFFJZ0FrR1krTUFBS0FJQVJnMERJQUlnQTBGNGNTSUNFRThnQUNBQklBSnFJZ0ZCQVhJMlxuQWdRZ0FDQUJhaUFCTmdJQUlBQkJtUGpBQUNnQ0FFY05BVUdRK01BQUlBRTJBZ0FQQlFzZ0FpQURRWDV4TmdJRUlBQWdBVUVCY2pZQ1xuQkNBQUlBRnFJQUUyQWdBTElBRkJnQUpQQkVBZ0FDQUJFRlVQQlFzZ0FVSDRBWEZCZ1BiQUFHb2hBZ0ovUVlqNHdBQW9BZ0FpQTBFQlxuSUFGQkEzWjBJZ0Z4UlFSQVFZajR3QUFnQVNBRGNqWUNBQ0FDREFFRkN5QUNLQUlJQ3lFQklBSWdBRFlDQ0NBQklBQTJBZ3dnQUNBQ1xuTmdJTUlBQWdBVFlDQ0E4TFFaejR3QUFnQURZQ0FFR1UrTUFBUVpUNHdBQW9BZ0FnQVdvaUFUWUNBQ0FBSUFGQkFYSTJBZ1FnQUVHWVxuK01BQUtBSUFSdzBCUVpENHdBQkJBRFlDQUVHWStNQUFRUUEyQWdBUEMwR1krTUFBSUFBMkFnQkJrUGpBQUVHUStNQUFLQUlBSUFGcVxuSWdFMkFnQWdBQ0FCUVFGeU5nSUVJQUFnQVdvZ0FUWUNBQXNMeWdNQ0FYOEtmaUFBS1FNWUlRUWdBQ2tERUNFRklBQXBBd2doQmlBQVxuS1FNQUlRY2pBRUVRYXlJRElBQXBBeUFpQ0VJL2h6Y0RDQ0FES1FNSUlRa2dBeWtEQ0NFS0lBTXBBd2doQ3lBREtRTUlJUXdnQXlrRFxuQ0NFTklBTWdBVUkvaHpjREFDQURJQU1wQXdBZ0NDQUNLUU1nSWdFZ0RZTjhoU0FES1FNQWZTQURLUU1BSUFRZ0Fpa0RHQ0lJSUF5RFxuZklVZ0F5a0RBSDBnQXlrREFDQUZJQUlwQXhBaUJDQUxnM3lGSUFNcEF3QjlJQU1wQXdBZ0JpQUNLUU1JSWdVZ0NvTjhoU0FES1FNQVxuZlNBREtRTUFJQWNnQWlrREFDSUdJQW1EZklVZ0F5a0RBSDBpQjBJK2gzd2lDVUkraDN3aUNrSStoM3dpQzBJK2gzd2lERUkvaHpjRFxuQ0NBQUlBWWdBeWtEQ0lNZ0IwTC8vLy8vLy8vLy96K0RmQ0lHUXYvLy8vLy8vLy8vUDRNM0F3QWdBQ0FGSUFNcEF3aURJQWxDLy8vL1xuLy8vLy8vOC9nM3dnQmtJK2gzd2lCVUwvLy8vLy8vLy8veitETndNSUlBQWdCQ0FES1FNSWd5QUtRdi8vLy8vLy8vLy9QNE44SUFWQ1xuUG9kOElnUkMvLy8vLy8vLy8vOC9nemNERUNBQUlBZ2dBeWtEQ0lNZ0MwTC8vLy8vLy8vLy96K0RmQ0FFUWo2SGZDSUVRdi8vLy8vL1xuLy8vL1A0TTNBeGdnQUNBQklBTXBBd2lESUF4OElBUkNQb2Q4TndNZ0M3a0RBUUYrSUFBZ0FTa0FHQ0lEUWppR0lBTkNLSVpDZ0lDQVxuZ0lDQXdQOEFnNFFnQTBJWWhrS0FnSUNBZ09BL2d5QURRZ2lHUW9DQWdJRHdINE9FaENBRFFnaUlRb0NBZ1BnUGd5QURRaGlJUW9DQVxuL0FlRGhDQURRaWlJUW9EK0E0TWdBMEk0aUlTRWhEY0RBQ0FBSUFFcEFCQWlBMEk0aGlBRFFpaUdRb0NBZ0lDQWdNRC9BSU9FSUFOQ1xuR0laQ2dJQ0FnSURnUDRNZ0EwSUloa0tBZ0lDQThCK0RoSVFnQTBJSWlFS0FnSUQ0RDRNZ0EwSVlpRUtBZ1B3SGc0UWdBMElvaUVLQVxuL2dPRElBTkNPSWlFaElRM0F3Z2dBQ0FCS1FBSUlnTkNPSVlnQTBJb2hrS0FnSUNBZ0lEQS93Q0RoQ0FEUWhpR1FvQ0FnSUNBNEQrRFxuSUFOQ0NJWkNnSUNBZ1BBZmc0U0VJQU5DQ0loQ2dJQ0ErQStESUFOQ0dJaENnSUQ4QjRPRUlBTkNLSWhDZ1A0RGd5QURRamlJaElTRVxuTndNUUlBQWdBU2tBQUNJRFFqaUdJQU5DS0laQ2dJQ0FnSUNBd1A4QWc0UWdBMElZaGtLQWdJQ0FnT0EvZ3lBRFFnaUdRb0NBZ0lEd1xuSDRPRWhDQURRZ2lJUW9DQWdQZ1BneUFEUWhpSVFvQ0EvQWVEaENBRFFpaUlRb0QrQTRNZ0EwSTRpSVNFaERjREdDQUFJQUFRMHdFUVxubmdFaEFDQUNCRUFnQWlBQU5nSUFCUXNMaWdNQkJIOENRQ0FCUVJCSkJFQWdBQ0VDREFFRkN3SkFJQUFnQUVFQUlBQnJRUU54SWdScVxuSWdOUERRQWdBQ0VDSUFRRVFDQUVJUVVEUUNBQ1FRQTZBQUFnQWtFQmFpRUNJQVZCQVdzaUJRMEFDd1VMSUFSQkFXdEJCMGtOQUFOQVxuSUFKQkFEb0FBQ0FDUVFkcVFRQTZBQUFnQWtFR2FrRUFPZ0FBSUFKQkJXcEJBRG9BQUNBQ1FRUnFRUUE2QUFBZ0FrRURha0VBT2dBQVxuSUFKQkFtcEJBRG9BQUNBQ1FRRnFRUUE2QUFBZ0FrRUlhaUlDSUFOSERRQUxDeUFESUFFZ0JHc2lBVUY4Y1dvaUFpQURTd1JBQTBBZ1xuQTBFQU5nSUFJQU5CQkdvaUF5QUNTUTBBQ3dVTElBRkJBM0VoQVFzQ1FDQUNJQUVnQW1vaUJFOE5BQ0FCUVFkeElnTUVRQU5BSUFKQlxuQURvQUFDQUNRUUZxSVFJZ0EwRUJheUlERFFBTEJRc2dBVUVCYTBFSFNRMEFBMEFnQWtFQU9nQUFJQUpCQjJwQkFEb0FBQ0FDUVFacVxuUVFBNkFBQWdBa0VGYWtFQU9nQUFJQUpCQkdwQkFEb0FBQ0FDUVFOcVFRQTZBQUFnQWtFQ2FrRUFPZ0FBSUFKQkFXcEJBRG9BQUNBQ1xuUVFocUlnSWdCRWNOQUFzTElBQUxxd01BSUFBZ0FTa0RJRUlvaUR3QUFDQUFJQUZCSkdvMUFnQThBQUVnQUNBQktRTWdRaGlJUEFBQ1xuSUFBZ0FTa0RJRUlRaUR3QUF5QUFJQUVwQXlCQ0NJZzhBQVFnQUNBQktRTWdQQUFGSUFBZ0FTa0RHRUlzaUR3QUJpQUFJQUVwQXhoQ1xuSklnOEFBY2dBQ0FCS1FNWVFoeUlQQUFJSUFBZ0FTa0RHRUlVaUR3QUNTQUFJQUVwQXhoQ0RJZzhBQW9nQUNBQktRTVlRZ1NJUEFBTFxuSUFBZ0FVRVdhak1CQUVJUGd5QUJLUU1ZUWdTR2hEd0FEQ0FBSUFFcEF4QkNLSWc4QUEwZ0FDQUJRUlJxTlFJQVBBQU9JQUFnQVNrRFxuRUVJWWlEd0FEeUFBSUFFcEF4QkNFSWc4QUJBZ0FDQUJLUU1RUWdpSVBBQVJJQUFnQVNrREVEd0FFaUFBSUFFcEF3aENMSWc4QUJNZ1xuQUNBQktRTUlRaVNJUEFBVUlBQWdBU2tEQ0VJY2lEd0FGU0FBSUFFcEF3aENGSWc4QUJZZ0FDQUJLUU1JUWd5SVBBQVhJQUFnQVNrRFxuQ0VJRWlEd0FHQ0FBSUFFekFRWkNENE1nQVNrRENFSUVob1E4QUJrZ0FDQUJLUU1BUWlpSVBBQWFJQUFnQVRVQ0JEd0FHeUFBSUFFcFxuQXdCQ0dJZzhBQndnQUNBQktRTUFRaENJUEFBZElBQWdBU2tEQUVJSWlEd0FIaUFBSUFFcEF3QThBQjhML2dJQkJYNGdBQ0FCTVFBZlxuSUFFeEFCNUNDSWFFSUFFeEFCMUNFSWFFSUFFeEFCeENHSWFFSUFFeEFCdENJSWFFSUFFeEFCcENLSWFFSUFFeEFCbENENE5DTUlhRVxuSWdJM0F3QWdBQ0FCTFFBWlFRUjJyU0FCTVFBWVFnU0doQ0FCTVFBWFFneUdoQ0FCTVFBV1FoU0doQ0FCTVFBVlFoeUdoQ0FCTVFBVVxuUWlTR2hDQUJNUUFUUWl5R2hDSUROd01JSUFBZ0FURUFFaUFCTVFBUlFnaUdoQ0FCTVFBUVFoQ0doQ0FCTVFBUFFoaUdoQ0FCTVFBT1xuUWlDR2hDQUJNUUFOUWlpR2hDQUJNUUFNUWcrRFFqQ0doQ0lFTndNUUlBQWdBUzBBREVFRWRxMGdBVEVBQzBJRWhvUWdBVEVBQ2tJTVxuaG9RZ0FURUFDVUlVaG9RZ0FURUFDRUljaG9RZ0FURUFCMElraG9RZ0FURUFCa0lzaG9RaUJUY0RHQ0FBSUFFeEFBVWdBVEVBQkVJSVxuaG9RZ0FURUFBMElRaG9RZ0FURUFBa0lZaG9RZ0FURUFBVUlnaG9RZ0FURUFBRUlvaG9RaUJqY0RJQ0FESUFTRElBV0RRdi8vLy8vL1xuLy84SFVpQUdRdi8vLy8vLy96OVNjaUFDUXEvNC8vL3YvLzhIVkhJTGdRTUJDWDRnQUVGL1FRQWdBVFVDSENBQ05RSWNRZ0FnQVRVQ1xuR0NBQ05RSVlRZ0FnQVRVQ0ZDQUNOUUlVUWdBZ0FUVUNFQ0FDTlFJUVFnQWdBVFVDRENBQ05RSU1RZ0FnQVRVQ0NDQUNOUUlJUWdBZ1xuQVRVQ0JDQUNOUUlFUWdBZ0FUVUNBQ0FDTlFJQWZTSUVRaUNJZlVML0FZTjhmU0lGUWlDSWZVTC9BWU44ZlNJR1FpQ0lmVUwvQVlOOFxuZlNJSFFpQ0lmVUwvQVlOOGZTSUlRaUNJZlVML0FZTjhmU0lKUWlDSWZVTC9BWU44ZlNJS1FpQ0lmVUwvQVlOOGZTSUxRb0NBZ0lEd1xuSDROQ0FGSWJJZ0d0SWdNZ0JFTC8vLy8vRDROOElnUStBZ0FnQUNBRlF2Ly8vLzhQZ3lBRGZDQUVRaUNJZkNJRVBnSUVJQUFnQmtML1xuLy8vL0Q0TWdBM3dnQkVJZ2lId2lBejRDQ0NBQUlBZEMvLy8vL3crRElBTkNJSWg4SWdNK0Fnd2dBQ0FJUXYvLy8vOFBneUFEUWlDSVxuZkNJRFBnSVFJQUFnQ1VMLy8vLy9ENE1nQTBJZ2lId2lBejRDRkNBQUlBRkJBWEd0SUFwQy8vLy8vdytEZkNBRFFpQ0lmQ0lEUGdJWVxuSUFBZ0FTQURRaUNJSUF0OHAybzJBaHdMNlFJQkJYOENRQ0FCUWMzL2V5QUFRUkFnQUVFUVN4c2lBR3RQRFFBZ0FFRVFJQUZCQzJwQlxuZUhFZ0FVRUxTUnNpQkdwQkRHb1FDQ0lDUlEwQUlBSkJDR3NoQVFKQUlBQkJBV3NpQXlBQ2NVVUVRQ0FCSVFBTUFRVUxJQUpCQkdzaVxuQlNnQ0FDSUdRWGh4SUFJZ0EycEJBQ0FBYTNGQkNHc2lBa0VBSUFBZ0FpQUJhMEVRU3h0cUlnQWdBV3NpQW1zaEF5QUdRUU54QkVBZ1xuQUNBRElBQW9BZ1JCQVhGeVFRSnlOZ0lFSUFBZ0Eyb2lBeUFES0FJRVFRRnlOZ0lFSUFVZ0FpQUZLQUlBUVFGeGNrRUNjallDQUNBQlxuSUFKcUlnTWdBeWdDQkVFQmNqWUNCQ0FCSUFJUVFBd0JCUXNnQVNnQ0FDRUJJQUFnQXpZQ0JDQUFJQUVnQW1vMkFnQUxBa0FnQUNnQ1xuQkNJQlFRTnhSUTBBSUFGQmVIRWlBaUFFUVJCcVRRMEFJQUFnQkNBQlFRRnhja0VDY2pZQ0JDQUFJQVJxSWdFZ0FpQUVheUlFUVFOeVxuTmdJRUlBQWdBbW9pQWlBQ0tBSUVRUUZ5TmdJRUlBRWdCQkJBQ3lBQVFRaHFJUU1MSUFNTG93TUJCSDhqQUVHd0Eyc2lBeVFBSUFNZ1xuQWtFQklBSVFzQUVnQTBFd2FpSUVJQU5CQVNBQ0VMQUJJQU5CNEFCcUlnSWdCRUVESUFRUXNBRWdBMEdRQVdvaUJpQUNRUVlnQWhDd1xuQVNBRFFjQUJhaUlGSUFaQkF5QUVFTEFCUVE4aEFpQURRZkFCYWlJRUlBVkJEeUFGRUxBQklBTkJvQUpxSWdVZ0JFRWVJQVFRc0FFZ1xuQTBIUUFtb2lCQ0FGUVR3Z0JSQ3dBU0FEUVlBRGFpQUVRZmdBSUFRUXNBRURRQ0FDQkVBZ0FrRUJheUVDSUFOQmdBTnFJZ1FnQkJEMFxuQWd3QkJRc0xJQU5CZ0FOcUlnSWdBaUFEUWNBQmFoRDVBa0VmSVFJRFFDQUNCRUFnQWtFQmF5RUNJQU5CZ0FOcUlnUWdCQkQwQWd3QlxuQlFzTElBTkJnQU5xSWdJZ0FpQURRZkFCYWhENUFrRUNJUUlEUUNBQ0JFQWdBa0VCYXlFQ0lBTkJnQU5xSWdRZ0JCRDBBZ3dCQlFzTFxuSUFOQmdBTnFJZ0lnQWlBREVQa0NRZDRBSVFJRFFDQUNCRUFnQWtFQmF5RUNJQU5CZ0FOcUlnUWdCQkQwQWd3QkJRc0xJQU5CZ0FOcVxuSWdJZ0FpQURRZkFCYWhENUFpQUNJQUlnQVNnQ0JDSUJLQUlFRVFRQUlBSWdBaUFCS0FJRUVRUUFJQUFnQWtFdy9Bb0FBQ0FEUWJBRFxuYWlRQUM2NERBUUYvSXdCQjhBQnJJZ3NrQUNBTFFTaHFJQUVnQWhEb0FTQUxJQXNvQWl3aUFUWUNQQ0FMSUFzb0FpZ2lBallDT0NBTFxuSUFFMkFqUWdDMEZBYXlBRElBUVEyd0VnQzBFZ2FpQUZJQVlRNkFFZ0N5Z0NKQ0VESUFzb0FpQWhCQ0FMUVJocUlBY2dDQkRvQVNBTFxuS0FJY0lRVWdDeWdDR0NFR0lBdEJFR29nQ1NBS0VPZ0JJQXNvQWhRaENDQUxLQUlRSVFrZ0MwSGtBR29nQWlBQlFRQWdDeWdDUkNBTFxuS0FKQVFZQ0FnSUI0UmhzZ0N5Z0NTQkFqQWtBQ1FDQUxLQUprUVFWR0JFQWdDeWdDYkNFQ0lBc29BbWdoQnd3QkJRc2dDMEhZQUdvZ1xuQzBIa0FHb1FXeUFMS0FKZ0lRSWdDeWdDWENFSElBc29BbGdpQVVHQWdJQ0FlRVlOQUNBTElBSTJBbFFnQ3lBSE5nSlFJQXNnQVRZQ1xuVEF3QkN5QUhJQWtnQ0NBR0lBVWdCQ0FESUFJb0FoQVJEZ0FFUUNBTFFjd0Fha0d3bWNBQUVGc01BUVVMSUF0QmdJQ0FnSGcyQWt3TFxuSUF0QlFHc1F5d0lnQzBFMGFoRGpBaUFKSUFnUTN3SWdCaUFGRU44Q0lBUWdBeERmQWlBTFFRaHFJQXRCekFCcUVJWUNJQXNvQWd3aFxuQVNBQUlBc29BZ2dpQWpZQ0JDQUFJQUZCQUNBQ1FRRnhHellDQUNBTFFmQUFhaVFBQzQ0REFnbC9BWDRqQUVIQUFXc2lCaVFBSUFaQlxuNEFCcUlnUWdBVUV3YWlJQ0VPZ0NJQVlnQVVIZ0FHb2lCUkQ3QWlBRUlBUVErd0lnQUVIZ0FHb2lBeUFGSUFJUTNBSWdBeUFERU9nQ1xuSUFaQk1Hb2lCU0FCSUFZUTNnSWdCaUFCSUFZUWZDQUFRVEJxSWdNZ0JCRDdBaU1BUVRCcklnY2tBQ0FES0FJQUlRa2dBeUFES0FJc1xuSWdKQkFYWTJBaXdnQWtFQmNTRUlRU2doQWdOQUlBSkJmRVlFUUNBSElBTTFBZ0JDZ0lDQWdBaDhJZ3MrQWdCQkJDRUNBMEFnQWtFd1xuUndSQUlBSWdCMm9nQWtHZzJNQUFhalVDQUNBQ0lBTnFOUUlBSUF0Q0lJaDhmQ0lMUGdJQUlBSkJCR29oQWd3QkJRc0xJQU1nQjBFQVxuSUFsQkFYRnJFT29CSUFkQk1Hb2tBQVVnQWlBRGFpSUtJQWhCSDNRZ0NpZ0NBQ0lJUVFGMmNqWUNBQ0FDUVFScklRSU1BUXNMSUFVZ1xuQlNBR0VOd0NJQVpCa0FGcUlnSWdCU0FGRU40Q0lBVWdBaUFGRU40Q0lBUWdCQ0FCRU53Q0lBSWdCQkRvQWlBQUlBVVErd0lnQUNBQVxuSUFJUWZDQUVJQVFnQUJCOElBUWdCQ0FGRU53Q0lBTWdCQ0FERUh3Z0JrSEFBV29rQUF2M0FnRUVmeU1BUVVCcUlnTWtBQ0FEUVFBMlxuQWp3Z0EwRW9ha0lBTndNQUlBTkJJR3BDQURjREFDQURRZ0EzQXhnZ0EwSUFOd01RQWtBZ0FTZ0NBQ0lFSUFKR0RRQWdCQzBBQUVFQ1xuUncwQUlBRWdCRUVCYWpZQ0FDQURRUXhxSUFFZ0FoQ0NBVVVOQUNBREtBSU1JZ1JGRFFBZ0FTZ0NBQ0lGSUFScUlBSkxEUUFDUUFKQVxuSUFVc0FBQWlBaUFFUVFKSmNrVUVRQ0FGTEFBQlFRQk9EUU5CQVNFR0RBRUZDd0ovQWtBZ0FrRi9SeUFFUVFKSmNrVUVRQ0FGTEFBQlxuUVFCT0RRRU1CUVVMUVFFZ0FrRUFUZzBCR2dzZ0EwRUJOZ0k4SUFVdEFBQWhBa0VBQ3lFR0lBSkIvd0Z4RFFFTElBRWdCVUVCYWlJRlxuTmdJQUlBUkJBV3NoQkFzQ1FDQUdSU0FFUVNCTGNrVUVRQ0FESUFSclFUQnFJQVVnQkJBcEdpQUFJQU5CRUdvZ0EwRThhaEJDSUFNb1xuQWp4RkRRRUZDeUFBUWdBM0F3QWdBRUVZYWtJQU53TUFJQUJCRUdwQ0FEY0RBQ0FBUVFocVFnQTNBd0FMSUFFZ0FTZ0NBQ0FFYWpZQ1xuQUVFQklRWUxJQU5CUUdza0FDQUdDNGdEQVFOL0l3QkIwQVZySWdNa0FBTkFJQUpCZ0FOR1JRUkFJQUlnQTJwQkFFRXcvQXNBSUFKQlxuTUdvaEFnd0JCUXNMSUFNZ0FVRXcvQW9BQUNBRFFZQURhaUFERUk4Q1FRQWhBZ05BSUFKQjBBSkdSUVJBSUFOQm9BVnFJZ1FnQWlBRFxuYWlJQklBTkJnQU5xRUpBQ0lBRkJNR29nQkVFdy9Bb0FBQ0FDUVRCcUlRSU1BUVVMQ3lBRFFiQURhaUlDSUFOQjBBSnFJZ0ZCQkNBQlxuRU9rQklBTkI0QU5xSWdRZ0FrRUlJQUlRNlFFZ0EwR1FCR29pQVNBRVFSQWdCQkRwQVNBRFFjQUVhaUlFSUFGQklDQUJFT2tCSUFOQlxuOEFScUlnSWdCRUVnSUFFUTZRRWdBMEdnQldvZ0FrSGdBQ0FDRU9rQlFRQWhBZ05BQWtBQ1FDQUNRYzRBUndSQUlBSkJ4Y3ZBQUdvdFxuQUFBaUJFRUhTdzBDSUFKQkFtb2hBU0FDUWNUTHdBQnFMUUFBSVFJRFFDQUNSUTBDSUFKQkFXc2hBaUFEUWFBRmFoRDNBZ3dBQ3dBRlxuQ3lBQUlBTkJvQVZxUVREOENnQUFJQU5CMEFWcUpBQVBDeUFEUWFBRmFpSUNJQUlnQXlBRVFUQnNhaERkQWlBQklRSU1BUXNMSUFSQlxuQ0VHMHk4QUFFTU1CQUF2WEFnSUxmd0YrSXdCQklHc2lBeVFBSUFCQmhBUVFReUVKSUFOQkdHb2dBVUVZYWlrREFDSU9Od01BSUFOQlxuRUdvZ0FVRVFhaWtEQURjREFDQURRUWhxSUFGQkNHb3BBd0EzQXdBZ0F5QUJLUU1BTndNQVFRRWhCaUFPUWdCVEJFQWdBeUFERUpFQlxuUVg4aEJnVUxJQUpCQVdzaENrRi9JUVVEUUVHQkFTQUVheUVBSUFrZ0JFRUNkR29oQ0NBRUlRRUNRQU5BSUFGQmdBRktEUUVnQnlBRFxuSUFGQkJuWWlDMEVEZENJTWFpa0RBQ0FCUVQ5eElnMnRpQ0lPcDBFQmNVWUVRQ0FJUVFScUlRZ2dBRUVCYXlFQUlBRkJBV29oQVF3QlxuQlFzTElBZ2dCeUFMSUFJZ0FDQUFJQUpLR3lBQmFpSUVRUUZyUVFaMlJ3UitJQU1nREdwQkNHb3BBd0JCd0FBZ0RXdXRoaUFPaEFVZ1xuRGd0Q2YwR0JBU0FCYXlJRklBSWdBaUFGU2h1dGhrSi9oWU9uYWlJQUlBQWdDblpCQVhFaUJ5QUNkR3NnQm13MkFnQWdBU0VGREFFTFxuQ3lBRFFTQnFKQUFnQlVFQmFndU5Bd0FnQUNBQlFSOXFNUUFBUEFBQUlBQWdBVUVlYWpNQkFEd0FBU0FBSUFFcEF4aENLSWc4QUFJZ1xuQUNBQlFSeHFOUUlBUEFBRElBQWdBU2tER0VJWWlEd0FCQ0FBSUFFcEF4aENFSWc4QUFVZ0FDQUJLUU1ZUWdpSVBBQUdJQUFnQVNrRFxuR0R3QUJ5QUFJQUZCRjJveEFBQThBQWdnQUNBQlFSWnFNd0VBUEFBSklBQWdBU2tERUVJb2lEd0FDaUFBSUFGQkZHbzFBZ0E4QUFzZ1xuQUNBQktRTVFRaGlJUEFBTUlBQWdBU2tERUVJUWlEd0FEU0FBSUFFcEF4QkNDSWc4QUE0Z0FDQUJLUU1RUEFBUElBQWdBVUVQYWpFQVxuQUR3QUVDQUFJQUZCRG1vekFRQThBQkVnQUNBQktRTUlRaWlJUEFBU0lBQWdBVUVNYWpVQ0FEd0FFeUFBSUFFcEF3aENHSWc4QUJRZ1xuQUNBQktRTUlRaENJUEFBVklBQWdBU2tEQ0VJSWlEd0FGaUFBSUFFcEF3ZzhBQmNnQUNBQk1RQUhQQUFZSUFBZ0FUTUJCandBR1NBQVxuSUFFcEF3QkNLSWc4QUJvZ0FDQUJOUUlFUEFBYklBQWdBU2tEQUVJWWlEd0FIQ0FBSUFFcEF3QkNFSWc4QUIwZ0FDQUJLUU1BUWdpSVxuUEFBZUlBQWdBU2tEQUR3QUh3dUhBd0VFZnlBQUtBSU1JUUlDUUFKQUFrQWdBVUdBQWs4RVFDQUFLQUlZSVFNQ1FBSkFJQUFnQWtZRVxuUUNBQVFSUkJFQ0FBS0FJVUlnSWJhaWdDQUNJQkRRRkJBQ0VDREFJRkN5QUFLQUlJSWdFZ0FqWUNEQ0FDSUFFMkFnZ01BUXNnQUVFVVxuYWlBQVFSQnFJQUliSVFRRFFDQUVJUVVnQVNJQ1FSUnFJQUpCRUdvZ0FpZ0NGQ0lCR3lFRUlBSkJGRUVRSUFFYmFpZ0NBQ0lCRFFBTFxuSUFWQkFEWUNBQXNnQTBVTkFnSkFJQUFvQWh4QkFuUkI4UFRBQUdvaUFTZ0NBQ0FBUndSQUlBTW9BaEFnQUVZTkFTQURJQUkyQWhRZ1xuQWcwRERBUUZDeUFCSUFJMkFnQWdBa1VOQkF3Q0N5QURJQUkyQWhBZ0FnMEJEQUlGQ3lBQUtBSUlJZ0FnQWtjRVFDQUFJQUkyQWd3Z1xuQWlBQU5nSUlEd1VMUVlqNHdBQkJpUGpBQUNnQ0FFRitJQUZCQTNaM2NUWUNBQThMSUFJZ0F6WUNHQ0FBS0FJUUlnRUVRQ0FDSUFFMlxuQWhBZ0FTQUNOZ0lZQlFzZ0FDZ0NGQ0lBUlEwQUlBSWdBRFlDRkNBQUlBSTJBaGdQQ3c4TFFZejR3QUJCalBqQUFDZ0NBRUYrSUFBb1xuQWh4M2NUWUNBQXVNQXdJRWZ3RitJd0JCd0FGcklnUWtBQ0FFUVFocUlBRVEvUUVnQkNnQ0RDRUJJQVFvQWdnaEJTQUVJQUlnQXhEb1xuQVNBRVFZQUJhaUFFS0FJQUlnSWdCQ2dDQkNJR0VHWkJBU0VEQWtBZ0JDMEFnQUZCQVVZRVFDQUVRUnhxSUFSQmpBRnFLQUlBTmdJQVxuSUFRZ0JDa0NoQUUzQWhRTUFRVUxJQVJCMkFCcUlBUkJtUUZxS1FBQUlnZzNBd0FnQkVFb2FpQUVRWWtCYWlrQUFEY0RBQ0FFUVRCcVxuSUFSQmtRRnFLUUFBTndNQUlBUkJPR29nQ0RjREFDQUVJQVFwQUlFQk53TWdRUUFoQXlBRVFZQUJha0VBUWNBQS9Bc0FJQVVvQWdBZ1xuQkVHQUFXb2lCU0FFUVNCcUVIOGFJQVJCUUdzaUJ5QUZRY0FBL0FvQUFDQUZJQWNRaHdFZ0JFRVVhaUFGUVNFUXRRRUxJQVFnQXpZQ1xuRUNBQ0lBWVEzd0lnQVNBQktBSUFRUUZyTmdJQUlBUkJnQUZxSUFSQkVHb1FvZ0VnQkNnQ2hBRWhBU0FBQW44Z0JDZ0NnQUVFUUVFQVxuSVFKQkFDRUZRUUVNQVFVTElBUW9Bb2dCSVFVZ0FTRUNRUUFoQVVFQUN6WUNEQ0FBSUFFMkFnZ2dBQ0FGTmdJRUlBQWdBallDQUNBRVxuUWNBQmFpUUFDK2tDQVFoL0l3QkJFR3NpQlNRQVFRb2hBaUFBSWdOQjZBZFBCRUFnQUNFRUEwQWdCVUVHYWlBQ2FpSUdRUU5ySUFRZ1xuQkVHUXpnQnVJZ05Ca000QWJHc2lCMEgvL3dOeFFlUUFiaUlJUVFGMElnbEJrWTNBQUdvdEFBQTZBQUFnQmtFRWF5QUpRWkNOd0FCcVxuTFFBQU9nQUFJQVpCQVdzZ0J5QUlRZVFBYkd0Qi8vOERjVUVCZENJSFFaR053QUJxTFFBQU9nQUFJQVpCQW1zZ0IwR1FqY0FBYWkwQVxuQURvQUFDQUNRUVJySVFJZ0JFSC9yT0lFU3lBRElRUU5BQXNGQ3dKQUlBTkJDVTBFUUNBRElRUU1BUVVMSUFJZ0JXcEJCV29nQXlBRFxuUWYvL0EzRkI1QUJ1SWdSQjVBQnNhMEgvL3dOeFFRRjBJZ05Ca1kzQUFHb3RBQUE2QUFBZ0FrRUNheUlDSUFWQkJtcHFJQU5Ca0kzQVxuQUdvdEFBQTZBQUFMUVFBZ0FDQUVHMFVFUUNBQ1FRRnJJZ0lnQlVFR2Ftb2dCRUVCZEVFZWNVR1JqY0FBYWkwQUFEb0FBQVVMSUFGQlxuQVVFQlFRQWdCVUVHYWlBQ2FrRUtJQUpyRURjZ0JVRVFhaVFBQzlJQ0FRTi9Jd0JCRUdzaUFpUUFBa0FnQVVHQUFVOEVRQ0FDUVFBMlxuQWd3Q2Z5QUJRWUFRVHdSQUlBRkJnSUFFVHdSQUlBSkJER3BCQTNJaEJDQUNJQUZCRW5aQjhBRnlPZ0FNSUFJZ0FVRUdka0UvY1VHQVxuQVhJNkFBNGdBaUFCUVF4MlFUOXhRWUFCY2pvQURVRUVEQUlGQ3lBQ1FReHFRUUp5SVFRZ0FpQUJRUXgyUWVBQmNqb0FEQ0FDSUFGQlxuQm5aQlAzRkJnQUZ5T2dBTlFRTU1BUVVMSUFKQkRHcEJBWEloQkNBQ0lBRkJCblpCd0FGeU9nQU1RUUlMSVFNZ0JDQUJRVDl4UVlBQlxuY2pvQUFDQUFLQUlBSUFBb0FnZ2lBV3NnQTBrRVFDQUFJQUVnQXhDRUFTQUFLQUlJSVFFRkN5QURCRUFnQUNnQ0JDQUJhaUFDUVF4cVxuSUFQOENnQUFCUXNnQUNBQklBTnFOZ0lJREFFRkN5QUFLQUlJSWdNZ0FDZ0NBRVlFUUNBQVFiU0t3QUFRbGdFRkN5QUFJQU5CQVdvMlxuQWdnZ0FDZ0NCQ0FEYWlBQk9nQUFDeUFDUVJCcUpBQkJBQXZ0QWdFSGZ5TUFRU0JySWdJa0FDQUFLQUlBSWdSQkJHb29BZ0FoQUNBRVxuS0FJQUlRVkJBQ0VFSUFFb0FnQkJ4WXJBQUVFQklBRW9BZ1FvQWd3UkJ3QWhBd05BSUFRaEJ3SkFBa0FnQUFSQVFRRWhCQ0FEUVFGeFxuUVFFaEF3MENJQUV0QUFwQmdBRnhSUVJBSUFkQkFYRkZEUUlnQVNnQ0FFSC9qTUFBUVFJZ0FTZ0NCQ2dDREJFSEFFVU5BZ3dEQlFzZ1xuQVNnQ0JDRUdJQUVvQWdBaENDQUhRUUZ4UlFSQUlBaEJqSTNBQUVFQklBWW9BZ3dSQndBTkF3VUxJQUpCQVRvQUR5QUNJQVkyQWdRZ1xuQWlBSU5nSUFJQUpCNEl6QUFEWUNGQ0FDSUFFcEFnZzNBaGdnQWlBQ1FROXFOZ0lJSUFJZ0FqWUNFQ0FGSUFKQkVHb1FaUVJBREFNRlxuQ3lBQ0tBSVFRWVNOd0FCQkFpQUNLQUlVS0FJTUVRY0FJUU1NQWdVTFFRRWhBQ0FEUVFGeFJRUkFJQUVvQWdCQmpZM0FBRUVCSUFFb1xuQWdRb0Fnd1JCd0FoQUFVTElBSkJJR29rQUNBQUR3c2dCU0FCRUdVaEF3c2dCVUVCYWlFRklBQkJBV3NoQUF3QUN3QUx6d0lCQm44alxuQUVFUWF5SUVKQUFnQVNnQ0RDRUdJQUVvQWdBaEJRSkFBa0FDUUFKQUFrQUNRQUpBQW44Q1FBSkFJQUVvQWdRaUJ3NENBQUVEQ3lBR1xuUlFSQVFRRWhBMEVBREFJRkN3d0RDeUFHRFFFZ0JTZ0NBQ0VESUFVb0FnUUxJUUlnQUNBRElBSVF0UUVNQlFzZ0JVRUVhaUVEQTBBZ1xuQXlnQ0FDQUNhaUVDSUFOQkNHb2hBeUFIUVFGcklnY05BQXNnQmtVTkFTQUNRUTlMRFFBZ0JTZ0NCRVVOQWdzZ0FrRUFJQUpCQUVvYlxuUVFGMElRSUxBa0FnQWtFQVRnUkFJQUpGRFFKQjFQakFBQzBBQUJvZ0FoQUlJZ05GRFFFTUF3VUxRWlNKd0FBUS9RSUxBQXRCQVNFRFxuUVFBaEFnc2dCRUVBTmdJSUlBUWdBellDQkNBRUlBSTJBZ0FnQkVHVWlNQUFJQUVRT0EwQklBQWdCQ2tDQURjQ0FDQUFRUWhxSUFSQlxuQ0dvb0FnQTJBZ0FMSUFSQkVHb2tBQThMUWJTSndBQkIxZ0FnQkVFUGFrR2tpY0FBUWFTS3dBQVFyd0VBQzcwQ0FRUi9RUjhoQWlBQVxuUWdBM0FoQWdBVUgvLy84SFRRUkFJQUZCQmlBQlFRaDJaeUlEYTNaQkFYRWdBMEVCZEd0QlBtb2hBZ1VMSUFBZ0FqWUNIQ0FDUVFKMFxuUWZEMHdBQnFJUVJCQVNBQ2RDSURRWXo0d0FBb0FnQnhSUVJBSUFRZ0FEWUNBQ0FBSUFRMkFoZ2dBQ0FBTmdJTUlBQWdBRFlDQ0VHTVxuK01BQVFZejR3QUFvQWdBZ0EzSTJBZ0FQQlFzQ1FBSkFJQUVnQkNnQ0FDSURLQUlFUVhoeFJnUkFJQU1oQWd3QkJRc2dBVUVBUVJrZ1xuQWtFQmRtc2dBa0VmUmh0MElRVURRQ0FESUFWQkhYWkJCSEZxSWdRb0FoQWlBa1VOQWlBRlFRRjBJUVVnQWlFRElBSW9BZ1JCZUhFZ1xuQVVjTkFBc0xJQUlvQWdnaUFTQUFOZ0lNSUFJZ0FEWUNDQ0FBUVFBMkFoZ2dBQ0FDTmdJTUlBQWdBVFlDQ0E4TElBUkJFR29nQURZQ1xuQUNBQUlBTTJBaGdnQUNBQU5nSU1JQUFnQURZQ0NBdTdBZ0VCZnlNQVFjQUJheUlHSkFBZ0JrSGdBR29nQWtFUWFpa0FBRGNEQUNBR1xuUWVnQWFpQUNRUmhxS1FBQU53TUFJQVpCK0FCcUlBRkJDR29wQUFBM0F3QWdCa0dBQVdvZ0FVRVFhaWtBQURjREFDQUdRWWdCYWlBQlxuUVJocUtRQUFOd01BSUFZZ0Fpa0FBRGNEVUNBR0lBSkJDR29wQUFBM0ExZ2dCaUFCS1FBQU53TndJQVFFZnlBR1FhZ0JhaUFFUVJocVxuS1FBQU53TUFJQVpCb0FGcUlBUkJFR29wQUFBM0F3QWdCa0dZQVdvZ0JFRUlhaWtBQURjREFDQUdJQVFwQUFBM0E1QUJRZUFBQlVIQVxuQUFzaEFTQUdRUWhxSUFaQjBBQnFJQU1FZnlBR1FkQUFhaUFCYWlJQ0lBTXBBQUEzQUFBZ0FrRUlhaUFEUVFocUtRQUFOd0FBSUFGQlxuRUhJRklBRUxFSFpCQUNFQkEwQWdBU0FGUzBVRVFDQUdRUWhxSUFBUWlnRWdBVUVCYWlFQkRBRUZDd3NnQmtIQUFXb2tBRUVCQzY4Q1xuQVFSL0l3QkJ3QUZySWdVa0FBSkFBa0FnQkNnQ0NDSUhRVEJCSUNBQkxRRDRBUnRxSWdZZ0IwOEVRQ0FHSUFRb0FnUk5EUUVGQ3lBQVxuUVFFMkFnQU1BUXNnQkNBR05nSUlBa0FnQmlBSGF5SUdRVEJCSUNBRFFRRnhHMFlFUUNBRUtBSUFJQVZCa0FGcUlnaEJBRUV3L0FzQVxuSUFkcUlBWkJBU0FDUVF4QkNDQURRUUZ4R3lJQ0lBZ2dBaEM3QVVVTkFRVUxJQUJCQVRZQ0FBd0JDeUFGSUFWQmtBRnFRVEQ4Q2dBQVxuUVFBaEJDQUZRVEJxUVFCQk1Qd0xBQU5BSUFSQk1FWkZCRUFnQlVHUUFXb2dCR29nQVNBRWFrRTRhaWdDQURZQ0FDQUVRUVJxSVFRTVxuQVFVTEN5QUZRZUFBYWlBRlFaQUJha0V3L0FvQUFDQUZRVEJxSWdJZ0JTQUZRZUFBYWlBQktBSUFFUVlBSUFCQkJHb2dBa0V3L0FvQVxuQUNBQVFRQTJBZ0FMSUFWQndBRnFKQUFMckFJQ0JIOEJmaU1BUVlBQmF5SURKQUFDUUNBQ1FTRkhCRUFnQUVFRWFrRUNJQUlRTmtFQlxuSVFJTUFRVUxJQU5CUUdzaUJVRUFRY0FBL0FzQVFRRWhBa0hrOU1BQUtBSUFHaU1BUVlBQ2F5SUVKQUFnQlVIQUFCQkRJUVVDUUFKL1xuSUFFdEFBQkIvZ0Z4UVFKSERRRkJBQ0FFUWRnQmFpQUJRUUZxRUVWRkRRQWFJQVJCQ0dvZ0JFSFlBV29nQVMwQUFFRURSaENwQVVFQVxuUnd0RkRRQWdCU0FFUVFocUlnRVFuQUlnQVJDL0FrRUJJUVlMSUFSQmdBSnFKQUFnQmtVRVFDQUFRUVJxUVFNZ0F4QTJEQUVGQ3lBQVxuSUFNdkFFQTdBQUVnQUVFRGFpQURRY0lBYWkwQUFEb0FBQ0FES1FCRElRY2dBMEVJYWlJQklBTkJ5d0JxUVRYOENnQUFJQUJCREdvZ1xuQVVFMS9Bb0FBQ0FBSUFjM0FnUkJBQ0VDQ3lBQUlBSTZBQUFnQTBHQUFXb2tBQXU3QWdJRGZ3SitJd0JCZ0FKcklnRWtBQ0FBRU1ZQ1xuSUFBb0FnQkJmMGNFUUNBQUtBSUlRUUZIQkg1Q0FBVWdBRUU0YWlFRElBQXBBekFoQkFOQUlBSkJ3QUJHUlFSQUlBRkJ1QUZxSUFKcVxuSUFJZ0Eyb3RBQUE2QUFBZ0FrRUJhaUVDREFFRkN3c2dBVUg0QUdvZ0FVRzRBV3BCd0FEOENnQUFJQUZCd0FGcUlBQkJHR29wQXdBM1xuQXdBZ0FVSElBV29nQUVFZ2Fpa0RBRGNEQUNBQlFkQUJhaUFBUVNocUtRTUFOd01BSUFFZ0FDa0RFRGNEdUFFZ0FDMEFlQ0VDUWdFTFxuSVFVZ0FVRVFhaUFCUWNBQmFpa0RBRGNEQUNBQlFSaHFJQUZCeUFGcUtRTUFOd01BSUFGQklHb2dBVUhRQVdvcEF3QTNBd0FnQVNBRlxuTndNQUlBRWdBU2tEdUFFM0F3Z2dBU0FFTndNb0lBRkJNR29nQVVINEFHcEJ3QUQ4Q2dBQUlBRWdBam9BY0NBQkVOWUNJQUZCZ0FKcVxuSkFBUEJRc1E2d0lBQzZFQ0FRUi9Jd0JCRUdzaUFpUUFBa0FnQVVHQUFVOEVRQ0FDUVF4cVFRSnlJUU1nQWtFQU5nSU1Ba0FnQVVHQVxuRUU4RVFDQUNRUXhxUVFOeUlRVWdBVUdBZ0FSUEJFQWdBa0VRYWlFRElBSWdBVUVTZGtId0FYSTZBQXdnQWlBQlFRWjJRVDl4UVlBQlxuY2pvQURpQUNJQUZCREhaQlAzRkJnQUZ5T2dBTklBVWhCQXdDQlFzZ0FpQUJRUXgyUWVBQmNqb0FEQ0FDSUFGQkJuWkJQM0ZCZ0FGeVxuT2dBTklBTWhCQ0FGSVFNTUFRVUxJQUpCREdwQkFYSWhCQ0FDSUFGQkJuWkJ3QUZ5T2dBTUN5QUVJQUZCUDNGQmdBRnlPZ0FBSUFBZ1xuQWtFTWFpQURFR2NNQVFVTElBQW9BZ2dpQXlBQUtBSUFSZ1JBSUFCQjZOSEFBQkNXQVFVTElBQWdBMEVCYWpZQ0NDQUFLQUlFSUFOcVxuSUFFNkFBQUxJQUpCRUdva0FFRUFDOU1DQVFGL0l3QkJRR29pQWlRQUlBSkJBRFlDRkNBQ1FvQ0FnSUFRTndJTUFrQUNRQUpBQWtBQ1xuUUFKQUFrQWdBU2dDQUVFQmF3NEVCQUFCQWdNTElBSkJER3BCL0puQUFFR1Jtc0FBRUdjTUJBc2dBa0VNYWtHUm1zQUFRYUthd0FBUVxuWnd3REN5QUNRUXhxUWFLYXdBQkJ3WnJBQUJCbkRBSUxJQUlnQVNrQ0JEY0NHQ0FDUVFFMkFpUWdBa0hRbWNBQU5nSWdJQUpDQVRjQ1xuTENBQ1FRazJBandnQWlBQ1FUaHFOZ0lvSUFJZ0FrRVlhallDT0NBQ1FReHFJQUpCSUdvUTd3SkZEUUVNQWdzZ0FpQUJLUUlFTndJWVxuSUFKQkFUWUNKQ0FDUWZTWndBQTJBaUFnQWtJQk53SXNJQUpCQ1RZQ1BDQUNJQUpCT0dvMkFpZ2dBaUFDUVJocU5nSTRJQUpCREdvZ1xuQWtFZ2FoRHZBZzBCQ3lBQUlBSXBBZ3czQWdBZ0FFRUlhaUFDUVJScUtBSUFOZ0lBSUFKQlFHc2tBQThMUWV5U3dBQkJOeUFDUVNCcVxuUWR5U3dBQkJwSlBBQUJDdkFRQUxnQU1CQVg4akFFRVFheUlDSkFBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQVxuS0FJQVFRRnJEZ3NCQWdNRUJRWUhDQWtLQ3dBTElBRW9BZ0JCZ0lMQUFFRVNJQUVvQWdRb0Fnd1JCd0FNQ3dzZ0FTZ0NBRUdTZ3NBQVxuUVE0Z0FTZ0NCQ2dDREJFSEFBd0tDeUFCS0FJQVFhQ0N3QUJCRUNBQktBSUVLQUlNRVFjQURBa0xJQUVvQWdCQnNJTEFBRUVRSUFFb1xuQWdRb0Fnd1JCd0FNQ0FzZ0FTZ0NBRUhBZ3NBQVFSQWdBU2dDQkNnQ0RCRUhBQXdIQ3lBQktBSUFRZENDd0FCQkV5QUJLQUlFS0FJTVxuRVFjQURBWUxJQUVvQWdCQjQ0TEFBRUVSSUFFb0FnUW9BZ3dSQndBTUJRc2dBU2dDQUVIMGdzQUFRUXdnQVNnQ0JDZ0NEQkVIQUF3RVxuQ3lBQktBSUFRWUNEd0FCQkR5QUJLQUlFS0FJTUVRY0FEQU1MSUFFb0FnQkJqNFBBQUVFVElBRW9BZ1FvQWd3UkJ3QU1BZ3NnQWlBQVxuUVFScU5nSU1JQUZCaktEQUFFRVNJQUpCREdwQkFSQjZEQUVMSUFFb0FnQkJvb1BBQUVFUElBRW9BZ1FvQWd3UkJ3QUxJQUpCRUdva1xuQUF1V0FnRURmeUFBS0FJQUlRQWdBU2dDQ0NJQ1FZQ0FnQkJ4UlFSQUlBSkJnSUNBSUhGRkJFQWdBQ0FCRU9vQ0R3VUxJQUFvQWdBaFxuQWlNQVFZQUJheUlFSkFCQmdRRWhBQU5BSUFBZ0JHcEJBbXNnQWtFUGNTSURRVEJ5SUFOQk4yb2dBMEVLU1JzNkFBQWdBRUVCYXlFQVxuSUFKQkQwc2dBa0VFZGlFQ0RRQUxJQUZCQVVHT2pjQUFRUUlnQUNBRWFrRUJhMEdCQVNBQWF4QTNJQVJCZ0FGcUpBQVBCUXNnQUNnQ1xuQUNFQ0l3QkJnQUZySWdRa0FFR0JBU0VBQTBBZ0FDQUVha0VDYXlBQ1FROXhJZ05CTUhJZ0EwSFhBR29nQTBFS1NSczZBQUFnQUVFQlxuYXlFQUlBSkJEMHNnQWtFRWRpRUNEUUFMSUFGQkFVR09qY0FBUVFJZ0FDQUVha0VCYTBHQkFTQUFheEEzSUFSQmdBRnFKQUFMeWdJQlxuQkg4akFFRWdheUlGSkFCQkFTRUhBa0FnQUMwQUJBMEFJQUF0QUFVaENDQUFLQUlBSWdZdEFBcEJnQUZ4UlFSQUlBWW9BZ0JCLzR6QVxuQUVIOGpNQUFJQWhCQVhFaUNCdEJBa0VESUFnYklBWW9BZ1FvQWd3UkJ3QU5BU0FHS0FJQUlBRWdBaUFHS0FJRUtBSU1FUWNBRFFFZ1xuQmlnQ0FFSE1qTUFBUVFJZ0JpZ0NCQ2dDREJFSEFBMEJJQU1nQmlBRUVRVUFJUWNNQVFVTElBaEJBWEZGQkVBZ0JpZ0NBRUdCamNBQVxuUVFNZ0JpZ0NCQ2dDREJFSEFBMEJCUXNnQlVFQk9nQVBJQVZCNEl6QUFEWUNGQ0FGSUFZcEFnQTNBZ0FnQlNBR0tRSUlOd0lZSUFVZ1xuQlVFUGFqWUNDQ0FGSUFVMkFoQWdCU0FCSUFJUU5RMEFJQVZCekl6QUFFRUNFRFVOQUNBRElBVkJFR29nQkJFRkFBMEFJQVVvQWhCQlxuaEkzQUFFRUNJQVVvQWhRb0Fnd1JCd0FoQndzZ0FFRUJPZ0FGSUFBZ0J6b0FCQ0FGUVNCcUpBQWdBQXVIQWdFSWZ5TUFRWkFCYXlJRFxuSkFBZ0FrRi9jeUVLSUFOQjRBQnFFS1lDSUFOQk1Hb1FwZ0lnQXhDbUFnTkFBa0FnQmtFUVJ3UkFJQVpCQVdvaUJpQUNjMEVCYXlBS1xuY1VFZmRTSUhRWDl6SVFoQkFDRUVBMEFnQkVFd1JnMENJQU5CNEFCcUlBUnFJZ1VnQnlBQklBUnFJZ2tvQWdCeElBVW9BZ0FnQ0hGeVxuTmdJQUlBTkJNR29nQkdvaUJTQUZLQUlBSUFoeElBbEJNR29vQWdBZ0IzRnlOZ0lBSUFNZ0JHb2lCU0FGS0FJQUlBaHhJQWxCNEFCcVxuS0FJQUlBZHhjallDQUNBRVFRUnFJUVFNQUFzQUJRc2dBQ0FEUWVBQWFoRDZBaUFBUVRCcUlBTkJNR29RK2dJZ0FFSGdBR29nQXhENlxuQWlBRFFaQUJhaVFBRHdzZ0FVR1FBV29oQVF3QUN3QUx2UUlCQlg4akFFRXdheUlESkFBZ0FFSFFBR29oQlFKQUFrQUNRRUdBQVNBQVxuTFFEUUFTSUVheUlHSUFKTkJFQWdCQTBCREFJRkN5QURRUWhxSUFRZ0JVR0FBVUh3bThBQUVKSUNJQU1nQWlBREtBSUlJQU1vQWd4QlxuZ0p6QUFCQ2pBaUFES0FJQUlBTW9BZ1FnQVNBQ1FaQ2N3QUFRblFJZ0FpQUVhaUVFREFJTElBTkJJR29nQVNBQ0lBWVExUUlnQXlnQ1xuTENFQ0lBTW9BaWdoQVNBREtBSWtJUVlnQXlnQ0lDRUhJQU5CR0dvZ0JDQUZRWUFCUWJDYndBQVFrZ0lnQXlnQ0dDQURLQUljSUFjZ1xuQmtIQW04QUFFSjBDSUFBZ0JVRUJFSWNDQ3lBQ1FmOEFjU0VFSUFKQmdBRlBCRUFnQUNBQklBSkJCM1lRaHdJRkN5QURRUkJxSUFRZ1xuQlVHQUFVSFFtOEFBRUtNQ0lBTW9BaEFnQXlnQ0ZDQUJJQUpCZ0g5eGFpQUVRZUNid0FBUW5RSUxJQUFnQkRvQTBBRWdBMEV3YWlRQVxuQzdnQ0FRVi9Jd0JCTUdzaUF5UUFJQUJCS0dvaEJRSkFBa0FDUUVIQUFDQUFMUUJvSWdScklnWWdBazBFUUNBRURRRU1BZ1VMSUFOQlxuQ0dvZ0JDQUZRY0FBUWZDYndBQVFrZ0lnQXlBQ0lBTW9BZ2dnQXlnQ0RFR0FuTUFBRUtNQ0lBTW9BZ0FnQXlnQ0JDQUJJQUpCa0p6QVxuQUJDZEFpQUNJQVJxSVFRTUFnc2dBMEVnYWlBQklBSWdCaERWQWlBREtBSXNJUUlnQXlnQ0tDRUJJQU1vQWlRaEJpQURLQUlnSVFjZ1xuQTBFWWFpQUVJQVZCd0FCQnNKdkFBQkNTQWlBREtBSVlJQU1vQWh3Z0J5QUdRY0Nid0FBUW5RSWdBQ0FGUVFFUXR3SUxJQUpCUDNFaFxuQkNBQ1FjQUFUd1JBSUFBZ0FTQUNRUVoyRUxjQ0JRc2dBMEVRYWlBRUlBVkJ3QUJCMEp2QUFCQ2pBaUFES0FJUUlBTW9BaFFnQVNBQ1xuUVVCeGFpQUVRZUNid0FBUW5RSUxJQUFnQkRvQWFDQURRVEJxSkFBTDZBRUJBMzhnQUNBREtBSUlJQUVvQWd3Z0FTZ0NDQ0lGUVJsM1xuSUFWQkRuZHpJQVZCQTNaemFtb2dCQ2dDQkNJR1FROTNJQVpCRFhkeklBWkJDblp6YWlJR05nSU1JQUFnQXlnQ0JDQUZJQUVvQWdRaVxuQjBFWmR5QUhRUTUzY3lBSFFRTjJjMnBxSUFRb0FnQWlCVUVQZHlBRlFRMTNjeUFGUVFwMmMyb2lCVFlDQ0NBQUlBTW9BZ0FnQnlBQlxuS0FJQUlnRkJHWGNnQVVFT2QzTWdBVUVEZG5OcWFpQUdRUTkzSUFaQkRYZHpJQVpCQ25aemFqWUNCQ0FBSUFFZ0JDZ0NER29nQWtFWlxuZHlBQ1FRNTNjeUFDUVFOMmMyb2dCVUVQZHlBRlFRMTNjeUFGUVFwMmMybzJBZ0FMbVFJQkJYOGpBRUV3YXlJREpBQWdBMEVvYWlBQlxuRVB3QkFrQWdBeTBBS0EwQUlBTXRBQ2tpQjBFZmNVRWZSZzBBSUFOQklHb2dBUkQ4QVNBRExRQWdCRUFNQVFVTEFrQWdBeXdBSVNJR1xuUVFCT0RRQUNRQUpBSUFaQi93RnhRWUVCYXc0Q0FBRURDeUFEUVFocUlBRVEvQUVnQXkwQUNBMENJQU1zQUFraUJFRUFUZzBDSUFSQlxuL3dGeElRWU1BUXNnQTBFWWFpQUJFUHdCSUFNdEFCZ05BU0FETFFBWklRUWdBMEVRYWlBQkVQd0JJQU10QUJBTkFTQUVRZjhCY1NJRVxuUlEwQklBTXRBQkVnQkVFSWRISWhCZ3NnQXlBQklBWVE0UUVnQXlnQ0FDSUJSUVJBREFFRkN5QURLQUlFSVFRZ0FTRUZDeUFBSUFRMlxuQWdRZ0FDQUZRUUFnQWtIL0FYRWdCMFliUVFBZ0JSczJBZ0FnQTBFd2FpUUFDNHNDQVFOL0l3QkJnQUZySWdRa0FDQUFLQUlBSVFBQ1xuZndKQUlBRW9BZ2dpQWtHQWdJQVFjVVVFUUNBQ1FZQ0FnQ0J4RFFFZ0FDZ0NBQ0FCRUZFTUFnVUxJQUFvQWdBaEFFR0JBU0VDQTBBZ1xuQWlBRWFrRUNheUFBUVE5eElnTkJNSElnQTBIWEFHb2dBMEVLU1JzNkFBQWdBa0VCYXlFQ0lBQkJEMHNnQUVFRWRpRUFEUUFMSUFGQlxuQVVHT2pjQUFRUUlnQWlBRWFrRUJhMEdCQVNBQ2F4QTNEQUVMSUFBb0FnQWhBRUdCQVNFQ0EwQWdBaUFFYWtFQ2F5QUFRUTl4SWdOQlxuTUhJZ0EwRTNhaUFEUVFwSkd6b0FBQ0FDUVFGcklRSWdBRUVQU3lBQVFRUjJJUUFOQUFzZ0FVRUJRWTZOd0FCQkFpQUNJQVJxUVFGclxuUVlFQklBSnJFRGNMSUFSQmdBRnFKQUFMaGdJQkEzOGpBRUdBQVdzaUJDUUFBbjhDUUNBQktBSUlJZ0pCZ0lDQUVIRkZCRUFnQWtHQVxuZ0lBZ2NRMEJJQUFnQVJDTUFRd0NCUXNnQUMwQUFDRUNRWUVCSVFBRFFDQUFJQVJxUVFKcklBSkJEM0VpQTBFd2NpQURRZGNBYWlBRFxuUVFwSkd6b0FBQ0FDSWdOQkJIWWhBaUFBUVFGcklRQWdBMEVQU3cwQUN5QUJRUUZCam8zQUFFRUNJQUFnQkdwQkFXdEJnUUVnQUdzUVxuTnd3QkN5QUFMUUFBSVFKQmdRRWhBQU5BSUFBZ0JHcEJBbXNnQWtFUGNTSURRVEJ5SUFOQk4yb2dBMEVLU1JzNkFBQWdBaUlEUVFSMlxuSVFJZ0FFRUJheUVBSUFOQkQwc05BQXNnQVVFQlFZNk53QUJCQWlBQUlBUnFRUUZyUVlFQklBQnJFRGNMSUFSQmdBRnFKQUFMa2dJQlxuQW44akFFRWdheUlESkFBQ1FDQUNRU0JIQkVBZ0FFRUVha0VBSUFJUU5rRUJJUUVNQVFVTElBTkJBbW9pQkNBQlFRSnFMUUFBT2dBQVxuSUFOQkUyb2dBVUVUYWlrQUFEY0FBQ0FEUVJocUlBRkJHR29wQUFBM0FBQWdBeUFCTHdBQU93RUFJQU1nQVNrQUN6Y0FDeUFESUFFcFxuQUFNM0FBTkJBQ0VCUWVUMHdBQW9BZ0FhSXdCQklHc2lBaVFBSUFJZ0F4Q0RBaUFDUVNCcUpBQkZCRUJCQVNFQklBQkJCR3BCQVNBRFxuRURZTUFRVUxJQUFnQXk4QkFEc0FBU0FBSUFNcEFBTTNBZ1FnQUNBRFFRdHFJZ0lwQUFBM0FBd2dBRUVEYWlBRUxRQUFPZ0FBSUFCQlxuRkdvZ0FrRUlhaWtBQURjQUFDQUFRUmxxSUFKQkRXb3BBQUEzQUFBTElBQWdBVG9BQUNBRFFTQnFKQUFMaXdJQkJYOGpBRUVnYXlJRFxuSkFBQ1FDQUNJQUZySWdVZ0FDZ0NBQ0lDSUFBb0FnZ2lCbXROQkVBZ0JTQUdhaUVISUFBb0FnUWhBZ3dCQlFzQ1FBSi9RUUFnQmlBRlxuSUFacUlnZExEUUFhUVFBZ0J5QUNRUUYwSWdRZ0JDQUhTUnNpQkVFSUlBUkJDRXNiSWdSQkFFZ05BQm9DZnlBQ1JRUkFRUUFoQWlBRFxuUVJocURBRUZDeUFEUVFFMkFoZ2dBeUFBS0FJRU5nSVVJQU5CSEdvTElBSTJBZ0FnQTBFSWFrRUJJQVFnQTBFVWFoQ2FBU0FES0FJSVxuUVFGSERRRWdBeWdDRUNFQUlBTW9BZ3dMSUFCQitOSEFBQkRQQWdBTElBTW9BZ3doQWlBQUlBUTJBZ0FnQUNBQ05nSUVDeUFGQkVBZ1xuQWlBR2FpQUJJQVg4Q2dBQUJRc2dBQ0FITmdJSUlBTkJJR29rQUF2d0FRSUJmd1orSXdCQlFHb2lBeVFBSUFNZ0FTQUNFQndnQUVJQVxuTndNUUlBQkJHR3BDQURjREFDQUFJQU1wQXpBM0F3QWdBQ0FES1FNNE53TUlJd0JCRUdzaUFTQURLUU1vUWorSVBnSU1JQUFnQVNnQ1xuREVFQmEwR0FBbkVpQVVIQUFFbXRJQUZCUDNHdElnYUdJZ1FnQUNrREFId2lCemNEQUNBQUlBRkJCbllpQVVFQlJxMGdCb1lpQ0NBQVxuS1FNSWZDSUZJQVFnQjFhdGZDSUhOd01JSUFBZ0FVRUNScTBnQm9ZaUNTQUFLUU1RZkNJRUlBVWdDRlN0SUFVZ0IxYXRmSHdpQlRjRFxuRUNBQUlBQXBBeGdnQVVFRFJxMGdCb1o4SUFRZ0NWU3RJQVFnQlZhdGZIdzNBeGdnQTBGQWF5UUFDLzhCQVFSL0l3QkJNR3NpQXlRQVxuSUFNZ0FDZ0NZQ0lDUVFWMklnUkJnSUNBT0hFMkFpZ2dBeUFFUVlEK0EzRWdBa0VMZEVHQWdQd0hjU0FDUVJ0MGNuSWdBa0VEZEVFWVxuZG5JMkFpd2dBRUhBOHNBQVFUY2dBbXRCUDNGQkFXb1FBaUFBSUFOQktHcEJDQkFDUVFBaEFnTkFJQUpCSUVaRkJFQWdBQ0FDYWlJRlxuS0FJQUlRUWdCVUVBTmdJQUlBSWdBMm9nQkVFSWRFR0FnUHdIY1NBRVFSaDBjaUFFUVFoMlFZRCtBM0VnQkVFWWRuSnlOZ0lBSUFKQlxuQkdvaEFnd0JCUXNMSUFFZ0F5a0RBRGNBQUNBQlFRaHFJQU1wQXdnM0FBQWdBVUVZYWlBRFFSaHFLUU1BTndBQUlBRkJFR29nQTBFUVxuYWlrREFEY0FBQ0FEUVRCcUpBQUx4UUlCQjM0Z0FDa0RDQ0FBS1FNQUlBQXBBeUFpQkVJd2lFTFJoNENBRUg1OElnRkNOSWg4SWdKQ1xuLy8vLy8vLy8vd2VESVFVZ0FDa0RHQ0FBS1FNUUlBSkNOSWg4SWdkQ05JaDhJZ05DLy8vLy8vLy8vd2VESVFZZ0FDQUVRdi8vLy8vL1xuL3orRElBTkNOSWg4SWdSQ01JZ2dBaUFIUXYvLy8vLy8vLzhIZ3lJQ2d5QURnMEwvLy8vLy8vLy9CMUVnQkVMLy8vLy8vLzgvVVhFZ1xuQVVMLy8vLy8vLy8vQjRNaUEwS3UrUC8vNy8vL0IxWnhyWVJRQkg0Z0JBVWdBMExSaDRDQUVId2lBVUwvLy8vLy8vLy9CNE1oQXlBRlxuSUFGQ05JaDhJZ0ZDLy8vLy8vLy8vd2VESVFVZ0FpQUJRalNJZkNJQlF2Ly8vLy8vLy84SGd5RUNJQVlnQVVJMGlId2lBVUwvLy8vL1xuLy8vL0I0TWhCaUFCUWpTSUlBUjhRdi8vLy8vLy96K0RDemNESUNBQUlBWTNBeGdnQUNBQ053TVFJQUFnQlRjRENDQUFJQU0zQXdBTFxua2dJQkJIOGpBRUVnYXlJREpBQUNRQ0FDUVNCSEJFQWdBRUVFYWtFRUlBSVFOa0VCSVFJTUFRVUxJQU5CQW1vZ0FVRUNhaUlFTFFBQVxuT2dBQUlBTkJFMm9nQVVFVGFpa0FBRGNBQUNBRFFSaHFJQUZCR0dvcEFBQTNBQUFnQXlBQkx3QUFPd0VBSUFNZ0FTZ0FCeUlGTmdBSFxuSUFNZ0FTZ0FBeUlHTmdBRElBTWdBU2tBQ3pjQUMwRUJJUUlnQTBIb29NQUFRU0FRNWdGQkFFb0VRQ0FBUVFScVFRVWdBeEEyREFFRlxuQ3lBQUlBVTJBZ2dnQUNBR05nSUVJQUFnQVM4QUFEc0FBU0FBSUFGQkMyb2lBU2tBQURjQURDQUFRUU5xSUFRdEFBQTZBQUFnQUVFVVxuYWlBQlFRaHFLUUFBTndBQUlBQkJHV29nQVVFTmFpa0FBRGNBQUVFQUlRSUxJQUFnQWpvQUFDQURRU0JxSkFBTHBnSUJBWDhqQUVId1xuQUdzaUJpUUFJQVlnQVRZQ0RDQUdJQUEyQWdnZ0JpQUROZ0lVSUFZZ0FqWUNFQ0FHUVFJMkFod2dCa0hFaThBQU5nSVlBa0FnQkNnQ1xuQUFSQUlBWkJNR29nQkVFUWFpa0NBRGNEQUNBR1FTaHFJQVJCQ0dvcEFnQTNBd0FnQmlBRUtRSUFOd01nSUFaQkJEWUNYQ0FHUWF5TVxud0FBMkFsZ2dCa0lFTndKa0lBWWdCa0VRYXExQ2dJQ0FnRENFTndOUUlBWWdCa0VJYXExQ2dJQ0FnRENFTndOSUlBWWdCa0VnYXExQ1xuZ0lDQWdJQUJoRGNEUUF3QkJRc2dCa0VETmdKY0lBWkIrSXZBQURZQ1dDQUdRZ00zQW1RZ0JpQUdRUkJxclVLQWdJQ0FNSVEzQTBnZ1xuQmlBR1FRaHFyVUtBZ0lDQU1JUTNBMEFMSUFZZ0JrRVlhcTFDZ0lDQWdNQUFoRGNET0NBR0lBWkJPR28yQW1BZ0JrSFlBR29nQlJCN1xuQUF2ckFRRUVmeU1BUVJCcklnVWtBRUVCSVFRZ0FVVWdBVUVDZGlBQlFRTnhRUUJIYWlBRFMzSkZCRUFnQWlBRFFRSjBhaUVHQTM4Z1xuQXdSL1FRQWhCRUVBSUFJZ0FpQUdSaHNnQWlBR1IwRUNkQ0VIQWtBZ0FFVUVRRUVBSVFBTUFRVUxJQUZGQkVCQkFDRUJRUUFoQUF3QlxuQlFzZ0JVRUFOZ0lNSUFVZ0FVRUVJQUZCQkVrYklnUnJRUkJxSUFRZ0FDQUJJQVJySWdGcUlBUVE4UUVnQlNnQ0RDSUVRUmgwSUFSQlxuZ1A0RGNVRUlkSElnQkVFSWRrR0EvZ054SUFSQkdIWnljaUVFQ3lBQ0lBZHFJUUlnQkRZQ0FDQURRUUZySVFNTUFRVkJBQXNMSVFRRlxuQ3lBRlFSQnFKQUFnQkF2NkFRRVBmMEYvUVFBZ0FSc2lBVUYvY3lFRUlBSW9BZ0FoQlNBREtBSUFJUVlnQWlnQ0JDRUhJQU1vQWdRaFxuQ0NBQ0tBSUlJUWtnQXlnQ0NDRUtJQUlvQWd3aEN5QURLQUlNSVF3Z0FpZ0NFQ0VOSUFNb0FoQWhEaUFDS0FJVUlROGdBeWdDRkNFUVxuSUFJb0FoZ2hFU0FES0FJWUlSSWdBQ0FES0FJY0lBRnhJQUlvQWh3Z0JIRnlOZ0ljSUFBZ0FTQVNjU0FFSUJGeGNqWUNHQ0FBSUFFZ1xuRUhFZ0JDQVBjWEkyQWhRZ0FDQUJJQTV4SUFRZ0RYRnlOZ0lRSUFBZ0FTQU1jU0FFSUF0eGNqWUNEQ0FBSUFFZ0NuRWdCQ0FKY1hJMlxuQWdnZ0FDQUJJQWh4SUFRZ0IzRnlOZ0lFSUFBZ0JDQUZjU0FCSUFaeGNqWUNBQXZXQVFFRmZ5QUFJQUVvQWd3Z0FpZ0NDQ0lGUVJwM1xuSUFWQkZYZHpJQVZCQjNkeklBUnFhaUFCS0FJSUlnY2dBaWdDRENJSWN5QUZjU0FIYzJvaUJDQUJLQUlFYWlJR05nSU1JQUFnQkNBQ1xuS0FJQUlnUWdBU2dDQUNJSklBSW9BZ1FpQW5OeElBSWdDWEZ6SUFSQkhuY2dCRUVUZDNNZ0JFRUtkM05xYWlJQk5nSUVJQUFnQ1NBRFxuSUFkcUlBZ2dCaUFGSUFoemNYTnFJQVpCR25jZ0JrRVZkM01nQmtFSGQzTnFJZ05xTmdJSUlBQWdBVUVlZHlBQlFSTjNjeUFCUVFwM1xuY3lBQklBSWdCSE54SUFJZ0JIRnphaUFEYWpZQ0FBdnNBUUVIZnlNQVFZQUNheUlHSkFBZ0JrSGdBV29pQ0NBRkVBVWdCa0hBQVdvaVxuQnlBRUVBVWdCa0dnQVdvaUN5QURJQWNRQkNBR1FZQUJhaUlLSUFNZ0NCQkdJQVpCNEFCcUlna2dBeUFJRURvZ0JrRkFheUlESUFrZ1xuQ1JBNklBa2dDU0FERURvZ0JrRWdhaUlNSUFvZ0NSQUVJQUFnREJBRklBWWdDeUFMRURvZ0JpQUdJQVlRT2lBRElBWWdCaEE2SUFBZ1xuQUNBREVFWWdDQ0FISUFnUU9pQUtJQVFnQlJBNklBSWdDaEFGSUFJZ0FpQUlFRVlnQVNBR0lBQVFSaUFISUFjZ0J4QTZJQWNnQnhBRlxuSUFFZ0RDQUJFQVFnQnlBSElBY1FPaUFCSUFFZ0J4QkdJQVpCZ0FKcUpBQUw2UUVDQTM4QmZpQUFJQUkxQWdBZ0FUVUNBSHdpQ0Q0Q1xuQUNBRVFRRWdCRUVCU3hzaUIwRUJheUVHUVFRaEJRTkFJQVlFUUNBQUlBVnFJQUlnQldvMUFnQWdBU0FGYWpVQ0FDQUlRaUNJZkh3aVxuQ0Q0Q0FDQUdRUUZySVFZZ0JVRUVhaUVGREFFRkN3c2dBQ0FBTlFJQUlBTW9BZ0FnQUNBRElBUVFwd0ZCZjNOQmZ5QUlRb0NBZ0lBUVxuVkJzaUFYR3RmU0lJUGdJQUlBTkJCR29oQWlBQVFRUnFJUVVnQjBFQmF5RUdBMEFnQmdSQUlBVWdCVFVDQUNBQ0tBSUFJQUZ4clNBSVxuUWlDSVFnR0RmSDBpQ0Q0Q0FDQUNRUVJxSVFJZ0JVRUVhaUVGSUFaQkFXc2hCZ3dCQlFzTEM5c0JBZ1IvQVg0Z0EwRUNkQ0FCYWtFRVxuYXlnQ0FDRUhJQU1oQmdOQUlBWUVRQ0FBSUFScUlBVWdBU0FFYWlnQ0FDSUZRUUYwY2pZQ0FDQUVRUVJxSVFRZ0JrRUJheUVHSUFWQlxuSDNZaEJRd0JCUUpBSUFBZ0FEVUNBQ0FDS0FJQUlBQWdBaUFERUtjQlFYOXpRWDhnQjBFQVRoc2lBWEd0ZlNJSVBnSUFJQUpCQkdvaFxuQlNBQVFRUnFJUVFnQTBFQklBTkJBVXNiUVFGcklRWURRQ0FHUlEwQklBUWdCRFVDQUNBRktBSUFJQUZ4clNBSVFpQ0lRZ0dEZkgwaVxuQ0Q0Q0FDQUZRUVJxSVFVZ0JFRUVhaUVFSUFaQkFXc2hCZ3dBQ3dBTEN3c0xwd0lCQlg0Z0FDQUFLUU1ZSUFBcEF4QWdBQ2tEQ0NBQVxuS1FNQUlBQXBBeUFpQTBJd2lFTFJoNENBRUg1OElnSkNOSWg4SWdGQ05JaDhJZ1JDTkloOElnVkNOSWdnQTBMLy8vLy8vLzgvZzN3aVxuQTBJd2lDQUVRdi8vLy8vLy8vOEhneUlFSUFHRElBV0RRdi8vLy8vLy8vOEhVU0FEUXYvLy8vLy8vejlSY1NBQ1F2Ly8vLy8vLy84SFxuZ3lJQ1FxNzQvLy92Ly84SFZuR3RoRUxSaDRDQUVINGdBbndpQWtMLy8vLy8vLy8vQjRNM0F3QWdBQ0FCUXYvLy8vLy8vLzhIZ3lBQ1xuUWpTSWZDSUJRdi8vLy8vLy8vOEhnemNEQ0NBQUlBRkNOSWdnQkh3aUFVTC8vLy8vLy8vL0I0TTNBeEFnQUNBRlF2Ly8vLy8vLy84SFxuZ3lBQlFqU0lmQ0lCUXYvLy8vLy8vLzhIZ3pjREdDQUFJQUZDTklnZ0EzeEMvLy8vLy8vL1A0TTNBeUFMN2dFQkEzOGpBRUZBYWlJQ1xuSkFBZ0FrRW9ha0lBTndNQUlBSkJNR3BDQURjREFDQUNRVGhxUWdBM0F3QWdBa0VZYWlBQlFSaHFLUUFBTndNQUlBSkJFR29nQVVFUVxuYWlrQUFEY0RBQ0FDUWdBM0F5QWdBaUFCS1FBQU53TUFJQUlnQVVFSWFpa0FBRGNEQ0NBQVFlUUFhaUlERUtnQ1FRQWhBUU5BSUFGQlxud0FCR1JRUkFJQUVnQW1vaUJDQUVMUUFBUWR3QWN6b0FBQ0FCUVFGcUlRRU1BUVVMQ3lBRElBSkJ3QUFRQWlBQUVLZ0NRUUFoQVFOQVxuSUFGQndBQkdSUVJBSUFFZ0Ftb2lBeUFETFFBQVFlb0Fjem9BQUNBQlFRRnFJUUVNQVFVTEN5QUFJQUpCd0FBUUFpQUNRVUJySkFBTFxuK1FFQkFYOGpBRUhRQUdzaUJTUUFJQVZCQ0dvZ0FTQUNFT2dCSUFVZ0JTZ0NEQ0lCTmdJY0lBVWdCU2dDQ0NJQ05nSVlJQVVnQVRZQ1xuRkNBRlFTQnFJQU1nQkJEYkFTQUZRY1FBYWlBQ0lBRkJBQ0FGS0FJa0lBVW9BaUJCZ0lDQWdIaEdHeUFGS0FJb0VDTUNRQUpBSUFVb1xuQWtSQkJVWU5BQ0FGUVRocUlBVkJ4QUJxRUZzZ0JTZ0NPQ0lCUVlDQWdJQjRSZzBBSUFVZ0JTa0NQRGNDTUNBRklBRTJBaXdNQVFzZ1xuQlVHQWdJQ0FlRFlDTEFzZ0JVRWdhaERMQWlBRlFSUnFFT01DSUFVZ0JVRXNhaENHQWlBRktBSUVJUUVnQUNBRktBSUFJZ0kyQWdRZ1xuQUNBQlFRQWdBa0VCY1JzMkFnQWdCVUhRQUdva0FBdUxBZ0VEZnlNQVFkQUJheUlGSkFBZ0FFS0Jnb1NJa0tEQWdBRTNBZ0FnQUVJQVxuTndJZ0lBQkJHR3BDZ1lLRWlKQ2d3SUFCTndJQUlBQkJFR3BDZ1lLRWlKQ2d3SUFCTndJQUlBQkJDR3BDZ1lLRWlKQ2d3SUFCTndJQVxuSUFCQktHcENBRGNDQUNBQVFUQnFRZ0EzQWdBZ0FFRTRha0lBTndJQUlBVkJDR29pQXlBQVFTQnFJZ1FRZENBRElBQkJJQkFDSUFOQlxuNFBIQUFFRUJFQUlnQXlBQklBSVFBaUFESUFRUWlBSWdBeUFFRUhRZ0F5QUFRU0FRQWlBRElBQVFpQUlnQXlBRUVIUWdBeUFBUVNBUVxuQWlBRFFlSHh3QUJCQVJBQ0lBTWdBU0FDRUFJZ0F5QUVFSWdDSUFNZ0JCQjBJQU1nQUVFZ0VBSWdBeUFBRUlnQ0lBQkJBRFlDUUNBRlxuUWRBQmFpUUFDK0VCQWdWL0FYNGpBQ0lHUVlBQ2EwRkFjU0lESkFBZ0EwSDhBV29nQTBINEFXb2dBUkRpQVNBRFFVQnJJZ1VnQWlBRFxuS0FMNEFSQmZJQVZCTUhJaUFoRHZBU0VFSUFNZ0FpZ0NBRUYvY3pZQ0FFRUVJUUVEUUNBQlFUQkdCRUFDUUNBRVFYOXpJUVJCQUNFQlxuQTBBZ0FVRXdSZzBCSUFFZ0Eyb2lCeUFIS0FJQUlBUnhOZ0lBSUFGQkJHb2hBUXdBQ3dBTEJTQUJJQU5xSUFGQnNOZkFBR28xQWdBZ1xuQ0NBQklBSnFOUUlBZkgwaUNENENBQ0FJUWlDSVFnR0RJUWdnQVVFRWFpRUJEQUVMQ3lBQ0lBTWdBeWdDL0FFUTZnRWdBQ0FBSUFVUVxuUGlBR0pBQUw5Z0VDQTM4Q2ZpTUFRWUFFYXlJQkpBQWdBQkRHQWlBQUtBSUFRWDlIQkVBZ0FTQUFLQUlRUVFGeEJINGdBRUh3QUdvaFxuQXlBQUtRTm9JUVFnQUNrRFlDRUZBMEFnQWtHQUFVWkZCRUFnQVVId0Ftb2dBbW9nQWlBRGFpMEFBRG9BQUNBQ1FRRnFJUUlNQVFVTFxuQ3lBQlFmQUJhaUFCUWZBQ2FpSURRWUFCL0FvQUFDQUFMUUR3QVNFQ0lBTWdBRUVnYWtIQUFQd0tBQUJDQVFWQ0FBczNBd0FnQVVJQVxuTndNSUlBRkJFR29nQVVId0FtcEJ3QUQ4Q2dBQUlBRWdCRGNEV0NBQklBVTNBMUFnQVVIZ0FHb2dBVUh3QVdwQmdBSDhDZ0FBSUFFZ1xuQWpvQTRBRWdBUkRVQWlBQlFZQUVhaVFBRHdVTEVPc0NBQXZXQVFFRWZ5TUFRYkFDYXlJREpBQWdBMEd3QVdvaUJDQUNRUUFRTWlBRFxuSUFSQktCQXBJZ1JCS0dvZ0JFSFlBV3BCS0JBcEdpQUVRUUEyQWxBZ0JFSFlBR29pQXlBQ0lBUkJnQUpxSWdVUTNnRWdBQ0FEUVNnUVxuS1NJRFFTaHFJQVJCZ0FGcVFTZ1FLUm9nQTBIUUFHb2dBa0hRQUdwQktCQXBHaUFEUVFBMkFuZ2dBU0FGUVNnUUtTRUdJQU1oQUVFb1xuSVFJRFFDQUNRY0FDUmtVRVFDQUFRWUFCYWlJQklBQWdCQ0FDSUFacUVDUWdBa0VvYWlFQ0lBRWhBQXdCQlFzTElBTkIwQWRxSWdBZ1xuQUNBRkVBNGdCRUd3QW1va0FBdjVBUUVEZnlNQVFTQnJJZ1VrQUVFQklRY0NRQ0FBS0FJQUlnWWdBU0FDSUFBb0FnUWlBaWdDRENJQlxuRVFjQURRQUNRQ0FBTFFBS1FZQUJjVVVFUUNBR1FZbU53QUJCQVNBQkVRY0FEUUlnQXlBQUlBUVJCUUFOQWlBQUtBSUFJUVlnQUNnQ1xuQkNnQ0RDRUJEQUVGQ3lBR1FZcU53QUJCQWlBQkVRY0FEUUVnQlVFQk9nQVBJQVVnQWpZQ0JDQUZJQVkyQWdBZ0JVSGdqTUFBTmdJVVxuSUFVZ0FDa0NDRGNDR0NBRklBVkJEMm8yQWdnZ0JTQUZOZ0lRSUFNZ0JVRVFhaUFFRVFVQURRRWdCU2dDRUVHRWpjQUFRUUlnQlNnQ1xuRkNnQ0RCRUhBQTBCQ3lBR1FjU0t3QUJCQVNBQkVRY0FJUWNMSUFWQklHb2tBQ0FIQyt3QkFnSi9BWDRqQUVFUWF5SUNKQUFnQWtFQlxuT3dFTUlBSWdBVFlDQ0NBQ0lBQTJBZ1FqQUVFUWF5SUJKQUFnQWtFRWFpSUFLUUlBSVFRZ0FTQUFOZ0lNSUFFZ0JEY0NCQ01BUVJCclxuSWdBa0FDQUJRUVJxSWdFb0FnQWlBaWdDRENFREFrQUNRQUpBQWtBZ0FpZ0NCQTRDQUFFQ0N5QUREUUZCQVNFQ1FRQWhBd3dDQ3lBRFxuRFFBZ0FpZ0NBQ0lDS0FJRUlRTWdBaWdDQUNFQ0RBRUxJQUJCZ0lDQWdIZzJBZ0FnQUNBQk5nSU1JQUJCSGlBQktBSUlJZ0F0QUFnZ1xuQUMwQUNSQzRBUUFMSUFBZ0F6WUNCQ0FBSUFJMkFnQWdBRUVmSUFFb0FnZ2lBQzBBQ0NBQUxRQUpFTGdCQUF2UEFRSURmd0YrSUFBZ1xuQVRVQ0FDQUNOUUlBZlNJR1BnSUFRUXNoQkVFRUlRTURRQ0FHUWlDSXAwRUJjU0VGSUFRRVFDQUFJQU5xSUFFZ0EybzFBZ0FnQWlBRFxuYWpVQ0FDQUZyWHg5SWdZK0FnQWdCRUVCYXlFRUlBTkJCR29oQXd3QkJRc0xJQUFnQURVQ0FFRUFJQVZySWdKQnNOZkFBQ2dDQUhHdFxuZkNJR1BnSUFRYlRYd0FBaEFTQUFRUVJxSVFOQkN5RUVBMEFnQkFSQUlBTWdBU2dDQUNBQ2NhMGdBelVDQUNBR1FpQ0lmSHdpQmo0Q1xuQUNBQlFRUnFJUUVnQTBFRWFpRURJQVJCQVdzaEJBd0JCUXNMQzhvQkFnRi9CMzRqQUVFUWF5SUNKQUFnQWlBQk5nSU1JQUJCQUNBQ1xuS0FJTWE2d2lBeUFBS1FNQWhTSUVJQU5Dd29MWmdjM1JsK20vZjROOElnWkNBRUovSUFBUXRRSWJJZ2VETndNQUlBQWdBQ2tEQ0NBRFxuaFNJSUlBTkN1OENpK3VxY3Q5ZTZmNE44SWdVZ0JDQUdWcTE4SWdZZ0I0TTNBd2dnQUNBQUtRTVFJQU9GSWdrZ0EwSitnM3dpQkNBRlxuSUFoVXJTQUZJQVpXclh4OElnVWdCNE0zQXhBZ0FDQUFLUU1ZSUFPRklBTjhJQVFnQ1ZTdElBUWdCVmF0Zkh3Z0I0TTNBeGdnQWtFUVxuYWlRQUMrNEJBUU4vSXdCQndBSnJJZ01rQUNBRFFRaHFJQUVnQWhEb0FTQURRVUJySWdRZ0F5Z0NDQ0lCSUFNb0Fnd2lBaEN0QVNBRFxuUVlnQmFrRUFRY0VBL0FzQUlBTkIrQUJxUWJDZXdBQXBBd0EzQXdBZ0EwSHdBR3BCcUo3QUFDa0RBRGNEQUNBRFFlZ0Fha0dnbnNBQVxuS1FNQU53TUFJQU5DQURjRGdBRWdBMEdZbnNBQUtRTUFOd05nSUFOQjRBQnFJZ1VnQkVFZ0VHRWdBMEhRQVdvaUJDQUZRZkFBL0FvQVxuQUNBRFFTQnFJZ1VnQkJBeElBTkJGR29pQkNBRlFTQVF0UUVnQVNBQ0VOOENJQU1nQkJENUFTQURLQUlFSVFFZ0FDQURLQUlBTmdJQVxuSUFBZ0FUWUNCQ0FEUWNBQ2FpUUFDOVlCQVFOL0l3QkJnQUZySWdRa0FDQUJRY0FBRUVNaEFRSkFJQUFvQWdoRkJFQkJxT3pBQUNBQVxuUWJRQmFpZ0NBQ0FBS0FLd0FSRUVBQXdCQlFzakFFR0FBV3NpQlNRQUlBUkJDR29pQTBHWTdzQUFJQU1nQWhDREFpSUNSUkNvQVNBQVxuUVFocUlBVWdBeEFUSUFSQktHb2lBQ0FGRUlrQklBVkJnQUZxSkFBZ0FpRURJQUVnQUJDY0FrSEFBQ0VDSXdCQkVHc2lBQ0FEUlRZQ1xuRENBQUtBSU1RUUZySVFBRFFDQUNCRUFnQVNBQkxRQUFJQUJ4T2dBQUlBSkJBV3NoQWlBQlFRRnFJUUVNQVFVTEN3c2dCRUdBQVdva1xuQUNBREM5QUJBUVYvSXdCQm9BRnJJZ1VrQUNBQUtBSUVJZ2dvQWdRaEJpQUZRZkFBYWtFQVFURDhDd0FnQlVId0FHb2lCeUFDSUFZUlxuQkFBZ0JVRVFhaUlKSUFkQk1Qd0tBQUFnQ0NnQ0JDRUNJQWRCQUVFdy9Bc0FJQWNnQVNBQ0VRUUFJQVZCUUdzaUJpQUhRVEQ4Q2dBQVxuSUFBb0FnQWlBaUFBTFFBSUlnQWdCaUFERUtFQ0lBWWdCaUFCSUFnb0FnQVJCZ0FnQWlBQUlBWWdCQkNoQWlBRlFRaHFJQWxCREVFSVxuSUFBYklnQWdCaUFBRU0wQklBVW9BZ2hCQVhFRVFCRG1BZ0FGQ3lBRktBSU1JQVZCb0FGcUpBQkZDODhCQVFOL0l3QkJNR3NpQVNRQVxuSUFGQkdHb2dBa0V3RUdNQ1FDQUJLQUlZSWdKRkJFQWdBRUVBTmdJQURBRUZDeUFCS0FJY0lRTWdBVUVBTmdJc0lBRWdBallDSkNBQlxuSUFNMkFpZ2dBVUVRYWlBQlFTUnFFSmtCQWtBZ0FTZ0NFQ0lDQkVBZ0FTZ0NGQ0VESUFGQkNHb2dBVUVrYWhDWkFTQUJLQUlJSWdRTlxuQVFVTElBQkJBRFlDQUF3QkN5QUJLQUlzSUFFb0FpaEhCRUFnQUVFQU5nSUFEQUVGQ3lBQktBSU1JUVVnQUNBRU5nSUlJQUFnQXpZQ1xuQkNBQUlBSTJBZ0FnQUNBRk5nSU1DeUFCUVRCcUpBQUx2QUVCQlg4Z0FFRUFOZ0lBQWtBZ0FTZ0NBQ0lESUFKUERRQWdBU0FEUVFGcVxuSWdRMkFnQWdBeTBBQUNJRFFmOEJSZzBBSUFOQmdBRnhSUVJBSUFBZ0F6WUNBRUVCRHdVTElBTkJnQUZHRFFBZ0EwSC9BSEVpQlNBQ1xuSUFScklnSkxEUUFnQkMwQUFFVWdCVUVFUzNJTkFBTkFJQVVFUUNBRUxRQUFJUU1nQVNBRVFRRnFJZ1EyQWdBZ0FDQURJQVpCQ0hSeVxuSWdZMkFnQWdBa0VCYXlFQ0lBVkJBV3NoQlF3QkJRc0xJQUlnQmtrTkFDQUdRZjhBU3lFSEN5QUhDOGNCQWdGL0FYNGpBRUVRYXlJRlxuSkFBZ0FBSi9Ba0FnQXlBRWFrRUJhMEVBSUFOcmNhMGdBYTErSWdaQ0lJaFFCRUFnQnFjaUJFR0FnSUNBZUNBRGEwME5BUVVMSUFCQlxuQURZQ0JFRUJEQUVMSUFSRkJFQWdBQ0FETmdJSUlBQkJBRFlDQkVFQURBRUZDd0ovSUFJRVFDQUZJQU1nQkVFQkVMOEJJQVVvQWdBTVxuQVFVTElBVkJDR29nQXlBRUVQY0JJQVVvQWdnTElnSUVRQ0FBSUFJMkFnZ2dBQ0FCTmdJRVFRQU1BUVVMSUFBZ0JEWUNDQ0FBSUFNMlxuQWdSQkFRczJBZ0FnQlVFUWFpUUFDN29CQVFKL0l3QkJJR3NpQXlRQUFrQUNmMEVBSUFFZ0FTQUNhaUlDU3cwQUdrRUFJQUlnQUNnQ1xuQUNJQlFRRjBJZ1FnQWlBRVN4c2lBa0VJSUFKQkNFc2JJZ1JCQUVnTkFCcEJBQ0VDSUFNZ0FRUi9JQU1nQVRZQ0hDQURJQUFvQWdRMlxuQWhSQkFRVkJBQXMyQWhnZ0EwRUlhaUFFSUFOQkZHb1ExZ0VnQXlnQ0NFRUJSdzBCSUFNb0FoQWhBQ0FES0FJTUN5QUFRZWlJd0FBUVxuendJQUN5QURLQUlNSVFFZ0FDQUVOZ0lBSUFBZ0FUWUNCQ0FEUVNCcUpBQUx4d0VCQVg4akFFRVFheUlMSkFBZ0FDZ0NBQ0FCSUFJZ1xuQUNnQ0JDZ0NEQkVIQUNFQklBdEJBRG9BRFNBTElBRTZBQXdnQ3lBQU5nSUlJQXRCQ0dvZ0F5QUVJQVVnQmhCZUlBY2dDQ0FKSUFvUVxuWGlFQklBc3RBQTBpQWlBTExRQU1JZ055SVFBQ1FDQURRUUZ4SUFKQkFVZHlEUUFnQVNnQ0FDSUFMUUFLUVlBQmNVVUVRQ0FBS0FJQVxuUVllTndBQkJBaUFBS0FJRUtBSU1FUWNBSVFBTUFRVUxJQUFvQWdCQmhvM0FBRUVCSUFBb0FnUW9BZ3dSQndBaEFBc2dDMEVRYWlRQVxuSUFCQkFYRUx2Z0VCQTM4akFFSFFBV3NpQlNRQUlBQW9BZ0FoQnlBRlFhQUJha0VBUVREOEN3QWdCVUdnQVdvaUJpQUVJQUlnQnhFR1xuQUNBRlFSQnFJZ0lnQmtFdy9Bb0FBQ0FGUWZRQWFrRUFRU3o4Q3dBZ0JVRUJOZ0p3SUFBb0FnQWhBQ0FHUVFCQk1Qd0xBQ0FHSUFNZ1xuQlVId0FHb2dBQkVHQUNBRlFVQnJJZ01nQmtFdy9Bb0FBQ0FGUVFocUlBSkJERUVJSUFGQkFYRWJJZ0FnQXlBQUVNMEJJQVVvQWdoQlxuQVhFRVFCRG1BZ0FGQ3lBRktBSU1JQVZCMEFGcUpBQkJBRWNMd2dFQkJuOGpBRUV3YXlJREpBQWdBMEVMYWlJR1FRQkJJZndMQUNBRFxuUVNFMkFpeEI1UFRBQUNnQ0FDRUZJd0JCNEFCcklnSWtBQUpBSUFOQkxHb2lCeWdDQUNJRVFTRkpCRUJCZ3UzQUFDQUZRYlFCYWlnQ1xuQUNBRktBS3dBUkVFQUF3QkJRc2dCMEVBTmdJQUlBSWdCRFlDQkNBR0lBUVFReUVFSUFVZ0FrRUlhaUFCRU1jQlJRMEFJQUpCQ0dvZ1xuQkNBQ1FRUnFRWUFDRU1BQlJRMEFJQWNnQWlnQ0JEWUNBQXNnQWtIZ0FHb2tBQ0FBSUFaQklmd0tBQUFnQTBFd2FpUUFDOEFCQVFSL1xuSXdCQmtBRnJJZ01rQUNBQ1FReEJDQ0FCS0FJQUlnVW9BZ0F0QVBnQkd4Q2JBa1VFUUNBQlFRaHFJUVlEUUNBRVFUQkdSUVJBSUFOQlxuNEFCcUlBUnFJQVFnQm1vb0FnQTJBZ0FnQkVFRWFpRUVEQUVGQ3dzZ0EwRXdhaUFEUWVBQWFrRXcvQW9BQUNBRktBSUVJUVFnQTBIZ1xuQUdvaUJVRUFRVEQ4Q3dBZ0JTQUNJQU5CTUdvZ0JCRUdBQ0FESUFWQk1Qd0tBQUFnQUNBRElBRW9BZ1FSQkFBZ0EwR1FBV29rQUE4RlxuQzBINHc4QUFRVFJCck1UQUFCRHNBUUFMdHdFQkEzOGpBRUhRQUdzaUFpUUFJQUFnQVNnQ2VEWUNVQ0FDUVNocUlnUWdBVUhRQUdvaVxuQTBFb0VDa2FJQVFRY3lBQ0lBUVFvQUVnQWtHSThNQUFFQkFnQXlBQ0VLRUJJQVFnQXhBWElBSWdBeUFFRUE0Z0FTQUJJQVFRRGlBQlxuUVNocUlnTWdBeUFDRUE0Z0FVSFlBR3BDQURjREFDQUJRZ0UzQTFBZ0FVSGdBR3BDQURjREFDQUJRZWdBYWtJQU53TUFJQUZCOEFCcVxuUWdBM0F3QWdBQ0FCUVNnUUtVRW9haUFEUVNnUUtSb2dBa0hRQUdva0FBdXpBUUVFZnlNQVFkQUJheUlFSkFBZ0FDZ0NRQVJBSUFSQlxuQ0dvaUFpQUFRU0JxSWdNUWRDQUNJQUJCSUJBQ0lBSkI0dkhBQUVFQkVBSWdBaUFERUlnQ0lBSWdBeEIwSUFJZ0FFRWdFQUlnQWlBQVxuRUlnQ0JRc2dBRUVnYWlFRlFTQWhBd05BSUFNRVFDQUVRUWhxSWdJZ0JSQjBJQUlnQUVFZ0VBSWdBaUFBRUlnQ0lBTWdBMEVnSUFOQlxuSUVnYklnSnJJUU1nQVNBQUlBSVFLU0FDYWlFQkRBRUZDd3NnQUVFQk5nSkFJQVJCMEFGcUpBQUwwQUVCQlg0Z0FDa0RBQ0FBS1FNZ1xuSWdOQ01JaEMwWWVBZ0JCK2ZDSUNRdi8vLy8vLy8vOEhneUlCUXRDSGdJQVFoU0VFQW44Z0FWQkZCRUJCQUNBRVF2Ly8vLy8vLy84SFxuVWcwQkdnVUxJQUVnQUNrRENDQUNRalNJZkNJQlF2Ly8vLy8vLy84SGc0UWdBQ2tERUNBQlFqU0lmQ0lDUXYvLy8vLy8vLzhIZzRRZ1xuQUNrREdDQUNRalNJZkNJRlF2Ly8vLy8vLy84SGc0UWdBMEwvLy8vLy8vOC9neUFGUWpTSWZDSURoRkFnQVNBRWd5QUNneUFGZ3lBRFxuUW9DQWdJQ0FnTUFIaFlOQy8vLy8vLy8vL3dkUmNnc0xxUUVCQTM4akFFRVFheUlESkFCQkF5RUNJQUF0QUFBaUFDRUVJQUJCQ2s4RVxuUUNBRElBQWdBRUhrQUc0aUJFSGtBR3hyUWY4QmNVRUJkQ0lDUVpHTndBQnFMUUFBT2dBUElBTWdBa0dRamNBQWFpMEFBRG9BRGtFQlxuSVFJRkMwRUFJQUFnQkJ0RkJFQWdBa0VCYXlJQ0lBTkJEV3BxSUFSQkFYUkIvZ0Z4UVpHTndBQnFMUUFBT2dBQUJRc2dBVUVCUVFGQlxuQUNBRFFRMXFJQUpxUVFNZ0Ftc1FOeUFEUVJCcUpBQUx1d0VCQTM4akFFR2dCR3NpQXlRQUlBTkJDR29nQVNBQ0VPZ0JJQU1vQWd3aFxuQVNBREtBSUlJUUlnQTBHd0FXcEJBRUdCQWZ3TEFDQURRZUFBYWlJRVFkQ2V3QUJCd0FEOENnQUFJQU5DQURjRHFBRWdBMElBTndPZ1xuQVNBRUlBSWdBUkJnSUFOQndBSnFJZ1VnQkVIZ0Fmd0tBQUFnQTBFZ2FpSUVJQVVRTFNBRFFSUnFJZ1VnQkVIQUFCQzFBU0FDSUFFUVxuM3dJZ0F5QUZFUGtCSUFNb0FnUWhBU0FBSUFNb0FnQTJBZ0FnQUNBQk5nSUVJQU5Cb0FScUpBQUxsd0VCQlg0Z0FDQUNLUU1BSWdNZ1xuQVNrREFId2lCRGNEQUNBQUlBTWdCRmF0SWdVZ0FTa0RDSHdpQXlBQ0tRTUlmQ0lHTndNSUlBQWdBaWtERUNJSElBRXBBeEI4SWdRZ1xuQXlBRlZLMGdBeUFHVnExOGZDSUZOd01RSUFBZ0Fpa0RHQ0lHSUFFcEF4aDhJZ01nQkNBSFZLMGdCQ0FGVnExOGZDSUVOd01ZSUFBZ1xuQUJEVEFTQURJQVpVclNBRElBUldyWHluYWhDZUFSb0x1QUVCQTM4akFFRWdheUlDSkFBZ0FrRVVhaUFCUVFGQkJFRUVFSU1CSUFJb1xuQWhnaEF3SkFJQUlvQWhSQkFVY0VRQ0FDSUFJb0Fod2lCRFlDRENBQ0lBTTJBZ2dnQWlBQk5nSVFJQUFnQVNBRFNRUi9JQUlnQWtFSVxuYWlBQlFRUkJCQkNRQVNBQ0tBSUFJZ0ZCZ1lDQWdIaEhEUUlnQWlnQ0RDRUVJQUlvQWhBRklBRUxOZ0lFSUFBZ0JEWUNBQ0FDUVNCcVxuSkFBUEJRc2dBeUFDS0FJY1FiaXN3QUFRendJQUN5QUJJQUlvQWdSQnlLekFBQkRQQWdBTHNRRUJCSDhqQUVFUWF5SUdKQUFDZnlBQlxuS0FJQUlnVkZCRUFnQmtFTWFpRUhRUUFNQVFVTElBWWdBellDRENBQktBSUVJUWdnQmtFSWFpRUhJQVFnQld3TElRVWdCeUFGTmdJQVxuQWtBZ0JpZ0NEQ0lGQkVBZ0JpZ0NDQ0VIQWtBZ0FrVUVRQ0FJSUFjUTN3SU1BUVVMSUFnZ0J5QUZJQUlnQkd3aUJCQWZJZ05GRFFJTFxuSUFFZ0FqWUNBQ0FCSUFNMkFnUUZDMEdCZ0lDQWVDRUZDeUFBSUFRMkFnUWdBQ0FGTmdJQUlBWkJFR29rQUF1ZkFRRUZmaUFBSUFFcFxuQXdCQ2Y0VWlBa0srL2FiK3NxN29sc0FBZlNJRFFnQkNmeUFCRUxVQ0d5SUVnemNEQUNBQUlBRXBBd2hDZjRVaUJTQUNJQU5Xclh3aVxuQWtMRnY5MkZsZVBJcU1VQWZTSURJQVNETndNSUlBQWdBU2tERUVKL2hTSUdJQUlnQlZTdElBSWdBMWF0Zkh3aUFrSUNmU0lESUFTRFxuTndNUUlBQWdBaUFHVkswZ0FpQURWcTE4SUFFcEF4aENmNFY4UWdGOUlBU0ROd01ZQzdJQkFRSi9Jd0JCd0FKcklnSWtBQ0FDUVFocVxuSUFFUTh3RWdBaWdDRENBQ0tBSUlJZ0ZDQURjRENDQUJLQUlBSVFNZ0FVSUFOd01BQWtBZ0EwRUJjUVJBSUFKQklHb2lBeUFCUVJCcVxuUWVBQi9Bb0FBQ0FDUVlBQ2FpSUJJQU1RTFNBQ1FSUnFJQUZCd0FBUXRRRU1BUVVMSUFKQkFEWUNIQ0FDUW9DQWdJQVFOd0lVQzBFQVxuTmdJQUlBSWdBa0VVYWhENUFTQUNLQUlFSVFFZ0FDQUNLQUlBTmdJQUlBQWdBVFlDQkNBQ1FjQUNhaVFBQzZvQkFRSi9Jd0JCc0FGclxuSWdJa0FDQUNRUWhxSUFFUTlBRWdBaWdDRENBQ0tBSUlJZ0VvQWdBaEF5QUJRZ0EzQXdBQ1FDQURRUUZ4QkVBZ0FrRWdhaUlESUFGQlxuQ0dwQjhBRDhDZ0FBSUFKQmtBRnFJZ0VnQXhBeElBSkJGR29nQVVFZ0VMVUJEQUVGQ3lBQ1FRQTJBaHdnQWtLQWdJQ0FFRGNDRkF0QlxuQURZQ0FDQUNJQUpCRkdvUStRRWdBaWdDQkNFQklBQWdBaWdDQURZQ0FDQUFJQUUyQWdRZ0FrR3dBV29rQUF1WkFRRUZmeU1BUWNBQlxuYXlJREpBQWdBMEdnQVdvaUJDQUJFSllDSUFOQmdBRnFJZ1VnQVVFZ2FoQ1dBaUFEUWVBQWFpSUdJQUZCUUdzUWxnSWdBMEZBYXlJQlxuSUFJUWxnSWdBMEVnYWlJSElBSkJJR29RbGdJZ0F5QUNRVUJyRUpZQ0lBUWdCU0FHSUFRZ0JTQUdRUUFnQVNBSElBTVFLQ0FBSUFRUVxubGdJZ0FFRWdhaUFGRUpZQ0lBQkJRR3NnQmhDV0FpQURRY0FCYWlRQUM3SUJBZ0ovQkg0akFFRXdheUlESkFBZ0FTa0RDQ0VFSUFFcFxuQXhBaEJTQUJLUU1BSVFZZ0EwRUlhaUlDSUFFcEF4Z2lCMEk0aURjRElDQUNJQVpDLy8vLy8vLy8vLzgvZ3pjREFDQUNJQWRDQm9ZZ1xuQlVJNmlJUkMvLy8vLy8vLy8vOC9nemNER0NBQ0lBVkNCSVlnQkVJOGlJUkMvLy8vLy8vLy8vOC9nemNERUNBQ0lBUkNBb1lnQmtJK1xuaUlSQy8vLy8vLy8vLy84L2d6Y0RDQ0FDUWJEeHdBQVFGaUFBSUFJUXdnRWdBMEV3YWlRQUM1c0JBUU4vSXdCQklHc2lBaVFBSUFBb1xuQWdBaUJFRUJkQ0lEUVFnZ0EwRUlTeHNpQTBFQVNBUkFRUUJCQUNBQkVNOENBQVVMSUFJZ0JBUi9JQUlnQkRZQ0hDQUNJQUFvQWdRMlxuQWhSQkFRVkJBQXMyQWhnZ0FrRUlhaUFESUFKQkZHb1ExZ0VnQWlnQ0NFRUJSZ1JBSUFJb0Fnd2dBaWdDRUNBQkVNOENBQVVMSUFJb1xuQWd3aEFTQUFJQU0yQWdBZ0FDQUJOZ0lFSUFKQklHb2tBQXVXQVFFRGZ5TUFRU0JySWdRa0FBSi9JQUpCQkU4RVFDQUNRWUFDVFFSQVxuUVFFaEJRSkFJQUFvQWd3aUJpQUNSdzBBSUFBb0FnUWlCaUFDUncwQUlBQW9BZ0FpQlNBRklBQW9BZ2dnQVNBRElBSVFLMEVBSVFVTFxuSUFSQkdHb2dCU0FHRUxnQ0lBUW9BaGdNQWdVTElBUkJFR29nQWhEWEFpQUVLQUlRREFFRkN5QUVRUWhxSUFJUTJBSWdCQ2dDQ0FzZ1xuQkVFZ2FpUUFDNDhCQWdGL0FuNGpBRUVRYXlJRElBSTJBZ3dnQUNBRE5BSU1JZ1JDQVgwaUJTQUFLUU1BZzBJQUlBUjlJZ1FnQVNrRFxuQUlPRU53TUFJQUFnQVNrRENDQUVneUFBS1FNSUlBV0RoRGNEQ0NBQUlBRXBBeEFnQklNZ0FDa0RFQ0FGZzRRM0F4QWdBQ0FCS1FNWVxuSUFTRElBQXBBeGdnQllPRU53TVlJQUFnQVNrRElDQUVneUFBS1FNZ0lBV0RoRGNESUF1SkFRRURmeU1BUVJCcklnSWtBQ0FDUVFocVxuSUFGQkFoQmpBa0FDUUFKQUlBSW9BZ2dpQVVVTkFDQUNLQUlNSWdORkRRQWdBU3dBQUNJRVJRUkFJQU5CQVdzaUF3MENRUUFoQVVFQlxuSVFNTUF3VUxJQVJCQUU0TkFndEJBQ0VCREFFTElBRkJBV29pQVN3QUFFRUFTQTBBUVFBaEFRc2dBQ0FETmdJRUlBQWdBVFlDQUNBQ1xuUVJCcUpBQUxrZ0VCQW44akFFRVFheUlFSkFBQ2Z5QURLQUlFQkVBZ0F5Z0NDQ0lGUlFSQUlBUkJDR29nQVNBQ1FRQVF2d0VnQkNnQ1xuQ0NFRElBUW9BZ3dNQWdVTElBTW9BZ0FnQlNBQklBSVFIeUVESUFJTUFRVUxJQVFnQVNBQ0VQY0JJQVFvQWdBaEF5QUVLQUlFQ3lFRlxuSUFBZ0F5QUJJQU1iTmdJRUlBQWdBMFUyQWdBZ0FDQUZJQUlnQXhzMkFnZ2dCRUVRYWlRQUM1Z0JBUUYvSXdCQklHc2lCaVFBQWtBZ1xuQVFSQUlBWkJGR29nQVNBRElBUWdCU0FDS0FJUUVRb0FJQUFnQmlnQ0hDSUJJQVlvQWhSSkJIOGdCa0VJYWlBR1FSUnFJQUZCQkVFRVxuRUxvQklBWW9BZ2dpQVVHQmdJQ0FlRWNOQWlBR0tBSWNCU0FCQ3pZQ0JDQUFJQVlvQWhnMkFnQWdCa0VnYWlRQUR3VUxRWVNsd0FCQlxuTWhEeUFnQUxJQUVnQmlnQ0RFSDBwTUFBRU04Q0FBdUxBUUVFZnlNQVFhQUNheUlESkFBZ0EwR1FBV29pQkNBQkVQb0NJQU5Cd0FGcVxuSWdVZ0FVRXdhaEQ2QWlBRFFmQUJhaUlHSUFGQjRBQnFFUG9DSUFNZ0FoRDZBaUFEUVRCcUlBSkJNR29RK2dJZ0EwSGdBR29nQWtIZ1xuQUdvUStnSWdCQ0FFSUFNUVBpQUFJQVFRK2dJZ0FFRXdhaUFGRVBvQ0lBQkI0QUJxSUFZUStnSWdBMEdnQW1va0FBdVFBUUVGZmlBQVxuS1FNSUlBQXBBd0FnQUNrRElDSUJRakNJUXRHSGdJQVFmbndpQWtJMGlId2lBeUFDaENBQUtRTVFJQU5DTkloOElnU0VJQUFwQXhnZ1xuQkVJMGlId2lCWVJDLy8vLy8vLy8vd2VESUFGQy8vLy8vLy8vUDRNZ0JVSTBpSHdpQVlSUUlBTWdBa0xRaDRDQUVJV0RJQVNESUFXRFxuSUFGQ2dJQ0FnSUNBd0FlRmcwTC8vLy8vLy8vL0IxRnlDNFVCQVFWK0lBQWdBQ2tEQUNJRUlBR3RJZ0pDdi8ybS9yS3U2SmJBQUg1OFxuSWdVM0F3QWdBQ0FBS1FNSUlnWWdBa0xFdjkyRmxlUElxTVVBZm53aUF5QUVJQVZXclh3aUJEY0RDQ0FBSUFBcEF4QWlCU0FDZkNJQ1xuSUFNZ0JsU3RJQU1nQkZhdGZId2lBemNERUNBQUlBQXBBeGdnQWlBRlZLMGdBaUFEVnExOGZEY0RHQ0FCQzRnQkFDQUNJQU5MQkVBalxuQUVFd2F5SUFKQUFnQUNBRE5nSUVJQUFnQWpZQ0FDQUFRUUkyQWd3Z0FFR0VrTUFBTmdJSUlBQkNBamNDRkNBQUlBQkJCR3F0UW9DQVxuZ0lEZ0FJUTNBeWdnQUNBQXJVS0FnSUNBNEFDRU53TWdJQUFnQUVFZ2FqWUNFQ0FBUVFocUlBUVFld0FGQ3lBQUlBTWdBbXMyQWdRZ1xuQUNBQklBSkJBblJxTmdJQUM1Z0JBUVYrSUFFcEF3QWhCU0FCS1FNSUlRSWdBU2tERUNFRElBRXBBeGdoQkNBQUlBRXBBeUFpQmtJb1xuaURjRElDQUFJQVpDRm9aQ2dJQ0Evdi8vLy84L2d5QUVRaDZJaERjREdDQUFJQVJDSUlaQ2dJQ0FnUEQvLy84L2d5QURRaFNJaERjRFxuRUNBQUlBTkNLb1pDZ0lDQWdJQ0EvLzgvZ3lBQ1FncUloRGNEQ0NBQUlBVWdBa0kwaG9SQy8vLy8vLy8vLy84L2d6Y0RBQXVVQVFFRlxuZmlBQktRTUlJUUlnQVNrREVDRURJQUVwQXlBaEJTQUJLUU1ZSVFRZ0FDQUJLUU1BSWdaQy8vLy8vLy8vL3dlRE53TUFJQUFnQlVJb1xuaGlBRVFoYUloRGNESUNBQUlBUkNIb1pDZ0lDQWdQei8vd2VESUFOQ0lJaUVOd01ZSUFBZ0EwSVVoa0tBZ01ELy8vLy9CNE1nQWtJcVxuaUlRM0F4QWdBQ0FDUWdxR1FvRDQvLy8vLy84SGd5QUdRalNJaERjRENBdUdBUUVEZnlNQVFTQnJJZ0lrQUNBQlFRUnFJUU5CQVNFRVxuQWtBZ0FTZ0NBRUVCUmdSQUlBTVF1UUloQVF3QkJRc2dBa0VZYWlBRFFRaHFLQUlBTmdJQUlBSWdBeWtDQURjREVDQUNRUWhxSUFKQlxuRUdwQjlLVEFBQkM5QVNBQ0tBSUlJUUVnQUNBQ0tBSU1OZ0lJUVFBaEJBc2dBQ0FFTmdJQUlBQWdBVFlDQkNBQ1FTQnFKQUFMYmdFR1xuZmlBQUlBTkMvLy8vL3crRElnVWdBVUwvLy8vL0Q0TWlCbjRpQnlBR0lBTkNJSWdpQm40aUNDQUZJQUZDSUlnaUNYNThJZ1ZDSUlaOFxuSWdvM0F3QWdBQ0FISUFwV3JTQUdJQWwrSUFVZ0NGU3RRaUNHSUFWQ0lJaUVmSHdnQVNBRWZpQUNJQU4rZkh3M0F3Z0xwUUVCQW44alxuQUVHZ0FXc2lCQ1FBSUFSQkFEWUNuQUVnQkVFQU5nS1FBU0FFUXF1emoveVJvN1B3MndBM0EwZ2dCRUwvcExtSXhaSGFncHQvTndOQVxuSUFSQzh1YTc0Nk9uL2FlbGZ6Y0RPQ0FFUXVmTXA5RFcwT3V6dTM4M0F6QWdCRUV3YWlJRklBRkJJQkFDSUFJZ0JDQUVRWmdCYWtFQlxuRU1BQkdpQUZJQVJCSVJBQ0lBVWdBMEVnRUFJZ0JTQUVFR2tnQUNBRUlBUkJuQUZxRUVJZ0JFR2dBV29rQUF0L0FRSi9Jd0JCRUdzaVxuQkNRQUFuOGdBeWdDQkNJRlFRUlBCRUFnQlVHQUFrMEVRRUVBSUFJZ0JVY05BaG9nQVNBQklBRWdBeWdDQUNBRFFRaHFJQUlRSzBFRFxuREFJRkN5QUVRUWhxSUFVUTF3SWdCQ2dDQ0F3QkJRc2dCQ0FGRU5nQ0lBUW9BZ0FMRVBVQklBQWdBallDQkNBQUlBRTJBZ0FnQkVFUVxuYWlRQUMxNEFJQUFnQVNBRWZDQURRaitKSUFOQ09JbUZJQU5DQjRpRmZDQUdRaTJKSUFaQ0E0bUZJQVpDQm9pRmZEY0RBQ0FBSUFGQ1xuUDRrZ0FVSTRpWVVnQVVJSGlJVWdBbndnQlh3Z0IwSXRpU0FIUWdPSmhTQUhRZ2FJaFh3M0F3Z0xjUUlDZndGK0lBRkJCR29oQXlBQVxuUVFScUlRUWdBRFVDQUNBQk5RSUFmU0VGSUFKQkFTQUNRUUZMRzBFQmF5RUNBMzhnQlVJZ2lLZEJBWEVoQUNBQ0JIOGdBa0VCYXlFQ1xuSUFRMUFnQWdBelVDQUNBQXJYeDlJUVVnQTBFRWFpRURJQVJCQkdvaEJBd0JCVUVBSUFCckN3c0xlUUlCZndKK0l3QkJFR3NpQXlBQ1xuTmdJTUlBQWdBelFDRENJRVFnRjlJZ1VnQUNrREFJTkNBQ0FFZlNJRUlBRXBBd0NEaERjREFDQUFJQUVwQXdnZ0JJTWdBQ2tEQ0NBRlxuZzRRM0F3Z2dBQ0FCS1FNUUlBU0RJQUFwQXhBZ0JZT0VOd01RSUFBZ0FTa0RHQ0FFZ3lBQUtRTVlJQVdEaERjREdBdDNBUUovSXdCQlxuMEFCcklnTWtBQ0FBSUFGQktCQXBJUUFnQTBFb2FpSUVJQUVRRnlBRElBRWdCQkFPSUFCQkFEWUNVQ0FEUWJqd3dBQVEzd0VDZjBFQVxuSUFCQktHb2lBQ0FERUNCRkRRQWFJQUFRYWtFQklBQW9BZ0JCQVhFZ0FrWU5BQm9nQUNBQVFRRVF6d0ZCQVFzZ0EwSFFBR29rQUF1V1xuQVFFQ2ZpQUFJQUFwQXdBZ0FDa0RJQ0lDUWpDSVF0R0hnSUFRZm53aUFVTC8vLy8vLy8vL0I0TTNBd0FnQUNBQUtRTUlJQUZDTkloOFxuSWdGQy8vLy8vLy8vL3dlRE53TUlJQUFnQUNrREVDQUJRalNJZkNJQlF2Ly8vLy8vLy84SGd6Y0RFQ0FBSUFBcEF4Z2dBVUkwaUh3aVxuQVVMLy8vLy8vLy8vQjRNM0F4Z2dBQ0FDUXYvLy8vLy8veitESUFGQ05JaDhOd01nQzRrQkFRSi9Jd0JCRUdzaUFpUUFJQUFReGdJQ1xuUUNBQUtBSUFSUVJBSUFBb0FnUWhBU0FBUVFnUXpBRkIwSUVFUWRBQklBRW9BZ2diSWdCQmdJREFBSElnQUNBQktBSUFHeUVBSUFFUVxudVFFZ0FFSHgvLy8vQjA4TkFTQUJJQUFRekFFZ0FrRVFhaVFBRHdVTEVPc0NBQXRCanREQUFFRXJJQUpCRDJwQjdKL0FBRUg4bjhBQVxuRUs4QkFBdDNBUUovSXdCQlFHb2lBeVFBSUFOQkVHb2dBQkQ5QVNBREtBSVVJUUFnQTBFSWFpQUJJQUlRNkFFZ0EwRWNhaUFES0FJSVxuSWdFZ0F5Z0NEQ0lDRUdZZ0F5MEFIQ0lFQkVBZ0F5Z0NJQ0FES0FJa0VPQUNCUXNnQVNBQ0VOOENJQUFnQUNnQ0FFRUJhellDQUNBRFxuUVVCckpBQWdCRUVCY3d1R0FRRUJmeU1BUWVBQmF5SURKQUFnQTBFb2FrRUFRY0VBL0FzQUlBTkJHR3BCc0o3QUFDa0RBRGNEQUNBRFxuUVJCcVFhaWV3QUFwQXdBM0F3QWdBMEVJYWtHZ25zQUFLUU1BTndNQUlBTkNBRGNESUNBRFFaaWV3QUFwQXdBM0F3QWdBeUFCSUFJUVxuWVNBRFFmQUFhaUlCSUFOQjhBRDhDZ0FBSUFBZ0FSQXhJQU5CNEFGcUpBQUxiZ0VFZmlBQ3JTRUVRUUFoQWdOL0lBTUVmeUFBSUFBMVxuQWdBZ0FxMGdBVFVDQUNBRWZpSUZRdi8vLy84UGczd2lCa0wvLy8vL0Q0TjhJZ2MrQWdBZ0JrSWdpQ0FGUWlDSWZDQUhRaUNJZktjaFxuQWlBQVFRUnFJUUFnQVVFRWFpRUJJQU5CQVdzaEF3d0JCU0FDQ3dzTGVnRUJmeU1BUVVCcUlnVWtBQ0FGSUFFMkFnd2dCU0FBTmdJSVxuSUFVZ0F6WUNGQ0FGSUFJMkFoQWdCVUVDTmdJY0lBVkIwSXpBQURZQ0dDQUZRZ0kzQWlRZ0JTQUZRUkJxclVLQWdJQ0FNSVEzQXpnZ1xuQlNBRlFRaHFyVUtBZ0lDQXdBQ0VOd013SUFVZ0JVRXdhallDSUNBRlFSaHFJQVFRZXdBTGRnRUNmeU1BUWVBQWF5SUVKQUFnQkVFd1xuYWlJRlFRQkJNUHdMQUNBRklBRVE5QUlnQkNBRlFURDhDZ0FBSUFKQkFXc2hBUU5BSUFFRVFDQUVJQVFROUFJZ0FVRUJheUVCREFFRlxuQ3dzZ0JFRXdhaUlCUVFCQk1Qd0xBQ0FCSUFRZ0F4RDVBaUFBSUFGQk1Qd0tBQUFnQkVIZ0FHb2tBQXQ5QVFGL0l3QkJzQU5ySWdVa1xuQUNBRklBSWdBU2dDQ0JFRUFDQUZRYUFDYWtFQVFaQUIvQXNBSUFWQm9BSnFJZ0lnQXlBRUlBUkJNR29nQVNnQ0RCRUlBQ0FGUVpBQlxuYWlJRElBSkJrQUg4Q2dBQUlBSkJBRUdRQWZ3TEFDQUNJQVVnQXlBQktBSVFFUVlBSUFBZ0FrR1FBZndLQUFBZ0JVR3dBMm9rQUF0WFxuQUNBQUlBSkNNb2tnQWtJdWlZVWdBa0lYaVlVZ0NYd2dDSHdnQkNBR2hTQUNneUFHaFh3aUFpQUhmRGNEQ0NBQUlBTWdCWVVnQVlNZ1xuQXlBRmc0VWdBVUlraVNBQlFoNkpoU0FCUWhtSmhYd2dBbnczQXdBTGNnQWdBQUovSUFKQklFY0VRQ0FBUVFScVFRWWdBaEEyUVFFTVxuQVFVTElBQWdBUzhBQURzQUFTQUFJQUVwQUFzM0FBd2dBQ0FCS1FBRE53SUVJQUJCQTJvZ0FVRUNhaTBBQURvQUFDQUFRUlJxSUFGQlxuRTJvcEFBQTNBQUFnQUVFWmFpQUJRUmhxS1FBQU53QUFRUUFMT2dBQUM0TUJBQ0FBSUFFcEF3QkMvLy8vLy8vLy93ZUROd01BSUFBZ1xuQVNrRENFSU1oa0tBNFAvLy8vLy9CNE1nQVNrREFFSTBpSVEzQXdnZ0FDQUJLUU1RUWhpR1FvQ0FnUGovLy84SGd5QUJLUU1JUWlpSVxuaERjREVDQUFJQUVwQXhoQ0pJWkNnSUNBZ0lEKy93ZURJQUVwQXhCQ0hJaUVOd01ZSUFBZ0FTa0RHRUlRaURjRElBdDBBUU4vSXdCQlxuRUdzaUF5UUFJQU5CQkdvZ0FrRUFRUUZCQVJDREFTQURLQUlJSVFRZ0F5Z0NCRUVCUndSQUlBTW9BZ3doQlNBQ0JFQWdCU0FCSUFMOFxuQ2dBQUJRc2dBQ0FDTmdJSUlBQWdCVFlDQkNBQUlBUTJBZ0FnQTBFUWFpUUFEd1VMSUFRZ0F5Z0NERUhjbjhBQUVNOENBQXRuQVFKL1xuSXdCQjBBQnJJZ0lrQUNBQ1FTaHFJZ01nQVVIUUFHb1FGeUFESUFNZ0FCQU9JQUlnQVVFb0VDa2lBQkNxQVNNQVFUQnJJZ0VrQUNBQlxuUVFocUlnSWdBRUVvYWtFQkVNOEJJQUlnQUJEZkFTQUNFSXNCSUFGQk1Hb2tBQ0FBUWRBQWFpUUFDMndCQTM4akFFRkFhaUlESkFBZ1xuQTBFSWFpQUJJQUlRNkFFZ0EwRWdhaUlFSUFNb0FnZ2lBU0FES0FJTUlnSVFyUUVnQTBFVWFpSUZJQVJCSUJDMUFTQUJJQUlRM3dJZ1xuQXlBRkVQa0JJQU1vQWdRaEFTQUFJQU1vQWdBMkFnQWdBQ0FCTmdJRUlBTkJRR3NrQUF0OEFRRi9Jd0JCRUdzaUF5UUFRZXowd0FCQlxuN1BUQUFDZ0NBQ0lFUVFGcU5nSUFBa0FnQkVFQVNBMEFBa0JCdVBqQUFDMEFBRVVFUUVHMCtNQUFRYlQ0d0FBb0FnQkJBV28yQWdCQlxuNlBUQUFDZ0NBRUVBVGcwQkRBSUZDeUFEUVFocUlBQWdBUkVFQUFBTFFiajR3QUJCQURvQUFDQUNSUTBBQUFzQUMzTUFBa0FDUUNBQVxuUWVUMHdBQW9BZ0JHQkVCQm51ckFBQ0FBUWJRQmFpZ0NBQ0FBS0FLd0FSRUVBQXdCQlFzZ0FFVU5BUXNnQUVJQU53SUFJQUJCRUdwQ1xuQURjREFDQUFRUmhxUWdBM0F3QWdBRUVnYWtJQU53TUFJQUJCS0dwQ0FEY0RBQ0FBUVRCcUVMQUNJQUJCQURZQ0NBc0xjUUVCZnlNQVxuUVNCcklnVWtBQ0FCS0FJQUlBSkpCRUFnQlVFQU5nSVlJQVZCQVRZQ0RDQUZRZFRUd0FBMkFnZ2dCVUlFTndJUUlBVkJDR3BCck5UQVxuQUJCN0FBVUxJQVVnQVNBQ0lBTWdCQkNRQVNBRktBSUVJUUVnQUNBRktBSUFOZ0lBSUFBZ0FUWUNCQ0FGUVNCcUpBQUxZQUVCZjBFQlxuSVFjQ1FDQUFJQUVnQlNBR0VHMGdCQ0FHUjNJTkFDQUZJQU1nQmhDbkFTSUFSU0VISUFJZ0FFVnlEUUJCQUNFSEEwQWdCU2dDQUNBSFxuY2lFSElBVkJCR29oQlNBR1FRRnJJZ1lOQUFzZ0J4QytBa0VBUnlFSEN5QUhDMlFCQkg4Z0FrSGdBQkNuQWlBQ1FTQnFJUVFnQUVFQlxuYXlFRkEwQWdBMEVQUmdSQUlBSkJRR3NpQVNBQUlBRkJrTm5BQUJCdUJTQUNJQU1nQlhNaUJpQUJJQUlRYmlBRUlBWWdBVUVnYWlBRVxuRUc0Z0FVRkFheUVCSUFOQkFXb2hBd3dCQ3dzTGJBRUNmeU1BUVJCcklnTWtBQUpBSUFBZ0FTZ0NDQ0lFSUFFb0FnQkpCSDhnQTBFSVxuYWlBQklBUkJBVUVCRUxvQklBTW9BZ2dpQkVHQmdJQ0FlRWNOQVNBQktBSUlCU0FFQ3pZQ0JDQUFJQUVvQWdRMkFnQWdBMEVRYWlRQVxuRHdzZ0JDQURLQUlNSUFJUXp3SUFDM1lCQVg4akFFR0FBV3NpQUNRQUlBQkJPR3BCQUVIQkFQd0xBQ0FBUVNocVFiQ2V3QUFwQXdBM1xuQXdBZ0FFRWdha0dvbnNBQUtRTUFOd01BSUFCQkdHcEJvSjdBQUNrREFEY0RBQ0FBUWdBM0F6QWdBRUlCTndNSUlBQkJtSjdBQUNrRFxuQURjREVDQUFRUWhxRU5ZQ0lBQkJnQUZxSkFBTGFBRUJmd0pBSUFKRkJFQWdBU0VFREFFRkMwSFUrTUFBTFFBQUdpQURSUVJBSUFJZ1xuQVJDNkFpRUVEQUVGQ3lBQ0VBZ2lBVVVOQUNBQlFRUnJMUUFBUVFOeFJTQUNSWEpGQkVBZ0FVRUFJQUw4Q3dBRkN5QUJJUVFMSUFBZ1xuQWpZQ0JDQUFJQVEyQWdBTFpRRUNmeUFBS0FKUVJRUkFJQUFRYWlBQVFTaHFJZ1VRYWtFQklRUWdBVUVCYWlBQUVFUWdBd1JBSUFKQlxuSVRZQ0FDQUJRUUpCQXlBRktRTUFRZ0dEVUJzNkFBQkJBUThGQ3lBQ1FjRUFOZ0lBSUFGQkJEb0FBQ0FCUVNGcUlBVVFSQVVMSUFRTFxuYUFFQmZ5TUFRU0JySWdVa0FDQUNJQU5KQkVBZ0JVRUFOZ0lZSUFWQkFUWUNEQ0FGUWVpMHdBQTJBZ2dnQlVJRU53SVFJQVZCQ0dvZ1xuQkJCN0FBVUxJQUFnQXpZQ0JDQUFJQUUyQWdBZ0FDQUNJQU5yTmdJTUlBQWdBU0FEYWpZQ0NDQUZRU0JxSkFBTFhnRUVmaUFCS1FNQVxuSVFRZ0FTa0RDQ0VDSUFFcEF4QWhBeUFBSUFFcEF5QkNPSVlnQVNrREdDSUZRZ2FJaERjREdDQUFJQVZDT29ZZ0EwSUVpSVEzQXhBZ1xuQUNBRFFqeUdJQUpDQW9pRU53TUlJQUFnQkNBQ1FqNkdoRGNEQUF0cUFRRi9Jd0JCTUdzaUF5UUFJQU1nQVRZQ0JDQURJQUEyQWdBZ1xuQTBFQ05nSU1JQU5CcEl2QUFEWUNDQ0FEUWdJM0FoUWdBeUFEclVLQWdJQ0E0QUNFTndNb0lBTWdBMEVFYXExQ2dJQ0FnT0FBaERjRFxuSUNBRElBTkJJR28yQWhBZ0EwRUlhaUFDRUhzQUMyb0JBWDhqQUVFd2F5SURKQUFnQXlBQU5nSUVJQU1nQVRZQ0FDQURRUU0yQWd3Z1xuQTBIb2tNQUFOZ0lJSUFOQ0FqY0NGQ0FESUFOQkJHcXRRb0NBZ0lEZ0FJUTNBeWdnQXlBRHJVS0FnSUNBNEFDRU53TWdJQU1nQTBFZ1xuYWpZQ0VDQURRUWhxSUFJUWV3QUxaQUVCZnlNQVFSQnJJZ01rQUNBRFFRaHFJQUFROHdFZ0F5Z0NEQ0FES0FJSUlRQWdBeUFCSUFJUVxuNkFFZ0F5Z0NCQ0VCSUFNb0FnQWhBaUFBS0FJQVFRRnhCRUFnQUVFUWFpQUNJQUVRWUFVTElBSWdBUkRmQWtFQU5nSUFJQU5CRUdva1xuQUF0a0FRRi9Jd0JCRUdzaUF5UUFJQU5CQ0dvZ0FCRDBBU0FES0FJTUlBTW9BZ2doQUNBRElBRWdBaERvQVNBREtBSUVJUUVnQXlnQ1xuQUNFQ0lBQW9BZ0JCQVVZRVFDQUFRUWhxSUFJZ0FSQmhCUXNnQWlBQkVOOENRUUEyQWdBZ0EwRVFhaVFBQzJjQkFYOGpBRUZBYWlJRFxuSkFBZ0FTQURJQUpCd0FBUUtTSURFTEVDUVFFaEFpQUJLUU1nSUFFcEF4Z2dBU2tERUNBQktRTUlJQUVwQXdDRWhJU0VVQVJBUWVUc1xud0FBZ0FFRzBBV29vQWdBZ0FDZ0NzQUVSQkFCQkFDRUNCUXNnQTBGQWF5UUFJQUlMWndFQmZ5TUFRVEJySWdRa0FDQUVJQUUyQWdRZ1xuQkNBQU5nSUFJQVJCQWpZQ0RDQUVJQU0yQWdnZ0JFSUNOd0lVSUFRZ0JFRUVhcTFDZ0lDQWdPQUFoRGNES0NBRUlBU3RRb0NBZ0lEZ1xuQUlRM0F5QWdCQ0FFUVNCcU5nSVFJQVJCQ0dvZ0FoQjdBQXRyQVFOL0l3QkJFR3NpQVNRQUFrQWdBQkNDQWtFUWFpSUNRZkgvLy84SFxuU1FSQVFkVDR3QUF0QUFBYUlBSkJFQkM2QWlJRERRRUFCUXRCanREQUFFRXJJQUZCRDJwQmlLSEFBRUhNbzhBQUVLOEJBQXNnQXlBQ1xuTmdJQUlBTkJFR29nQUJBTElBRkJFR29rQUF0aUFRRi9Jd0JCUUdvaUF5UUFJQU5CRUdwQkFFRXcvQXNBSUFOQkNHb2dBa0VBUVF4QlxuQ0NBQlFRRnhHeUlCUWZEQ3dBQVFud0VnQTBFUWFpSUNJQUVnQXlnQ0NDQURLQUlNUVlERHdBQVFrd0lnQUNBQ1FURDhDZ0FBSUFOQlxuUUdza0FBdHlBZ0ovQVg0Z0FDa0RHQ0lEUWorSXB5SUNRWDl6SWdFZ0FDa0RFRUovVW5FZ0EwTC8vLy8vLy8vLy8vOEFWSElnQUNrRFxuQ0NJRFFwMmdrYjIxenR1cjNRQlVJQUZ4Y2tGL2N5SUJJQU5DbmFDUnZiWE8yNnZkQUZaeElBSnlJQUVnQUNrREFFS2d3ZXpBNXVqTFxuOUY5V2NYSUxYZ0VDZndKQUlBQkJCR3NvQWdBaUFrRjRjU0lEUVFSQkNDQUNRUU54SWdJYklBRnFUd1JBSUFKQkFDQURJQUZCSjJwTFxuR3cwQklBQVFLZzhGQzBHeDBzQUFRUzVCNE5MQUFCRHNBUUFMUWZEU3dBQkJMa0dnMDhBQUVPd0JBQXRhQUNBQ0lBUkhCSDlCQVFWQlxuQUNFRUEwQWdBZ1JBSUFKQkFXc2hBaUFES0FJQUlBRW9BZ0J6SUFSeUlRUWdBMEVFYWlFRElBRkJCR29oQVF3QkJRc0xJQVFRdmdJaFxuQWtFQUN5RURJQUFnQWpZQ0JDQUFJQU0yQWdBTFZ3QWdBQ0FCS1FNQUlBRXBBd2hDTklhRU53TUFJQUFnQVNrREVFSW9oaUFCS1FNSVxuUWd5SWhEY0RDQ0FBSUFFcEF4aENISVlnQVNrREVFSVlpSVEzQXhBZ0FDQUJLUU1nUWhDR0lBRXBBeGhDSklpRU53TVlDMnNCQW40Z1xuQUNBQ1FRRnFyU0lEUXQ3dy8vL2YvLzhQZmlBQktRTUFmVGNEQUNBQUlBTkMvdi8vLy8vLy93OStJZ1FnQVNrRENIMDNBd2dnQUNBRVxuSUFFcEF4QjlOd01RSUFBZ0JDQUJLUU1ZZlRjREdDQUFJQU5DL3YvLy8vLy8vd0IrSUFFcEF5QjlOd01nQzFZQkFuOGpBRUV3YXlJRlxuSkFBZ0JVRUFRVEQ4Q3dCQkFTRUdJQUFnQXlBRVFRQWdBVUVNUVFnZ0FrRUJjUnNpQVNBRklBRVF1d0VFZjBFQkJTQUFRUVJxSUFWQlxuTVB3S0FBQkJBQXMyQWdBZ0JVRXdhaVFBQzFZQUl3QkJNR3NpQVNRQUlBRWdBQkN6QWpZQ0RDQUJJQUEyQWdnZ0FVRUJOZ0lVSUFFZ1xuQXpZQ0VDQUJRZ0UzQWh3Z0FVRUpOZ0lzSUFFZ0FVRW9hallDR0NBQklBRkJDR28yQWlnZ0FVRVFhaUFDRUhzQUMxWUJBWDhqQUVFUVxuYXlJRUpBQUNmeUFBUlFSQVFRQWhBQ0FFUVF4cURBRUZDeUFFSUFJMkFnd2dBQ0FEYkNFQUlBUkJDR29MSUFBMkFnQWdCQ2dDRENJQVxuQkVBZ0FTQUVLQUlJRU44Q0JRc2dCRUVRYWlRQUMyUUNBbjhDZmlBQUtRTVlRbjlTSUFBcEF4QWlBMEorVkhJaUFTQUFLUU1JSWdSQ1xudThDaSt1cWN0OWU2ZjFSeVFYOXpJZ0lnQkVLN3dLTDY2cHkzMTdwL1ZuRWdBVUYvY3lBRFFuOVJjWElnQUNrREFFTEFndG1CemRHWFxuNmI5L1ZpQUNjWElMVmdFQmZ3Si9RUUFnQVNnQ0FFRUJSdzBBR2lBQktBSUVJZ0lnQVNnQ0NFY0VRQ0FCSUFKQkFXbzJBZ1FnQVNBQ1xuYWkwQURDRUJRUUVNQVFVTElBRkJBRFlDQUVFQUN5RUNJQUFnQVRvQUFTQUFJQUk2QUFBTFVnSUNmd0orUVNBaEFVRUZJUUlDZndOQVxuUVFBZ0FrRUJheUlDUVFCSURRRWFJQUFnQVdvcEF3QWlBeUFCUWVEd3dBQnFLUU1BSWdSV0JFQkJBUThGQ3lBQlFRaHJJUUVnQXlBRVxuV2cwQUMwRi9Dd3RhQVFGL0FuOGdBaWdDQkFSQUFrQWdBaWdDQ0NJRFJRUkFEQUVGQ3lBQ0tBSUFJQU5CQVNBQkVCOE1BZ3NGQzBIVVxuK01BQUxRQUFHaUFCRUFnTElRSWdBQ0FCTmdJSUlBQWdBa0VCSUFJYk5nSUVJQUFnQWtVMkFnQUxTd0VDZnlNQVFkQUFheUlDSkFBZ1xuQWtFb2FpSURJQUZCS0JBcEdpQURFSE1nQWlBQlFTaHFRU2dRS1NJQkVITWdBQ0FCUVNocUVNNEJJQUJCSUdvZ0FSRE9BU0FCUWRBQVxuYWlRQUMwb0JBMzhqQUVFd2F5SURKQUFnQTBFSWFpSUVJQUVRRnlBQUlBQWdCQkFPSUFCQktHb2lBaUFDSUFRUURpQUNJQUlnQVJBT1xuSUFCQjBBQnFJZ0FnQUNBQkVBNGdBMEV3YWlRQUMxZ0JBMzhqQUVId0FXc2lBaVFBSUFKQm1NbkFBQkR5QVNBQ1FUQnFJZ05CeU1uQVxuQUJEeUFTQUNRZUFBYWtFQVFaQUIvQXNBSUFKQjRBQnFJZ1FnQVNBQ0lBTVFPeUFBSUFSQmtBSDhDZ0FBSUFKQjhBRnFKQUFMU1FFQ1xuZjBFTUlRTkJmeUVDQTM4Z0F3Ui9JQUlnQWtGL2MzRWdBa0VBSUFFb0FnQWdBQ2dDQUVZYmNpRUNJQUZCQkdvaEFTQUFRUVJxSVFBZ1xuQTBFQmF5RUREQUVGSUFJTEN3dFRBUUYvSUFFRVFDTUFRUkJySWdNa0FDQURRUWhxSUFFZ0FoRG9BU0FES0FJSUlRRWdBQ0FES0FJTVxuSWdJMkFnZ2dBQ0FCTmdJRUlBQWdBallDQUNBRFFSQnFKQUFQQlFzZ0FFR0FnSUNBZURZQ0FBdFdBUUYvSXdCQjhBRnJJZ0FrQUNBQVxuUWVBQWFrRUFRWUVCL0FzQUlBQkJFR3BCMEo3QUFFSEFBUHdLQUFBZ0FFSUFOd01JSUFCQ0FUY0RBQ0FBUWdBM0ExZ2dBRUlBTndOUVxuSUFBUTFBSWdBRUh3QVdva0FBdFJBUU4vQWtBZ0FTMEFDQTBBSUFFb0FnQWlCQ0FCS0FJRUlnTkxEUUFnQXlBRVRRUkFRUUVoQWlBQlxuUVFFNkFBZ01BUVVMSUFFZ0EwRUJhellDQkVFQklRSUxJQUFnQXpZQ0JDQUFJQUkyQWdBTFNRRUNmeU1BUWRBQWF5SURKQUFnQTBFb1xuYWlJRUlBSVFGeUFESUFRZ0FoQU9JQUFnQVNBRUVBNGdBRUVvYWlBQlFTaHFJQU1RRGlBQUlBRW9BbmcyQWxBZ0EwSFFBR29rQUF0U1xuQUNBQUlBQXBBd0FnQVNrREFIdzNBd0FnQUNBQUtRTUlJQUVwQXdoOE53TUlJQUFnQUNrREVDQUJLUU1RZkRjREVDQUFJQUFwQXhnZ1xuQVNrREdIdzNBeGdnQUNBQUtRTWdJQUVwQXlCOE53TWdDMDhCQW44Z0FDZ0NCQ0VDSUFBb0FnQWhBd0pBSUFBb0FnZ2lBQzBBQUVVTlxuQUNBRFFmaU13QUJCQkNBQ0tBSU1FUWNBUlEwQVFRRVBDeUFBSUFGQkNrWTZBQUFnQXlBQklBSW9BaEFSQlFBTFNBRURmd0pBSUFJZ1xuQVNnQ0NDSUNhaUlESUFKSkRRQWdBeUFCS0FJRVN3MEFJQUVnQXpZQ0NDQURJQUpySVFVZ0FTZ0NBQ0FDYWlFRUN5QUFJQVUyQWdRZ1xuQUNBRU5nSUFDendCQVg4Z0FFRUFRUUFnQWtFRmRpSUFheUlEUVFGeGF6WUNBQ0FCSUFCQkFXc2dBbkZCUHlBQ2F5QURjWElpQUVFQlxuZGlBQVFRRnhhallDQUF0UkFRSi9Jd0JCRUdzaUFTUUFJQUFRdVFFZ0FFRVFheUlBS0FJQUlnSkI4Zi8vL3dkUEJFQkJqdERBQUVFclxuSUFGQkQycEJpS0hBQUVIY284QUFFSzhCQUFVTElBQWdBaERNQVNBQlFSQnFKQUFMUlFFQmZ5QUFJQUVvQW5nMkFuZ2dBQ0FCUVNnUVxuS1NJQ1FTaHFJQUZCS0dwQktCQXBJUUFnQWtIUUFHb2dBVUhRQUdwQktCQXBHaUFBRUtvQklBQWdBRUVCRU04QkMwZ0JBWDRnQUNBQlxuclNJQ0lBQXBBd0IrTndNQUlBQWdBQ2tEQ0NBQ2ZqY0RDQ0FBSUFBcEF4QWdBbjQzQXhBZ0FDQUFLUU1ZSUFKK053TVlJQUFnQUNrRFxuSUNBQ2ZqY0RJQXRFQVFOL0FrQWdBa1VOQUFOQUlBQXRBQUFpQkNBQkxRQUFJZ1ZHQkVBZ0FFRUJhaUVBSUFGQkFXb2hBU0FDUVFGclxuSWdJTkFRd0NCUXNMSUFRZ0JXc2hBd3NnQXd0S0FRRi9JQUFvQWdBZ0FDZ0NDQ0lEYXlBQ1NRUkFJQUFnQXlBQ0VJUUJJQUFvQWdnaFxuQXdVTElBSUVRQ0FBS0FJRUlBTnFJQUVnQXZ3S0FBQUZDeUFBSUFJZ0EybzJBZ2hCQUF0RkFRRi9Jd0JCSUdzaUF5UUFJQU1nQWpZQ1xuSENBRElBRTJBaGdnQXlBQ05nSVVJQU5CQ0dvZ0EwRVVha0dRMXNBQUVMMEJJQUFnQXlrRENEY0RBQ0FEUVNCcUpBQUxRZ0VCZnlNQVxuUVRCcklnUWtBQ0FFSUFFUWp3SWdBa0VCYXlFQkEwQWdBUVJBSUFGQkFXc2hBU0FFRVBjQ0RBRUZDd3NnQUNBRUlBTVFrQUlnQkVFd1xuYWlRQUN6NEJBMzhnQWtGL2N5RUVBMEFnQTBFd1J3UkFJQUFnQTJvaUJTQUNJQUVnQTJvb0FnQnhJQVVvQWdBZ0JIRnlOZ0lBSUFOQlxuQkdvaEF3d0JCUXNMQzBFQkFYOGpBQ0FCYXlJRkpBQWdCU0FEYWlBQUlBVDhDZ0FBSUFFZ0F4QzJBaUlBUVFBMkFnQWdBRUVFYWlBRlxuUVFScUlBTDhDZ0FBSUFVZ0FXb2tBQ0FBQzBFQkFYOGpBRUVnYXlJREpBQWdBMEVBTmdJUUlBTkJBVFlDQkNBRFFnUTNBZ2dnQXlBQlxuTmdJY0lBTWdBRFlDR0NBRElBTkJHR28yQWdBZ0F5QUNFSHNBQzBNQkFYOGpBRUVRYXlJQ0pBQWdBaUFBUVFocU5nSU1JQUZCdVpQQVxuQUVFTlFjYVR3QUJCQ3lBQVFRcEIwWlBBQUVFSUlBSkJER3BCQ3hDRkFTQUNRUkJxSkFBTFF3RUJmeU1BUVJCcklnSWtBQ0FDSUFCQlxuQkdvMkFnd2dBVUhNc01BQVFRVkIwYkRBQUVFS0lBQkJHVUhic01BQVFSRWdBa0VNYWtFYUVJVUJJQUpCRUdva0FBczVBUUovUVF3aFxuQVFOL0lBRUVmeUFCUVFGcklRRWdBQ2dDQUNBQ2NpRUNJQUJCQkdvaEFBd0JCU0FDUVFGcklBSkJmM054UVI5MUN3c0xQd0VDZnlNQVxuUWRBQWF5SUNKQUFnQWtFb2FpSURJQUZCS0JBcEdpQURFR29nQWlBREVLQUJJQUpCaVBEQUFCQVdJQUFnQWhDaEFTQUNRZEFBYWlRQVxuQ3pnQUlBTWdBU0FCSUFOTEd5RUJBMEFnQVFSQUlBQWdBaTBBQURvQUFDQUJRUUZySVFFZ0FrRUJhaUVDSUFCQkFXb2hBQXdCQlFzTFxuQ3pzQkFuOGpBRUV3YXlFREEwQWdBa0V3UmtVRVFDQUNJQU5xSUFFZ0Ftb29BZ0EyQWdBZ0FrRUVhaUVDREFFRkN3c2dBQ0FEUVREOFxuQ2dBQUN6c0JBWDhqQUVFUWF5SUNKQUFnQVJER0FpQUNRUWhxSUFFUTdRSWdBaWdDRENFQklBQWdBaWdDQ0RZQ0FDQUFJQUUyQWdRZ1xuQWtFUWFpUUFDenNCQVg4akFFRVFheUlDSkFBZ0FSREdBaUFDUVFocUlBRVE3QUlnQWlnQ0RDRUJJQUFnQWlnQ0NEWUNBQ0FBSUFFMlxuQWdRZ0FrRVFhaVFBQzA0QUlBQkJBMGNFUUFKQUFrQUNRQ0FBUVFGckRnSUJBZ0FMUWRERHdBQkJLRUhvc3NBQUVPd0JBQXRCME1QQVxuQUVFb1FmaXl3QUFRN0FFQUMwSFF3OEFBUVNoQmlMUEFBQkRzQVFBRkN3czVBQUpBSUFGcFFRRkhJQUJCZ0lDQWdIZ2dBV3RMY2cwQVxuSUFBRVFFSFUrTUFBTFFBQUdpQUFJQUVRdWdJaUFVVU5BUVVMSUFFUEN3QUxPZ0VCZnlNQVFSQnJJZ01rQUNBRFFRaHFJQUVnQWtFQVxuRUw4QklBTW9BZ3doQVNBQUlBTW9BZ2cyQWdBZ0FDQUJOZ0lFSUFOQkVHb2tBQXM1QUFKQUlBSkJnSURFQUVZTkFDQUFJQUlnQVNnQ1xuRUJFRkFFVU5BRUVCRHdzZ0EwVUVRRUVBRHdVTElBQWdBeUFFSUFFb0Fnd1JCd0FMT3dFQmZ5TUFRUkJySWdJa0FDQUNRUWhxSUFGQlxuOUtUQUFCQzlBU0FDS0FJTUlRRWdBQ0FDS0FJSU5nSUFJQUFnQVRZQ0JDQUNRUkJxSkFBTE5RQWdBQ0FCSUFFUXpRSWdBa0VCSUFKQlxuQVVzYlFRRnJJUUlEUUNBQ0JFQWdBQ0FBSUFBUXpRSWdBa0VCYXlFQ0RBRUZDd3NMTmdFQ2Z5TUFRVUJxSWdNa0FDQURRU0JxSWdRZ1xuQVJDV0FpQURJQUlRbGdJZ0JDQUVJQU1RQkNBQUlBUVFsZ0lnQTBGQWF5UUFDem9CQW44Z0FDQUJLQUlJSWdJZ0FTZ0NCRThpQXdSL1xuUVFBRklBRWdBa0VCYWpZQ0NDQUJLQUlBSUFKcUxRQUFDem9BQVNBQUlBTTZBQUFMTmdFQmZ5QUJFTVlDSUFFb0FnQWlBa0YvUmdSQVxuRU9zQ0FBVUxJQUVnQWtFQmFqWUNBQ0FBSUFFMkFnUWdBQ0FCUVFScU5nSUFDelVCQVg4akFFRVFheUlCSkFBZ0FCREdBaUFCUVFocVxuSUFBUTdRSWdBU2dDREVFQU5nSUFJQUJCZ0FJUXpBRWdBVUVRYWlRQUN6VUJBWDhqQUVFUWF5SUJKQUFnQUJER0FpQUJRUWhxSUFBUVxuN0FJZ0FTZ0NERUVBTmdJQUlBQkJnQUVRekFFZ0FVRVFhaVFBQ3kwQUFrQWdBMmxCQVVjZ0FVR0FnSUNBZUNBRGEwdHlEUUFnQUNBQlxuSUFNZ0FoQWZJZ0JGRFFBZ0FBOExBQXN4QUNBQUtBSWNJQUFvQWhnZ0FDZ0NGQ0FBS0FJUUlBQW9BZ3dnQUNnQ0NDQUFLQUlFSUFBb1xuQWdCeWNuSnljbkp5Q3pZQUlBQkIvd0Z4UVFGSEJFQkJrT3JBQUVFQUVPUUNRUUFQQlFzZ0FFRU1kRUdBZ01BQWNVSFFnUVJCMEFFZ1xuQUVHQUJIRWJjZ3N2QVFGL0l3QkJFR3NpQWlRQUlBQWdBU0FDUVF4cUVFSWdBaWdDRENFQklBQVF0UUlnQWtFUWFpUUFJQUZ5UlFzd1xuQVFGL0l3QkJFR3NpQlNRQUlBVWdBVFlDRENBRklBQTJBZ2dnQlVFSWFpQUVJQVZCREdvZ0JDQUNJQU1RYkFBTE13RUJmeU1BUVNCclxuSWdJa0FDQUNRUUEyQWhnZ0FrRUJOZ0lNSUFJZ0FUWUNDQ0FDUWdRM0FoQWdBa0VJYWlBQUVIc0FDenNCQVg4Z0FTZ0NBRUdBZ0lDQVxuZUVZRWYwRUFCU0FCS0FJRUlBRW9BZ2dRQUNFQ0lBRVE0d0pCQVFzaEFTQUFJQUkyQWdRZ0FDQUJOZ0lBQ3k4QkFuNGdBQ0FBS1FOQVxuSWdNZ0FxMThJZ1EzQTBBZ0FDQUFLUU5JSUFNZ0JGYXRmRGNEU0NBQUlBRWdBaEFIQ3k0QkFYOGpBRUVnYXlJQ0pBQWdBQ0FDRUdrZ1xuQUVIa0FHb2lBQ0FDUVNBUUFpQUFJQUVRYVNBQ1FTQnFKQUFMTUFFQmZ5TUFRUkJySWdJa0FDQUNJQUFvQWdBMkFnd2dBVUdNb01BQVxuUVJJZ0FrRU1ha0VDRUhvZ0FrRVFhaVFBQ3pBQkFYOGpBRUVRYXlJQ0pBQWdBaUFBS0FJQU5nSU1JQUZCb0xUQUFFRUpJQUpCREdwQlxuREJCNklBSkJFR29rQUFzM0FDQUJLQUlBSUFBb0FnQkIwQUJxTFFBQVFRSjBJZ0JCdE5iQUFHb29BZ0FnQUVHZzFzQUFhaWdDQUNBQlxuS0FJRUtBSU1FUWNBQ3pBQkFYOGpBRUV3YXlJQ0pBQWdBa0VBUVREOEN3QWdBaUFCUVFFUStnRWdBQ0FDUVREOENnQUFJQUpCTUdva1xuQUFzd0FRRi9Jd0JCTUdzaUF5UUFJQU5CQUVFdy9Bc0FJQU1nQVNBQ0VNMENJQUFnQTBFdy9Bb0FBQ0FEUVRCcUpBQUxMd0VCZnlNQVxuUVRCcklnUWtBQ0FFUVFCQk1Qd0xBQ0FFSUFFZ0FoRDZBU0FBSUFRZ0F4Q05BaUFFUVRCcUpBQUxNQUVCZnlNQVFUQnJJZ0lrQUNBQ1xuUVFCQk1Qd0xBQ0FDSUFFZ0FSRGRBaUFBSUFKQk1Qd0tBQUFnQWtFd2FpUUFDekFCQVg4akFFRXdheUlESkFBZ0EwRUFRVEQ4Q3dBZ1xuQXlBQklBSVEzUUlnQUNBRFFURDhDZ0FBSUFOQk1Hb2tBQXN0QVFGL0l3QkJFR3NpQWlRQUlBSWdBRFlDRENBQlFlaXV3QUJCRHlBQ1xuUVF4cVFSc1FlaUFDUVJCcUpBQUxLUUFnQVNBRFN3UkFJQUVnQXlBRUVPRUNBQVVMSUFBZ0F5QUJhellDQkNBQUlBRWdBbW8yQWdBTFxuS3dBZ0FTQURSZ1JBSUFGQkFuUWlBUVJBSUFBZ0FpQUIvQW9BQUFVTER3VUxJQUVnQXlBRUVNUUJBQXNuQVFGL1FRRWhCaUFESUFWSFxuSUFFZ0EwZHlCSDlCQVFVZ0FDQUFJQUlnQkNBREVIRkJBQXNMTUFBZ0FTZ0NBQ0FBTFFBTVFRSjBJZ0JCNE5iQUFHb29BZ0FnQUVISVxuMXNBQWFpZ0NBQ0FCS0FJRUtBSU1FUWNBQ3lrQkFYOERRQ0FDUVNCSEJFQWdBQ0FDYWlBQklBSnFMUUFBT2dBQUlBSkJBV29oQWd3QlxuQlFzTEN5Z0JBWDhqQUVFZ2F5SUNKQUFnQWlBQkVKWUNJQUlnQWhBRklBQWdBaENXQWlBQ1FTQnFKQUFMS1FBZ0FTZ0NBRVVFUUNBQlxuUVg4MkFnQWdBQ0FCTmdJRUlBQWdBU0FDYWpZQ0FBOEZDeERyQWdBTEtRRUJmd05BSUFNZ0FrY0VRQ0FBSUFOcUlBRWdBMm9vQWdBMlxuQWdBZ0EwRUVhaUVEREFFRkN3c0xMd0VCZnlBQktBSUFRWUNBZ0lCNFJnUi9RUUFGSUFFUXVRSWhBVUVCQ3lFQ0lBQWdBVFlDQkNBQVxuSUFJMkFnQUxKZ0VCZndOQUlBQW9BZ0FnQW5JaEFpQUFRUVJxSVFBZ0FVRUJheUlCRFFBTElBSVF2Z0lMSlFFQmZ5TUFRVUJxSWdJa1xuQUNBQ0lBRVExd0VnQUNBQ1FjQUFFQ2thSUFKQlFHc2tBQXNtQUNBQklBTkdCRUFnQVFSQUlBQWdBaUFCL0FvQUFBVUxEd1VMSUFFZ1xuQXlBRUVNUUJBQXNqQVFGL1FRRWhCQ0FEUlNBQklBTkhjZ1IvUVFFRklBQWdBQ0FDSUFNUWNrRUFDd3NtQVFGL0lBQUVRRUhBQUNBQVxuYmlJQklBQWdBV3hCd0FCSGFnOEZDMEh3dE1BQUVQNENBQXNwQUNBQklBTkdCRUFnQVFSQUlBQWdBaUFCL0FvQUFBVUxEd1VMSUFFZ1xuQTBIc3Q4QUFFTVFCQUFzakFDQUNRUXhCQ0NBQlFRRnhHeUlCSUFNZ0FTQUFJQUVRbEFJRVFCRG1BZ0FGQ3dza0FRRi9BMEFnQVVFb1xuUmtVRVFDQUFJQUZxUWdBM0F3QWdBVUVJYWlFQkRBRUZDd3NMSXdBZ0FTQURTd1JBSUFFZ0F5QUVFT0lDQUFVTElBQWdBVFlDQkNBQVxuSUFJMkFnQUxKZ0FnQUVVRVFFR0VwY0FBUVRJUThnSUFCUXNnQUNBQ0lBTWdCQ0FGSUFFb0FoQVJDd0FMSWdBRFFDQUJCRUFnQUVFQVxuT2dBQUlBRkJBV3NoQVNBQVFRRnFJUUFNQVFVTEN3c2pBUUYvQTBBZ0FVRXdSd1JBSUFBZ0FXcEJBRFlDQUNBQlFRUnFJUUVNQVFVTFxuQ3dzaUFBTkFJQUVFUUNBQVFRQTZBQUFnQUVFQmFpRUFJQUZCQVdzaEFRd0JCUXNMQzBrQUlBQkJBRFlDWUNBQVFxdXpqL3lSbzdQd1xuMndBM0FoZ2dBRUwvcExtSXhaSGFncHQvTndJUUlBQkM4dWE3NDZPbi9hZWxmemNDQ0NBQVF1Zk1wOURXME91enUzODNBZ0FMSkFBZ1xuQUVVRVFFR0VwY0FBUVRJUThnSUFCUXNnQUNBQ0lBTWdCQ0FCS0FJUUVRZ0FDeVFBSUFCRkJFQkJoS1hBQUVFeUVQSUNBQVVMSUFBZ1xuQWlBRElBUWdBU2dDRUJFSkFBc2tBQ0FBUlFSQVFZU2x3QUJCTWhEeUFnQUZDeUFBSUFJZ0F5QUVJQUVvQWhBUkhBQUxKQUFnQUVVRVxuUUVHRXBjQUFRVElROGdJQUJRc2dBQ0FDSUFNZ0JDQUJLQUlRRVIwQUN5UUFJQUJGQkVCQmhLWEFBRUV5RVBJQ0FBVUxJQUFnQWlBRFxuSUFRZ0FTZ0NFQkVZQUFzZEFRRi9Jd0JCTUdzaUFTUUFJQUZCQ0dvZ0FCQWdJQUZCTUdva0FBc2lBQ0FBUlFSQVFZU2x3QUJCTWhEeVxuQWdBRkN5QUFJQUlnQXlBQktBSVFFUVlBQ3g4QUlBQkJBRFlDZUNBQUVLSUNJQUJCS0dvUW9nSWdBRUhRQUdvUW9nSUxIUUFnQUNBQlxuRUxRQklBQkJLR29nQVVFZ2FoQzBBU0FBUVFBMkFsQUxId0FnQUVFQk5nSjRJQUFRb2dJZ0FFRW9haENpQWlBQVFkQUFhaENpQWdzZVxuQVFGL0EzOGdBQ0FCYWkwQUFBUi9JQUZCQVdvaEFRd0JCU0FCQ3dzTElBQWdBRVVFUUVHRXBjQUFRVElROGdJQUJRc2dBQ0FDSUFFb1xuQWhBUkJRQUxHZ0FnQUNrREdDQUFLUU1RSUFBcEF3Z2dBQ2tEQUlTRWhGQUxIQUJCMVBqQUFDMEFBQm9nQUNBQkVMb0NJZ0JGQkVBQVxuQlFzZ0FBc1lBQ0FBSUFBcEF5QWdBcTE4TndNZ0lBQWdBU0FDRUFZTEdBQWdBQ0FDTmdJRUlBQkJBRUVESUFGQkFYRWJOZ0lBQ3h3QlxuQVg4Z0FDZ0NCQ0lCSUFBb0FnZ1FBQ0FBS0FJQUlBRVE0QUlMRmdBZ0FVRUpUd1JBSUFFZ0FCQkhEd1VMSUFBUUNBc1hBQ0FCSUFOR1xuQkg4Z0FDQUNJQUVRNWdFRlFRRUxSUXNjQUNBQUtBSUFJQUFvQWdRUXpBSWdBQ2dDRkNBQUtBSVlFTXdDQ3hjQUlBRkZCRUJCekxUQVxuQUJEK0FnQUZDeUFBSUFGdUN4QUFJQUJCQVdzZ0FFRi9jM0ZCSDNVTEZnQWdBRUVBTmdKUUlBQVFvZ0lnQUVFb2FoQ2lBZ3NaQUNBQlxuS0FJQVFiU1R3QUJCQlNBQktBSUVLQUlNRVFjQUN4a0JBWDhnQUNnQ0FDSUJCRUFnQUNnQ0JDQUJFTXdCQlFzTEdRQWdBU2dDQUVHb1xub2NBQVFRc2dBU2dDQkNnQ0RCRUhBQXNaQUNBQktBSUFRY3k3d0FCQkN5QUJLQUlFS0FJTUVRY0FDeGtBSUFFb0FnQkJuS2pBQUVFS1xuSUFFb0FnUW9BZ3dSQndBTEZBQWdBQ0FBSUFFUStnRWdBQ0FBSUFJUXpRSUxGQUFnQUFSQUR3VUxRYnpVd0FCQkd4RHlBZ0FMRXdBZ1xuQVNnQ0JCb2dBRUdVaU1BQUlBRVFPQXNVQUNBQUtBSUFJQUVnQUNnQ0JDZ0NEQkVGQUFzVEFDQUJLQUlFR2lBQVFlQ013QUFnQVJBNFxuQ3c4QUlBQWdBU0FCSUFKcUVHZEJBQXNYQUNBQUtBSUFRWUNBZ0lCNFJ3UkFJQUFRNHdJRkN3c1NBQ0FCQkVBZ0FDQUJRUUowRU13QlxuQlFzTEZnQWdBQ0FCSUFKQmdOZkFBRUdnMThBQVFRZ1FLd3NRQUNBQUlBRWdBaUFESUFSQkRCQXJDdzhBSUFBRVFBQUZDeUFDRVAwQ1xuQUFzU0FDQUFJQUVnQWlBRFFiU0x3QUFRaEFJTEVnQWdBQ0FCSUFJZ0EwR1lvY0FBRUlRQ0N4QUFJQUVvQWdBZ0FTZ0NCQ0FBRURnTFxuRUFBZ0FTQUFLQUlBSUFBb0FnUVFHZ3NTQUNBQVFZQUNRZndCUVJCQjhBRVE2d0VMRWdBZ0FDQUJJQUlnQTBHZ204QUFFTUVCQ3hJQVxuSUFCQmdBRkIvQUJCQ0VINEFCRHJBUXNRQUNBQUlBRTJBZ1FnQUVFQ05nSUFDeEFBSUFBZ0FUWUNCQ0FBUVFFMkFnQUxFZ0FnQUNBQlxuSUFJZ0EwSHN0Y0FBRU1FQkN4SUFJQUJCeU1iQUFDQUJJQUlnQXhDeEFRc1NBQ0FBUWZqSndBQWdBU0FDSUFNUXNRRUxGUUFnQUNBQlxuSUFKQnNOZkFBRUhRMk1BQUVNNENDeFVBSUFBZ0FTQUNRZURYd0FCQmtOakFBQkRPQWdzUkFDQUFJQUVnQWtHdzE4QUFRUXdRY1FzUFxuQUNBQkJFQWdBQ0FCRU13QkJRc0xEUUFnQUNBQlFRRkJBUkRTQVFzUUFDQUFJQUVnQWtHd2o4QUFFTWdCQ3hBQUlBQWdBU0FDUWRDUFxud0FBUXlBRUxEd0FnQUNnQ0FDQUFLQUlFRU9BQ0N4TUFJQUFnQVVHWXBNQUFRWkNrd0FBUTBRRUxFd0FnQUNBQlFlU2t3QUJCM0tUQVxuQUJEUkFRc1NBRUhRdzhBQVFTaEJ2TVRBQUJEc0FRQUxEd0FnQVFSQUlBQWdBUkRNQVFVTEN3OEFJQUFnQVVHdzE4QUFRUXdRY2dzTFxuQUNBQUl3QnFKQUFqQUFzTEFDQUFLQUlBSUFFUVVRc09BRUhYMU1BQVFjOEFFUElDQUFzTEFDQUFJQUZCQ0JDWUFnc0xBQ0FBSUFGQlxuRUJDWUFnc01BQ0FBS0FJQUlBRVE2Z0lMRFFBZ0FFSEVrc0FBSUFFUU9Bc0tBQ0FBSUFGQkFSQUhDd29BSUFBZ0FVRUJFQVlMQ1FBZ1xuQUNBQkVBRUFDdzBBSUFGQnVkREFBRUVDRUJvTEN3QWdBQ0FCSUFFUStRSUxEZ0FnQUVIa3hzQUFJQUVRaUFFTERnQWdBRUdVeXNBQVxuSUFFUWlBRUxDd0FnQUNBQUlBQVEzUUlMREFBZ0FDQUJLUUlBTndNQUN3c0FJQUFnQVNBQ0VOd0NDd3NBSUFBZ0FVRXdFSmtDQ3dzQVxuSUFBZ0FTQUJFTndDQ3dzQUlBQWdBVUVnRUprQ0N3d0FJQUJCd0lqQUFCQ0ZBZ3NNQUNBQVFmU093QUFRaFFJTENRQWdBRUVBTmdJQVxuQ3djQUlBQW9BZ0FMQzdWdkxnQkJnSURBQUF1aENTOWhjSEF2Ylc5a2RXeGxjeTlsWTJGemFDMXpaV053TWpVMmF6RXZjM0pqTDJWalxuWkhOaEwzTmxjbWxoYkdsNlpXUmZjMmxuYm1GMGRYSmxMbkp6QUFCSUFBQUFZWFIwWlcxd2RDQjBieUJ6WlhRZ2JHVnVaM1JvSUhSdlxuSUNCaWRYUWdkR2hsSUcxaGVHbHRkVzBnYVhNZ0FBQUFSQUFRQUJrQUFBQmRBQkFBRkFBQUFBQUFFQUErQUFBQXRRQUFBQWtBQUFCbVxuWm1rZ2NtVjBkWEp1WldRZ2FXNTJZV3hwWkNCU1pXTnZkbVZ5ZVVsa0lRQUpFQUF5QUFBQWFRQUFBQjRBQUFCaGMzTmxjblJwYjI0Z1xuWm1GcGJHVmtPaUJsY25JZ1BUMGdNUUFBQUFrUUFESUFBQUJtQUFBQURRQUFBQUFBQUFBSUFBQUFCQUFBQUNBQUFBQkpibU52Y25KbFxuWTNSVGFXZHVZWFIxY21WSmJuWmhiR2xrVFdWemMyRm5aVWx1ZG1Gc2FXUlFkV0pzYVdOTFpYbEpiblpoYkdsa1UybG5ibUYwZFhKbFxuU1c1MllXeHBaRk5sWTNKbGRFdGxlVWx1ZG1Gc2FXUlRhR0Z5WldSVFpXTnlaWFJKYm5aaGJHbGtVbVZqYjNabGNubEpaRWx1ZG1Gc1xuYVdSVWQyVmhhMDV2ZEVWdWIzVm5hRTFsYlc5eWVVbHVkbUZzYVdSUWRXSnNhV05MWlhsVGRXMUpiblpoYkdsa1JXeHNVM2RwWm5SdFxuYjJSMWJHVnpMMlZqWVhOb0xXeHBZaTEzWVhOdEwzTnlZeTlsWTJNdWNuTUFBTEVCRUFBaEFBQUFBQUVBQUJzQUFBQkpiblpoYkdsa1xuSUhKbFkyOTJaWEo1SUVsRU9pQUFBQURrQVJBQUZRQUFBRWx1ZG1Gc2FXUWdjMmxuYm1GMGRYSmxJR1p2Y20xaGRFbHVkbUZzYVdRZ1xuYlhObklHeGxibWQwYUNBQUhBSVFBQk1BQUFCVGFXZHVZWFIxY21VZ2NtVmpiM1psY25rZ1ptRnBiR1ZrU1c1MllXeHBaQ0J6WldOeVxuWlhRZ2EyVjVJSE5wZW1Vc0lHVjRjR1ZqZEdWa0lETXlJR0o1ZEdWeklHSjFkQ0JuYjNRZ1VRSVFBRE1BQUFCVFpXTnlaWFFnYTJWNVxuSUc1dmRDQjJZV3hwWkNCbWIzSWdjMlZqY0RJMU5tc3hTVzUyWVd4cFpDQndkV0pzYVdNZ2EyVjVJSE5wZW1Vc0lHVjRjR1ZqZEdWa1xuSURNeklHSjVkR1Z6SUdKMWRDQm5iM1FnQUFBQXJnSVFBRE1BQUFCUWRXSnJaWGtnYTJWNUlHNXZkQ0IyWVd4cFpDQm1iM0lnYzJWalxuY0RJMU5tc3hTVzUyWVd4cFpDQnpZMkZzWVhJZ2MybDZaU3dnWlhod1pXTjBaV1FnTXpJZ1lubDBaWE1nWW5WMElHZHZkQ0FBQUFBT1xuQXhBQUx3QUFBRk5qWVd4aGNpQnViM1FnZG1Gc2FXUWdabTl5SUhObFkzQXlOVFpyTVVsdWRtRnNhV1FnYldWemMyRm5aU0J6YVhwbFxuTENCbGVIQmxZM1JsWkNBek1pQmllWFJsY3lCaWRYUWdaMjkwSUFBQVpnTVFBREFBQUFCSmJuWmhiR2xrSUVSRlVpQnphV2R1WVhSMVxuY21VZ1ptOXliV0YwU1c1MllXeHBaQ0JUWTJodWIzSnlJSE5wWjI1aGRIVnlaU0J6YVhwbExDQmxlSEJsWTNSbFpDQTJOQ0JpZVhSbFxuY3lCaWRYUWdaMjkwSUFBQXZBTVFBRG9BQUFCSmJtTnZjbkpsWTNRZ2MybG5ibUYwZFhKbEFDRUFBQUFNQUFBQUJBQUFBQ0lBQUFBalxuQUFBQUpBQUFBR05oY0dGamFYUjVJRzkyWlhKbWJHOTNBQUFBTEFRUUFCRUFBQUJzYVdKeVlYSjVMMkZzYkc5akwzTnlZeTl5WVhkZlxuZG1WakwyMXZaQzV5YzBnRUVBQWdBQUFBTGdJQUFCRUFBQUJzYVdKeVlYSjVMMkZzYkc5akwzTnlZeTl6ZEhKcGJtY3Vjbk1BZUFRUVxuQUJzQUFBRG9BUUFBRndCQnJJbkFBQXV0Q1FFQUFBQWxBQUFBWVNCbWIzSnRZWFIwYVc1bklIUnlZV2wwSUdsdGNHeGxiV1Z1ZEdGMFxuYVc5dUlISmxkSFZ5Ym1Wa0lHRnVJR1Z5Y205eUlIZG9aVzRnZEdobElIVnVaR1Z5YkhscGJtY2djM1J5WldGdElHUnBaQ0J1YjNSc1xuYVdKeVlYSjVMMkZzYkc5akwzTnlZeTltYlhRdWNuTUFBQW9GRUFBWUFBQUFpZ0lBQUE0QUFBQjRCQkFBR3dBQUFIMEZBQUFiQUFBQVxuS1Z0allXeHNaV1FnWUU5d2RHbHZiam82ZFc1M2NtRndLQ2xnSUc5dUlHRWdZRTV2Ym1WZ0lIWmhiSFZsYVc1a1pYZ2diM1YwSUc5bVxuSUdKdmRXNWtjem9nZEdobElHeGxiaUJwY3lBZ1luVjBJSFJvWlNCcGJtUmxlQ0JwY3lBQWNRVVFBQ0FBQUFDUkJSQUFFZ0FBQUFBQVxuQUFBRUFBQUFCQUFBQUNZQUFBQTlQV0Z6YzJWeWRHbHZiaUJnYkdWbWRDQWdjbWxuYUhSZ0lHWmhhV3hsWkFvZ0lHeGxablE2SUFvZ1xuY21sbmFIUTZJQUFBeGdVUUFCQUFBQURXQlJBQUZ3QUFBTzBGRUFBSkFBQUFJSEpwWjJoMFlDQm1ZV2xzWldRNklBb2dJR3hsWm5RNlxuSUFBQUFNWUZFQUFRQUFBQUVBWVFBQkFBQUFBZ0JoQUFDUUFBQU8wRkVBQUpBQUFBT2lBQUFBRUFBQUFBQUFBQVRBWVFBQUlBQUFBQVxuQUFBQURBQUFBQVFBQUFBbkFBQUFLQUFBQUNrQUFBQWdJQ0FnSUhzZ0xDQWdld29zQ24wZ2ZTZ29DZ3BkTUhnd01EQXhNREl3TXpBMFxuTURVd05qQTNNRGd3T1RFd01URXhNakV6TVRReE5URTJNVGN4T0RFNU1qQXlNVEl5TWpNeU5ESTFNall5TnpJNE1qa3pNRE14TXpJelxuTXpNME16VXpOak0zTXpnek9UUXdOREUwTWpRek5EUTBOVFEyTkRjME9EUTVOVEExTVRVeU5UTTFORFUxTlRZMU56VTROVGsyTURZeFxuTmpJMk16WTBOalUyTmpZM05qZzJPVGN3TnpFM01qY3pOelEzTlRjMk56YzNPRGM1T0RBNE1UZ3lPRE00TkRnMU9EWTROemc0T0RrNVxuTURreE9USTVNemswT1RVNU5qazNPVGc1T1dGMGRHVnRjSFFnZEc4Z1pHbDJhV1JsSUdKNUlIcGxjbThBQUFCWUJ4QUFHUUFBQUhKaFxuYm1kbElITjBZWEowSUdsdVpHVjRJQ0J2ZFhRZ2IyWWdjbUZ1WjJVZ1ptOXlJSE5zYVdObElHOW1JR3hsYm1kMGFDQjhCeEFBRWdBQVxuQUk0SEVBQWlBQUFBY21GdVoyVWdaVzVrSUdsdVpHVjRJTUFIRUFBUUFBQUFqZ2NRQUNJQUFBQnpiR2xqWlNCcGJtUmxlQ0J6ZEdGeVxuZEhNZ1lYUWdJR0oxZENCbGJtUnpJR0YwSUFEZ0J4QUFGZ0FBQVBZSEVBQU5BQUFBWTI5d2VWOW1jbTl0WDNOc2FXTmxPaUJ6YjNWeVxuWTJVZ2MyeHBZMlVnYkdWdVozUm9JQ2dwSUdSdlpYTWdibTkwSUcxaGRHTm9JR1JsYzNScGJtRjBhVzl1SUhOc2FXTmxJR3hsYm1kMFxuYUNBb0FBQUFGQWdRQUNZQUFBQTZDQkFBS3dBQUFFUUZFQUFCQUFBQUwyRndjQzl0YjJSMWJHVnpMMlZqWVhOb0xYTmxZM0F5TlRaclxuTVM5emNtTXZjMk5vYm05eWNtRmlZeTV5Y3dBQWdBZ1FBQzRBQUFBYUFBQUFEUUFBQUM5aGNIQXZiVzlrZFd4bGN5OWxZMkZ6YUMxelxuWldOd01qVTJhekV2YzNKakwyVmpaSE5oTDIxdlpDNXljd0FBQU1BSUVBQXRBQUFBQXdFQUFBMEFBQUF2WVhCd0wyMXZaSFZzWlhNdlxuWldOaGMyZ3RjMlZqY0RJMU5tc3hMM055WXk5bFkyUnpZUzl5WldOdmRtVnllUzV5Y3dBQUFBa1FBRElBQUFDbkFBQUFEUUFBQUNvQVxuQUFBTUFBQUFCQUFBQUNzQUFBQXNBQUFBTFFCQjVKTEFBQXZOQmdFQUFBQXVBQUFBWVNCRWFYTndiR0Y1SUdsdGNHeGxiV1Z1ZEdGMFxuYVc5dUlISmxkSFZ5Ym1Wa0lHRnVJR1Z5Y205eUlIVnVaWGh3WldOMFpXUnNlUUNjS0JBQVN3QUFBTkVLQUFBT0FBQUFSWEp5YjNKU1xuYzJGUVlYSmhiV1YwWlhKemNHRmtaR2x1WjE5aGJHZHRhVzVmWW1sMGN6RXVNeTR4TXpJdU1DNHpNekV1TWk0NE5EQXVNVEF3TkRVdVxuTXk0eExqY3hMak11TVRNeUxqQXVNelF4TGpNdU1UTXlMakF1TXpWaGJuTnBjRFV5TVhJeFlXNXphWEF5TWpSeU1URXVNaTQ0TkRBdVxuTVRBd05EQXVOQzR4TVM0eUxqZzBNQzR4TURBME1DNDBMakl4TGpJdU9EUXdMakV3TURRd0xqUXVNekV1TWk0NE5EQXVNVEV6TlRRNVxuTGpFdU1TNHhNUzR5TGpnME1DNHhNVE0xTkRrdU1TNHhMakl4TGpJdU9EUXdMakV4TXpVME9TNHhMakV1TXpFdU1pNDROREF1TVRFelxuTlRRNUxqRXVNUzQwTVM0eUxqZzBNQzR4TVRNMU5Ea3VNUzR4TGpVeExqSXVPRFF3TGpFeE16VTBPUzR4TGpFdU1URXhMakl1T0RRd1xuTGpFeE16VTBPUzR4TGpFdU1USXhMakl1T0RRd0xqRXhNelUwT1M0eExqRXVNVE14TGpJdU9EUXdMakV4TXpVME9TNHhMakV1TVRReVxuTGpFMkxqZzBNQzR4TGpFd01TNHpMalF1TWk0NE1pNHhOaTQ0TkRBdU1TNHhNREV1TXk0MExqSXVPVEl1TVRZdU9EUXdMakV1TVRBeFxuTGpNdU5DNHlMakV3TVM0eUxqZzBNQzR4TURBME5TNHlMakV4TGpJdU9EUXdMakV3TURRMUxqUXVNVEV1TWk0NE5EQXVNVEF3TkRVdVxuTkM0ekxqRXhMakl1T0RRd0xqRXdNRFExTGpRdU15NHlNUzR5TGpnME1DNHhNREEwTlM0MExqTXVNekV1TWk0NE5EQXVNVEF3TkRVdVxuTkM0ekxqUmxZMlJ6WVZkcGRHaFRTRUUxTVRJQUFBQUFBQkFBQUFBRUFBQUFMd0FBQURBQUFBQmxZMlJ6WVZkcGRHaFRTRUV5TWpSbFxuWTJSellWZHBkR2hUU0VFeFpXTlFkV0pzYVdOTFpYbHphR0V6TFRVeE1uTm9ZVE10TXpnMGMyaGhNeTB5TlRaemFHRXlNalJYYVhSb1xuVWxOQlJXNWpjbmx3ZEdsdmJnQUFBQUFBQUF3QUFBQUVBQUFBTVFBQUFESUFBQUJ0WkRWWGFYUm9VbE5CUlc1amNubHdkR2x2Ym0xa1xuTkZkcGRHaFNVMEZGYm1OeWVYQjBhVzl1YldReVYybDBhRkpUUVVWdVkzSjVjSFJwYjI1eWMyRkZibU55ZVhCMGFXOXVaSE5oVjJsMFxuYUZOb1lURmtjMkZOWVhSamFHUnpZUUFFQUVHOG1jQUFDNGtGU1c1elpXTjFjbVVnWVd4bmIzSnBkR2h0T2lDOERCQUFGQUFBQUVGc1xuWjI5eWFYUm9iU0J1YjNRZ2MzVndjRzl5ZEdWa09pQUFBQURZREJBQUdRQUFBRTFwYzNOcGJtY2djR0Z5WVcxeklHWnZjaUJGUTFWdVxuYTI1dmQyNGdZV3huYjNKcGRHaHRTVzUyWVd4cFpDQnphV2R1WVhSMWNtVWdiM0lnY0hWaWJHbGpJR3RsZVM5MWMzSXZiRzlqWVd3dlxuWTJGeVoyOHZjbVZuYVhOMGNua3ZjM0pqTDJsdVpHVjRMbU55WVhSbGN5NXBieTB4T1RRNVkyWTRZelppTldJMU5UZG1MMkpzYjJOclxuTFdKMVptWmxjaTB3TGpFd0xqUXZjM0pqTDJ4cFlpNXljd0FBUVEwUUFGMEFBQUNpQUFBQUp3QUFBRUVORUFCZEFBQUFwQUFBQUJnQVxuQUFCQkRSQUFYUUFBQUtRQUFBQWdBQUFBUVEwUUFGMEFBQUN1QUFBQUZBQUFBRUVORUFCZEFBQUFyZ0FBQUJvQUFBQkJEUkFBWFFBQVxuQUowQUFBQVlBQUFBUVEwUUFGMEFBQUNkQUFBQUh3QUFBRUVORUFCZEFBQUFuUUFBQUNVQUFBQkJEUkFBWFFBQUFDMEJBQUFpQUFBQVxuQVNORlo0bXJ6ZS8rM0xxWWRsUXlFUERoMHNNdmRYTnlMMnh2WTJGc0wyTmhjbWR2TDNKbFoybHpkSEo1TDNOeVl5OXBibVJsZUM1alxuY21GMFpYTXVhVzh0TVRrME9XTm1PR00yWWpWaU5UVTNaaTl5YVhCbGJXUXRNQzR4TGpNdmMzSmpMMnhwWWk1eWN3QUFSQTRRQUZZQVxuQUFDZ0FBQUFBUUFBQUM5MWMzSXZiRzlqWVd3dlkyRnlaMjh2Y21WbmFYTjBjbmt2YzNKakwybHVaR1Y0TG1OeVlYUmxjeTVwYnkweFxuT1RRNVkyWTRZelppTldJMU5UZG1MM05vWVRJdE1DNHhNQzQ1TDNOeVl5OWpiM0psWDJGd2FTNXljd0FBckE0UUFGb0FBQUJDQUFBQVxuRXdBQUFHZm1DV3FGcm1lN2N2TnVQRHIxVDZWL1VnNVJqR2dGbTZ2Wmd4OFp6ZUJickE0UUFGb0FBQUNNQUFBQUV3QkIwSjdBQUF1WlxuQVFqSnZQTm41Z2xxTzZmS2hJV3VaN3NyK0pUK2N2TnVQUEUySFY4NjlVK2wwWUxtclg5U0RsRWZiRDRyakdnRm0ydTlRZnVyMllNZlxuZVNGK0V4bk40RnN2Y25WemRHTXZNVGN3TmpkbE9XRmpObVEzWldOaU56QmxOVEJtT1RKak1UazBOR1UxTkRVeE9EaGtNak0xT1M5c1xuYVdKeVlYSjVMMkZzYkc5akwzTnlZeTl6YkdsalpTNXljd0FBa0E4UUFFb0FBQUMrQVFBQUhRQkI5Si9BQUFzcUFRQUFBRE1BQUFBd1xuRUJBQUpnQUFBTHNBQUFCQUFBQUFTVzUyWVd4cFpGQmhjbWwwZVZaaGJIVmxBRUdvb01BQUM0VUdBUUFBQURNQUFBQnRiMlIxYkdWelxuTDJWallYTm9MWE5sWTNBeU5UWnJNUzl6Y21NdlkyOXVkR1Y0ZEM1eWN3QUFNQkFRQUNZQUFBRGVBQUFBUUFBQUFQLy8vLy8vLy8vL1xuLy8vLy8vLy8vLzY2cnR6bXIwaWdPNy9TWG96UU5rRkFBQUFBQUFBQUFBQUJBQUFBTXdBQUFBQUFBQUFFQUFBQUJBQUFBQUlBQUFCTVxuWVhsdmRYUkZjbkp2Y2dBRUFBQUFiVzlrZFd4bGN5OWxZMkZ6YUMxelpXTndNalUyYXpFdlpXTmhjMmd0YzJWamNESTFObXN4TFhONVxuY3k5emNtTXZkSGx3WlhNdWNuTzRFQkFBT0FBQUFGY0FBQUFKQUFBQXVCQVFBRGdBQUFCWUFBQUFDUUFBQUxnUUVBQTRBQUFBV2dBQVxuQUFrQUFBQzRFQkFBT0FBQUFGc0FBQUFKQUFBQXVCQVFBRGdBQUFCZEFBQUFDUUFBQUxnUUVBQTRBQUFBWGdBQUFBa0FBQUFCQUFBQVxudUJBUUFEZ0FBQUJnQUFBQUNRQUFBTGdRRUFBNEFBQUFZUUFBQUFrQUFBQzRFQkFBT0FBQUFHTUFBQUFKQUFBQXVCQVFBRGdBQUFCa1xuQUFBQUNRQUFBRzF2WkhWc1pYTXZaV05oYzJndGMyVmpjREkxTm1zeEwyVmpZWE5vTFhObFkzQXlOVFpyTVMxemVYTXZjM0pqTDJ4cFxuWWk1eWN3QUFsQkVRQURZQUFBQ2hBd0FBUWdBQUFKUVJFQUEyQUFBQXlnTUFBRUlBQUFCYmJHbGljMlZqY0RJMU5tc3hYU0JwYkd4bFxuWjJGc0lHRnlaM1Z0Wlc1MExpQUFBQURzRVJBQUlRQUFBSlFSRUFBMkFBQUE4Z01BQUFVQUFBQmJiR2xpYzJWamNESTFObXN4WFNCcFxuYm5SbGNtNWhiQ0JqYjI1emFYTjBaVzVqZVNCamFHVmpheUJtWVdsc1pXUWdBQUFBS0JJUUFERUFBQUNVRVJBQU5nQUFBQlFFQUFBRlxuQUFBQXBpb1FBR2dBQUFBWkFRQUFFZ0FBQUdOc2IzTjFjbVVnYVc1MmIydGxaQ0J5WldOMWNuTnBkbVZzZVNCdmNpQmhablJsY2lCaVxuWldsdVp5QmtjbTl3Y0dWa0wzVnpjaTlzYjJOaGJDOWpZWEpuYnk5eVpXZHBjM1J5ZVM5emNtTXZhVzVrWlhndVkzSmhkR1Z6TG1sdlxuTFRFNU5EbGpaamhqTm1JMVlqVTFOMll2Y21sdVp5MHdMakUzTGpFMEwzTnlZeTlzYVcxaUxuSnpBQUFBdGhJUUFGY0FBQUNIQUFBQVxuR1FBQUFMWVNFQUJYQUFBQTR3QUFBQVVBUWJpbXdBQUwzUXdCQUFBQU5BQUFBQzkxYzNJdmJHOWpZV3d2WTJGeVoyOHZjbVZuYVhOMFxuY25rdmMzSmpMMmx1WkdWNExtTnlZWFJsY3k1cGJ5MHhPVFE1WTJZNFl6WmlOV0kxTlRkbUwzSnBibWN0TUM0eE55NHhOQzl6Y21NdlxuWldNdmMzVnBkR1ZmWWk5bFkyUnpZUzlrYVdkbGMzUmZjMk5oYkdGeUxuSnpBQUFBUUJNUUFIRUFBQUJCQUFBQUNnQUFBREFoTUFrR1xuQlNzT0F3SWFCUUFFRkRBeE1BMEdDV0NHU0FGbEF3UUNBUVVBQkNBd1FUQU5CZ2xnaGtnQlpRTUVBZ0lGQUFRd01GRXdEUVlKWUlaSVxuQVdVREJBSURCUUFFUUFBQUFBQUFBQUFBQVFBQUFEVUFBQUJGYm1SUFprbHVjSFYwTDNWemNpOXNiMk5oYkM5allYSm5ieTl5WldkcFxuYzNSeWVTOXpjbU12YVc1a1pYZ3VZM0poZEdWekxtbHZMVEU1TkRsalpqaGpObUkxWWpVMU4yWXZkVzUwY25WemRHVmtMVEF1T1M0d1xuTDNOeVl5OXlaV0ZrWlhJdWNuTUFBQ1lVRUFCY0FBQUFhUUFBQUNJQUFBQXZkWE55TDJ4dlkyRnNMMk5oY21kdkwzSmxaMmx6ZEhKNVxuTDNOeVl5OXBibVJsZUM1amNtRjBaWE11YVc4dE1UazBPV05tT0dNMllqVmlOVFUzWmk5eWFXNW5MVEF1TVRjdU1UUXZjM0pqTDNKelxuWVM5d1lXUmthVzVuTDNCclkzTXhMbkp6bEJRUUFHUUFBQUE5QUFBQUtRQUFBR0Z6YzJWeWRHbHZiaUJtWVdsc1pXUTZJR1Z0TG14bFxuYmlncElENDlJR1JwWjJWemRGOXNaVzRnS3lBeE1RQUFBSlFVRUFCa0FBQUFVUUFBQUFVQUFBQ1VGQkFBWkFBQUFGTUFBQUFGQUFBQVxubEJRUUFHUUFBQUJVQUFBQUJRQUFBSlFVRUFCa0FBQUFXQUFBQUFVQUFBQ1VGQkFBWkFBQUFGb0FBQUFwQUFBQWxCUVFBR1FBQUFCYVxuQUFBQU9RQUFBSlFVRUFCa0FBQUFXd0FBQUJNQUFBQ1VGQkFBWkFBQUFGd0FBQUFRQUFBQWxCUVFBR1FBQUFCV0FBQUFDUUFBQUM5MVxuYzNJdmJHOWpZV3d2WTJGeVoyOHZjbVZuYVhOMGNua3ZjM0pqTDJsdVpHVjRMbU55WVhSbGN5NXBieTB4T1RRNVkyWTRZelppTldJMVxuTlRkbUwzSnBibWN0TUM0eE55NHhOQzl6Y21NdllYSnBkR2h0WlhScFl5OWlhV2RwYm5RdlltOTRaV1JmYkdsdFluTXVjblBJRlJBQVxuY0FBQUFFa0FBQUFVQUFBQXlCVVFBSEFBQUFCSkFBQUFJUUFBQUpndmlrS1JSRGR4ei92QXRhWGJ0ZWxid2xZNThSSHhXYVNDUDVMVlxuWGh5cm1Lb0gyQUZiZ3hLK2hURWt3MzBNVlhSZHZuTCtzZDZBcHdiY20zVHhtOEhCYVp2a2hrZSs3OGFkd1EvTW9Rd2tieXpwTGFxRVxuZEVyY3FiQmMyb2o1ZGxKUlBwaHR4akdveUNjRHNNZC9XYi96QytER1I1R24xVkZqeWdabktTa1VoUXEzSnpnaEd5NzhiU3hORXcwNFxuVTFSekNtVzdDbXAyTHNuQ2dZVXNjcEtoNkwraVMyWWFxSENMUzhLalVXekhHZWlTMFNRR21kYUZOUTcwY0tCcUVCYkJwQmtJYkRjZVxuVEhkSUo3VzhzRFN6REJ3NVNxcllUay9LbkZ2emJ5NW83b0tQZEc5anBYZ1VlTWlFQ0FMSGpQci92cERyYkZDazk2UDV2dko0Y2NZQVxuQUFBQUFBQUFBQUVBQUFBMkFBQUFWSEo1Um5KdmJVbHVkRVZ5Y205eUwzVnpjaTlzYjJOaGJDOWpZWEpuYnk5eVpXZHBjM1J5ZVM5elxuY21NdmFXNWtaWGd1WTNKaGRHVnpMbWx2TFRFNU5EbGpaamhqTm1JMVlqVTFOMll2Y21sdVp5MHdMakUzTGpFMEwzTnlZeTl5YzJFdlxuY0hWaWJHbGpYMnRsZVM1eWMzY1hFQUJoQUFBQXVBQUFBRmdBQUFCM0Z4QUFZUUFBQU44QUFBQVhBQUFBZHhjUUFHRUFBQURoQUFBQVxuSGdBQUFHRnpjMlZ5ZEdsdmJpQm1ZV2xzWldRNklIQmhaR1JwYm1jdWFYUmxjaWdwTG1Gc2JDaDhKbUo4SUdJZ1BUMGdNQ2tBQUFCM1xuRnhBQVlRQUFBT0lBQUFBRkFBQUFVRXREVXpGa2FXZGxjM1JmWVd4blpHbG5aWE4wYVc1bWIxOXdjbVZtYVhqSUdSQUF4Qk1RQUE4QVxuQUFBQUFBQUFEQUFBQUFRQUFBQTNBQUFBT0FBQUFEa0FBQUJzR0JBQWVCZ1FBQUFJQUFCWUpoQUEweE1RQUJNQUFBQ2NHQkFBZUJnUVxuQUFBSUFBRHdKaEFBNWhNUUFCTUFBQUMwR0JBQWVCZ1FBQUFJQUFBQUhCQUErUk1RQUJNQUFBRE1HQkFBZUJnUUFBQUlBQUF2ZFhOeVxuTDJ4dlkyRnNMMk5oY21kdkwzSmxaMmx6ZEhKNUwzTnlZeTlwYm1SbGVDNWpjbUYwWlhNdWFXOHRNVGswT1dObU9HTTJZalZpTlRVM1xuWmk5eWFXNW5MVEF1TVRjdU1UUXZjM0pqTDJGeWFYUm9iV1YwYVdNdlltbG5hVzUwTG5KejVCZ1FBR1FBQUFCZEFBQUFFd0FBQU9RWVxuRUFCa0FBQUFOQU1BQUFVQUFBRGtHQkFBWkFBQUFEc0RBQUFyQUFBQTVCZ1FBR1FBQUFBOEF3QUFLQUFBQU9RWUVBQmtBQUFBUFFNQVxuQUNjQVFhQ3p3QUFMUUFFQUFBQTBBQUFBa0JzUUFGa0FBQUFWQVFBQUZRQUFBSkFiRUFCWkFBQUFKZ0VBQUFvQUFBQUJBQUFBQVNORlxuWjRtcnplLyszTHFZZGxReUVQRGgwc01BUVpDMHdBQUw2UU02QUFBQUZBQUFBQUFVUUFBQUFBQUFRbWwwVEdWdVozUm9VMGhCTVZOSVxuUVRJMU5sTklRVE00TkZOSVFUVXhNbE5JUVRVeE1sOHlOVFlBQUFBN0tCQUFUZ0FBQUNNSUFBQVJBQUFBYldsa0lENGdiR1Z1QUFBQVxuWEJvUUFBa0FBQUE3S0JBQVRnQUFBS3dHQUFBVkFBQUFMM1Z6Y2k5c2IyTmhiQzlqWVhKbmJ5OXlaV2RwYzNSeWVTOXpjbU12YVc1a1xuWlhndVkzSmhkR1Z6TG1sdkxURTVORGxqWmpoak5tSTFZalUxTjJZdmNtbHVaeTB3TGpFM0xqRTBMM055WXk5d2IyeDVabWxzYkM5elxuYkdsalpTOWhjMTlqYUhWdWEzTXVjbk1BZ0JvUUFHc0FBQUFXQUFBQUxBQUFBQzkxYzNJdmJHOWpZV3d2WTJGeVoyOHZjbVZuYVhOMFxuY25rdmMzSmpMMmx1WkdWNExtTnlZWFJsY3k1cGJ5MHhPVFE1WTJZNFl6WmlOV0kxTlRkbUwzSnBibWN0TUM0eE55NHhOQzl6Y21NdlxuWkdsblpYTjBMMlI1Ym5OMFlYUmxMbkp6QUFEOEdoQUFZZ0FBQURrQUFBQU5BQUFBL0JvUUFHSUFBQUJLQUFBQURRQUFBUHdhRUFCaVxuQUFBQVd3QUFBQTBBQUFBdmRYTnlMMnh2WTJGc0wyTmhjbWR2TDNKbFoybHpkSEo1TDNOeVl5OXBibVJsZUM1amNtRjBaWE11YVc4dFxuTVRrME9XTm1PR00yWWpWaU5UVTNaaTl5YVc1bkxUQXVNVGN1TVRRdmMzSmpMMlJwWjJWemRDNXljd0FBQUpBYkVBQlpBQUFBR0FJQVxuQUE4QVFZaTR3QUFMU3dqSnZQTm41Z2xxTzZmS2hJV3VaN3NyK0pUK2N2TnVQUEUySFY4NjlVK2wwWUxtclg5U0RsRWZiRDRyakdnRlxubTJ1OVFmdXIyWU1mZVNGK0V4bk40RnM3QUFBQVFBQUFBQU5BZ0FCQjRMakFBQXVBREFFQUFBQTBBQUFBTDNWemNpOXNiMk5oYkM5alxuWVhKbmJ5OXlaV2RwYzNSeWVTOXpjbU12YVc1a1pYZ3VZM0poZEdWekxtbHZMVEU1TkRsalpqaGpObUkxWWpVMU4yWXZjbWx1Wnkwd1xuTGpFM0xqRTBMM055WXk5aGNtbDBhRzFsZEdsakwyMXZiblJuYjIxbGNua3Vjbk5vSEJBQWFBQUFBQmdCQUFBR0FBQUFhQndRQUdnQVxuQUFBbEFRQUFCZ0FBQUdnY0VBQm9BQUFBS0FFQUFDWUFBQUJvSEJBQWFBQUFBQ2NCQUFBSkFBQUFZWE56WlhKMGFXOXVJR1poYVd4bFxuWkRvZ2JXbHVYMkpwZEhNZ1BqMGdUVWxPWDBKSlZGTXZkWE55TDJ4dlkyRnNMMk5oY21kdkwzSmxaMmx6ZEhKNUwzTnlZeTlwYm1SbFxuZUM1amNtRjBaWE11YVc4dE1UazBPV05tT0dNMllqVmlOVFUzWmk5eWFXNW5MVEF1TVRjdU1UUXZjM0pqTDNKellTOXdkV0pzYVdOZlxuYlc5a2RXeDFjeTV5Y3dBMkhSQUFaUUFBQUQ0QUFBQUpBQUFBTmgwUUFHVUFBQUJCQUFBQURnQUFBR2djRUFCb0FBQUE2d0FBQUI4QVxuQUFCVmJuTndaV05wWm1sbFpBQWlyaWpYbUMrS1FzMWw3eU9SUkRkeEx6dE43TS83d0xXODI0bUJwZHUxNlRpMVNQTmJ3bFk1R2RBRlxudHZFUjhWbWJUeG12cElJL2toaUJiZHJWWGh5clFnSURvNWlxQjlpK2IzQkZBVnVERW95eTVFNitoVEVrNHJULzFjTjlERlZ2aVh2eVxuZEYyK2NyR1dGanYrc2Q2QU5STEhKYWNHM0p1VUptblBkUEdid2RKSzhaN0JhWnZrNHlWUE9JWkh2dSsxMVl5THhwM0JEMldjckhmTVxub1F3a2RRSXJXVzhzNlMyRDVLWnVxb1IwU3RUN1FiM2NxYkJjdFZNUmc5cUkrWGFyMzJidVVsRSttQkF5dEMxdHhqR29QeUg3bU1nblxuQTdEa0R1Kyt4MzladjhLUHFEM3pDK0RHSmFjS2swZVJwOVZ2Z2dQZ1VXUEtCbkJ1RGdwbktTa1UvQy9TUm9VS3R5Y215U1pjT0NFYlxuTHUwcXhGcjhiU3hOMzdPVm5STU5PRlBlWTYrTFZITUtaYWl5ZHp5N0NtcDI1cTd0Unk3SndvRTdOWUlVaFN4eWttUUQ4VXloNkwraVxuQVRCQ3ZFdG1HcWlSbC9qUWNJdEx3akMrVkFhalVXekhHRkx2MWhub2t0RVFxV1ZWSkFhWjFpb2djVmVGTlE3MHVORzdNbkNnYWhESVxuME5LNEZzR2tHVk9yUVZFSWJEY2VtZXVPMzB4M1NDZW9TSnZodGJ5d05HTmF5Y1d6REJ3NXk0cEI0MHFxMkU1ejQyTjNUOHFjVzZPNFxuc3RiemJ5NW8vTEx2WGU2Q2ozUmdMeGREYjJPbGVIS3I4S0VVZU1pRTdEbGtHZ2dDeDR3b0htTWordisra09tOWd0N3JiRkNrRlhuR1xuc3ZlaitiNHJVM0xqOG5oeHhweGhKdXJPUGlmS0I4TEFJY2U0aHRFZTYrRE4xbjNhNm5qUmJ1NS9UMzMxdW04WGNxcG44QWFtbU1paVxueFgxakNxNE4rYjRFbUQ4UkcwY2NFelVMY1J1RWZRUWo5WGZiS0pNa3gwQjdxOG95dkw3SkZRcStuanhNRFJDY3hHY2RRN1pDUHN1K1xuMU1WTUtuNWwvSndwZjFucyt0WTZxMi9MWHhkWVIwcU1HVVJzVENJUUFKd2pFQUF2ZFhOeUwyeHZZMkZzTDJOaGNtZHZMM0psWjJselxuZEhKNUwzTnlZeTlwYm1SbGVDNWpjbUYwWlhNdWFXOHRNVGswT1dObU9HTTJZalZpTlRVM1ppOXlhVzVuTFRBdU1UY3VNVFF2YzNKalxuTDJGeWFYUm9iV1YwYVdNdlltbG5hVzUwTDIxdlpIVnNkWE11Y25OZ0lCQUFiQUFBQUZ3QUFBQXVBQUFBWUNBUUFHd0FBQUJpQUFBQVxuSmdBQUFHQWdFQUJzQUFBQWt3QUFBQWtBQUFCZ0lCQUFiQUFBQUtRQUFBQWRBQUFBTDNWemNpOXNiMk5oYkM5allYSm5ieTl5WldkcFxuYzNSeWVTOXpjbU12YVc1a1pYZ3VZM0poZEdWekxtbHZMVEU1TkRsalpqaGpObUkxWWpVMU4yWXZjbWx1Wnkwd0xqRTNMakUwTDNOeVxuWXk5bFl5OXpkV2wwWlY5aUwyOXdjeTV5Y3dBQUFBd2hFQUJoQUFBQUJnRUFBRFFBQUFBTUlSQUFZUUFBQUFZQkFBQWVBQUFBRENFUVxuQUdFQUFBQU5BUUFBTkFBQUFBd2hFQUJoQUFBQURRRUFBQjRBQUFBTUlSQUFZUUFBQUJRQkFBQTBBQUFBRENFUUFHRUFBQUFVQVFBQVxuSGdBQUFHbHVkR1Z5Ym1Gc0lHVnljbTl5T2lCbGJuUmxjbVZrSUhWdWNtVmhZMmhoWW14bElHTnZaR1ZoYzNObGNuUnBiMjRnWm1GcFxuYkdWa09pQWhjMlZzWmk1elkyRnNZWEpmYjNCekxtTnZiVzF2Ymk1cGMxOTZaWEp2S0dFcERDRVFBR0VBQUFEWUFRQUFDUUFBQUF3aFxuRUFCaEFBQUFZUUlBQUFVQUFBQThBQUFBUFFBQUFQLy8vLy8vLy8vLy8vLy8vd0JCN01UQUFBc0lBUUFBQVAvLy8vOEFRWVRGd0FBTFxuSFFNQUFBQUFBQUFBLy8vLy8vdi8vLy8rLy8vLy8vLy8vLzMvLy84RUFFRzB4Y0FBQ3lCUkpXUDh3c3E1ODRTZUY2ZXQrdWE4Ly8vL1xuLy8vLy8vOEFBQUFBLy8vLy93QkI1TVhBQUFzTi9QLy8vLy8vLy8vLy8vLy9Bd0JCL01YQUFBc0lCQUFBQVB6Ly8vOEFRWlRHd0FBTFxuSU4rOXhDbGkzNXpZa0RDRWVNMEY4S3pXTGlIM3F5Q2k1VFJJaHdRZEJqRGNBRUhJeHNBQUMwUk1JaEFBUGdBQUFEOEFBQUJBQUFBQVxuUVFBQUFFd2lFQUJDQUFBQVhDTVFBRU1BQUFDaTdubStsVXdrZzZadnZVbWNlWmxHV2V4ckt6bXlSU2dnVnRuemxDM2haZ0JCbk1mQVxuQUF0WkhBQUFBQjBBQUFELy8vLy9BQUFBQUFBQUFBRC8vLy8vL3YvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy84QkFBQUEvdi8vL3dBQUFBQUNBQUFBQUFBQUFQNy8vLzhBQUFBQUFnQUFBQUVBUVlUSXdBQUxzQVJ6S2NYTWFobnM3SHFuc0VpeVxuRFJwWTN5MDM5SUZOWThmLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy84Ly8vL0F3QUFBQUFBQUFEOC8vLy8rLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9NTFVHZGNZZ1JDT3d5VEhyWXJTbjNMZ0lnR1pzZzhuZmlpcE9VN2tzM1xuNDVRZ0FoLzBJU3UyK2I5UFlFc1JDTTBCQUFBQUtMWEFTV1oxMEQwNHp0YWc0bmpqSUc1TkcxVDhPcHlIL3c2aldZU0dWR1FyM2s1aFxuSS9jdmdSTVZuaW5DclRwTi9xUURTNjA5QkNPc3FiUjd2Nmkvb1ZDd2d5NVc1NjJMMmYvMGFCbFN3OFpBcUdrNUpnS0EzZW5GRlZyQ1xucTNncm5DTVFBRVFBQUFCRkFBQUFSZ0FBQUVjQUFBQ2NJeEFBU0FBQUFBd2xFQUJKQUFBQXFRbTBHU1NiTVMwWnBCcmY1WUU5LzBjcFxudVB3NlNENjh4UnlyU2hkSkRkU1ZhQ1lvZWx1d1B5Ry9PU3NCN29RTUwzVnpjaTlzYjJOaGJDOWpZWEpuYnk5eVpXZHBjM1J5ZVM5elxuY21NdmFXNWtaWGd1WTNKaGRHVnpMbWx2TFRFNU5EbGpaamhqTm1JMVlqVTFOMll2Y21sdVp5MHdMakUzTGpFMEwzTnlZeTlsWXk5elxuZFdsMFpWOWlMMjl3Y3k5d016ZzBMbkp6QUFCTUpSQUFaZ0FBQUFnQkFBQThBQUFBQWdFR0F3TUJCUUVGQkFRRkNnY0RBZ1VBQkFVRVxuQkFVR0JBWUVCd1VGQ2dZSkJnUUZCZ1FEQUFjRkJ3SUZBd1VIQlFVRUJRVURBd0VIQVFZRkJBSURBUVFCQkFFR0FnVUNCUUlDQVFRQVxuQUFCY0l4QUFXQ0FRQUVvQUFBQkxBQUFBcnRxY0F6MDFSZ3g3WWVoWVV3VVpRd0JCMk16QUFBc2tBUUFBQUdmbUNXcUZybWU3Y3ZOdVxuUERyMVQ2Vi9VZzVSakdnRm02dlpneDhaemVCYkFFR2d6Y0FBQ3poTUFBQUFJQUFBQUFFZ1FBQUFBQUFBRENVUUFGd2dFQUJOQUFBQVxuVGdBQUFJeldPak9XNWhNVGhWaFB0MHp5NWFjZjBzZ0xmcktjT0FCQitNM0FBQXYvQ05pZUJjRmRuYnZMQjlWOE5pb3BtbUlYM1hBd1xuV2dGWmtUbFpEdmZZN0M4Vk1RdkEvMmNtTTJjUkZWaG9oMHEwanFlUCtXUU5MZ3picEUvNnZoMUl0VWM3QUFBQVFBQUFBQUl3Z0FBQVxuQUFBQUZDWVFBRmdtRUFCUEFBQUFBQUFBQUJRbUVBRHdKaEFBVHdBQUFBSUFBQUN3SmhBQVdDWVFBRThBQUFBREFBQUFzQ1lRQVBBbVxuRUFCUEFBQUFCQUFBQUVWRFJGTkJYMUF5TlRaZlUwaEJNalUyWDBGVFRqRkZRMFJUUVY5UU1qVTJYMU5JUVRJMU5sOUdTVmhGUkVWRFxuUkZOQlgxQXlOVFpmVTBoQk16ZzBYMEZUVGpGRlEwUlRRVjlRTXpnMFgxTklRVEkxTmw5QlUwNHhSVU5FVTBGZlVETTRORjlUU0VFelxuT0RSZlFWTk9NVVZEUkZOQlgxQXpPRFJmVTBoQk16ZzBYMFpKV0VWRVkyRnNiR1ZrSUdCU1pYTjFiSFE2T25WdWQzSmhjQ2dwWUNCdlxuYmlCaGJpQmdSWEp5WUNCMllXeDFaU2dwTDNKMWMzUmpMekUzTURZM1pUbGhZelprTjJWallqY3daVFV3WmpreVl6RTVORFJsTlRRMVxuTVRnNFpESXpOVGt2YkdsaWNtRnllUzlqYjNKbEwzTnlZeTl6YkdsalpTOXBkR1Z5TG5KekFBQUFPeWdRQUU0QUFBQ0RCd0FBRVFBQVxuQUM5eWRYTjBZeTh4TnpBMk4yVTVZV00yWkRkbFkySTNNR1UxTUdZNU1tTXhPVFEwWlRVME5URTRPR1F5TXpVNUwyeHBZbkpoY25rdlxuWVd4c2IyTXZjM0pqTDNOMGNtbHVaeTV5Y3dDY0tCQUFTd0FBQUgwRkFBQWJBQUFBM0NrUUFGQUFBQUF1QWdBQUVRQUFBQzl5ZFhOMFxuTDJSbGNITXZaR3h0WVd4c2IyTXRNQzR5TGpjdmMzSmpMMlJzYldGc2JHOWpMbkp6WVhOelpYSjBhVzl1SUdaaGFXeGxaRG9nY0hOcFxuZW1VZ1BqMGdjMmw2WlNBcklHMXBibDl2ZG1WeWFHVmhaQUFJS1JBQUtRQUFBS2dFQUFBSkFBQUFZWE56WlhKMGFXOXVJR1poYVd4bFxuWkRvZ2NITnBlbVVnUEQwZ2MybDZaU0FySUcxaGVGOXZkbVZ5YUdWaFpBQUFDQ2tRQUNrQUFBQ3VCQUFBRFFBQUFGUnlhV1ZrSUhSdlxuSUhOb2NtbHVheUIwYnlCaElHeGhjbWRsY2lCallYQmhZMmwwZWJBcEVBQWtBQUFBTDNKMWMzUmpMekUzTURZM1pUbGhZelprTjJWalxuWWpjd1pUVXdaamt5WXpFNU5EUmxOVFExTVRnNFpESXpOVGt2YkdsaWNtRnllUzloYkd4dll5OXpjbU12Y21GM1gzWmxZeTl0YjJRdVxuY25QY0tSQUFVQUFBQUxrQ0FBQUpBQUFBYm5Wc2JDQndiMmx1ZEdWeUlIQmhjM05sWkNCMGJ5QnlkWE4wY21WamRYSnphWFpsSUhWelxuWlNCdlppQmhiaUJ2WW1wbFkzUWdaR1YwWldOMFpXUWdkMmhwWTJnZ2QyOTFiR1FnYkdWaFpDQjBieUIxYm5OaFptVWdZV3hwWVhOcFxuYm1jZ2FXNGdjblZ6ZEM5MWMzSXZiRzlqWVd3dlkyRnlaMjh2Y21WbmFYTjBjbmt2YzNKakwybHVaR1Y0TG1OeVlYUmxjeTVwYnkweFxuT1RRNVkyWTRZelppTldJMU5UZG1MM2RoYzIwdFltbHVaR2RsYmkwd0xqSXVPVEl2YzNKakwyTnZiblpsY25RdmMyeHBZMlZ6TG5KelxuQUFDbUtoQUFhQUFBQU40QUFBQUJBQUFBQkFBQUFBWUFBQUFHQUFBQUJnQUFBQW9BQUFBcEdoQUFMUm9RQURNYUVBQTVHaEFBUHhvUVxuQUJZQUFBQVhBQUFBRmdBQUFCWUFBQUFXQUFBQUZ3QUFBSWduRUFDZUp4QUF0U2NRQU1zbkVBRGhKeEFBOXljUUFFR0ExOEFBQzVnQlxuVVNWai9NTEt1Zk9FbmhlbnJmcm12UC8vLy8vLy8vLy9BQUFBQVAvLy8vOVB2QUR1cXNqUnpBQUFBQUFBQUFBQS8vLy8vd0FBQUFBQVxuQUFBQS8vLy8vLzcvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL2N5bkZ6R29aN094NnA3QklzZzBhV044dFxuTi9TQlRXUEgvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1JkeVA2SWxnMUc0QVFhUFl3QUFMTW9BQUFBQUFBQUFBZ1AvL1xuLzMvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9md0VBQUFBQkFFSGcyTUFBQ3hFQkFBQUEvLy8vLy8vL1xuLy84QUFBQUFBUUJCa05uQUFBc0JBUUJCbk5uQUFBdWVELy8vLy8vLy8vLy8vLy8vLy83Ly8vOEFBQUFBUEJTcEdOUXc1M2tCdHUxZlxuL0pXNmRSQWxZbmNyYy90NXhsVTNwWFpma0JnS1ZwWE9WMVB5M1Z6a0dicmt1RXFMSmZNaDNZaUc2TktGWFlnbEdQOXhoYnZTb0JiRlxuTDVKUG1UUmlHbXpCWEEyTExNWlhPczlCa245bUcvMWhhVjR2bHhlZzlRdkhGVnlTWVpWZ1RiUWdQVkxiSHdjM0c1RUVldzl2alJiNVxuU1BhOHV6ZmhSMmhXbnV3TGFvcWVSalRrWXpUWGVXRW54TEVWQUQwVGhRSytXcXQ5VE1COGc2cVNCd3dtUTB5ZlBWYzN6T1o0WWhXVFxuRElOemIydGJjcnVVSlFuaXYwVENxR0puNk55UHc1ckJrV053T04zVnBaWmE5aVRUSWRTSDFXSHFjM0dqb25OMjZHV0xkMU1JZ0lRalxuUHJTNkJSNUUrQkMrN3lGR0V2NFIrdjJmc1N3ckg0a2NJenlTc1Z1TnVnR095c1dLWnozUXR0eStFeDlNc0c1WUNlM29KK1hHTlF6aVxuN1JrWVBLT0JIdnBTeGxiQTFvOG5FVStHY0FpczFSblZNN1hTTkhkWFlzRGR2YUgyaWp0bms4S2VwNXA4ZmxleFpyTERVZVp0dTdOWlxuVXJZNk1Pbm5nSFE2ME5Pdm9OWW4vRHliMFlPc3hadTVHRjJhWWJSZ0hLcmxHdUU0YXIxWU51ZEpLMlczdU8ySFgrNFVBQk1MemYvclxucnJJbkQ1MVZDbk42TVVhU3lqckl1OTB2VzVXY2Nab0JyT0Rmd1FlTnhHNDFiVlpLSkdxeCtQUU9RZmhXYWlaN3hQNGFKSmZCaDV4dFxuam10QUNodXJRczBDUGorQWFlemJCS2dKQTM5ZjBMbzc5NFU3cUg4WmpxMXpjZ25Hd2ExblVBNUVsOEEwcTNuRDhsWnFoTkg0SFlTTFxuQnU2bzcyaHNGMWxFTVNBd0gxK1IxVEt2OFZDOWRWMHhkY09adkdjdjk3ci9mSU0vY3RkSUdLUVRCb3NjMU9JdzhkQWpLMXErMVNYaVxuayszRzh6UlpnNW5uYi94dllpSW1DUlJEYWlHUWVkbTB1MUEreG43bHhwR0JON0xOSFJoQUxFSmw5dUEyQXBzSnFFSERTZjRCR0FFUVxuSzVNVk9adkZ0V2o4L0hDQ1dhTDFoY083M0pyUnF2TkVjUXl1KzRPWmlWWGQ5Qys0ZEk2THVKUEpOT2R4UUR6ZzBpb3l3RU92bm5xYVxuUVdDZEZGSEY1T2IrSWV5QS9rdmhYNEsrVmNKcUVjNzJaMTFLTHdkYXZKaXZZMzdiU0hIUytyTUZxeW1zdHNDUTVob2xUanlvcVRkOVxuM3FyQ2RjaDlDb1FhRHAvamZUaDMxdzFzcFVuTW5oNTBiQWhHMlB6UHBjNnVCZlVJRkhxUGZzVHd2c0NGZTdPUGFnN001TGFXTlNPUFxuT0d1L1MyMzlUdStjdy9wVHBLdlZLUGI1eUZvVG5MNzR5SldVY2h3S3YyTHpPNERFWVNtczFHUGZBNFJCbmdEcDdKSEwrUW5CQlZlVVxuV05DVjBNTEFoZXZkbGowSXVadEVRSHFOSzJtRTRSN3VMazgwdzV0ME1KRkNWdU5hRGJGQ3BVZ25HMGxWS25NUXMyV21uRWJCVEJwZlxuVWgxWktUK1lUN2hyVzIvbjRZUmZuMEh2ZnI2Sm9icUFsdFFBRWl3ejd4Z2ZWWFpqbWxGSFFRS0dLQ0R3Y3JNbXJCNlkwTWpyaGFmS1xucDlTcDZWamYydzNGVTltUEQxbjl6R0ZqblJmSjVrUnJZdWx5ejJUckloQmgyWC96aUxLZWZycytoalE5NXJBeDd1ZFBxMC9scVhJRlxuWVBTa3RlZlZORE5Kd0RGSTFRYVMrNG1GT2xXRFpjejFjS3JsU1ZiaVNnbDVDRkpHQkJBSFJaRE1UeHhVQW0xcHNPdVoyb2s3d0tDNlxucXlKQUtMaWUxL0ttNkFVY3VHSjRoQ2RqVGVVRldVdDZNMHA1OXlFTlVHYzhZWDl0ZmJjRmNDRG8xczhFZ1RkYUN0Yjd3dlRWNEdVTlxuejBrMWJRL2xNOVJlWnMzNmIya3piN1Q4RWM2cy9WdHBZSmg4cjFMaURvRXN1MWx4NFE5RlpYczFpM1crdnQvM2N1cWYxblIrQlN0RlxuRjNPU2VuR0YxR2wyUCtpN2FSL09hMzJIY29LdStBbU5KMFF5Vks1SWxaekJ3dVBlVlhjZ1JSbnZiOWxodllmREtDMng3enlCR0twa1xuMzNMVzBieWZEYkJVY2VWZTNFaFVNWnIwbmtZUDc1b3VLMjZWcFlVK25FcVNxaDdzcWtVWlI1Nmd5TjhTcWgyZjlrMG5jdkltYzE3L1xub2l6STVPQkUzYW0zYzg3WXVRR3BqT1J6YmdOczhGTnhwT0VoNU9ISkdBU1NlVHRzdUhKMlhYQ0h6cjJUZDVxM3lwUG5XdklNblladFxubzVReEgyVENoa21DeUZXZFhwUnVDYU5lKzBrK0N0c1RVK2E0T1VxejBEWEFlMEhqcDhBbmcyczRDMFRSWWdPc0xTYTNqMFA1emVCTVxuRVVFc3NhQ1ZyZkhPcFN0aVE5Vm5xRGVid01tRzVBSFN6ZFltbDVML1FyOTZSeURTWndxOFFSc1NENG9rVFVRS2R0UmlOMGViWlIxUFxuQkE2b3RBc2xaZVA5Q0lmeWk0VGF3KzZzYnAwMjA0SWhwc0tDbEVTUzNOK0NOZGRzWFZiU0wzNHZhNGVLRjdVaUFRcTBCRkVJLzViL1xuVVhhZjhoU3JNUXNGNXRTSFg0dXlxNFFLZVhDQ24wUHQxV3YwNDRXZHRXd3RFaUllYkJ0YzlYVkFWbVVYWjI5RDVXMVo2NXJNWHBiQ1xudEpJOEF1Y0Q2Z0ZoT1FFdXRyUUVSMmVqWHBBLy9hZ01ZU3NiVlVJNlVwSUd6UTg1bktpM0hqNm1rZ08rMHZIbk13emJUV1NpM0paSVxubURNVkRpRWNJNDJNZDNEb0tIcm9jT0ZXYVdIbUhaMExuTEFyT01uRFNuMlltR2xSQmI0WjF2UUpyc1IySTRzOWt6OGFaYmZnSGZRRlxubCtQSGxBMDRIY014akV1VmhUWU1HdkpiQUQxVGFNbWV4M1Z1WXRjTFZKM0dRa2QxRjhxeTI5TDIvOXB1ekJpZFNoZTlqQTM5NkhoRlxucXBPSFhvZm1MS3VjRTZkMnFkdWhQclFScXpmT2t0SlpVcW54ZndxRzhZU1BJUUliaFJPdCt0N3FLeUtuUkpFS0sreDRyS0xGV2ZyeVxuVVVBQ1dqak9SMkdsN05HUmtNWXF2Q1BWbEw0UEd1eDUvYTZOTFplY3M4Nzkxcnc3bFJyMldQeGZWL1VndFBldHhJYloyN2VlOHhVVVxuaUtxQmJKZU51Zlg4NG01OWNTL1BYVWRsVk5DN1lHakUweVNPQkFRRUJBUUVBUUVFQkFCQjhPbkFBQXNKVVFBQUFBQUFBQUJTQUVHSVxuNnNBQUM4MERVUUFBQUFBQUFBQkpiblpoYkdsa0lHWnNZV2R6QUdOMGVDQWhQU0J6WldOd01qVTJhekZmWTI5dWRHVjRkRjl1YjE5d1xuY21WamIyMXdBSE5sYkdZZ2RHVnpkQ0JtWVdsc1pXUUFSbTl5SUhSb2FYTWdjMkZ0Y0d4bExDQjBhR2x6SURZekxXSjVkR1VnYzNSeVxuYVc1bklIZHBiR3dnWW1VZ2RYTmxaQ0JoY3lCcGJuQjFkQ0JrWVhSaEFDaG1iR0ZuY3lBbUlGTkZRMUF5TlRaTE1WOUdURUZIVTE5VVxuV1ZCRlgwMUJVMHNwSUQwOUlGTkZRMUF5TlRaTE1WOUdURUZIVTE5VVdWQkZYME5QVFZCU1JWTlRTVTlPQUhKbFkybGtJRDQ5SURBZ1xuSmlZZ2NtVmphV1FnUEQwZ013QnpaV053TWpVMmF6RmZaV050ZFd4MFgyTnZiblJsZUhSZmFYTmZZblZwYkhRb0ptTjBlQzArWldOdFxuZFd4MFgyTjBlQ2tBYzJWamNESTFObXN4WDJWamJYVnNkRjluWlc1ZlkyOXVkR1Y0ZEY5cGMxOWlkV2xzZENnbVkzUjRMVDVsWTIxMVxuYkhSZloyVnVYMk4wZUNrQUlYTmxZM0F5TlRack1WOW1aVjlwYzE5NlpYSnZLQ1puWlMwK2VDa0FLbTkxZEhCMWRHeGxiaUErUFNBb1xuS0dac1lXZHpJQ1lnVTBWRFVESTFOa3N4WDBaTVFVZFRYMEpKVkY5RFQwMVFVa1ZUVTBsUFRpa2dQeUF6TTNVZ09pQTJOWFVwQUZJQVxuQUFBQUFBQUFVQUFBQUZBQVFlRHR3QUFMRUVWRFJGTkJLMFJGVWlBZ0lDQWdJQ0FBUVpqdXdBQUxBUUVBUWNEdXdBQUxFRVZEUkZOQlxuSzFKbFkyOTJaWEo1SUNBQVFlRHV3QUFMYnZDS2VNdTY3Z2dyQlNyZ2NJOHkraDVReGNRaHFuY3JwZHUwQnFMcWErTkNtQmY0Rmx1QlxuQWdDZmxZM2kzTElOQVB5YkFnY0xodzRBWENrR1dzVzZDd0RjK1g1bXZua0FBTGpVRVB1UDBBY0F4SmxCVldpS0JBQzBGLzJvQ0JFT1xuQU1DL1Q5cFZSZ3dBb3laMzJqcElBRUhnNzhBQUN6QlVhR1VnYzJOaGJHRnlJR1p2Y2lCMGFHbHpJSGdnYVhNZ2RXNXJibTkzYmdBQVxuQUFBQUFBQUFML3ovLy83Ly8vOEFRYW53d0FBTEVBRUFBQUFBQUFEUHl0b3Q0dmJISndjQVFlRHd3QUFMRk82NnlTOXlvUTBBQWtUOFxuZFF1VkFRQWpVVVVCQUVHSThjQUFDMEJCUVRiUWpGNENBUDI3QTRyMGFnNEEzSzY2L3YvL0R3RC8vLy8vLy84UEFQLy8vLy8vL3dBQVxuUVVFMjBJeGUwai91Z0NLOW1uTzdLdXYvLy8vLy8vLy9BRUhSOGNBQUN4Z0JBQUFBQUFBQXdVNTNxcGtBOGpRQUFRQUFBQUFBQUFFQVxuUVpEeXdBQUxBUUVBUWNEeXdBQUxBWUFBUVlEendBQUxFTVBrdndxcGYxUnZLSWdPQWRaK1ErUUFRYUR6d0FBTHBnRXNWckU5cU0xbFxuMTIwMGRBZkZDaWlLL3YvLy8vLy8vLy8vLy8vLy8vLy8vekd3MjBXYUlKUG9mOHJvY1JTS3FqMFY2NFNTNUpCczZNMXIxS2NoMG9Zd1xuY1gvRWlxNjBjUlhHQnZXZHJBZ1NJc1RrdndxcGYxUnZLSWdPQWRaK1ErUnl2U01iZkpZQzMzaG1nU0RxSWk0U1dtUVNpQUljSnFYZ1xuTUZ6QVRLMWpVKzRCbFhFb2JBa0FFMXlaV0M5UkJ3Qko4SnpwTkRRTUFPcDVST1lHY1FBQWZHVXJhdWw2QUVIUTlNQUFDeEJUWTJodVxuYjNKeUsxTklRVEkxTmlBZ0FFSGs5TUFBQ3dOQU5CQUFLZ1J1WVcxbEFTTUI2UUlmWDE5M1ltbHVaR2RsYmw5aFpHUmZkRzlmYzNSaFxuWTJ0ZmNHOXBiblJsY2dDSUFRbHdjbTlrZFdObGNuTUNDR3hoYm1kMVlXZGxBZ1JTZFhOMEFBTkRPVGtBREhCeWIyTmxjM05sWkMxaVxuZVFRRmNuVnpkR01kTVM0NE55NHdJQ2d4TnpBMk4yVTVZV01nTWpBeU5TMHdOUzB3T1NrTVJHVmlhV0Z1SUdOc1lXNW5CakUwTGpBdVxuTmdaM1lXeHlkWE1HTUM0eU1DNHpESGRoYzIwdFltbHVaR2RsYmdZd0xqSXVPVElBYXc5MFlYSm5aWFJmWm1WaGRIVnlaWE1HS3c5dFxuZFhSaFlteGxMV2RzYjJKaGJITXJFMjV2Ym5SeVlYQndhVzVuTFdad2RHOXBiblFyQzJKMWJHc3RiV1Z0YjNKNUt3aHphV2R1TFdWNFxuZENzUGNtVm1aWEpsYm1ObExYUjVjR1Z6S3dwdGRXeDBhWFpoYkhWbFxuYDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1216\n\n}")},1292:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Bytes = exports.endianToBool = void 0;\nfunction endianToBool(endian) {\n    if (!endian) {\n        // By default, little endian\n        return true;\n    }\n    return endian === 'LE';\n}\nexports.endianToBool = endianToBool;\n/** Reads ints/bytes from a Uint8Array. All integers are little-endian. */\nclass Bytes {\n    /** Create a new Bytes that reads from the given data */\n    constructor(data) {\n        this.data = data;\n        this.view = new DataView(this.data.buffer, this.data.byteOffset, this.data.byteLength);\n        this.idx = 0;\n    }\n    /** Read a single byte */\n    readU8() {\n        this.ensureSize(1);\n        const result = this.data[this.idx];\n        this.idx++;\n        return result;\n    }\n    /** Read 2-byte little-endian integer (uint16_t) */\n    readU16(endian) {\n        this.ensureSize(2);\n        const result = this.view.getUint16(this.idx, endianToBool(endian));\n        this.idx += 2;\n        return result;\n    }\n    /** Read 4-byte little-endian integer (uint32_t) */\n    readU32(endian) {\n        this.ensureSize(4);\n        const result = this.view.getUint32(this.idx, endianToBool(endian));\n        this.idx += 4;\n        return result;\n    }\n    /** Read 6-byte little-endian integer */\n    readU48() {\n        this.ensureSize(6);\n        const low = this.readU32('LE');\n        const high = this.readU16('LE');\n        return BigInt(low) | (BigInt(high) << 32n);\n    }\n    /** Read 8-byte little-endian integer (uint64_t) */\n    readU64(endian) {\n        this.ensureSize(8);\n        const result = this.view.getBigUint64(this.idx, endianToBool(endian));\n        this.idx += 8;\n        return result;\n    }\n    /** Read the given number of bytes as array */\n    readBytes(numBytes) {\n        this.ensureSize(numBytes);\n        const result = this.data.slice(this.idx, this.idx + numBytes);\n        this.idx += numBytes;\n        return result;\n    }\n    ensureSize(extraBytes) {\n        if (this.data.length < this.idx + extraBytes) {\n            const bytesLeft = this.data.length - this.idx;\n            throw new Error(`Not enough bytes: Tried reading ${extraBytes} byte(s), but ` +\n                `there are only ${bytesLeft} byte(s) left`);\n        }\n    }\n}\nexports.Bytes = Bytes;\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L2lvL2J5dGVzLmpzPzVjMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CeXRlcyA9IGV4cG9ydHMuZW5kaWFuVG9Cb29sID0gdm9pZCAwO1xuZnVuY3Rpb24gZW5kaWFuVG9Cb29sKGVuZGlhbikge1xuICAgIGlmICghZW5kaWFuKSB7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGxpdHRsZSBlbmRpYW5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBlbmRpYW4gPT09ICdMRSc7XG59XG5leHBvcnRzLmVuZGlhblRvQm9vbCA9IGVuZGlhblRvQm9vbDtcbi8qKiBSZWFkcyBpbnRzL2J5dGVzIGZyb20gYSBVaW50OEFycmF5LiBBbGwgaW50ZWdlcnMgYXJlIGxpdHRsZS1lbmRpYW4uICovXG5jbGFzcyBCeXRlcyB7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBCeXRlcyB0aGF0IHJlYWRzIGZyb20gdGhlIGdpdmVuIGRhdGEgKi9cbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLmRhdGEuYnl0ZU9mZnNldCwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgfVxuICAgIC8qKiBSZWFkIGEgc2luZ2xlIGJ5dGUgKi9cbiAgICByZWFkVTgoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlU2l6ZSgxKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kYXRhW3RoaXMuaWR4XTtcbiAgICAgICAgdGhpcy5pZHgrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIFJlYWQgMi1ieXRlIGxpdHRsZS1lbmRpYW4gaW50ZWdlciAodWludDE2X3QpICovXG4gICAgcmVhZFUxNihlbmRpYW4pIHtcbiAgICAgICAgdGhpcy5lbnN1cmVTaXplKDIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMuaWR4LCBlbmRpYW5Ub0Jvb2woZW5kaWFuKSk7XG4gICAgICAgIHRoaXMuaWR4ICs9IDI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKiBSZWFkIDQtYnl0ZSBsaXR0bGUtZW5kaWFuIGludGVnZXIgKHVpbnQzMl90KSAqL1xuICAgIHJlYWRVMzIoZW5kaWFuKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlU2l6ZSg0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLmlkeCwgZW5kaWFuVG9Cb29sKGVuZGlhbikpO1xuICAgICAgICB0aGlzLmlkeCArPSA0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKiogUmVhZCA2LWJ5dGUgbGl0dGxlLWVuZGlhbiBpbnRlZ2VyICovXG4gICAgcmVhZFU0OCgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVTaXplKDYpO1xuICAgICAgICBjb25zdCBsb3cgPSB0aGlzLnJlYWRVMzIoJ0xFJyk7XG4gICAgICAgIGNvbnN0IGhpZ2ggPSB0aGlzLnJlYWRVMTYoJ0xFJyk7XG4gICAgICAgIHJldHVybiBCaWdJbnQobG93KSB8IChCaWdJbnQoaGlnaCkgPDwgMzJuKTtcbiAgICB9XG4gICAgLyoqIFJlYWQgOC1ieXRlIGxpdHRsZS1lbmRpYW4gaW50ZWdlciAodWludDY0X3QpICovXG4gICAgcmVhZFU2NChlbmRpYW4pIHtcbiAgICAgICAgdGhpcy5lbnN1cmVTaXplKDgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcuZ2V0QmlnVWludDY0KHRoaXMuaWR4LCBlbmRpYW5Ub0Jvb2woZW5kaWFuKSk7XG4gICAgICAgIHRoaXMuaWR4ICs9IDg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKiBSZWFkIHRoZSBnaXZlbiBudW1iZXIgb2YgYnl0ZXMgYXMgYXJyYXkgKi9cbiAgICByZWFkQnl0ZXMobnVtQnl0ZXMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVTaXplKG51bUJ5dGVzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuaWR4LCB0aGlzLmlkeCArIG51bUJ5dGVzKTtcbiAgICAgICAgdGhpcy5pZHggKz0gbnVtQnl0ZXM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuc3VyZVNpemUoZXh0cmFCeXRlcykge1xuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA8IHRoaXMuaWR4ICsgZXh0cmFCeXRlcykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXNMZWZ0ID0gdGhpcy5kYXRhLmxlbmd0aCAtIHRoaXMuaWR4O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZW5vdWdoIGJ5dGVzOiBUcmllZCByZWFkaW5nICR7ZXh0cmFCeXRlc30gYnl0ZShzKSwgYnV0IGAgK1xuICAgICAgICAgICAgICAgIGB0aGVyZSBhcmUgb25seSAke2J5dGVzTGVmdH0gYnl0ZShzKSBsZWZ0YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJ5dGVzID0gQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1292\n\n}")},1332:(__unused_webpack_module,exports)=>{eval("{/**\n * Data mask pattern reference\n * @type {Object}\n */\nexports.Patterns = {\n  PATTERN000: 0,\n  PATTERN001: 1,\n  PATTERN010: 2,\n  PATTERN011: 3,\n  PATTERN100: 4,\n  PATTERN101: 5,\n  PATTERN110: 6,\n  PATTERN111: 7\n}\n\n/**\n * Weighted penalty scores for the undesirable features\n * @type {Object}\n */\nconst PenaltyScores = {\n  N1: 3,\n  N2: 3,\n  N3: 40,\n  N4: 10\n}\n\n/**\n * Check if mask pattern value is valid\n *\n * @param  {Number}  mask    Mask pattern\n * @return {Boolean}         true if valid, false otherwise\n */\nexports.isValid = function isValid (mask) {\n  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7\n}\n\n/**\n * Returns mask pattern from a value.\n * If value is not valid, returns undefined\n *\n * @param  {Number|String} value        Mask pattern value\n * @return {Number}                     Valid mask pattern or undefined\n */\nexports.from = function from (value) {\n  return exports.isValid(value) ? parseInt(value, 10) : undefined\n}\n\n/**\n* Find adjacent modules in row/column with the same color\n* and assign a penalty value.\n*\n* Points: N1 + i\n* i is the amount by which the number of adjacent modules of the same color exceeds 5\n*/\nexports.getPenaltyN1 = function getPenaltyN1 (data) {\n  const size = data.size\n  let points = 0\n  let sameCountCol = 0\n  let sameCountRow = 0\n  let lastCol = null\n  let lastRow = null\n\n  for (let row = 0; row < size; row++) {\n    sameCountCol = sameCountRow = 0\n    lastCol = lastRow = null\n\n    for (let col = 0; col < size; col++) {\n      let module = data.get(row, col)\n      if (module === lastCol) {\n        sameCountCol++\n      } else {\n        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n        lastCol = module\n        sameCountCol = 1\n      }\n\n      module = data.get(col, row)\n      if (module === lastRow) {\n        sameCountRow++\n      } else {\n        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n        lastRow = module\n        sameCountRow = 1\n      }\n    }\n\n    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n  }\n\n  return points\n}\n\n/**\n * Find 2x2 blocks with the same color and assign a penalty value\n *\n * Points: N2 * (m - 1) * (n - 1)\n */\nexports.getPenaltyN2 = function getPenaltyN2 (data) {\n  const size = data.size\n  let points = 0\n\n  for (let row = 0; row < size - 1; row++) {\n    for (let col = 0; col < size - 1; col++) {\n      const last = data.get(row, col) +\n        data.get(row, col + 1) +\n        data.get(row + 1, col) +\n        data.get(row + 1, col + 1)\n\n      if (last === 4 || last === 0) points++\n    }\n  }\n\n  return points * PenaltyScores.N2\n}\n\n/**\n * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n * preceded or followed by light area 4 modules wide\n *\n * Points: N3 * number of pattern found\n */\nexports.getPenaltyN3 = function getPenaltyN3 (data) {\n  const size = data.size\n  let points = 0\n  let bitsCol = 0\n  let bitsRow = 0\n\n  for (let row = 0; row < size; row++) {\n    bitsCol = bitsRow = 0\n    for (let col = 0; col < size; col++) {\n      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)\n      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++\n\n      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)\n      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++\n    }\n  }\n\n  return points * PenaltyScores.N3\n}\n\n/**\n * Calculate proportion of dark modules in entire symbol\n *\n * Points: N4 * k\n *\n * k is the rating of the deviation of the proportion of dark modules\n * in the symbol from 50% in steps of 5%\n */\nexports.getPenaltyN4 = function getPenaltyN4 (data) {\n  let darkCount = 0\n  const modulesCount = data.data.length\n\n  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]\n\n  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)\n\n  return k * PenaltyScores.N4\n}\n\n/**\n * Return mask value at given position\n *\n * @param  {Number} maskPattern Pattern reference value\n * @param  {Number} i           Row\n * @param  {Number} j           Column\n * @return {Boolean}            Mask value\n */\nfunction getMaskAt (maskPattern, i, j) {\n  switch (maskPattern) {\n    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0\n    case exports.Patterns.PATTERN001: return i % 2 === 0\n    case exports.Patterns.PATTERN010: return j % 3 === 0\n    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0\n    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0\n    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0\n    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0\n    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0\n\n    default: throw new Error('bad maskPattern:' + maskPattern)\n  }\n}\n\n/**\n * Apply a mask pattern to a BitMatrix\n *\n * @param  {Number}    pattern Pattern reference number\n * @param  {BitMatrix} data    BitMatrix data\n */\nexports.applyMask = function applyMask (pattern, data) {\n  const size = data.size\n\n  for (let col = 0; col < size; col++) {\n    for (let row = 0; row < size; row++) {\n      if (data.isReserved(row, col)) continue\n      data.xor(row, col, getMaskAt(pattern, row, col))\n    }\n  }\n}\n\n/**\n * Returns the best mask pattern for data\n *\n * @param  {BitMatrix} data\n * @return {Number} Mask pattern reference number\n */\nexports.getBestMask = function getBestMask (data, setupFormatFunc) {\n  const numPatterns = Object.keys(exports.Patterns).length\n  let bestPattern = 0\n  let lowerPenalty = Infinity\n\n  for (let p = 0; p < numPatterns; p++) {\n    setupFormatFunc(p)\n    exports.applyMask(p, data)\n\n    // Calculate penalty\n    const penalty =\n      exports.getPenaltyN1(data) +\n      exports.getPenaltyN2(data) +\n      exports.getPenaltyN3(data) +\n      exports.getPenaltyN4(data)\n\n    // Undo previously applied mask\n    exports.applyMask(p, data)\n\n    if (penalty < lowerPenalty) {\n      lowerPenalty = penalty\n      bestPattern = p\n    }\n  }\n\n  return bestPattern\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCOztBQUVwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEMsc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2NvcmUvbWFzay1wYXR0ZXJuLmpzPzc5MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEYXRhIG1hc2sgcGF0dGVybiByZWZlcmVuY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuUGF0dGVybnMgPSB7XG4gIFBBVFRFUk4wMDA6IDAsXG4gIFBBVFRFUk4wMDE6IDEsXG4gIFBBVFRFUk4wMTA6IDIsXG4gIFBBVFRFUk4wMTE6IDMsXG4gIFBBVFRFUk4xMDA6IDQsXG4gIFBBVFRFUk4xMDE6IDUsXG4gIFBBVFRFUk4xMTA6IDYsXG4gIFBBVFRFUk4xMTE6IDdcbn1cblxuLyoqXG4gKiBXZWlnaHRlZCBwZW5hbHR5IHNjb3JlcyBmb3IgdGhlIHVuZGVzaXJhYmxlIGZlYXR1cmVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBQZW5hbHR5U2NvcmVzID0ge1xuICBOMTogMyxcbiAgTjI6IDMsXG4gIE4zOiA0MCxcbiAgTjQ6IDEwXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgbWFzayBwYXR0ZXJuIHZhbHVlIGlzIHZhbGlkXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgbWFzayAgICBNYXNrIHBhdHRlcm5cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKG1hc2spIHtcbiAgcmV0dXJuIG1hc2sgIT0gbnVsbCAmJiBtYXNrICE9PSAnJyAmJiAhaXNOYU4obWFzaykgJiYgbWFzayA+PSAwICYmIG1hc2sgPD0gN1xufVxuXG4vKipcbiAqIFJldHVybnMgbWFzayBwYXR0ZXJuIGZyb20gYSB2YWx1ZS5cbiAqIElmIHZhbHVlIGlzIG5vdCB2YWxpZCwgcmV0dXJucyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAgICAgICAgTWFzayBwYXR0ZXJuIHZhbHVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgVmFsaWQgbWFzayBwYXR0ZXJuIG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tICh2YWx1ZSkge1xuICByZXR1cm4gZXhwb3J0cy5pc1ZhbGlkKHZhbHVlKSA/IHBhcnNlSW50KHZhbHVlLCAxMCkgOiB1bmRlZmluZWRcbn1cblxuLyoqXG4qIEZpbmQgYWRqYWNlbnQgbW9kdWxlcyBpbiByb3cvY29sdW1uIHdpdGggdGhlIHNhbWUgY29sb3JcbiogYW5kIGFzc2lnbiBhIHBlbmFsdHkgdmFsdWUuXG4qXG4qIFBvaW50czogTjEgKyBpXG4qIGkgaXMgdGhlIGFtb3VudCBieSB3aGljaCB0aGUgbnVtYmVyIG9mIGFkamFjZW50IG1vZHVsZXMgb2YgdGhlIHNhbWUgY29sb3IgZXhjZWVkcyA1XG4qL1xuZXhwb3J0cy5nZXRQZW5hbHR5TjEgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjEgKGRhdGEpIHtcbiAgY29uc3Qgc2l6ZSA9IGRhdGEuc2l6ZVxuICBsZXQgcG9pbnRzID0gMFxuICBsZXQgc2FtZUNvdW50Q29sID0gMFxuICBsZXQgc2FtZUNvdW50Um93ID0gMFxuICBsZXQgbGFzdENvbCA9IG51bGxcbiAgbGV0IGxhc3RSb3cgPSBudWxsXG5cbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgc2l6ZTsgcm93KyspIHtcbiAgICBzYW1lQ291bnRDb2wgPSBzYW1lQ291bnRSb3cgPSAwXG4gICAgbGFzdENvbCA9IGxhc3RSb3cgPSBudWxsXG5cbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBzaXplOyBjb2wrKykge1xuICAgICAgbGV0IG1vZHVsZSA9IGRhdGEuZ2V0KHJvdywgY29sKVxuICAgICAgaWYgKG1vZHVsZSA9PT0gbGFzdENvbCkge1xuICAgICAgICBzYW1lQ291bnRDb2wrK1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNhbWVDb3VudENvbCA+PSA1KSBwb2ludHMgKz0gUGVuYWx0eVNjb3Jlcy5OMSArIChzYW1lQ291bnRDb2wgLSA1KVxuICAgICAgICBsYXN0Q29sID0gbW9kdWxlXG4gICAgICAgIHNhbWVDb3VudENvbCA9IDFcbiAgICAgIH1cblxuICAgICAgbW9kdWxlID0gZGF0YS5nZXQoY29sLCByb3cpXG4gICAgICBpZiAobW9kdWxlID09PSBsYXN0Um93KSB7XG4gICAgICAgIHNhbWVDb3VudFJvdysrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2FtZUNvdW50Um93ID49IDUpIHBvaW50cyArPSBQZW5hbHR5U2NvcmVzLk4xICsgKHNhbWVDb3VudFJvdyAtIDUpXG4gICAgICAgIGxhc3RSb3cgPSBtb2R1bGVcbiAgICAgICAgc2FtZUNvdW50Um93ID0gMVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzYW1lQ291bnRDb2wgPj0gNSkgcG9pbnRzICs9IFBlbmFsdHlTY29yZXMuTjEgKyAoc2FtZUNvdW50Q29sIC0gNSlcbiAgICBpZiAoc2FtZUNvdW50Um93ID49IDUpIHBvaW50cyArPSBQZW5hbHR5U2NvcmVzLk4xICsgKHNhbWVDb3VudFJvdyAtIDUpXG4gIH1cblxuICByZXR1cm4gcG9pbnRzXG59XG5cbi8qKlxuICogRmluZCAyeDIgYmxvY2tzIHdpdGggdGhlIHNhbWUgY29sb3IgYW5kIGFzc2lnbiBhIHBlbmFsdHkgdmFsdWVcbiAqXG4gKiBQb2ludHM6IE4yICogKG0gLSAxKSAqIChuIC0gMSlcbiAqL1xuZXhwb3J0cy5nZXRQZW5hbHR5TjIgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjIgKGRhdGEpIHtcbiAgY29uc3Qgc2l6ZSA9IGRhdGEuc2l6ZVxuICBsZXQgcG9pbnRzID0gMFxuXG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHNpemUgLSAxOyByb3crKykge1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHNpemUgLSAxOyBjb2wrKykge1xuICAgICAgY29uc3QgbGFzdCA9IGRhdGEuZ2V0KHJvdywgY29sKSArXG4gICAgICAgIGRhdGEuZ2V0KHJvdywgY29sICsgMSkgK1xuICAgICAgICBkYXRhLmdldChyb3cgKyAxLCBjb2wpICtcbiAgICAgICAgZGF0YS5nZXQocm93ICsgMSwgY29sICsgMSlcblxuICAgICAgaWYgKGxhc3QgPT09IDQgfHwgbGFzdCA9PT0gMCkgcG9pbnRzKytcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9pbnRzICogUGVuYWx0eVNjb3Jlcy5OMlxufVxuXG4vKipcbiAqIEZpbmQgMToxOjM6MToxIHJhdGlvIChkYXJrOmxpZ2h0OmRhcms6bGlnaHQ6ZGFyaykgcGF0dGVybiBpbiByb3cvY29sdW1uLFxuICogcHJlY2VkZWQgb3IgZm9sbG93ZWQgYnkgbGlnaHQgYXJlYSA0IG1vZHVsZXMgd2lkZVxuICpcbiAqIFBvaW50czogTjMgKiBudW1iZXIgb2YgcGF0dGVybiBmb3VuZFxuICovXG5leHBvcnRzLmdldFBlbmFsdHlOMyA9IGZ1bmN0aW9uIGdldFBlbmFsdHlOMyAoZGF0YSkge1xuICBjb25zdCBzaXplID0gZGF0YS5zaXplXG4gIGxldCBwb2ludHMgPSAwXG4gIGxldCBiaXRzQ29sID0gMFxuICBsZXQgYml0c1JvdyA9IDBcblxuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBzaXplOyByb3crKykge1xuICAgIGJpdHNDb2wgPSBiaXRzUm93ID0gMFxuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHNpemU7IGNvbCsrKSB7XG4gICAgICBiaXRzQ29sID0gKChiaXRzQ29sIDw8IDEpICYgMHg3RkYpIHwgZGF0YS5nZXQocm93LCBjb2wpXG4gICAgICBpZiAoY29sID49IDEwICYmIChiaXRzQ29sID09PSAweDVEMCB8fCBiaXRzQ29sID09PSAweDA1RCkpIHBvaW50cysrXG5cbiAgICAgIGJpdHNSb3cgPSAoKGJpdHNSb3cgPDwgMSkgJiAweDdGRikgfCBkYXRhLmdldChjb2wsIHJvdylcbiAgICAgIGlmIChjb2wgPj0gMTAgJiYgKGJpdHNSb3cgPT09IDB4NUQwIHx8IGJpdHNSb3cgPT09IDB4MDVEKSkgcG9pbnRzKytcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9pbnRzICogUGVuYWx0eVNjb3Jlcy5OM1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBwcm9wb3J0aW9uIG9mIGRhcmsgbW9kdWxlcyBpbiBlbnRpcmUgc3ltYm9sXG4gKlxuICogUG9pbnRzOiBONCAqIGtcbiAqXG4gKiBrIGlzIHRoZSByYXRpbmcgb2YgdGhlIGRldmlhdGlvbiBvZiB0aGUgcHJvcG9ydGlvbiBvZiBkYXJrIG1vZHVsZXNcbiAqIGluIHRoZSBzeW1ib2wgZnJvbSA1MCUgaW4gc3RlcHMgb2YgNSVcbiAqL1xuZXhwb3J0cy5nZXRQZW5hbHR5TjQgPSBmdW5jdGlvbiBnZXRQZW5hbHR5TjQgKGRhdGEpIHtcbiAgbGV0IGRhcmtDb3VudCA9IDBcbiAgY29uc3QgbW9kdWxlc0NvdW50ID0gZGF0YS5kYXRhLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kdWxlc0NvdW50OyBpKyspIGRhcmtDb3VudCArPSBkYXRhLmRhdGFbaV1cblxuICBjb25zdCBrID0gTWF0aC5hYnMoTWF0aC5jZWlsKChkYXJrQ291bnQgKiAxMDAgLyBtb2R1bGVzQ291bnQpIC8gNSkgLSAxMClcblxuICByZXR1cm4gayAqIFBlbmFsdHlTY29yZXMuTjRcbn1cblxuLyoqXG4gKiBSZXR1cm4gbWFzayB2YWx1ZSBhdCBnaXZlbiBwb3NpdGlvblxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gbWFza1BhdHRlcm4gUGF0dGVybiByZWZlcmVuY2UgdmFsdWVcbiAqIEBwYXJhbSAge051bWJlcn0gaSAgICAgICAgICAgUm93XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGogICAgICAgICAgIENvbHVtblxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICBNYXNrIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldE1hc2tBdCAobWFza1BhdHRlcm4sIGksIGopIHtcbiAgc3dpdGNoIChtYXNrUGF0dGVybikge1xuICAgIGNhc2UgZXhwb3J0cy5QYXR0ZXJucy5QQVRURVJOMDAwOiByZXR1cm4gKGkgKyBqKSAlIDIgPT09IDBcbiAgICBjYXNlIGV4cG9ydHMuUGF0dGVybnMuUEFUVEVSTjAwMTogcmV0dXJuIGkgJSAyID09PSAwXG4gICAgY2FzZSBleHBvcnRzLlBhdHRlcm5zLlBBVFRFUk4wMTA6IHJldHVybiBqICUgMyA9PT0gMFxuICAgIGNhc2UgZXhwb3J0cy5QYXR0ZXJucy5QQVRURVJOMDExOiByZXR1cm4gKGkgKyBqKSAlIDMgPT09IDBcbiAgICBjYXNlIGV4cG9ydHMuUGF0dGVybnMuUEFUVEVSTjEwMDogcmV0dXJuIChNYXRoLmZsb29yKGkgLyAyKSArIE1hdGguZmxvb3IoaiAvIDMpKSAlIDIgPT09IDBcbiAgICBjYXNlIGV4cG9ydHMuUGF0dGVybnMuUEFUVEVSTjEwMTogcmV0dXJuIChpICogaikgJSAyICsgKGkgKiBqKSAlIDMgPT09IDBcbiAgICBjYXNlIGV4cG9ydHMuUGF0dGVybnMuUEFUVEVSTjExMDogcmV0dXJuICgoaSAqIGopICUgMiArIChpICogaikgJSAzKSAlIDIgPT09IDBcbiAgICBjYXNlIGV4cG9ydHMuUGF0dGVybnMuUEFUVEVSTjExMTogcmV0dXJuICgoaSAqIGopICUgMyArIChpICsgaikgJSAyKSAlIDIgPT09IDBcblxuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignYmFkIG1hc2tQYXR0ZXJuOicgKyBtYXNrUGF0dGVybilcbiAgfVxufVxuXG4vKipcbiAqIEFwcGx5IGEgbWFzayBwYXR0ZXJuIHRvIGEgQml0TWF0cml4XG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSAgICBwYXR0ZXJuIFBhdHRlcm4gcmVmZXJlbmNlIG51bWJlclxuICogQHBhcmFtICB7Qml0TWF0cml4fSBkYXRhICAgIEJpdE1hdHJpeCBkYXRhXG4gKi9cbmV4cG9ydHMuYXBwbHlNYXNrID0gZnVuY3Rpb24gYXBwbHlNYXNrIChwYXR0ZXJuLCBkYXRhKSB7XG4gIGNvbnN0IHNpemUgPSBkYXRhLnNpemVcblxuICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBzaXplOyBjb2wrKykge1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHNpemU7IHJvdysrKSB7XG4gICAgICBpZiAoZGF0YS5pc1Jlc2VydmVkKHJvdywgY29sKSkgY29udGludWVcbiAgICAgIGRhdGEueG9yKHJvdywgY29sLCBnZXRNYXNrQXQocGF0dGVybiwgcm93LCBjb2wpKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJlc3QgbWFzayBwYXR0ZXJuIGZvciBkYXRhXG4gKlxuICogQHBhcmFtICB7Qml0TWF0cml4fSBkYXRhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IE1hc2sgcGF0dGVybiByZWZlcmVuY2UgbnVtYmVyXG4gKi9cbmV4cG9ydHMuZ2V0QmVzdE1hc2sgPSBmdW5jdGlvbiBnZXRCZXN0TWFzayAoZGF0YSwgc2V0dXBGb3JtYXRGdW5jKSB7XG4gIGNvbnN0IG51bVBhdHRlcm5zID0gT2JqZWN0LmtleXMoZXhwb3J0cy5QYXR0ZXJucykubGVuZ3RoXG4gIGxldCBiZXN0UGF0dGVybiA9IDBcbiAgbGV0IGxvd2VyUGVuYWx0eSA9IEluZmluaXR5XG5cbiAgZm9yIChsZXQgcCA9IDA7IHAgPCBudW1QYXR0ZXJuczsgcCsrKSB7XG4gICAgc2V0dXBGb3JtYXRGdW5jKHApXG4gICAgZXhwb3J0cy5hcHBseU1hc2socCwgZGF0YSlcblxuICAgIC8vIENhbGN1bGF0ZSBwZW5hbHR5XG4gICAgY29uc3QgcGVuYWx0eSA9XG4gICAgICBleHBvcnRzLmdldFBlbmFsdHlOMShkYXRhKSArXG4gICAgICBleHBvcnRzLmdldFBlbmFsdHlOMihkYXRhKSArXG4gICAgICBleHBvcnRzLmdldFBlbmFsdHlOMyhkYXRhKSArXG4gICAgICBleHBvcnRzLmdldFBlbmFsdHlONChkYXRhKVxuXG4gICAgLy8gVW5kbyBwcmV2aW91c2x5IGFwcGxpZWQgbWFza1xuICAgIGV4cG9ydHMuYXBwbHlNYXNrKHAsIGRhdGEpXG5cbiAgICBpZiAocGVuYWx0eSA8IGxvd2VyUGVuYWx0eSkge1xuICAgICAgbG93ZXJQZW5hbHR5ID0gcGVuYWx0eVxuICAgICAgYmVzdFBhdHRlcm4gPSBwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJlc3RQYXR0ZXJuXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1332\n\n}")},1333:module=>{eval("{// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\n\nmodule.exports = function () {\n  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2Nhbi1wcm9taXNlLmpzPzY3ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FuLXByb21pc2UgaGFzIGEgY3Jhc2ggaW4gc29tZSB2ZXJzaW9ucyBvZiByZWFjdCBuYXRpdmUgdGhhdCBkb250IGhhdmVcbi8vIHN0YW5kYXJkIGdsb2JhbCBvYmplY3RzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc29sZGFpci9ub2RlLXFyY29kZS9pc3N1ZXMvMTU3XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgUHJvbWlzZS5wcm90b3R5cGUgJiYgUHJvbWlzZS5wcm90b3R5cGUudGhlblxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1333\n\n}")},1354:module=>{"use strict";eval('{\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === "function") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n    var sourceMapping = "/*# ".concat(data, " */");\n    return [content].concat([sourceMapping]).join("\\n");\n  }\n  return [content].join("\\n");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM1NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcz9hZjEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1354\n\n}')},1427:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const Utils = __webpack_require__(6886)\nconst ECCode = __webpack_require__(7518)\nconst ECLevel = __webpack_require__(9953)\nconst Mode = __webpack_require__(208)\nconst VersionCheck = __webpack_require__(1878)\n\n// Generator polynomial used to encode version information\nconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\nconst G18_BCH = Utils.getBCHDigit(G18)\n\nfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\nfunction getReservedBitsCount (mode, version) {\n  // Character count indicator + mode indicator bits\n  return Mode.getCharCountIndicator(mode, version) + 4\n}\n\nfunction getTotalBitsFromDataArray (segments, version) {\n  let totalBits = 0\n\n  segments.forEach(function (data) {\n    const reservedBits = getReservedBitsCount(data.mode, version)\n    totalBits += reservedBits + data.getBitsLength()\n  })\n\n  return totalBits\n}\n\nfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    const length = getTotalBitsFromDataArray(segments, currentVersion)\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns version number from a value.\n * If value is not a valid version, returns defaultValue\n *\n * @param  {Number|String} value        QR Code version\n * @param  {Number}        defaultValue Fallback value\n * @return {Number}                     QR Code version number\n */\nexports.from = function from (value, defaultValue) {\n  if (VersionCheck.isValid(value)) {\n    return parseInt(value, 10)\n  }\n\n  return defaultValue\n}\n\n/**\n * Returns how much data can be stored with the specified QR code version\n * and error correction level\n *\n * @param  {Number} version              QR Code version (1-40)\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Mode}   mode                 Data mode\n * @return {Number}                      Quantity of storable data\n */\nexports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  // Use Byte mode as default\n  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n  // Return max number of storable codewords\n  switch (mode) {\n    case Mode.NUMERIC:\n      return Math.floor((usableBits / 10) * 3)\n\n    case Mode.ALPHANUMERIC:\n      return Math.floor((usableBits / 11) * 2)\n\n    case Mode.KANJI:\n      return Math.floor(usableBits / 13)\n\n    case Mode.BYTE:\n    default:\n      return Math.floor(usableBits / 8)\n  }\n}\n\n/**\n * Returns the minimum version needed to contain the amount of data\n *\n * @param  {Segment} data                    Segment of data\n * @param  {Number} [errorCorrectionLevel=H] Error correction level\n * @param  {Mode} mode                       Data mode\n * @return {Number}                          QR Code version\n */\nexports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n  let seg\n\n  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n  if (Array.isArray(data)) {\n    if (data.length > 1) {\n      return getBestVersionForMixedData(data, ecl)\n    }\n\n    if (data.length === 0) {\n      return 1\n    }\n\n    seg = data[0]\n  } else {\n    seg = data\n  }\n\n  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n}\n\n/**\n * Returns version information with relative error correction bits\n *\n * The version information is included in QR Code symbols of version 7 or larger.\n * It consists of an 18-bit sequence containing 6 data bits,\n * with 12 error correction bits calculated using the (18, 6) Golay code.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Encoded version info bits\n */\nexports.getEncodedBits = function getEncodedBits (version) {\n  if (!VersionCheck.isValid(version) || version < 7) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  let d = version << 12\n\n  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n  }\n\n  return (version << 12) | d\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQyNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBUztBQUMvQixlQUFlLG1CQUFPLENBQUMsSUFBeUI7QUFDaEQsZ0JBQWdCLG1CQUFPLENBQUMsSUFBMEI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLEdBQVE7QUFDN0IscUJBQXFCLG1CQUFPLENBQUMsSUFBaUI7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksZUFBZTtBQUMzQixZQUFZLDRCQUE0QjtBQUN4QztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2NvcmUvdmVyc2lvbi5qcz9jOGFhIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBFQ0NvZGUgPSByZXF1aXJlKCcuL2Vycm9yLWNvcnJlY3Rpb24tY29kZScpXG5jb25zdCBFQ0xldmVsID0gcmVxdWlyZSgnLi9lcnJvci1jb3JyZWN0aW9uLWxldmVsJylcbmNvbnN0IE1vZGUgPSByZXF1aXJlKCcuL21vZGUnKVxuY29uc3QgVmVyc2lvbkNoZWNrID0gcmVxdWlyZSgnLi92ZXJzaW9uLWNoZWNrJylcblxuLy8gR2VuZXJhdG9yIHBvbHlub21pYWwgdXNlZCB0byBlbmNvZGUgdmVyc2lvbiBpbmZvcm1hdGlvblxuY29uc3QgRzE4ID0gKDEgPDwgMTIpIHwgKDEgPDwgMTEpIHwgKDEgPDwgMTApIHwgKDEgPDwgOSkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgMikgfCAoMSA8PCAwKVxuY29uc3QgRzE4X0JDSCA9IFV0aWxzLmdldEJDSERpZ2l0KEcxOClcblxuZnVuY3Rpb24gZ2V0QmVzdFZlcnNpb25Gb3JEYXRhTGVuZ3RoIChtb2RlLCBsZW5ndGgsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG4gIGZvciAobGV0IGN1cnJlbnRWZXJzaW9uID0gMTsgY3VycmVudFZlcnNpb24gPD0gNDA7IGN1cnJlbnRWZXJzaW9uKyspIHtcbiAgICBpZiAobGVuZ3RoIDw9IGV4cG9ydHMuZ2V0Q2FwYWNpdHkoY3VycmVudFZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsLCBtb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWZXJzaW9uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBnZXRSZXNlcnZlZEJpdHNDb3VudCAobW9kZSwgdmVyc2lvbikge1xuICAvLyBDaGFyYWN0ZXIgY291bnQgaW5kaWNhdG9yICsgbW9kZSBpbmRpY2F0b3IgYml0c1xuICByZXR1cm4gTW9kZS5nZXRDaGFyQ291bnRJbmRpY2F0b3IobW9kZSwgdmVyc2lvbikgKyA0XG59XG5cbmZ1bmN0aW9uIGdldFRvdGFsQml0c0Zyb21EYXRhQXJyYXkgKHNlZ21lbnRzLCB2ZXJzaW9uKSB7XG4gIGxldCB0b3RhbEJpdHMgPSAwXG5cbiAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgIGNvbnN0IHJlc2VydmVkQml0cyA9IGdldFJlc2VydmVkQml0c0NvdW50KGRhdGEubW9kZSwgdmVyc2lvbilcbiAgICB0b3RhbEJpdHMgKz0gcmVzZXJ2ZWRCaXRzICsgZGF0YS5nZXRCaXRzTGVuZ3RoKClcbiAgfSlcblxuICByZXR1cm4gdG90YWxCaXRzXG59XG5cbmZ1bmN0aW9uIGdldEJlc3RWZXJzaW9uRm9yTWl4ZWREYXRhIChzZWdtZW50cywgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcbiAgZm9yIChsZXQgY3VycmVudFZlcnNpb24gPSAxOyBjdXJyZW50VmVyc2lvbiA8PSA0MDsgY3VycmVudFZlcnNpb24rKykge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldFRvdGFsQml0c0Zyb21EYXRhQXJyYXkoc2VnbWVudHMsIGN1cnJlbnRWZXJzaW9uKVxuICAgIGlmIChsZW5ndGggPD0gZXhwb3J0cy5nZXRDYXBhY2l0eShjdXJyZW50VmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIE1vZGUuTUlYRUQpKSB7XG4gICAgICByZXR1cm4gY3VycmVudFZlcnNpb25cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogUmV0dXJucyB2ZXJzaW9uIG51bWJlciBmcm9tIGEgdmFsdWUuXG4gKiBJZiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB2ZXJzaW9uLCByZXR1cm5zIGRlZmF1bHRWYWx1ZVxuICpcbiAqIEBwYXJhbSAge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICBRUiBDb2RlIHZlcnNpb25cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgIGRlZmF1bHRWYWx1ZSBGYWxsYmFjayB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIFFSIENvZGUgdmVyc2lvbiBudW1iZXJcbiAqL1xuZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoVmVyc2lvbkNoZWNrLmlzVmFsaWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMClcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWVcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGhvdyBtdWNoIGRhdGEgY2FuIGJlIHN0b3JlZCB3aXRoIHRoZSBzcGVjaWZpZWQgUVIgY29kZSB2ZXJzaW9uXG4gKiBhbmQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uICgxLTQwKVxuICogQHBhcmFtICB7TnVtYmVyfSBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXG4gKiBAcGFyYW0gIHtNb2RlfSAgIG1vZGUgICAgICAgICAgICAgICAgIERhdGEgbW9kZVxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICBRdWFudGl0eSBvZiBzdG9yYWJsZSBkYXRhXG4gKi9cbmV4cG9ydHMuZ2V0Q2FwYWNpdHkgPSBmdW5jdGlvbiBnZXRDYXBhY2l0eSAodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIG1vZGUpIHtcbiAgaWYgKCFWZXJzaW9uQ2hlY2suaXNWYWxpZCh2ZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBRUiBDb2RlIHZlcnNpb24nKVxuICB9XG5cbiAgLy8gVXNlIEJ5dGUgbW9kZSBhcyBkZWZhdWx0XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3VuZGVmaW5lZCcpIG1vZGUgPSBNb2RlLkJZVEVcblxuICAvLyBUb3RhbCBjb2Rld29yZHMgZm9yIHRoaXMgUVIgY29kZSB2ZXJzaW9uIChEYXRhICsgRXJyb3IgY29ycmVjdGlvbilcbiAgY29uc3QgdG90YWxDb2Rld29yZHMgPSBVdGlscy5nZXRTeW1ib2xUb3RhbENvZGV3b3Jkcyh2ZXJzaW9uKVxuXG4gIC8vIFRvdGFsIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICBjb25zdCBlY1RvdGFsQ29kZXdvcmRzID0gRUNDb2RlLmdldFRvdGFsQ29kZXdvcmRzQ291bnQodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpXG5cbiAgLy8gVG90YWwgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXG4gIGNvbnN0IGRhdGFUb3RhbENvZGV3b3Jkc0JpdHMgPSAodG90YWxDb2Rld29yZHMgLSBlY1RvdGFsQ29kZXdvcmRzKSAqIDhcblxuICBpZiAobW9kZSA9PT0gTW9kZS5NSVhFRCkgcmV0dXJuIGRhdGFUb3RhbENvZGV3b3Jkc0JpdHNcblxuICBjb25zdCB1c2FibGVCaXRzID0gZGF0YVRvdGFsQ29kZXdvcmRzQml0cyAtIGdldFJlc2VydmVkQml0c0NvdW50KG1vZGUsIHZlcnNpb24pXG5cbiAgLy8gUmV0dXJuIG1heCBudW1iZXIgb2Ygc3RvcmFibGUgY29kZXdvcmRzXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgTW9kZS5OVU1FUklDOlxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHVzYWJsZUJpdHMgLyAxMCkgKiAzKVxuXG4gICAgY2FzZSBNb2RlLkFMUEhBTlVNRVJJQzpcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKCh1c2FibGVCaXRzIC8gMTEpICogMilcblxuICAgIGNhc2UgTW9kZS5LQU5KSTpcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHVzYWJsZUJpdHMgLyAxMylcblxuICAgIGNhc2UgTW9kZS5CWVRFOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih1c2FibGVCaXRzIC8gOClcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gdmVyc2lvbiBuZWVkZWQgdG8gY29udGFpbiB0aGUgYW1vdW50IG9mIGRhdGFcbiAqXG4gKiBAcGFyYW0gIHtTZWdtZW50fSBkYXRhICAgICAgICAgICAgICAgICAgICBTZWdtZW50IG9mIGRhdGFcbiAqIEBwYXJhbSAge051bWJlcn0gW2Vycm9yQ29ycmVjdGlvbkxldmVsPUhdIEVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAqIEBwYXJhbSAge01vZGV9IG1vZGUgICAgICAgICAgICAgICAgICAgICAgIERhdGEgbW9kZVxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgICAgICAgUVIgQ29kZSB2ZXJzaW9uXG4gKi9cbmV4cG9ydHMuZ2V0QmVzdFZlcnNpb25Gb3JEYXRhID0gZnVuY3Rpb24gZ2V0QmVzdFZlcnNpb25Gb3JEYXRhIChkYXRhLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICBsZXQgc2VnXG5cbiAgY29uc3QgZWNsID0gRUNMZXZlbC5mcm9tKGVycm9yQ29ycmVjdGlvbkxldmVsLCBFQ0xldmVsLk0pXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmVzdFZlcnNpb25Gb3JNaXhlZERhdGEoZGF0YSwgZWNsKVxuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBzZWcgPSBkYXRhWzBdXG4gIH0gZWxzZSB7XG4gICAgc2VnID0gZGF0YVxuICB9XG5cbiAgcmV0dXJuIGdldEJlc3RWZXJzaW9uRm9yRGF0YUxlbmd0aChzZWcubW9kZSwgc2VnLmdldExlbmd0aCgpLCBlY2wpXG59XG5cbi8qKlxuICogUmV0dXJucyB2ZXJzaW9uIGluZm9ybWF0aW9uIHdpdGggcmVsYXRpdmUgZXJyb3IgY29ycmVjdGlvbiBiaXRzXG4gKlxuICogVGhlIHZlcnNpb24gaW5mb3JtYXRpb24gaXMgaW5jbHVkZWQgaW4gUVIgQ29kZSBzeW1ib2xzIG9mIHZlcnNpb24gNyBvciBsYXJnZXIuXG4gKiBJdCBjb25zaXN0cyBvZiBhbiAxOC1iaXQgc2VxdWVuY2UgY29udGFpbmluZyA2IGRhdGEgYml0cyxcbiAqIHdpdGggMTIgZXJyb3IgY29ycmVjdGlvbiBiaXRzIGNhbGN1bGF0ZWQgdXNpbmcgdGhlICgxOCwgNikgR29sYXkgY29kZS5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgRW5jb2RlZCB2ZXJzaW9uIGluZm8gYml0c1xuICovXG5leHBvcnRzLmdldEVuY29kZWRCaXRzID0gZnVuY3Rpb24gZ2V0RW5jb2RlZEJpdHMgKHZlcnNpb24pIHtcbiAgaWYgKCFWZXJzaW9uQ2hlY2suaXNWYWxpZCh2ZXJzaW9uKSB8fCB2ZXJzaW9uIDwgNykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBRUiBDb2RlIHZlcnNpb24nKVxuICB9XG5cbiAgbGV0IGQgPSB2ZXJzaW9uIDw8IDEyXG5cbiAgd2hpbGUgKFV0aWxzLmdldEJDSERpZ2l0KGQpIC0gRzE4X0JDSCA+PSAwKSB7XG4gICAgZCBePSAoRzE4IDw8IChVdGlscy5nZXRCQ0hEaWdpdChkKSAtIEcxOF9CQ0gpKVxuICB9XG5cbiAgcmV0dXJuICh2ZXJzaW9uIDw8IDEyKSB8IGRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1427\n\n}")},1433:(module,__unused_webpack_exports,__webpack_require__)=>{eval("{const Mode = __webpack_require__(208)\n\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nconst ALPHA_NUM_CHARS = [\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n]\n\nfunction AlphanumericData (data) {\n  this.mode = Mode.ALPHANUMERIC\n  this.data = data\n}\n\nAlphanumericData.getBitsLength = function getBitsLength (length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2)\n}\n\nAlphanumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength () {\n  return AlphanumericData.getBitsLength(this.data.length)\n}\n\nAlphanumericData.prototype.write = function write (bitBuffer) {\n  let i\n\n  // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45\n\n    // The character value of the second digit is added to the product\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])\n\n    // The sum is then stored as 11-bit binary number\n    bitBuffer.put(value, 11)\n  }\n\n  // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)\n  }\n}\n\nmodule.exports = AlphanumericData\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsR0FBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvY29yZS9hbHBoYW51bWVyaWMtZGF0YS5qcz85ZDk0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1vZGUgPSByZXF1aXJlKCcuL21vZGUnKVxuXG4vKipcbiAqIEFycmF5IG9mIGNoYXJhY3RlcnMgYXZhaWxhYmxlIGluIGFscGhhbnVtZXJpYyBtb2RlXG4gKlxuICogQXMgcGVyIFFSIENvZGUgc3BlY2lmaWNhdGlvbiwgdG8gZWFjaCBjaGFyYWN0ZXJcbiAqIGlzIGFzc2lnbmVkIGEgdmFsdWUgZnJvbSAwIHRvIDQ0IHdoaWNoIGluIHRoaXMgY2FzZSBjb2luY2lkZXNcbiAqIHdpdGggdGhlIGFycmF5IGluZGV4XG4gKlxuICogQHR5cGUge0FycmF5fVxuICovXG5jb25zdCBBTFBIQV9OVU1fQ0hBUlMgPSBbXG4gICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcbiAgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLFxuICAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsXG4gICcgJywgJyQnLCAnJScsICcqJywgJysnLCAnLScsICcuJywgJy8nLCAnOidcbl1cblxuZnVuY3Rpb24gQWxwaGFudW1lcmljRGF0YSAoZGF0YSkge1xuICB0aGlzLm1vZGUgPSBNb2RlLkFMUEhBTlVNRVJJQ1xuICB0aGlzLmRhdGEgPSBkYXRhXG59XG5cbkFscGhhbnVtZXJpY0RhdGEuZ2V0Qml0c0xlbmd0aCA9IGZ1bmN0aW9uIGdldEJpdHNMZW5ndGggKGxlbmd0aCkge1xuICByZXR1cm4gMTEgKiBNYXRoLmZsb29yKGxlbmd0aCAvIDIpICsgNiAqIChsZW5ndGggJSAyKVxufVxuXG5BbHBoYW51bWVyaWNEYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aFxufVxuXG5BbHBoYW51bWVyaWNEYXRhLnByb3RvdHlwZS5nZXRCaXRzTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Qml0c0xlbmd0aCAoKSB7XG4gIHJldHVybiBBbHBoYW51bWVyaWNEYXRhLmdldEJpdHNMZW5ndGgodGhpcy5kYXRhLmxlbmd0aClcbn1cblxuQWxwaGFudW1lcmljRGF0YS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoYml0QnVmZmVyKSB7XG4gIGxldCBpXG5cbiAgLy8gSW5wdXQgZGF0YSBjaGFyYWN0ZXJzIGFyZSBkaXZpZGVkIGludG8gZ3JvdXBzIG9mIHR3byBjaGFyYWN0ZXJzXG4gIC8vIGFuZCBlbmNvZGVkIGFzIDExLWJpdCBiaW5hcnkgY29kZXMuXG4gIGZvciAoaSA9IDA7IGkgKyAyIDw9IHRoaXMuZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgIC8vIFRoZSBjaGFyYWN0ZXIgdmFsdWUgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBtdWx0aXBsaWVkIGJ5IDQ1XG4gICAgbGV0IHZhbHVlID0gQUxQSEFfTlVNX0NIQVJTLmluZGV4T2YodGhpcy5kYXRhW2ldKSAqIDQ1XG5cbiAgICAvLyBUaGUgY2hhcmFjdGVyIHZhbHVlIG9mIHRoZSBzZWNvbmQgZGlnaXQgaXMgYWRkZWQgdG8gdGhlIHByb2R1Y3RcbiAgICB2YWx1ZSArPSBBTFBIQV9OVU1fQ0hBUlMuaW5kZXhPZih0aGlzLmRhdGFbaSArIDFdKVxuXG4gICAgLy8gVGhlIHN1bSBpcyB0aGVuIHN0b3JlZCBhcyAxMS1iaXQgYmluYXJ5IG51bWJlclxuICAgIGJpdEJ1ZmZlci5wdXQodmFsdWUsIDExKVxuICB9XG5cbiAgLy8gSWYgdGhlIG51bWJlciBvZiBpbnB1dCBkYXRhIGNoYXJhY3RlcnMgaXMgbm90IGEgbXVsdGlwbGUgb2YgdHdvLFxuICAvLyB0aGUgY2hhcmFjdGVyIHZhbHVlIG9mIHRoZSBmaW5hbCBjaGFyYWN0ZXIgaXMgZW5jb2RlZCBhcyBhIDYtYml0IGJpbmFyeSBudW1iZXIuXG4gIGlmICh0aGlzLmRhdGEubGVuZ3RoICUgMikge1xuICAgIGJpdEJ1ZmZlci5wdXQoQUxQSEFfTlVNX0NIQVJTLmluZGV4T2YodGhpcy5kYXRhW2ldKSwgNilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFscGhhbnVtZXJpY0RhdGFcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1433\n\n}")},1447:(__unused_webpack_module,exports)=>{"use strict";eval('{\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return "";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join("");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzP2M4ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1447\n\n}')},1451:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.writeVarSize = exports.readVarSize = void 0;\n/**\n * Read a VARINT, which encodes a size in the Bitcoin protocol, see:\n * https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\n */\nfunction readVarSize(bytes) {\n    const firstByte = bytes.readU8();\n    if (firstByte <= 0xfc) {\n        return firstByte;\n    }\n    else if (firstByte == 0xfd) {\n        return bytes.readU16();\n    }\n    else if (firstByte == 0xfe) {\n        return bytes.readU32();\n    }\n    else if (firstByte == 0xff) {\n        return bytes.readU64();\n    }\n    else {\n        throw 'Unreachable';\n    }\n}\nexports.readVarSize = readVarSize;\n/**\n * Write a VARINT, which encodes a size in the Bitcoin protocol, see:\n * https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\n * @param size Size integer to write\n * @param writer Writer to write the size to\n */\nfunction writeVarSize(size, writer) {\n    if (size <= 0xfc) {\n        writer.putU8(size);\n    }\n    else if (size <= 0xffff) {\n        writer.putU8(0xfd);\n        writer.putU16(size);\n    }\n    else if (size <= 0xffffffff) {\n        writer.putU8(0xfe);\n        writer.putU32(size);\n    }\n    else if (size <= 0xffffffffffffffffn) {\n        writer.putU8(0xff);\n        writer.putU64(size);\n    }\n    else {\n        throw 'Integer too big for VarSize';\n    }\n}\nexports.writeVarSize = writeVarSize;\n//# sourceMappingURL=varsize.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ1MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvaW8vdmFyc2l6ZS5qcz80OWJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JpdGVWYXJTaXplID0gZXhwb3J0cy5yZWFkVmFyU2l6ZSA9IHZvaWQgMDtcbi8qKlxuICogUmVhZCBhIFZBUklOVCwgd2hpY2ggZW5jb2RlcyBhIHNpemUgaW4gdGhlIEJpdGNvaW4gcHJvdG9jb2wsIHNlZTpcbiAqIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL1Byb3RvY29sX2RvY3VtZW50YXRpb24jVmFyaWFibGVfbGVuZ3RoX2ludGVnZXJcbiAqL1xuZnVuY3Rpb24gcmVhZFZhclNpemUoYnl0ZXMpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBieXRlcy5yZWFkVTgoKTtcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4ZmMpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlID09IDB4ZmQpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnJlYWRVMTYoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlID09IDB4ZmUpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnJlYWRVMzIoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlID09IDB4ZmYpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnJlYWRVNjQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93ICdVbnJlYWNoYWJsZSc7XG4gICAgfVxufVxuZXhwb3J0cy5yZWFkVmFyU2l6ZSA9IHJlYWRWYXJTaXplO1xuLyoqXG4gKiBXcml0ZSBhIFZBUklOVCwgd2hpY2ggZW5jb2RlcyBhIHNpemUgaW4gdGhlIEJpdGNvaW4gcHJvdG9jb2wsIHNlZTpcbiAqIGh0dHBzOi8vZW4uYml0Y29pbi5pdC93aWtpL1Byb3RvY29sX2RvY3VtZW50YXRpb24jVmFyaWFibGVfbGVuZ3RoX2ludGVnZXJcbiAqIEBwYXJhbSBzaXplIFNpemUgaW50ZWdlciB0byB3cml0ZVxuICogQHBhcmFtIHdyaXRlciBXcml0ZXIgdG8gd3JpdGUgdGhlIHNpemUgdG9cbiAqL1xuZnVuY3Rpb24gd3JpdGVWYXJTaXplKHNpemUsIHdyaXRlcikge1xuICAgIGlmIChzaXplIDw9IDB4ZmMpIHtcbiAgICAgICAgd3JpdGVyLnB1dFU4KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaXplIDw9IDB4ZmZmZikge1xuICAgICAgICB3cml0ZXIucHV0VTgoMHhmZCk7XG4gICAgICAgIHdyaXRlci5wdXRVMTYoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpemUgPD0gMHhmZmZmZmZmZikge1xuICAgICAgICB3cml0ZXIucHV0VTgoMHhmZSk7XG4gICAgICAgIHdyaXRlci5wdXRVMzIoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpemUgPD0gMHhmZmZmZmZmZmZmZmZmZmZmbikge1xuICAgICAgICB3cml0ZXIucHV0VTgoMHhmZik7XG4gICAgICAgIHdyaXRlci5wdXRVNjQoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyAnSW50ZWdlciB0b28gYmlnIGZvciBWYXJTaXplJztcbiAgICB9XG59XG5leHBvcnRzLndyaXRlVmFyU2l6ZSA9IHdyaXRlVmFyU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhcnNpemUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1451\n\n}")},1509:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HdNode = void 0;\nconst ecc_js_1 = __webpack_require__(3799);\nconst hmac_js_1 = __webpack_require__(3771);\nconst hash_js_1 = __webpack_require__(5632);\nconst bytes_js_1 = __webpack_require__(1292);\nconst str_js_1 = __webpack_require__(2392);\nconst writerbytes_js_1 = __webpack_require__(8161);\nconst HIGHEST_BIT = 0x80000000;\nclass HdNode {\n    constructor(params) {\n        this._ecc = new ecc_js_1.Ecc();\n        this._seckey = params.seckey;\n        this._pubkey = params.pubkey;\n        this._chainCode = params.chainCode;\n        this._depth = params.depth;\n        this._index = params.index;\n        this._parentFingerprint = params.parentFingerprint;\n    }\n    seckey() {\n        return this._seckey;\n    }\n    pubkey() {\n        return this._pubkey;\n    }\n    pkh() {\n        return (0, hash_js_1.shaRmd160)(this._pubkey);\n    }\n    fingerprint() {\n        return this.pkh().slice(0, 4);\n    }\n    index() {\n        return this._index;\n    }\n    depth() {\n        return this._depth;\n    }\n    parentFingerprint() {\n        return this._parentFingerprint;\n    }\n    chainCode() {\n        return this._chainCode;\n    }\n    derive(index) {\n        const isHardened = index >= HIGHEST_BIT;\n        const data = new writerbytes_js_1.WriterBytes(1 + 32 + 4);\n        if (isHardened) {\n            if (this._seckey === undefined) {\n                throw new Error('Missing private key for hardened child key');\n            }\n            data.putU8(0);\n            data.putBytes(this._seckey);\n        }\n        else {\n            data.putBytes(this._pubkey);\n        }\n        data.putU32(index, 'BE');\n        const hashed = (0, hmac_js_1.hmacSha512)(this._chainCode, data.data);\n        const hashedLeft = hashed.slice(0, 32);\n        const hashedRight = hashed.slice(32);\n        // In case the secret key doesn't lie on the curve, we proceed with the\n        // next index. This is astronomically unlikely but part of the specification.\n        if (!this._ecc.isValidSeckey(hashedLeft)) {\n            return this.derive(index + 1);\n        }\n        let seckey;\n        let pubkey;\n        if (this._seckey !== undefined) {\n            try {\n                seckey = this._ecc.seckeyAdd(this._seckey, hashedLeft);\n            }\n            catch (ex) {\n                console.log('Skipping index', index, ':', ex);\n                return this.derive(index + 1);\n            }\n            pubkey = this._ecc.derivePubkey(seckey);\n        }\n        else {\n            try {\n                pubkey = this._ecc.pubkeyAdd(this._pubkey, hashedLeft);\n            }\n            catch (ex) {\n                console.log('Skipping index', index, ':', ex);\n                return this.derive(index + 1);\n            }\n            seckey = undefined;\n        }\n        return new HdNode({\n            seckey: seckey,\n            pubkey: pubkey,\n            chainCode: hashedRight,\n            depth: this._depth + 1,\n            index,\n            parentFingerprint: new bytes_js_1.Bytes(this.fingerprint()).readU32('BE'),\n        });\n    }\n    deriveHardened(index) {\n        if (index < 0 || index >= HIGHEST_BIT) {\n            throw new TypeError(`index must be between 0 and ${HIGHEST_BIT}, got ${index}`);\n        }\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this._parentFingerprint) {\n                throw new TypeError('Expected master, got child');\n            }\n            splitPath = splitPath.slice(1);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let hd = this;\n        for (const step of splitPath) {\n            if (step.slice(-1) === `'`) {\n                hd = hd.deriveHardened(parseInt(step.slice(0, -1), 10));\n            }\n            else {\n                hd = hd.derive(parseInt(step, 10));\n            }\n        }\n        return hd;\n    }\n    static fromPrivateKey(seckey, chainCode) {\n        return new HdNode({\n            seckey: seckey,\n            pubkey: new ecc_js_1.Ecc().derivePubkey(seckey),\n            chainCode,\n            depth: 0,\n            index: 0,\n            parentFingerprint: 0,\n        });\n    }\n    static fromSeed(seed) {\n        if (seed.length < 16 || seed.length > 64) {\n            throw new TypeError('Seed must be between 16 and 64 bytes long');\n        }\n        const hashed = (0, hmac_js_1.hmacSha512)((0, str_js_1.strToBytes)('Bitcoin seed'), seed);\n        const hashedLeft = hashed.slice(0, 32);\n        const hashedRight = hashed.slice(32);\n        return HdNode.fromPrivateKey(hashedLeft, hashedRight);\n    }\n}\nexports.HdNode = HdNode;\n//# sourceMappingURL=hdwallet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUwOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsaUJBQWlCLG1CQUFPLENBQUMsSUFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFXO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLElBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsSUFBZTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFhO0FBQ3RDLHlCQUF5QixtQkFBTyxDQUFDLElBQXFCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVksUUFBUSxNQUFNO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L2hkd2FsbGV0LmpzP2JhZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjUgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IZE5vZGUgPSB2b2lkIDA7XG5jb25zdCBlY2NfanNfMSA9IHJlcXVpcmUoXCIuL2VjYy5qc1wiKTtcbmNvbnN0IGhtYWNfanNfMSA9IHJlcXVpcmUoXCIuL2htYWMuanNcIik7XG5jb25zdCBoYXNoX2pzXzEgPSByZXF1aXJlKFwiLi9oYXNoLmpzXCIpO1xuY29uc3QgYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuL2lvL2J5dGVzLmpzXCIpO1xuY29uc3Qgc3RyX2pzXzEgPSByZXF1aXJlKFwiLi9pby9zdHIuanNcIik7XG5jb25zdCB3cml0ZXJieXRlc19qc18xID0gcmVxdWlyZShcIi4vaW8vd3JpdGVyYnl0ZXMuanNcIik7XG5jb25zdCBISUdIRVNUX0JJVCA9IDB4ODAwMDAwMDA7XG5jbGFzcyBIZE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICB0aGlzLl9lY2MgPSBuZXcgZWNjX2pzXzEuRWNjKCk7XG4gICAgICAgIHRoaXMuX3NlY2tleSA9IHBhcmFtcy5zZWNrZXk7XG4gICAgICAgIHRoaXMuX3B1YmtleSA9IHBhcmFtcy5wdWJrZXk7XG4gICAgICAgIHRoaXMuX2NoYWluQ29kZSA9IHBhcmFtcy5jaGFpbkNvZGU7XG4gICAgICAgIHRoaXMuX2RlcHRoID0gcGFyYW1zLmRlcHRoO1xuICAgICAgICB0aGlzLl9pbmRleCA9IHBhcmFtcy5pbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50RmluZ2VycHJpbnQgPSBwYXJhbXMucGFyZW50RmluZ2VycHJpbnQ7XG4gICAgfVxuICAgIHNlY2tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlY2tleTtcbiAgICB9XG4gICAgcHVia2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVia2V5O1xuICAgIH1cbiAgICBwa2goKSB7XG4gICAgICAgIHJldHVybiAoMCwgaGFzaF9qc18xLnNoYVJtZDE2MCkodGhpcy5fcHVia2V5KTtcbiAgICB9XG4gICAgZmluZ2VycHJpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBraCgpLnNsaWNlKDAsIDQpO1xuICAgIH1cbiAgICBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH1cbiAgICBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcHRoO1xuICAgIH1cbiAgICBwYXJlbnRGaW5nZXJwcmludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudEZpbmdlcnByaW50O1xuICAgIH1cbiAgICBjaGFpbkNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFpbkNvZGU7XG4gICAgfVxuICAgIGRlcml2ZShpbmRleCkge1xuICAgICAgICBjb25zdCBpc0hhcmRlbmVkID0gaW5kZXggPj0gSElHSEVTVF9CSVQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgd3JpdGVyYnl0ZXNfanNfMS5Xcml0ZXJCeXRlcygxICsgMzIgKyA0KTtcbiAgICAgICAgaWYgKGlzSGFyZGVuZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZWNrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlIGtleSBmb3IgaGFyZGVuZWQgY2hpbGQga2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnB1dFU4KDApO1xuICAgICAgICAgICAgZGF0YS5wdXRCeXRlcyh0aGlzLl9zZWNrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5wdXRCeXRlcyh0aGlzLl9wdWJrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHV0VTMyKGluZGV4LCAnQkUnKTtcbiAgICAgICAgY29uc3QgaGFzaGVkID0gKDAsIGhtYWNfanNfMS5obWFjU2hhNTEyKSh0aGlzLl9jaGFpbkNvZGUsIGRhdGEuZGF0YSk7XG4gICAgICAgIGNvbnN0IGhhc2hlZExlZnQgPSBoYXNoZWQuc2xpY2UoMCwgMzIpO1xuICAgICAgICBjb25zdCBoYXNoZWRSaWdodCA9IGhhc2hlZC5zbGljZSgzMik7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIHNlY3JldCBrZXkgZG9lc24ndCBsaWUgb24gdGhlIGN1cnZlLCB3ZSBwcm9jZWVkIHdpdGggdGhlXG4gICAgICAgIC8vIG5leHQgaW5kZXguIFRoaXMgaXMgYXN0cm9ub21pY2FsbHkgdW5saWtlbHkgYnV0IHBhcnQgb2YgdGhlIHNwZWNpZmljYXRpb24uXG4gICAgICAgIGlmICghdGhpcy5fZWNjLmlzVmFsaWRTZWNrZXkoaGFzaGVkTGVmdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWNrZXk7XG4gICAgICAgIGxldCBwdWJrZXk7XG4gICAgICAgIGlmICh0aGlzLl9zZWNrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWNrZXkgPSB0aGlzLl9lY2Muc2Vja2V5QWRkKHRoaXMuX3NlY2tleSwgaGFzaGVkTGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2tpcHBpbmcgaW5kZXgnLCBpbmRleCwgJzonLCBleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwdWJrZXkgPSB0aGlzLl9lY2MuZGVyaXZlUHVia2V5KHNlY2tleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHB1YmtleSA9IHRoaXMuX2VjYy5wdWJrZXlBZGQodGhpcy5fcHVia2V5LCBoYXNoZWRMZWZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTa2lwcGluZyBpbmRleCcsIGluZGV4LCAnOicsIGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlY2tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhkTm9kZSh7XG4gICAgICAgICAgICBzZWNrZXk6IHNlY2tleSxcbiAgICAgICAgICAgIHB1YmtleTogcHVia2V5LFxuICAgICAgICAgICAgY2hhaW5Db2RlOiBoYXNoZWRSaWdodCxcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLl9kZXB0aCArIDEsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50OiBuZXcgYnl0ZXNfanNfMS5CeXRlcyh0aGlzLmZpbmdlcnByaW50KCkpLnJlYWRVMzIoJ0JFJyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXJpdmVIYXJkZW5lZChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IEhJR0hFU1RfQklUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbmRleCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgJHtISUdIRVNUX0JJVH0sIGdvdCAke2luZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIEhJR0hFU1RfQklUKTtcbiAgICB9XG4gICAgZGVyaXZlUGF0aChwYXRoKSB7XG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChzcGxpdFBhdGhbMF0gPT09ICdtJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudEZpbmdlcnByaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbWFzdGVyLCBnb3QgY2hpbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwbGl0UGF0aCA9IHNwbGl0UGF0aC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgbGV0IGhkID0gdGhpcztcbiAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHNwbGl0UGF0aCkge1xuICAgICAgICAgICAgaWYgKHN0ZXAuc2xpY2UoLTEpID09PSBgJ2ApIHtcbiAgICAgICAgICAgICAgICBoZCA9IGhkLmRlcml2ZUhhcmRlbmVkKHBhcnNlSW50KHN0ZXAuc2xpY2UoMCwgLTEpLCAxMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGQgPSBoZC5kZXJpdmUocGFyc2VJbnQoc3RlcCwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShzZWNrZXksIGNoYWluQ29kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEhkTm9kZSh7XG4gICAgICAgICAgICBzZWNrZXk6IHNlY2tleSxcbiAgICAgICAgICAgIHB1YmtleTogbmV3IGVjY19qc18xLkVjYygpLmRlcml2ZVB1YmtleShzZWNrZXkpLFxuICAgICAgICAgICAgY2hhaW5Db2RlLFxuICAgICAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50OiAwLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoIDwgMTYgfHwgc2VlZC5sZW5ndGggPiA2NCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2VlZCBtdXN0IGJlIGJldHdlZW4gMTYgYW5kIDY0IGJ5dGVzIGxvbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNoZWQgPSAoMCwgaG1hY19qc18xLmhtYWNTaGE1MTIpKCgwLCBzdHJfanNfMS5zdHJUb0J5dGVzKSgnQml0Y29pbiBzZWVkJyksIHNlZWQpO1xuICAgICAgICBjb25zdCBoYXNoZWRMZWZ0ID0gaGFzaGVkLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgY29uc3QgaGFzaGVkUmlnaHQgPSBoYXNoZWQuc2xpY2UoMzIpO1xuICAgICAgICByZXR1cm4gSGROb2RlLmZyb21Qcml2YXRlS2V5KGhhc2hlZExlZnQsIGhhc2hlZFJpZ2h0KTtcbiAgICB9XG59XG5leHBvcnRzLkhkTm9kZSA9IEhkTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhkd2FsbGV0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1509\n\n}")},1659:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SIG_HASH_TYPES_LEGACY = exports.SIG_HASH_TYPES_BIP143 = exports.SINGLE_ANYONECANPAY_LEGACY = exports.SINGLE_LEGACY = exports.NONE_ANYONECANPAY_LEGACY = exports.NONE_LEGACY = exports.ALL_ANYONECANPAY_LEGACY = exports.ALL_LEGACY = exports.SINGLE_ANYONECANPAY_BIP143 = exports.SINGLE_BIP143 = exports.NONE_ANYONECANPAY_BIP143 = exports.NONE_BIP143 = exports.ALL_ANYONECANPAY_BIP143 = exports.ALL_BIP143 = exports.SigHashTypeOutputs = exports.SigHashTypeInputs = exports.SigHashTypeVariant = exports.SigHashType = void 0;\n/** Type of sighash used to sign for an input for a OP_CHECKSIG operation. */\nclass SigHashType {\n    constructor(params) {\n        this.variant = params.variant;\n        this.inputType = params.inputType;\n        this.outputType = params.outputType;\n    }\n    /** Reconstruct a SigHashType from the flags */\n    static fromInt(flags) {\n        if (flags > 0xff || flags < 0) {\n            return undefined;\n        }\n        // No bits may be set other than 0x80, 0x40, 0x02 and 0x01\n        if ((flags & 0x3c) != 0) {\n            return undefined;\n        }\n        const outputFlags = flags & 0x03;\n        if (outputFlags == 0) {\n            // 0 is not a valid output type\n            return undefined;\n        }\n        return new SigHashType({\n            variant: flags & 0x40\n                ? SigHashTypeVariant.BIP143\n                : SigHashTypeVariant.LEGACY,\n            inputType: flags & 0x80\n                ? SigHashTypeInputs.ANYONECANPAY\n                : SigHashTypeInputs.FIXED,\n            outputType: outputFlags == 1\n                ? SigHashTypeOutputs.ALL\n                : outputFlags == 2\n                    ? SigHashTypeOutputs.NONE\n                    : SigHashTypeOutputs.SINGLE,\n        });\n    }\n    /** Get the sighash type as integer flags */\n    toInt() {\n        return this.variant | this.inputType | this.outputType;\n    }\n}\nexports.SigHashType = SigHashType;\n/** Variant of the sighash */\nvar SigHashTypeVariant;\n(function (SigHashTypeVariant) {\n    /** Original Satoshi, pre-BIP143 sighash */\n    SigHashTypeVariant[SigHashTypeVariant["LEGACY"] = 0] = "LEGACY";\n    /** New BIP143 sighash introduced by UAHF */\n    SigHashTypeVariant[SigHashTypeVariant["BIP143"] = 64] = "BIP143";\n})(SigHashTypeVariant || (exports.SigHashTypeVariant = SigHashTypeVariant = {}));\n/** How tx inputs are signed */\nvar SigHashTypeInputs;\n(function (SigHashTypeInputs) {\n    /** Inputs are fixed, no other inputs can added/removeed */\n    SigHashTypeInputs[SigHashTypeInputs["FIXED"] = 0] = "FIXED";\n    /** Inputs are arbitrary, other inputs can be added/removed */\n    SigHashTypeInputs[SigHashTypeInputs["ANYONECANPAY"] = 128] = "ANYONECANPAY";\n})(SigHashTypeInputs || (exports.SigHashTypeInputs = SigHashTypeInputs = {}));\n/** How tx outputs are signed */\nvar SigHashTypeOutputs;\n(function (SigHashTypeOutputs) {\n    /** All outputs are signed, no outputs can be added/removed */\n    SigHashTypeOutputs[SigHashTypeOutputs["ALL"] = 1] = "ALL";\n    /** No outputs are signed, they can be anything */\n    SigHashTypeOutputs[SigHashTypeOutputs["NONE"] = 2] = "NONE";\n    /** The output with the identical index as this input is signed */\n    SigHashTypeOutputs[SigHashTypeOutputs["SINGLE"] = 3] = "SINGLE";\n})(SigHashTypeOutputs || (exports.SigHashTypeOutputs = SigHashTypeOutputs = {}));\n/** ALL|BIP143 */\nexports.ALL_BIP143 = new SigHashType({\n    variant: SigHashTypeVariant.BIP143,\n    inputType: SigHashTypeInputs.FIXED,\n    outputType: SigHashTypeOutputs.ALL,\n});\n/** ALL|ANYONECANPAY|BIP143 */\nexports.ALL_ANYONECANPAY_BIP143 = new SigHashType({\n    variant: SigHashTypeVariant.BIP143,\n    inputType: SigHashTypeInputs.ANYONECANPAY,\n    outputType: SigHashTypeOutputs.ALL,\n});\n/** NONE|BIP143 */\nexports.NONE_BIP143 = new SigHashType({\n    variant: SigHashTypeVariant.BIP143,\n    inputType: SigHashTypeInputs.FIXED,\n    outputType: SigHashTypeOutputs.NONE,\n});\n/** NONE|ANYONECANPAY|BIP143 */\nexports.NONE_ANYONECANPAY_BIP143 = new SigHashType({\n    variant: SigHashTypeVariant.BIP143,\n    inputType: SigHashTypeInputs.ANYONECANPAY,\n    outputType: SigHashTypeOutputs.NONE,\n});\n/** SINGLE|BIP143 */\nexports.SINGLE_BIP143 = new SigHashType({\n    variant: SigHashTypeVariant.BIP143,\n    inputType: SigHashTypeInputs.FIXED,\n    outputType: SigHashTypeOutputs.SINGLE,\n});\n/** SINGLE|ANYONECANPAY|BIP143 */\nexports.SINGLE_ANYONECANPAY_BIP143 = new SigHashType({\n    variant: SigHashTypeVariant.BIP143,\n    inputType: SigHashTypeInputs.ANYONECANPAY,\n    outputType: SigHashTypeOutputs.SINGLE,\n});\n/** ALL|LEGACY */\nexports.ALL_LEGACY = new SigHashType({\n    variant: SigHashTypeVariant.LEGACY,\n    inputType: SigHashTypeInputs.FIXED,\n    outputType: SigHashTypeOutputs.ALL,\n});\n/** ALL|ANYONECANPAY|LEGACY */\nexports.ALL_ANYONECANPAY_LEGACY = new SigHashType({\n    variant: SigHashTypeVariant.LEGACY,\n    inputType: SigHashTypeInputs.ANYONECANPAY,\n    outputType: SigHashTypeOutputs.ALL,\n});\n/** NONE|LEGACY */\nexports.NONE_LEGACY = new SigHashType({\n    variant: SigHashTypeVariant.LEGACY,\n    inputType: SigHashTypeInputs.FIXED,\n    outputType: SigHashTypeOutputs.NONE,\n});\n/** NONE|ANYONECANPAY|LEGACY */\nexports.NONE_ANYONECANPAY_LEGACY = new SigHashType({\n    variant: SigHashTypeVariant.LEGACY,\n    inputType: SigHashTypeInputs.ANYONECANPAY,\n    outputType: SigHashTypeOutputs.NONE,\n});\n/** SINGLE|LEGACY */\nexports.SINGLE_LEGACY = new SigHashType({\n    variant: SigHashTypeVariant.LEGACY,\n    inputType: SigHashTypeInputs.FIXED,\n    outputType: SigHashTypeOutputs.SINGLE,\n});\n/** SINGLE|ANYONECANPAY|LEGACY */\nexports.SINGLE_ANYONECANPAY_LEGACY = new SigHashType({\n    variant: SigHashTypeVariant.LEGACY,\n    inputType: SigHashTypeInputs.ANYONECANPAY,\n    outputType: SigHashTypeOutputs.SINGLE,\n});\n/** List of BIP143 sighashes (FORKID) */\nexports.SIG_HASH_TYPES_BIP143 = [\n    exports.ALL_BIP143,\n    exports.ALL_ANYONECANPAY_BIP143,\n    exports.NONE_BIP143,\n    exports.NONE_ANYONECANPAY_BIP143,\n    exports.SINGLE_BIP143,\n    exports.SINGLE_ANYONECANPAY_BIP143,\n];\n/** List of legacy sighashes (OG Bitcoin signature) */\nexports.SIG_HASH_TYPES_LEGACY = [\n    exports.ALL_LEGACY,\n    exports.ALL_ANYONECANPAY_LEGACY,\n    exports.NONE_LEGACY,\n    exports.NONE_ANYONECANPAY_LEGACY,\n    exports.SINGLE_LEGACY,\n    exports.SINGLE_ANYONECANPAY_LEGACY,\n];\n//# sourceMappingURL=sigHashType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY1OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyxrQ0FBa0MsR0FBRyxxQkFBcUIsR0FBRyxnQ0FBZ0MsR0FBRyxtQkFBbUIsR0FBRywrQkFBK0IsR0FBRyxrQkFBa0IsR0FBRyxrQ0FBa0MsR0FBRyxxQkFBcUIsR0FBRyxnQ0FBZ0MsR0FBRyxtQkFBbUIsR0FBRywrQkFBK0IsR0FBRyxrQkFBa0IsR0FBRywwQkFBMEIsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyxtQkFBbUI7QUFDbmdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QiwwQkFBMEIsMEJBQTBCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IseUJBQXlCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QiwwQkFBMEIsMEJBQTBCO0FBQzlFO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3Qvc2lnSGFzaFR5cGUuanM/NTJlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNJR19IQVNIX1RZUEVTX0xFR0FDWSA9IGV4cG9ydHMuU0lHX0hBU0hfVFlQRVNfQklQMTQzID0gZXhwb3J0cy5TSU5HTEVfQU5ZT05FQ0FOUEFZX0xFR0FDWSA9IGV4cG9ydHMuU0lOR0xFX0xFR0FDWSA9IGV4cG9ydHMuTk9ORV9BTllPTkVDQU5QQVlfTEVHQUNZID0gZXhwb3J0cy5OT05FX0xFR0FDWSA9IGV4cG9ydHMuQUxMX0FOWU9ORUNBTlBBWV9MRUdBQ1kgPSBleHBvcnRzLkFMTF9MRUdBQ1kgPSBleHBvcnRzLlNJTkdMRV9BTllPTkVDQU5QQVlfQklQMTQzID0gZXhwb3J0cy5TSU5HTEVfQklQMTQzID0gZXhwb3J0cy5OT05FX0FOWU9ORUNBTlBBWV9CSVAxNDMgPSBleHBvcnRzLk5PTkVfQklQMTQzID0gZXhwb3J0cy5BTExfQU5ZT05FQ0FOUEFZX0JJUDE0MyA9IGV4cG9ydHMuQUxMX0JJUDE0MyA9IGV4cG9ydHMuU2lnSGFzaFR5cGVPdXRwdXRzID0gZXhwb3J0cy5TaWdIYXNoVHlwZUlucHV0cyA9IGV4cG9ydHMuU2lnSGFzaFR5cGVWYXJpYW50ID0gZXhwb3J0cy5TaWdIYXNoVHlwZSA9IHZvaWQgMDtcbi8qKiBUeXBlIG9mIHNpZ2hhc2ggdXNlZCB0byBzaWduIGZvciBhbiBpbnB1dCBmb3IgYSBPUF9DSEVDS1NJRyBvcGVyYXRpb24uICovXG5jbGFzcyBTaWdIYXNoVHlwZSB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudmFyaWFudCA9IHBhcmFtcy52YXJpYW50O1xuICAgICAgICB0aGlzLmlucHV0VHlwZSA9IHBhcmFtcy5pbnB1dFR5cGU7XG4gICAgICAgIHRoaXMub3V0cHV0VHlwZSA9IHBhcmFtcy5vdXRwdXRUeXBlO1xuICAgIH1cbiAgICAvKiogUmVjb25zdHJ1Y3QgYSBTaWdIYXNoVHlwZSBmcm9tIHRoZSBmbGFncyAqL1xuICAgIHN0YXRpYyBmcm9tSW50KGZsYWdzKSB7XG4gICAgICAgIGlmIChmbGFncyA+IDB4ZmYgfHwgZmxhZ3MgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGJpdHMgbWF5IGJlIHNldCBvdGhlciB0aGFuIDB4ODAsIDB4NDAsIDB4MDIgYW5kIDB4MDFcbiAgICAgICAgaWYgKChmbGFncyAmIDB4M2MpICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0RmxhZ3MgPSBmbGFncyAmIDB4MDM7XG4gICAgICAgIGlmIChvdXRwdXRGbGFncyA9PSAwKSB7XG4gICAgICAgICAgICAvLyAwIGlzIG5vdCBhIHZhbGlkIG91dHB1dCB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2lnSGFzaFR5cGUoe1xuICAgICAgICAgICAgdmFyaWFudDogZmxhZ3MgJiAweDQwXG4gICAgICAgICAgICAgICAgPyBTaWdIYXNoVHlwZVZhcmlhbnQuQklQMTQzXG4gICAgICAgICAgICAgICAgOiBTaWdIYXNoVHlwZVZhcmlhbnQuTEVHQUNZLFxuICAgICAgICAgICAgaW5wdXRUeXBlOiBmbGFncyAmIDB4ODBcbiAgICAgICAgICAgICAgICA/IFNpZ0hhc2hUeXBlSW5wdXRzLkFOWU9ORUNBTlBBWVxuICAgICAgICAgICAgICAgIDogU2lnSGFzaFR5cGVJbnB1dHMuRklYRUQsXG4gICAgICAgICAgICBvdXRwdXRUeXBlOiBvdXRwdXRGbGFncyA9PSAxXG4gICAgICAgICAgICAgICAgPyBTaWdIYXNoVHlwZU91dHB1dHMuQUxMXG4gICAgICAgICAgICAgICAgOiBvdXRwdXRGbGFncyA9PSAyXG4gICAgICAgICAgICAgICAgICAgID8gU2lnSGFzaFR5cGVPdXRwdXRzLk5PTkVcbiAgICAgICAgICAgICAgICAgICAgOiBTaWdIYXNoVHlwZU91dHB1dHMuU0lOR0xFLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEdldCB0aGUgc2lnaGFzaCB0eXBlIGFzIGludGVnZXIgZmxhZ3MgKi9cbiAgICB0b0ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFyaWFudCB8IHRoaXMuaW5wdXRUeXBlIHwgdGhpcy5vdXRwdXRUeXBlO1xuICAgIH1cbn1cbmV4cG9ydHMuU2lnSGFzaFR5cGUgPSBTaWdIYXNoVHlwZTtcbi8qKiBWYXJpYW50IG9mIHRoZSBzaWdoYXNoICovXG52YXIgU2lnSGFzaFR5cGVWYXJpYW50O1xuKGZ1bmN0aW9uIChTaWdIYXNoVHlwZVZhcmlhbnQpIHtcbiAgICAvKiogT3JpZ2luYWwgU2F0b3NoaSwgcHJlLUJJUDE0MyBzaWdoYXNoICovXG4gICAgU2lnSGFzaFR5cGVWYXJpYW50W1NpZ0hhc2hUeXBlVmFyaWFudFtcIkxFR0FDWVwiXSA9IDBdID0gXCJMRUdBQ1lcIjtcbiAgICAvKiogTmV3IEJJUDE0MyBzaWdoYXNoIGludHJvZHVjZWQgYnkgVUFIRiAqL1xuICAgIFNpZ0hhc2hUeXBlVmFyaWFudFtTaWdIYXNoVHlwZVZhcmlhbnRbXCJCSVAxNDNcIl0gPSA2NF0gPSBcIkJJUDE0M1wiO1xufSkoU2lnSGFzaFR5cGVWYXJpYW50IHx8IChleHBvcnRzLlNpZ0hhc2hUeXBlVmFyaWFudCA9IFNpZ0hhc2hUeXBlVmFyaWFudCA9IHt9KSk7XG4vKiogSG93IHR4IGlucHV0cyBhcmUgc2lnbmVkICovXG52YXIgU2lnSGFzaFR5cGVJbnB1dHM7XG4oZnVuY3Rpb24gKFNpZ0hhc2hUeXBlSW5wdXRzKSB7XG4gICAgLyoqIElucHV0cyBhcmUgZml4ZWQsIG5vIG90aGVyIGlucHV0cyBjYW4gYWRkZWQvcmVtb3ZlZWQgKi9cbiAgICBTaWdIYXNoVHlwZUlucHV0c1tTaWdIYXNoVHlwZUlucHV0c1tcIkZJWEVEXCJdID0gMF0gPSBcIkZJWEVEXCI7XG4gICAgLyoqIElucHV0cyBhcmUgYXJiaXRyYXJ5LCBvdGhlciBpbnB1dHMgY2FuIGJlIGFkZGVkL3JlbW92ZWQgKi9cbiAgICBTaWdIYXNoVHlwZUlucHV0c1tTaWdIYXNoVHlwZUlucHV0c1tcIkFOWU9ORUNBTlBBWVwiXSA9IDEyOF0gPSBcIkFOWU9ORUNBTlBBWVwiO1xufSkoU2lnSGFzaFR5cGVJbnB1dHMgfHwgKGV4cG9ydHMuU2lnSGFzaFR5cGVJbnB1dHMgPSBTaWdIYXNoVHlwZUlucHV0cyA9IHt9KSk7XG4vKiogSG93IHR4IG91dHB1dHMgYXJlIHNpZ25lZCAqL1xudmFyIFNpZ0hhc2hUeXBlT3V0cHV0cztcbihmdW5jdGlvbiAoU2lnSGFzaFR5cGVPdXRwdXRzKSB7XG4gICAgLyoqIEFsbCBvdXRwdXRzIGFyZSBzaWduZWQsIG5vIG91dHB1dHMgY2FuIGJlIGFkZGVkL3JlbW92ZWQgKi9cbiAgICBTaWdIYXNoVHlwZU91dHB1dHNbU2lnSGFzaFR5cGVPdXRwdXRzW1wiQUxMXCJdID0gMV0gPSBcIkFMTFwiO1xuICAgIC8qKiBObyBvdXRwdXRzIGFyZSBzaWduZWQsIHRoZXkgY2FuIGJlIGFueXRoaW5nICovXG4gICAgU2lnSGFzaFR5cGVPdXRwdXRzW1NpZ0hhc2hUeXBlT3V0cHV0c1tcIk5PTkVcIl0gPSAyXSA9IFwiTk9ORVwiO1xuICAgIC8qKiBUaGUgb3V0cHV0IHdpdGggdGhlIGlkZW50aWNhbCBpbmRleCBhcyB0aGlzIGlucHV0IGlzIHNpZ25lZCAqL1xuICAgIFNpZ0hhc2hUeXBlT3V0cHV0c1tTaWdIYXNoVHlwZU91dHB1dHNbXCJTSU5HTEVcIl0gPSAzXSA9IFwiU0lOR0xFXCI7XG59KShTaWdIYXNoVHlwZU91dHB1dHMgfHwgKGV4cG9ydHMuU2lnSGFzaFR5cGVPdXRwdXRzID0gU2lnSGFzaFR5cGVPdXRwdXRzID0ge30pKTtcbi8qKiBBTEx8QklQMTQzICovXG5leHBvcnRzLkFMTF9CSVAxNDMgPSBuZXcgU2lnSGFzaFR5cGUoe1xuICAgIHZhcmlhbnQ6IFNpZ0hhc2hUeXBlVmFyaWFudC5CSVAxNDMsXG4gICAgaW5wdXRUeXBlOiBTaWdIYXNoVHlwZUlucHV0cy5GSVhFRCxcbiAgICBvdXRwdXRUeXBlOiBTaWdIYXNoVHlwZU91dHB1dHMuQUxMLFxufSk7XG4vKiogQUxMfEFOWU9ORUNBTlBBWXxCSVAxNDMgKi9cbmV4cG9ydHMuQUxMX0FOWU9ORUNBTlBBWV9CSVAxNDMgPSBuZXcgU2lnSGFzaFR5cGUoe1xuICAgIHZhcmlhbnQ6IFNpZ0hhc2hUeXBlVmFyaWFudC5CSVAxNDMsXG4gICAgaW5wdXRUeXBlOiBTaWdIYXNoVHlwZUlucHV0cy5BTllPTkVDQU5QQVksXG4gICAgb3V0cHV0VHlwZTogU2lnSGFzaFR5cGVPdXRwdXRzLkFMTCxcbn0pO1xuLyoqIE5PTkV8QklQMTQzICovXG5leHBvcnRzLk5PTkVfQklQMTQzID0gbmV3IFNpZ0hhc2hUeXBlKHtcbiAgICB2YXJpYW50OiBTaWdIYXNoVHlwZVZhcmlhbnQuQklQMTQzLFxuICAgIGlucHV0VHlwZTogU2lnSGFzaFR5cGVJbnB1dHMuRklYRUQsXG4gICAgb3V0cHV0VHlwZTogU2lnSGFzaFR5cGVPdXRwdXRzLk5PTkUsXG59KTtcbi8qKiBOT05FfEFOWU9ORUNBTlBBWXxCSVAxNDMgKi9cbmV4cG9ydHMuTk9ORV9BTllPTkVDQU5QQVlfQklQMTQzID0gbmV3IFNpZ0hhc2hUeXBlKHtcbiAgICB2YXJpYW50OiBTaWdIYXNoVHlwZVZhcmlhbnQuQklQMTQzLFxuICAgIGlucHV0VHlwZTogU2lnSGFzaFR5cGVJbnB1dHMuQU5ZT05FQ0FOUEFZLFxuICAgIG91dHB1dFR5cGU6IFNpZ0hhc2hUeXBlT3V0cHV0cy5OT05FLFxufSk7XG4vKiogU0lOR0xFfEJJUDE0MyAqL1xuZXhwb3J0cy5TSU5HTEVfQklQMTQzID0gbmV3IFNpZ0hhc2hUeXBlKHtcbiAgICB2YXJpYW50OiBTaWdIYXNoVHlwZVZhcmlhbnQuQklQMTQzLFxuICAgIGlucHV0VHlwZTogU2lnSGFzaFR5cGVJbnB1dHMuRklYRUQsXG4gICAgb3V0cHV0VHlwZTogU2lnSGFzaFR5cGVPdXRwdXRzLlNJTkdMRSxcbn0pO1xuLyoqIFNJTkdMRXxBTllPTkVDQU5QQVl8QklQMTQzICovXG5leHBvcnRzLlNJTkdMRV9BTllPTkVDQU5QQVlfQklQMTQzID0gbmV3IFNpZ0hhc2hUeXBlKHtcbiAgICB2YXJpYW50OiBTaWdIYXNoVHlwZVZhcmlhbnQuQklQMTQzLFxuICAgIGlucHV0VHlwZTogU2lnSGFzaFR5cGVJbnB1dHMuQU5ZT05FQ0FOUEFZLFxuICAgIG91dHB1dFR5cGU6IFNpZ0hhc2hUeXBlT3V0cHV0cy5TSU5HTEUsXG59KTtcbi8qKiBBTEx8TEVHQUNZICovXG5leHBvcnRzLkFMTF9MRUdBQ1kgPSBuZXcgU2lnSGFzaFR5cGUoe1xuICAgIHZhcmlhbnQ6IFNpZ0hhc2hUeXBlVmFyaWFudC5MRUdBQ1ksXG4gICAgaW5wdXRUeXBlOiBTaWdIYXNoVHlwZUlucHV0cy5GSVhFRCxcbiAgICBvdXRwdXRUeXBlOiBTaWdIYXNoVHlwZU91dHB1dHMuQUxMLFxufSk7XG4vKiogQUxMfEFOWU9ORUNBTlBBWXxMRUdBQ1kgKi9cbmV4cG9ydHMuQUxMX0FOWU9ORUNBTlBBWV9MRUdBQ1kgPSBuZXcgU2lnSGFzaFR5cGUoe1xuICAgIHZhcmlhbnQ6IFNpZ0hhc2hUeXBlVmFyaWFudC5MRUdBQ1ksXG4gICAgaW5wdXRUeXBlOiBTaWdIYXNoVHlwZUlucHV0cy5BTllPTkVDQU5QQVksXG4gICAgb3V0cHV0VHlwZTogU2lnSGFzaFR5cGVPdXRwdXRzLkFMTCxcbn0pO1xuLyoqIE5PTkV8TEVHQUNZICovXG5leHBvcnRzLk5PTkVfTEVHQUNZID0gbmV3IFNpZ0hhc2hUeXBlKHtcbiAgICB2YXJpYW50OiBTaWdIYXNoVHlwZVZhcmlhbnQuTEVHQUNZLFxuICAgIGlucHV0VHlwZTogU2lnSGFzaFR5cGVJbnB1dHMuRklYRUQsXG4gICAgb3V0cHV0VHlwZTogU2lnSGFzaFR5cGVPdXRwdXRzLk5PTkUsXG59KTtcbi8qKiBOT05FfEFOWU9ORUNBTlBBWXxMRUdBQ1kgKi9cbmV4cG9ydHMuTk9ORV9BTllPTkVDQU5QQVlfTEVHQUNZID0gbmV3IFNpZ0hhc2hUeXBlKHtcbiAgICB2YXJpYW50OiBTaWdIYXNoVHlwZVZhcmlhbnQuTEVHQUNZLFxuICAgIGlucHV0VHlwZTogU2lnSGFzaFR5cGVJbnB1dHMuQU5ZT05FQ0FOUEFZLFxuICAgIG91dHB1dFR5cGU6IFNpZ0hhc2hUeXBlT3V0cHV0cy5OT05FLFxufSk7XG4vKiogU0lOR0xFfExFR0FDWSAqL1xuZXhwb3J0cy5TSU5HTEVfTEVHQUNZID0gbmV3IFNpZ0hhc2hUeXBlKHtcbiAgICB2YXJpYW50OiBTaWdIYXNoVHlwZVZhcmlhbnQuTEVHQUNZLFxuICAgIGlucHV0VHlwZTogU2lnSGFzaFR5cGVJbnB1dHMuRklYRUQsXG4gICAgb3V0cHV0VHlwZTogU2lnSGFzaFR5cGVPdXRwdXRzLlNJTkdMRSxcbn0pO1xuLyoqIFNJTkdMRXxBTllPTkVDQU5QQVl8TEVHQUNZICovXG5leHBvcnRzLlNJTkdMRV9BTllPTkVDQU5QQVlfTEVHQUNZID0gbmV3IFNpZ0hhc2hUeXBlKHtcbiAgICB2YXJpYW50OiBTaWdIYXNoVHlwZVZhcmlhbnQuTEVHQUNZLFxuICAgIGlucHV0VHlwZTogU2lnSGFzaFR5cGVJbnB1dHMuQU5ZT05FQ0FOUEFZLFxuICAgIG91dHB1dFR5cGU6IFNpZ0hhc2hUeXBlT3V0cHV0cy5TSU5HTEUsXG59KTtcbi8qKiBMaXN0IG9mIEJJUDE0MyBzaWdoYXNoZXMgKEZPUktJRCkgKi9cbmV4cG9ydHMuU0lHX0hBU0hfVFlQRVNfQklQMTQzID0gW1xuICAgIGV4cG9ydHMuQUxMX0JJUDE0MyxcbiAgICBleHBvcnRzLkFMTF9BTllPTkVDQU5QQVlfQklQMTQzLFxuICAgIGV4cG9ydHMuTk9ORV9CSVAxNDMsXG4gICAgZXhwb3J0cy5OT05FX0FOWU9ORUNBTlBBWV9CSVAxNDMsXG4gICAgZXhwb3J0cy5TSU5HTEVfQklQMTQzLFxuICAgIGV4cG9ydHMuU0lOR0xFX0FOWU9ORUNBTlBBWV9CSVAxNDMsXG5dO1xuLyoqIExpc3Qgb2YgbGVnYWN5IHNpZ2hhc2hlcyAoT0cgQml0Y29pbiBzaWduYXR1cmUpICovXG5leHBvcnRzLlNJR19IQVNIX1RZUEVTX0xFR0FDWSA9IFtcbiAgICBleHBvcnRzLkFMTF9MRUdBQ1ksXG4gICAgZXhwb3J0cy5BTExfQU5ZT05FQ0FOUEFZX0xFR0FDWSxcbiAgICBleHBvcnRzLk5PTkVfTEVHQUNZLFxuICAgIGV4cG9ydHMuTk9ORV9BTllPTkVDQU5QQVlfTEVHQUNZLFxuICAgIGV4cG9ydHMuU0lOR0xFX0xFR0FDWSxcbiAgICBleHBvcnRzLlNJTkdMRV9BTllPTkVDQU5QQVlfTEVHQUNZLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ0hhc2hUeXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1659\n\n}')},1878:(__unused_webpack_module,exports)=>{eval("{/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nexports.isValid = function isValid (version) {\n  return !isNaN(version) && version >= 1 && version <= 40\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3OC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQSxlQUFlO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9jb3JlL3ZlcnNpb24tY2hlY2suanM/MjdhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoZWNrIGlmIFFSIENvZGUgdmVyc2lvbiBpcyB2YWxpZFxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gIHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgIHRydWUgaWYgdmFsaWQgdmVyc2lvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKHZlcnNpb24pIHtcbiAgcmV0dXJuICFpc05hTih2ZXJzaW9uKSAmJiB2ZXJzaW9uID49IDEgJiYgdmVyc2lvbiA8PSA0MFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1878\n\n}")},1904:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\n// Copyright (c) 2023-2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(2216), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsSUFBcUI7QUFDMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2Nocm9uaWstY2xpZW50L2Rpc3QvaW5kZXguanM/N2FmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyMy0yMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NyYy9DaHJvbmlrQ2xpZW50XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1904\n\n}')},1921:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.pbkdf2 = void 0;\nconst hmac_1 = __webpack_require__(3771);\nfunction pbkdf2(params) {\n    const arr = new Uint8Array(4);\n    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n    const result = new Uint8Array(params.dkLen);\n    const prf = new hmac_1.Hmac(params.hashFactory, params.blockLength, params.password);\n    const prfSalt = prf.clone();\n    prfSalt.update(params.salt);\n    for (let idx = 1, pos = 0; pos < params.dkLen; idx++, pos += params.outputLength) {\n        const ti = result.subarray(pos, pos + params.outputLength);\n        view.setInt32(0, idx, false);\n        const prfSaltClone = prfSalt.clone();\n        prfSaltClone.update(arr);\n        let u = prfSaltClone.digest();\n        ti.set(u.subarray(0, ti.length));\n        for (let ui = 1; ui < params.iterations; ui++) {\n            const prfClone = prf.clone();\n            prfClone.update(u);\n            u = prfClone.digest();\n            for (let i = 0; i < ti.length; i++) {\n                ti[i] ^= u[i];\n            }\n        }\n    }\n    prf.free();\n    prfSalt.free();\n    return result;\n}\nexports.pbkdf2 = pbkdf2;\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyMS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZUFBZSxtQkFBTyxDQUFDLElBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvcGJrZGYyLmpzPzNlMDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjUgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYmtkZjIgPSB2b2lkIDA7XG5jb25zdCBobWFjXzEgPSByZXF1aXJlKFwiLi9obWFjXCIpO1xuZnVuY3Rpb24gcGJrZGYyKHBhcmFtcykge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShwYXJhbXMuZGtMZW4pO1xuICAgIGNvbnN0IHByZiA9IG5ldyBobWFjXzEuSG1hYyhwYXJhbXMuaGFzaEZhY3RvcnksIHBhcmFtcy5ibG9ja0xlbmd0aCwgcGFyYW1zLnBhc3N3b3JkKTtcbiAgICBjb25zdCBwcmZTYWx0ID0gcHJmLmNsb25lKCk7XG4gICAgcHJmU2FsdC51cGRhdGUocGFyYW1zLnNhbHQpO1xuICAgIGZvciAobGV0IGlkeCA9IDEsIHBvcyA9IDA7IHBvcyA8IHBhcmFtcy5ka0xlbjsgaWR4KyssIHBvcyArPSBwYXJhbXMub3V0cHV0TGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRpID0gcmVzdWx0LnN1YmFycmF5KHBvcywgcG9zICsgcGFyYW1zLm91dHB1dExlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgaWR4LCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IHByZlNhbHRDbG9uZSA9IHByZlNhbHQuY2xvbmUoKTtcbiAgICAgICAgcHJmU2FsdENsb25lLnVwZGF0ZShhcnIpO1xuICAgICAgICBsZXQgdSA9IHByZlNhbHRDbG9uZS5kaWdlc3QoKTtcbiAgICAgICAgdGkuc2V0KHUuc3ViYXJyYXkoMCwgdGkubGVuZ3RoKSk7XG4gICAgICAgIGZvciAobGV0IHVpID0gMTsgdWkgPCBwYXJhbXMuaXRlcmF0aW9uczsgdWkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJmQ2xvbmUgPSBwcmYuY2xvbmUoKTtcbiAgICAgICAgICAgIHByZkNsb25lLnVwZGF0ZSh1KTtcbiAgICAgICAgICAgIHUgPSBwcmZDbG9uZS5kaWdlc3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aVtpXSBePSB1W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByZi5mcmVlKCk7XG4gICAgcHJmU2FsdC5mcmVlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGJrZGYyID0gcGJrZGYyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGJrZGYyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1921\n\n}')},2040:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2023-2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromHexRev = exports.fromHex = exports.toHexRev = exports.toHex = void 0;\nconst LUT_HEX_4b = [\n    '0',\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8',\n    '9',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n];\nconst LUT_HEX_8b = new Array(0x100);\nconst LUT_BIN_8b = {};\nfor (let n = 0; n < 0x100; n++) {\n    const hex = `${LUT_HEX_4b[(n >>> 4) & 0xf]}${LUT_HEX_4b[n & 0xf]}`;\n    LUT_HEX_8b[n] = hex;\n    LUT_BIN_8b[hex] = n;\n}\n// End Pre-Init\nfunction toHex(buffer) {\n    let out = '';\n    for (let idx = 0, edx = buffer.length; idx < edx; ++idx) {\n        out += LUT_HEX_8b[buffer[idx]];\n    }\n    return out;\n}\nexports.toHex = toHex;\nfunction toHexRev(buffer) {\n    let out = '';\n    for (let idx = buffer.length - 1; idx >= 0; --idx) {\n        out += LUT_HEX_8b[buffer[idx]];\n    }\n    return out;\n}\nexports.toHexRev = toHexRev;\nfunction fromHex(str) {\n    if ((str.length & 1) != 0) {\n        throw new Error(`Odd hex length: ${str}`);\n    }\n    const nBytes = str.length >> 1;\n    const array = new Uint8Array(nBytes);\n    for (let idx = 0; idx < str.length; idx += 2) {\n        const pair = str.substr(idx, 2);\n        const byte = LUT_BIN_8b[pair];\n        if (byte === undefined) {\n            throw new Error(`Invalid hex pair: ${pair}, at index ${idx}`);\n        }\n        array[idx >> 1] = byte;\n    }\n    return array;\n}\nexports.fromHex = fromHex;\nfunction fromHexRev(str) {\n    const array = fromHex(str);\n    array.reverse();\n    return array;\n}\nexports.fromHexRev = fromHexRev;\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA0MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsbUJBQW1CLDRCQUE0QixFQUFFLG9CQUFvQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUssYUFBYSxJQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvY2hyb25pay1jbGllbnQvZGlzdC9zcmMvaGV4LmpzPzFmYTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjMtMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21IZXhSZXYgPSBleHBvcnRzLmZyb21IZXggPSBleHBvcnRzLnRvSGV4UmV2ID0gZXhwb3J0cy50b0hleCA9IHZvaWQgMDtcbmNvbnN0IExVVF9IRVhfNGIgPSBbXG4gICAgJzAnLFxuICAgICcxJyxcbiAgICAnMicsXG4gICAgJzMnLFxuICAgICc0JyxcbiAgICAnNScsXG4gICAgJzYnLFxuICAgICc3JyxcbiAgICAnOCcsXG4gICAgJzknLFxuICAgICdhJyxcbiAgICAnYicsXG4gICAgJ2MnLFxuICAgICdkJyxcbiAgICAnZScsXG4gICAgJ2YnLFxuXTtcbmNvbnN0IExVVF9IRVhfOGIgPSBuZXcgQXJyYXkoMHgxMDApO1xuY29uc3QgTFVUX0JJTl84YiA9IHt9O1xuZm9yIChsZXQgbiA9IDA7IG4gPCAweDEwMDsgbisrKSB7XG4gICAgY29uc3QgaGV4ID0gYCR7TFVUX0hFWF80YlsobiA+Pj4gNCkgJiAweGZdfSR7TFVUX0hFWF80YltuICYgMHhmXX1gO1xuICAgIExVVF9IRVhfOGJbbl0gPSBoZXg7XG4gICAgTFVUX0JJTl84YltoZXhdID0gbjtcbn1cbi8vIEVuZCBQcmUtSW5pdFxuZnVuY3Rpb24gdG9IZXgoYnVmZmVyKSB7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGZvciAobGV0IGlkeCA9IDAsIGVkeCA9IGJ1ZmZlci5sZW5ndGg7IGlkeCA8IGVkeDsgKytpZHgpIHtcbiAgICAgICAgb3V0ICs9IExVVF9IRVhfOGJbYnVmZmVyW2lkeF1dO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZnVuY3Rpb24gdG9IZXhSZXYoYnVmZmVyKSB7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGZvciAobGV0IGlkeCA9IGJ1ZmZlci5sZW5ndGggLSAxOyBpZHggPj0gMDsgLS1pZHgpIHtcbiAgICAgICAgb3V0ICs9IExVVF9IRVhfOGJbYnVmZmVyW2lkeF1dO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy50b0hleFJldiA9IHRvSGV4UmV2O1xuZnVuY3Rpb24gZnJvbUhleChzdHIpIHtcbiAgICBpZiAoKHN0ci5sZW5ndGggJiAxKSAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2RkIGhleCBsZW5ndGg6ICR7c3RyfWApO1xuICAgIH1cbiAgICBjb25zdCBuQnl0ZXMgPSBzdHIubGVuZ3RoID4+IDE7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShuQnl0ZXMpO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHN0ci5sZW5ndGg7IGlkeCArPSAyKSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBzdHIuc3Vic3RyKGlkeCwgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBMVVRfQklOXzhiW3BhaXJdO1xuICAgICAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaGV4IHBhaXI6ICR7cGFpcn0sIGF0IGluZGV4ICR7aWR4fWApO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2lkeCA+PiAxXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5mdW5jdGlvbiBmcm9tSGV4UmV2KHN0cikge1xuICAgIGNvbnN0IGFycmF5ID0gZnJvbUhleChzdHIpO1xuICAgIGFycmF5LnJldmVyc2UoKTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmZyb21IZXhSZXYgPSBmcm9tSGV4UmV2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2040\n\n}")},2216:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\n// Copyright (c) 2023-2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ALP_TOKEN_TYPES = exports.WsEndpoint = exports.PluginEndpoint = exports.LokadIdEndpoint = exports.TokenIdEndpoint = exports.ScriptEndpoint = exports.ChronikClient = exports.sortNodesByLatency = exports.measureWebsocketLatency = exports.ConnectionStrategy = void 0;\nconst ecashaddrjs_1 = __webpack_require__(6942);\nconst isomorphic_ws_1 = __importDefault(__webpack_require__(169));\nconst proto = __importStar(__webpack_require__(8331));\nconst failoverProxy_1 = __webpack_require__(1199);\nconst hex_1 = __webpack_require__(2040);\nconst validation_1 = __webpack_require__(6450);\nvar ConnectionStrategy;\n(function (ConnectionStrategy) {\n    ConnectionStrategy[\"ClosestFirst\"] = \"CLOSEST_FIRST\";\n    ConnectionStrategy[\"AsOrdered\"] = \"AS_ORDERED\";\n})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));\nconst WEBSOCKET_TIMEOUT_MS = 1000;\n/**\n * Measures connection latency to a given WebSocket URL\n * @param {string} wsUrl WebSocket URL to test connection\n * @returns {Promise<number>} Returns latency in milliseconds, or Infinity if connection times out or fails\n */\nasync function measureWebsocketLatency(wsUrl) {\n    return new Promise(resolve => {\n        const timeoutFailure = setTimeout(() => {\n            testWs.close();\n            resolve(Infinity);\n        }, WEBSOCKET_TIMEOUT_MS);\n        const startTime = Date.now();\n        const testWs = new isomorphic_ws_1.default(wsUrl);\n        testWs.onerror = function () {\n            testWs.close();\n            clearTimeout(timeoutFailure);\n            return resolve(Infinity);\n        };\n        testWs.onopen = function () {\n            const latency = Date.now() - startTime;\n            testWs.close();\n            clearTimeout(timeoutFailure);\n            return resolve(latency);\n        };\n    }).catch(() => {\n        return Infinity;\n    });\n}\nexports.measureWebsocketLatency = measureWebsocketLatency;\n/**\n * Sort nodes by latency\n * @param {string[]} urls Array of URLs to sort\n * @returns {Promise<string[]>} Array of URLs sorted by latency\n */\nasync function sortNodesByLatency(urls) {\n    // Convert URLs using appendWsUrls\n    const endpoints = (0, failoverProxy_1.appendWsUrls)(urls);\n    // Test latency of all endpoints in parallel\n    const results = await Promise.all(endpoints.map(async (endpoint) => {\n        const latency = await measureWebsocketLatency(endpoint.wsUrl);\n        return {\n            url: endpoint.url,\n            latency: latency,\n        };\n    }));\n    results.sort((a, b) => a.latency - b.latency);\n    const sortedUrls = results.map(r => r.url);\n    sortedUrls.forEach((url, idx) => {\n        const result = results.find(r => r.url === url);\n        console.log(result?.latency === Infinity\n            ? `  ${idx + 1}. ${url} - latency: >${Math.round(WEBSOCKET_TIMEOUT_MS)}ms`\n            : `  ${idx + 1}. ${url} - latency: ${Math.round(result?.latency || 0)}ms`);\n    });\n    return sortedUrls;\n}\nexports.sortNodesByLatency = sortNodesByLatency;\n/**\n * Client to access an in-node Chronik instance.\n * Plain object, without any connections.\n */\nclass ChronikClient {\n    /**\n     * Create a new client. This just creates an object, without any connections.\n     *\n     * @param {string[]} urls Array of valid urls. A valid url comes with schema and without a trailing slash.\n     * e.g. '['https://chronik.be.cash/xec2', 'https://chronik-native.fabien.cash']\n     * The approach of accepting an array of urls as input is to ensure redundancy if the\n     * first url encounters downtime.\n     * @throws {error} throws error on invalid constructor inputs\n     */\n    constructor(urls) {\n        // Instantiate FailoverProxy with the urls array\n        this._proxyInterface = new failoverProxy_1.FailoverProxy(urls);\n    }\n    /**\n     * Create Chronik client instance with specified strategy\n     *\n     * @param {ConnectionStrategy} strategy Connection strategy\n     * @param {string[]} urls Array of Chronik URLs\n     * @returns {Promise<ChronikClient>} Client instance created with sorted URLs\n     */\n    static async useStrategy(strategy, urls) {\n        let sortedUrls = [...urls];\n        // If using ClosestFirst strategy, sort nodes by latency first\n        if (strategy === ConnectionStrategy.ClosestFirst) {\n            try {\n                sortedUrls = await sortNodesByLatency(urls);\n            }\n            catch (error) {\n                console.error('Error sorting nodes by latency:', error, 'Using original order:');\n            }\n        }\n        return new ChronikClient(sortedUrls);\n    }\n    // For unit test verification\n    proxyInterface() {\n        return this._proxyInterface;\n    }\n    /**\n     * Broadcasts the `rawTx` on the network.\n     * If `skipTokenChecks` is false, it will be checked that the tx doesn't burn\n     * any tokens before broadcasting.\n     */\n    async broadcastTx(rawTx, skipTokenChecks = false) {\n        const request = proto.BroadcastTxRequest.encode({\n            rawTx: typeof rawTx === 'string' ? (0, hex_1.fromHex)(rawTx) : rawTx,\n            skipTokenChecks,\n        }).finish();\n        const data = await this._proxyInterface.post('/broadcast-tx', request);\n        const broadcastResponse = proto.BroadcastTxResponse.decode(data);\n        return {\n            txid: (0, hex_1.toHexRev)(broadcastResponse.txid),\n        };\n    }\n    /**\n     * Broadcasts the `rawTxs` on the network, only if all of them are valid.\n     * If `skipTokenChecks` is false, it will be checked that the txs don't burn\n     * any tokens before broadcasting.\n     */\n    async broadcastTxs(rawTxs, skipTokenChecks = false) {\n        const request = proto.BroadcastTxsRequest.encode({\n            rawTxs: rawTxs.map(rawTx => typeof rawTx === 'string' ? (0, hex_1.fromHex)(rawTx) : rawTx),\n            skipTokenChecks,\n        }).finish();\n        const data = await this._proxyInterface.post('/broadcast-txs', request);\n        const broadcastResponse = proto.BroadcastTxsResponse.decode(data);\n        return {\n            txids: broadcastResponse.txids.map(hex_1.toHexRev),\n        };\n    }\n    /**\n     *  Validate a tx by rawtx\n     *  This is a sort of preflight check before broadcasting a tx\n     *  Allows us to\n     *  - check before broadcast if a tx unintentionally burns tokens\n     */\n    async validateRawTx(rawTx) {\n        // Validate input\n        if (typeof rawTx !== 'string' && !(rawTx instanceof Uint8Array)) {\n            // User has called validateRawTx with invalid input, no need to use chronik\n            // to validate this rawTx\n            throw new Error('rawTx must be a hex string or a Uint8Array');\n        }\n        const request = proto.RawTx.encode({\n            rawTx: typeof rawTx === 'string' ? (0, hex_1.fromHex)(rawTx) : rawTx,\n        }).finish();\n        const data = await this._proxyInterface.post('/validate-tx', request);\n        const validateResponse = proto.Tx.decode(data);\n        return convertToTx(validateResponse);\n    }\n    /** Fetch current info of the blockchain, such as tip hash and height. */\n    async blockchainInfo() {\n        const data = await this._proxyInterface.get(`/blockchain-info`);\n        const blockchainInfo = proto.BlockchainInfo.decode(data);\n        return convertToBlockchainInfo(blockchainInfo);\n    }\n    /** Fetch info about the current running chronik server */\n    async chronikInfo() {\n        const data = await this._proxyInterface.get(`/chronik-info`);\n        const chronikServerInfo = proto.ChronikInfo.decode(data);\n        return convertToChronikInfo(chronikServerInfo);\n    }\n    /** Fetch the block given hash or height. */\n    async block(hashOrHeight) {\n        const data = await this._proxyInterface.get(`/block/${hashOrHeight}`);\n        const block = proto.Block.decode(data);\n        return convertToBlock(block);\n    }\n    /** Fetch the tx history of a block given hash or height. */\n    async blockTxs(hashOrHeight, page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/block-txs/${hashOrHeight}?page=${page}&page_size=${pageSize}`);\n        const blockTxs = proto.TxHistoryPage.decode(data);\n        return convertToTxHistoryPage(blockTxs);\n    }\n    /**\n     * Fetch block info of a range of blocks.\n     * `startHeight` and `endHeight` are inclusive ranges.\n     */\n    async blocks(startHeight, endHeight) {\n        const data = await this._proxyInterface.get(`/blocks/${startHeight}/${endHeight}`);\n        const blocks = proto.Blocks.decode(data);\n        return blocks.blocks.map(convertToBlockInfo);\n    }\n    /** Fetch token info and stats given the tokenId. */\n    async token(tokenId) {\n        const data = await this._proxyInterface.get(`/token/${tokenId}`);\n        const tokenInfo = proto.TokenInfo.decode(data);\n        return convertToTokenInfo(tokenInfo);\n    }\n    /** Fetch tx details given the txid. */\n    async tx(txid) {\n        const data = await this._proxyInterface.get(`/tx/${txid}`);\n        const tx = proto.Tx.decode(data);\n        return convertToTx(tx);\n    }\n    /** Fetch tx details given the txid. */\n    async rawTx(txid) {\n        const data = await this._proxyInterface.get(`/raw-tx/${txid}`);\n        const rawTx = proto.RawTx.decode(data);\n        return convertToRawTx(rawTx);\n    }\n    /** Create object that allows fetching info about a given token */\n    tokenId(tokenId) {\n        return new TokenIdEndpoint(this._proxyInterface, tokenId);\n    }\n    /** Create object that allows fetching info about a given lokadId */\n    lokadId(lokadId) {\n        return new LokadIdEndpoint(this._proxyInterface, lokadId);\n    }\n    /** Create object that allows fetching info about a given plugin */\n    plugin(pluginName) {\n        return new PluginEndpoint(this._proxyInterface, pluginName);\n    }\n    /** Create object that allows fetching script history or UTXOs. */\n    script(scriptType, scriptPayload) {\n        return new ScriptEndpoint(this._proxyInterface, scriptType, scriptPayload);\n    }\n    /** Create object that allows fetching script history or UTXOs by p2pkh or p2sh address */\n    address(address) {\n        const { type, hash } = (0, ecashaddrjs_1.decodeCashAddress)(address);\n        return new ScriptEndpoint(this._proxyInterface, type, hash);\n    }\n    /** Open a WebSocket connection to listen for updates. */\n    ws(config) {\n        return new WsEndpoint(this._proxyInterface, config);\n    }\n}\nexports.ChronikClient = ChronikClient;\n/** Allows fetching script history and UTXOs. */\nclass ScriptEndpoint {\n    constructor(proxyInterface, scriptType, scriptPayload) {\n        this._proxyInterface = proxyInterface;\n        this._scriptType = scriptType;\n        this._scriptPayload = scriptPayload;\n    }\n    /**\n     * Fetches the tx history of this script, in anti-chronological order.\n     * This means it's ordered by first-seen first, i.e. TxHistoryPage.txs[0]\n     * will be the most recent tx. If the tx hasn't been seen\n     * by the indexer before, it's ordered by the block timestamp.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async history(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/script/${this._scriptType}/${this._scriptPayload}/history?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the confirmed tx history of this script, in the order they appear on the blockchain.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async confirmedTxs(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/script/${this._scriptType}/${this._scriptPayload}/confirmed-txs?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the unconfirmed tx history of this script, in chronological order.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async unconfirmedTxs(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/script/${this._scriptType}/${this._scriptPayload}/unconfirmed-txs?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the current UTXO set for this script.\n     * It is grouped by output script, in case a script type can match multiple\n     * different output scripts (e.g. Taproot on Lotus).\n     */\n    async utxos() {\n        const data = await this._proxyInterface.get(`/script/${this._scriptType}/${this._scriptPayload}/utxos`);\n        const scriptUtxos = proto.ScriptUtxos.decode(data);\n        return {\n            outputScript: (0, hex_1.toHex)(scriptUtxos.script),\n            utxos: scriptUtxos.utxos.map(convertToScriptUtxo),\n        };\n    }\n}\nexports.ScriptEndpoint = ScriptEndpoint;\n/** Allows fetching tokenId confirmedTxs, unconfirmedTxs, history, and UTXOs. */\nclass TokenIdEndpoint {\n    constructor(proxyInterface, tokenId) {\n        this._proxyInterface = proxyInterface;\n        this._tokenId = tokenId;\n    }\n    /**\n     * Fetches the tx history of this tokenId, in anti-chronological order.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async history(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/token-id/${this._tokenId}/history?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the confirmed tx history of this tokenId, in the order they appear on the blockchain.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async confirmedTxs(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/token-id/${this._tokenId}/confirmed-txs?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the unconfirmed tx history of this tokenId, in chronological order.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async unconfirmedTxs(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/token-id/${this._tokenId}/unconfirmed-txs?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the current UTXO set for this tokenId.\n     */\n    async utxos() {\n        const data = await this._proxyInterface.get(`/token-id/${this._tokenId}/utxos`);\n        const utxos = proto.Utxos.decode(data);\n        return {\n            tokenId: this._tokenId,\n            utxos: utxos.utxos.map(convertToUtxo),\n        };\n    }\n}\nexports.TokenIdEndpoint = TokenIdEndpoint;\n/** Allows fetching lokadId confirmedTxs, unconfirmedTxs, and history. */\nclass LokadIdEndpoint {\n    constructor(proxyInterface, lokadId) {\n        this._proxyInterface = proxyInterface;\n        this._lokadId = lokadId;\n    }\n    /**\n     * Fetches the tx history of this tokenId, in anti-chronological order.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async history(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/lokad-id/${this._lokadId}/history?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the confirmed tx history of this tokenId, in the order they appear on the blockchain.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async confirmedTxs(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/lokad-id/${this._lokadId}/confirmed-txs?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the unconfirmed tx history of this tokenId, in chronological order.\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async unconfirmedTxs(page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/lokad-id/${this._lokadId}/unconfirmed-txs?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n}\nexports.LokadIdEndpoint = LokadIdEndpoint;\n/** Allows fetching plugin UTXOs. */\nclass PluginEndpoint {\n    constructor(proxyInterface, pluginName) {\n        this._proxyInterface = proxyInterface;\n        this._pluginName = pluginName;\n    }\n    /**\n     * Fetches the current UTXO set for this plugin group.\n     */\n    async utxos(groupHex) {\n        const data = await this._proxyInterface.get(`/plugin/${this._pluginName}/${groupHex}/utxos`);\n        const utxos = proto.Utxos.decode(data);\n        return {\n            pluginName: this._pluginName,\n            groupHex,\n            utxos: utxos.utxos.map(convertToUtxo),\n        };\n    }\n    /**\n     * Fetches groups of this plugin.\n     */\n    async groups(prefixHex, startHex, pageSize) {\n        const query = new URLSearchParams();\n        if (prefixHex !== undefined) {\n            query.set('prefix', prefixHex);\n        }\n        if (startHex !== undefined) {\n            query.set('start', startHex);\n        }\n        if (pageSize !== undefined) {\n            query.set('page_size', pageSize.toString());\n        }\n        const data = await this._proxyInterface.get(`/plugin/${this._pluginName}/groups?${query.toString()}`);\n        const groups = proto.PluginGroups.decode(data);\n        return convertToPluginGroups(groups);\n    }\n    /**\n     * Fetches the tx history of this groupHex for this plugin, in anti-chronological order.\n     * @param groupHex group as a lowercase hex string\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async history(groupHex, page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/plugin/${this._pluginName}/${groupHex}/history?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the confirmed tx history of this groupHex for this plugin, in the order they appear on the blockchain.\n     * @param groupHex group as a lowercase hex string\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async confirmedTxs(groupHex, page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/plugin/${this._pluginName}/${groupHex}/confirmed-txs?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n    /**\n     * Fetches the unconfirmed tx history of this groupHex for this plugin, in chronological order.\n     * @param groupHex group as a lowercase hex string\n     * @param page Page index of the tx history.\n     * @param pageSize Number of txs per page.\n     */\n    async unconfirmedTxs(groupHex, page = 0, // Get the first page if unspecified\n    pageSize = 25) {\n        const data = await this._proxyInterface.get(`/plugin/${this._pluginName}/${groupHex}/unconfirmed-txs?page=${page}&page_size=${pageSize}`);\n        const historyPage = proto.TxHistoryPage.decode(data);\n        return {\n            txs: historyPage.txs.map(convertToTx),\n            numPages: historyPage.numPages,\n            numTxs: historyPage.numTxs,\n        };\n    }\n}\nexports.PluginEndpoint = PluginEndpoint;\n/** WebSocket connection to Chronik. */\nclass WsEndpoint {\n    constructor(proxyInterface, config) {\n        this.onMessage = config.onMessage;\n        this.onConnect = config.onConnect;\n        this.onReconnect = config.onReconnect;\n        this.onEnd = config.onEnd;\n        this.autoReconnect =\n            config.autoReconnect !== undefined ? config.autoReconnect : true;\n        this.manuallyClosed = false;\n        this.subs = {\n            scripts: [],\n            tokens: [],\n            txids: [],\n            lokadIds: [],\n            plugins: [],\n            blocks: false,\n        };\n        this._proxyInterface = proxyInterface;\n    }\n    /** Wait for the WebSocket to be connected. */\n    async waitForOpen() {\n        await this._proxyInterface.connectWs(this);\n        await this.connected;\n    }\n    /**\n     * Subscribe to block messages\n     */\n    subscribeToBlocks() {\n        this.subs.blocks = true;\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            this._subUnsubBlocks(false);\n        }\n    }\n    /**\n     * Unsubscribe from block messages\n     */\n    unsubscribeFromBlocks() {\n        this.subs.blocks = false;\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            this._subUnsubBlocks(true);\n        }\n    }\n    /**\n     * Subscribe to the given script type and payload.\n     * For \"p2pkh\", `scriptPayload` is the 20 byte public key hash.\n     */\n    subscribeToScript(type, payload) {\n        // Build sub according to chronik expected type\n        const subscription = {\n            scriptType: type,\n            payload,\n        };\n        // We do not want to add invalid subs to ws.subs\n        const scriptSubscriptionValidationCheck = (0, validation_1.isValidWsSubscription)(subscription);\n        if (scriptSubscriptionValidationCheck !== true) {\n            // isValidWsSubscription returns string error msg if the sub is invalid\n            throw new Error(scriptSubscriptionValidationCheck);\n        }\n        this.subs.scripts.push(subscription);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            this._subUnsubScript(false, subscription);\n        }\n    }\n    /** Unsubscribe from the given script type and payload. */\n    unsubscribeFromScript(type, payload) {\n        // Build sub according to chronik expected type\n        const subscription = {\n            scriptType: type,\n            payload,\n        };\n        // Find the requested unsub script and remove it\n        const unsubIndex = this.subs.scripts.findIndex(sub => sub.scriptType === type && sub.payload === payload);\n        if (unsubIndex === -1) {\n            // If we cannot find this subscription in this.subs, throw an error\n            // We do not want an app developer thinking they have unsubscribed from something\n            throw new Error(`No existing sub at ${type}, ${payload}`);\n        }\n        // Remove the requested subscription from this.subs\n        this.subs.scripts.splice(unsubIndex, 1);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            this._subUnsubScript(true, subscription);\n        }\n    }\n    /**\n     * Subscribe to an address\n     * Method can be used for p2pkh or p2sh addresses\n     */\n    subscribeToAddress(address) {\n        // Get type and hash\n        const { type, hash } = (0, ecashaddrjs_1.decodeCashAddress)(address);\n        // Subscribe to script\n        this.subscribeToScript(type, hash);\n    }\n    /** Unsubscribe from the given address */\n    unsubscribeFromAddress(address) {\n        // Get type and hash\n        const { type, hash } = (0, ecashaddrjs_1.decodeCashAddress)(address);\n        // Unsubscribe from script\n        this.unsubscribeFromScript(type, hash);\n    }\n    /** Subscribe to a lokadId */\n    subscribeToLokadId(lokadId) {\n        (0, validation_1.verifyLokadId)(lokadId);\n        // Update ws.subs to include this lokadId\n        this.subs.lokadIds.push(lokadId);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            // Send subscribe msg to chronik server\n            this._subUnsubLokadId(false, lokadId);\n        }\n    }\n    /** Unsubscribe from the given lokadId */\n    unsubscribeFromLokadId(lokadId) {\n        // Find the requested unsub lokadId and remove it\n        const unsubIndex = this.subs.lokadIds.findIndex(thisLokadId => thisLokadId === lokadId);\n        if (unsubIndex === -1) {\n            // If we cannot find this subscription in this.subs.lokadIds, throw an error\n            // We do not want an app developer thinking they have unsubscribed from something if no action happened\n            throw new Error(`No existing sub at lokadId \"${lokadId}\"`);\n        }\n        // Remove the requested lokadId subscription from this.subs.lokadIds\n        this.subs.lokadIds.splice(unsubIndex, 1);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            // Send unsubscribe msg to chronik server\n            this._subUnsubLokadId(true, lokadId);\n        }\n    }\n    /** Subscribe to a tokenId */\n    subscribeToTokenId(tokenId) {\n        (0, validation_1.verifyTokenId)(tokenId);\n        // Update ws.subs to include this tokenId\n        this.subs.tokens.push(tokenId);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            // Send subscribe msg to chronik server\n            this._subUnsubToken(false, tokenId);\n        }\n    }\n    /** Unsubscribe from the given tokenId */\n    unsubscribeFromTokenId(tokenId) {\n        // Find the requested unsub tokenId and remove it\n        const unsubIndex = this.subs.tokens.findIndex(thisTokenId => thisTokenId === tokenId);\n        if (unsubIndex === -1) {\n            // If we cannot find this subscription in this.subs.tokens, throw an error\n            // We do not want an app developer thinking they have unsubscribed from something if no action happened\n            throw new Error(`No existing sub at tokenId \"${tokenId}\"`);\n        }\n        // Remove the requested tokenId subscription from this.subs.tokens\n        this.subs.tokens.splice(unsubIndex, 1);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            // Send unsubscribe msg to chronik server\n            this._subUnsubToken(true, tokenId);\n        }\n    }\n    /** Subscribe to a plugin */\n    subscribeToPlugin(pluginName, group) {\n        // Build sub according to chronik expected type\n        const subscription = {\n            pluginName,\n            group,\n        };\n        (0, validation_1.verifyPluginSubscription)(subscription);\n        // Update ws.subs to include this plugin\n        this.subs.plugins.push(subscription);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            // Send subscribe msg to chronik server\n            this._subUnsubPlugin(false, subscription);\n        }\n    }\n    /** Unsubscribe from the given plugin */\n    unsubscribeFromPlugin(pluginName, group) {\n        // Find the requested unsub script and remove it\n        const unsubIndex = this.subs.plugins.findIndex(sub => sub.pluginName === pluginName && sub.group === group);\n        if (unsubIndex === -1) {\n            // If we cannot find this subscription in this.subs.plugins, throw an error\n            // We do not want an app developer thinking they have unsubscribed from something\n            throw new Error(`No existing sub at pluginName=\"${pluginName}\", group=\"${group}\"`);\n        }\n        // Remove the requested subscription from this.subs.plugins\n        this.subs.plugins.splice(unsubIndex, 1);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            // Send unsubscribe msg to chronik server\n            this._subUnsubPlugin(true, {\n                pluginName,\n                group,\n            });\n        }\n    }\n    /** Subscribe to a txid */\n    subscribeToTxid(txid) {\n        (0, validation_1.verifyTxid)(txid);\n        // Update ws.subs to include this txid\n        this.subs.txids.push(txid);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            // Send subscribe msg to chronik server\n            this._subUnsubTxid(false, txid);\n        }\n    }\n    /** Unsubscribe from the given txid */\n    unsubscribeFromTxid(txid) {\n        // Find the requested unsub txid and remove it\n        const unsubIndex = this.subs.txids.findIndex(thisTxid => thisTxid === txid);\n        if (unsubIndex === -1) {\n            // If we cannot find this subscription in this.subs.txids, throw an error\n            // We do not want an app developer thinking they have unsubscribed from something if no action happened\n            throw new Error(`No existing sub to txid \"${txid}\"`);\n        }\n        // Remove the requested txid subscription from this.subs.txids\n        this.subs.txids.splice(unsubIndex, 1);\n        if (this.ws?.readyState === isomorphic_ws_1.default.OPEN) {\n            // Send unsubscribe msg to chronik server\n            this._subUnsubTxid(true, txid);\n        }\n    }\n    /**\n     * Close the WebSocket connection and prevent any future reconnection\n     * attempts.\n     */\n    close() {\n        this.manuallyClosed = true;\n        this.ws?.close();\n    }\n    _subUnsubBlocks(isUnsub) {\n        // Blocks subscription is empty object\n        const BLOCKS_SUBSCRIPTION = {};\n        const encodedSubscription = proto.WsSub.encode({\n            isUnsub,\n            blocks: BLOCKS_SUBSCRIPTION,\n        }).finish();\n        if (this.ws === undefined) {\n            throw new Error('Invalid state; _ws is undefined');\n        }\n        this.ws.send(encodedSubscription);\n    }\n    _subUnsubScript(isUnsub, subscription) {\n        // If this subscription is to an address, leave the 'blocks' key undefined\n        const encodedSubscription = proto.WsSub.encode({\n            isUnsub,\n            script: {\n                scriptType: subscription.scriptType,\n                payload: (0, hex_1.fromHex)(subscription.payload),\n            },\n        }).finish();\n        if (this.ws === undefined) {\n            throw new Error('Invalid state; _ws is undefined');\n        }\n        this.ws.send(encodedSubscription);\n    }\n    _subUnsubLokadId(isUnsub, lokadId) {\n        const encodedSubscription = proto.WsSub.encode({\n            isUnsub,\n            lokadId: {\n                // User input for lokadId is string\n                // Chronik expects bytes\n                lokadId: (0, hex_1.fromHex)(lokadId),\n            },\n        }).finish();\n        if (this.ws === undefined) {\n            throw new Error('Invalid state; _ws is undefined');\n        }\n        this.ws.send(encodedSubscription);\n    }\n    _subUnsubToken(isUnsub, tokenId) {\n        const encodedSubscription = proto.WsSub.encode({\n            isUnsub,\n            tokenId: {\n                tokenId: tokenId,\n            },\n        }).finish();\n        if (this.ws === undefined) {\n            throw new Error('Invalid state; _ws is undefined');\n        }\n        this.ws.send(encodedSubscription);\n    }\n    _subUnsubTxid(isUnsub, txid) {\n        const encodedSubscription = proto.WsSub.encode({\n            isUnsub,\n            txid: {\n                txid: txid,\n            },\n        }).finish();\n        if (this.ws === undefined) {\n            throw new Error('Invalid state; _ws is undefined');\n        }\n        this.ws.send(encodedSubscription);\n    }\n    _subUnsubPlugin(isUnsub, plugin) {\n        const encodedSubscription = proto.WsSub.encode({\n            isUnsub,\n            plugin: {\n                pluginName: plugin.pluginName,\n                // User input for plugin group is string\n                // Chronik expects bytes\n                group: (0, hex_1.fromHex)(plugin.group),\n            },\n        }).finish();\n        if (this.ws === undefined) {\n            throw new Error('Invalid state; _ws is undefined');\n        }\n        this.ws.send(encodedSubscription);\n    }\n    async handleMsg(wsMsg) {\n        if (typeof this.onMessage === 'undefined') {\n            return;\n        }\n        const data = typeof window === 'undefined'\n            ? // NodeJS\n                wsMsg.data\n            : // Browser\n                new Uint8Array(await wsMsg.data.arrayBuffer());\n        const msg = proto.WsMsg.decode(data);\n        if (typeof msg.error !== 'undefined') {\n            this.onMessage({ type: 'Error', ...msg.error });\n        }\n        else if (typeof msg.block !== 'undefined') {\n            const msgBlock = {\n                type: 'Block',\n                msgType: convertToBlockMsgType(msg.block.msgType),\n                blockHash: (0, hex_1.toHexRev)(msg.block.blockHash),\n                blockHeight: msg.block.blockHeight,\n                blockTimestamp: Number(msg.block.blockTimestamp),\n            };\n            if (typeof msg.block.coinbaseData !== 'undefined') {\n                msgBlock.coinbaseData = convertToCoinbaseData(msg.block.coinbaseData);\n            }\n            this.onMessage(msgBlock);\n        }\n        else if (typeof msg.tx !== 'undefined') {\n            const txMsg = {\n                type: 'Tx',\n                msgType: convertToTxMsgType(msg.tx.msgType),\n                txid: (0, hex_1.toHexRev)(msg.tx.txid),\n            };\n            if (typeof msg.tx.finalizationReason !== 'undefined') {\n                txMsg.finalizationReasonType =\n                    convertToTxFinalizationReasonType(msg.tx.finalizationReason.finalizationType);\n            }\n            this.onMessage(txMsg);\n        }\n        else {\n            console.log('Silently ignored unknown Chronik message:', msg);\n        }\n    }\n}\nexports.WsEndpoint = WsEndpoint;\nfunction convertToBlockchainInfo(blockchainInfo) {\n    return {\n        tipHash: (0, hex_1.toHexRev)(blockchainInfo.tipHash),\n        tipHeight: blockchainInfo.tipHeight,\n    };\n}\nfunction convertToChronikInfo(chronikInfo) {\n    if (chronikInfo.version === undefined) {\n        throw new Error('chronikInfo has no version');\n    }\n    return {\n        version: chronikInfo.version.length !== 0 ? chronikInfo.version : '',\n    };\n}\nfunction convertToBlock(block) {\n    if (block.blockInfo === undefined) {\n        throw new Error('Block has no blockInfo');\n    }\n    return {\n        blockInfo: convertToBlockInfo(block.blockInfo),\n    };\n}\nfunction convertToTxHistoryPage(blockTxs) {\n    const { txs, numPages, numTxs } = blockTxs;\n    const convertedTxs = txs.map(convertToTx);\n    return {\n        txs: convertedTxs,\n        numPages,\n        numTxs,\n    };\n}\nfunction convertToBlockInfo(block) {\n    return {\n        ...block,\n        hash: (0, hex_1.toHexRev)(block.hash),\n        prevHash: (0, hex_1.toHexRev)(block.prevHash),\n        timestamp: Number(block.timestamp),\n        blockSize: Number(block.blockSize),\n        numTxs: Number(block.numTxs),\n        numInputs: Number(block.numInputs),\n        numOutputs: Number(block.numOutputs),\n        sumInputSats: block.sumInputSats,\n        sumCoinbaseOutputSats: block.sumCoinbaseOutputSats,\n        sumNormalOutputSats: block.sumNormalOutputSats,\n        sumBurnedSats: block.sumBurnedSats,\n    };\n}\nfunction convertToTx(tx) {\n    const convertedTx = {\n        txid: (0, hex_1.toHexRev)(tx.txid),\n        version: tx.version,\n        inputs: tx.inputs.map(convertToTxInput),\n        outputs: tx.outputs.map(convertToTxOutput),\n        lockTime: tx.lockTime,\n        timeFirstSeen: Number(tx.timeFirstSeen),\n        size: tx.size,\n        isCoinbase: tx.isCoinbase,\n        tokenEntries: tx.tokenEntries.map(convertToTokenEntry),\n        tokenFailedParsings: tx.tokenFailedParsings.map(convertToTokenFailedParsing),\n        tokenStatus: convertToTokenStatus(tx.tokenStatus),\n        isFinal: tx.isFinal,\n    };\n    if (typeof tx.block !== 'undefined') {\n        // Only include block if the tx is in a block\n        convertedTx.block = convertToBlockMeta(tx.block);\n    }\n    return convertedTx;\n}\nfunction convertToTxInput(input) {\n    if (input.prevOut === undefined) {\n        throw new Error('Invalid proto, no prevOut');\n    }\n    const txInput = {\n        prevOut: {\n            txid: (0, hex_1.toHexRev)(input.prevOut.txid),\n            outIdx: input.prevOut.outIdx,\n        },\n        inputScript: (0, hex_1.toHex)(input.inputScript),\n        sats: input.sats,\n        sequenceNo: input.sequenceNo,\n    };\n    if (typeof input.token !== 'undefined') {\n        // We only return a token key if we have token data for this input\n        txInput.token = convertToToken(input.token);\n    }\n    if (Object.keys(input.plugins).length > 0) {\n        // We only return a plugins key if we have plugins\n        txInput.plugins = convertToPluginEntries(input.plugins);\n    }\n    if (typeof input.outputScript !== 'undefined' &&\n        input.outputScript.length > 0) {\n        // Coinbase tx inputs do not have an outputScript\n        txInput.outputScript = (0, hex_1.toHex)(input.outputScript);\n    }\n    return txInput;\n}\nfunction convertToTxOutput(output) {\n    const txOutput = {\n        sats: BigInt(output.sats),\n        outputScript: (0, hex_1.toHex)(output.outputScript),\n    };\n    if (Object.keys(output.plugins).length > 0) {\n        // We only return a plugins key if we have plugins\n        txOutput.plugins = convertToPluginEntries(output.plugins);\n    }\n    if (typeof output.token !== 'undefined') {\n        // We only return a token key if we have token data for this input\n        txOutput.token = convertToToken(output.token);\n    }\n    if (typeof output.spentBy !== 'undefined') {\n        // We only return a spentBy key if this output has been spent\n        txOutput.spentBy = {\n            txid: (0, hex_1.toHexRev)(output.spentBy.txid),\n            outIdx: output.spentBy.inputIdx,\n        };\n    }\n    return txOutput;\n}\nfunction convertToPluginEntries(plugins) {\n    const pluginEntries = {};\n    for (const [pluginName, plugin] of Object.entries(plugins)) {\n        if (typeof pluginName === 'undefined') {\n            continue;\n        }\n        const { groups, data } = plugin;\n        pluginEntries[pluginName] = {\n            groups: groups.map(hex_1.toHex),\n            data: data.map(hex_1.toHex),\n        };\n    }\n    return pluginEntries;\n}\nfunction convertToPluginGroups(protoPluginGroups) {\n    const { groups } = protoPluginGroups;\n    return {\n        groups: groups.map(group => ({ group: (0, hex_1.toHex)(group.group) })),\n        nextStart: (0, hex_1.toHex)(protoPluginGroups.nextStart),\n    };\n}\nfunction convertToBlockMeta(block) {\n    return {\n        height: block.height,\n        hash: (0, hex_1.toHexRev)(block.hash),\n        timestamp: Number(block.timestamp),\n    };\n}\nfunction convertToRawTx(rawTx) {\n    return {\n        rawTx: (0, hex_1.toHex)(rawTx.rawTx),\n    };\n}\nfunction convertToScriptUtxo(utxo) {\n    if (utxo.outpoint === undefined) {\n        throw new Error('UTXO outpoint is undefined');\n    }\n    const convertedScriptUtxo = {\n        outpoint: {\n            txid: (0, hex_1.toHexRev)(utxo.outpoint.txid),\n            outIdx: utxo.outpoint.outIdx,\n        },\n        blockHeight: utxo.blockHeight,\n        isCoinbase: utxo.isCoinbase,\n        sats: BigInt(utxo.sats),\n        isFinal: utxo.isFinal,\n    };\n    if (typeof utxo.token !== 'undefined') {\n        // We only return a token key if we have token data for this input\n        convertedScriptUtxo.token = convertToToken(utxo.token);\n    }\n    if (Object.keys(utxo.plugins).length > 0) {\n        // We only return a plugins key if we have plugins\n        convertedScriptUtxo.plugins = convertToPluginEntries(utxo.plugins);\n    }\n    return convertedScriptUtxo;\n}\nfunction convertToUtxo(utxo) {\n    if (utxo.outpoint === undefined) {\n        throw new Error('UTXO outpoint is undefined');\n    }\n    const convertedUtxo = {\n        outpoint: {\n            txid: (0, hex_1.toHexRev)(utxo.outpoint.txid),\n            outIdx: utxo.outpoint.outIdx,\n        },\n        blockHeight: utxo.blockHeight,\n        isCoinbase: utxo.isCoinbase,\n        script: (0, hex_1.toHex)(utxo.script),\n        sats: BigInt(utxo.sats),\n        isFinal: utxo.isFinal,\n    };\n    if (typeof utxo.token !== 'undefined') {\n        // We only return a token key if we have token data for this input\n        convertedUtxo.token = convertToToken(utxo.token);\n    }\n    if (Object.keys(utxo.plugins).length > 0) {\n        // We only return a plugins key if we have plugins\n        convertedUtxo.plugins = convertToPluginEntries(utxo.plugins);\n    }\n    return convertedUtxo;\n}\nfunction convertToTokenEntry(tokenEntry) {\n    if (typeof tokenEntry.tokenType === 'undefined') {\n        // Not expected to ever happen\n        throw new Error(`chronik returned undefined tokenEntry.tokenType for tokenId \"${tokenEntry.tokenId}\"`);\n    }\n    const returnObj = {\n        tokenId: tokenEntry.tokenId,\n        tokenType: convertToTokenType(tokenEntry.tokenType),\n        txType: convertToTokenTxType(tokenEntry.txType),\n        isInvalid: tokenEntry.isInvalid,\n        burnSummary: tokenEntry.burnSummary,\n        failedColorings: tokenEntry.failedColorings,\n        actualBurnAtoms: BigInt(tokenEntry.actualBurnAtoms),\n        intentionalBurnAtoms: tokenEntry.intentionalBurnAtoms,\n        burnsMintBatons: tokenEntry.burnsMintBatons,\n    };\n    if (tokenEntry.groupTokenId !== '') {\n        // Only include groupTokenId if it is not empty\n        returnObj.groupTokenId = tokenEntry.groupTokenId;\n    }\n    return returnObj;\n}\nfunction convertToTokenFailedParsing(tokenFailedParsing) {\n    return {\n        pushdataIdx: tokenFailedParsing.pushdataIdx,\n        bytes: (0, hex_1.toHex)(tokenFailedParsing.bytes),\n        error: tokenFailedParsing.error,\n    };\n}\nfunction convertToTokenType(tokenType) {\n    if (typeof tokenType.alp !== 'undefined') {\n        return {\n            protocol: 'ALP',\n            type: convertToAlpTokenType(tokenType.alp),\n            number: tokenType.alp,\n        };\n    }\n    if (typeof tokenType.slp !== 'undefined') {\n        return {\n            protocol: 'SLP',\n            type: convertToSlpTokenType(tokenType.slp),\n            number: tokenType.slp,\n        };\n    }\n    // In case the Chronik instance supports a protocol this client doesn't\n    return {\n        protocol: 'UNKNOWN',\n        type: 'UNKNOWN',\n        number: 0,\n    };\n}\nfunction convertToSlpTokenType(msgType) {\n    const slpTokenType = proto.slpTokenTypeToJSON(msgType);\n    if (isSlpTokenType(slpTokenType)) {\n        return slpTokenType;\n    }\n    return 'SLP_TOKEN_TYPE_UNKNOWN';\n}\nfunction isSlpTokenType(msgType) {\n    return SLP_TOKEN_TYPES.includes(msgType);\n}\nfunction convertToAlpTokenType(msgType) {\n    const alpTokenType = proto.alpTokenTypeToJSON(msgType);\n    if (isAlpTokenType(alpTokenType)) {\n        return alpTokenType;\n    }\n    return 'ALP_TOKEN_TYPE_UNKNOWN';\n}\nfunction isAlpTokenType(msgType) {\n    return exports.ALP_TOKEN_TYPES.includes(msgType);\n}\nfunction convertToTokenStatus(msgType) {\n    const tokenStatus = proto.tokenStatusToJSON(msgType);\n    if (isTokenStatus(tokenStatus)) {\n        return tokenStatus;\n    }\n    return 'TOKEN_STATUS_UNKNOWN';\n}\nfunction isTokenStatus(msgType) {\n    return TOKEN_STATUS_TYPES.includes(msgType);\n}\nfunction convertToTokenTxType(msgType) {\n    const tokenTxType = proto.tokenTxTypeToJSON(msgType);\n    if (isTokenTxType(tokenTxType)) {\n        return tokenTxType;\n    }\n    return 'UNKNOWN';\n}\nfunction isTokenTxType(msgType) {\n    return TOKEN_TX_TYPE_TYPES.includes(msgType);\n}\nfunction convertToToken(token) {\n    if (typeof token.tokenType === 'undefined') {\n        // Not expected to ever happen\n        throw new Error(`chronik returned undefined token.tokenType for tokenId \"${token.tokenId}\"`);\n    }\n    const convertedToken = {\n        tokenId: token.tokenId,\n        tokenType: convertToTokenType(token.tokenType),\n        atoms: BigInt(token.atoms),\n        isMintBaton: token.isMintBaton,\n    };\n    // We do not bother including entryIdx for utxos, where it is always -1\n    if (token.entryIdx !== -1) {\n        convertedToken.entryIdx = token.entryIdx;\n    }\n    return convertedToken;\n}\nfunction convertToBlockMsgType(msgType) {\n    const blockMsgType = proto.blockMsgTypeToJSON(msgType);\n    if (isBlockMsgType(blockMsgType)) {\n        return blockMsgType;\n    }\n    return 'UNRECOGNIZED';\n}\nfunction isBlockMsgType(msgType) {\n    return BLK_MSG_TYPES.includes(msgType);\n}\nfunction convertToTxMsgType(msgType) {\n    const txMsgType = proto.txMsgTypeToJSON(msgType);\n    if (isTxMsgType(txMsgType)) {\n        return txMsgType;\n    }\n    return 'UNRECOGNIZED';\n}\nfunction isTxMsgType(msgType) {\n    return TX_MSG_TYPES.includes(msgType);\n}\n// Add converter and type guards for tx finalization reason\nfunction convertToTxFinalizationReasonType(reason) {\n    const reasonStr = proto.txFinalizationReasonTypeToJSON(reason);\n    if (isTxFinalizationReasonType(reasonStr)) {\n        return reasonStr;\n    }\n    return 'UNRECOGNIZED';\n}\nfunction isTxFinalizationReasonType(reason) {\n    return TX_FINALIZATION_REASON_TYPES.includes(reason);\n}\nfunction convertToTokenInfo(tokenInfo) {\n    if (typeof tokenInfo.tokenType === 'undefined') {\n        // Not expected to ever happen\n        throw new Error(`chronik returned undefined tokenInfo.tokenType for tokenId \"${tokenInfo.tokenId}\"`);\n    }\n    if (typeof tokenInfo.genesisInfo === 'undefined') {\n        // Not expected to ever happen\n        throw new Error(`chronik returned undefined tokenInfo.genesisInfo for tokenId \"${tokenInfo.tokenId}\"`);\n    }\n    // We use tokenType to get the correct shape of genesisInfo\n    const tokenType = convertToTokenType(tokenInfo.tokenType);\n    const returnedTokenInfo = {\n        tokenId: tokenInfo.tokenId,\n        tokenType,\n        timeFirstSeen: Number(tokenInfo.timeFirstSeen),\n        genesisInfo: convertToGenesisInfo(tokenInfo.genesisInfo, tokenType),\n    };\n    if (typeof tokenInfo.block !== 'undefined') {\n        // Only include block if the tx is in a block\n        returnedTokenInfo.block = convertToBlockMeta(tokenInfo.block);\n    }\n    return returnedTokenInfo;\n}\nfunction convertToGenesisInfo(genesisInfo, tokenType) {\n    const decoder = new TextDecoder();\n    const returnedGenesisInfo = {\n        tokenTicker: decoder.decode(genesisInfo.tokenTicker),\n        tokenName: decoder.decode(genesisInfo.tokenName),\n        url: decoder.decode(genesisInfo.url),\n        decimals: genesisInfo.decimals,\n    };\n    // Add ALP fields for ALP types only\n    if (tokenType.protocol === 'ALP') {\n        returnedGenesisInfo.data = (0, hex_1.toHex)(genesisInfo.data);\n        returnedGenesisInfo.authPubkey = (0, hex_1.toHex)(genesisInfo.authPubkey);\n    }\n    // Add mintVaultHash for SLP Mint Vault only\n    if (tokenType.type === 'SLP_TOKEN_TYPE_MINT_VAULT') {\n        returnedGenesisInfo.mintVaultScripthash = (0, hex_1.toHex)(genesisInfo.mintVaultScripthash);\n    }\n    // Add url for SLP only\n    if (tokenType.protocol === 'SLP') {\n        returnedGenesisInfo.hash = (0, hex_1.toHex)(genesisInfo.hash);\n    }\n    return returnedGenesisInfo;\n}\nfunction convertToCoinbaseData(coinbaseData) {\n    const returnedCoinbaseData = {\n        scriptsig: (0, hex_1.toHex)(coinbaseData.coinbaseScriptsig),\n        outputs: coinbaseData.coinbaseOutputs.map(convertToTxOutput),\n    };\n    return returnedCoinbaseData;\n}\nexports.ALP_TOKEN_TYPES = [\n    'ALP_TOKEN_TYPE_STANDARD',\n    'ALP_TOKEN_TYPE_UNKNOWN',\n];\nconst SLP_TOKEN_TYPES = [\n    'SLP_TOKEN_TYPE_FUNGIBLE',\n    'SLP_TOKEN_TYPE_MINT_VAULT',\n    'SLP_TOKEN_TYPE_NFT1_GROUP',\n    'SLP_TOKEN_TYPE_NFT1_CHILD',\n    'SLP_TOKEN_TYPE_UNKNOWN',\n];\nconst TOKEN_STATUS_TYPES = [\n    'TOKEN_STATUS_NON_TOKEN',\n    'TOKEN_STATUS_NORMAL',\n    'TOKEN_STATUS_NOT_NORMAL',\n    'TOKEN_STATUS_UNKNOWN',\n];\nconst TOKEN_TX_TYPE_TYPES = [\n    'NONE',\n    'UNKNOWN',\n    'GENESIS',\n    'SEND',\n    'MINT',\n    'BURN',\n];\nconst BLK_MSG_TYPES = [\n    'BLK_CONNECTED',\n    'BLK_DISCONNECTED',\n    'BLK_FINALIZED',\n    'BLK_INVALIDATED',\n    'UNRECOGNIZED',\n];\nconst TX_MSG_TYPES = [\n    'TX_ADDED_TO_MEMPOOL',\n    'TX_REMOVED_FROM_MEMPOOL',\n    'TX_CONFIRMED',\n    'TX_FINALIZED',\n    'TX_INVALIDATED',\n    'UNRECOGNIZED',\n];\nconst TX_FINALIZATION_REASON_TYPES = [\n    'TX_FINALIZATION_REASON_POST_CONSENSUS',\n    'TX_FINALIZATION_REASON_PRE_CONSENSUS',\n    'UNRECOGNIZED',\n];\n//# sourceMappingURL=ChronikClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0Esa0RBQWtELEtBQUssSUFBSSxRQUFRO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFFBQVE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVcsWUFBWSxNQUFNO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkJBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLHVDQUF1QyxzQ0FBc0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLG1CQUFtQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsY0FBYztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGtCQUFrQjtBQUN6RztBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsa0JBQWtCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2Nocm9uaWstY2xpZW50L2Rpc3Qvc3JjL0Nocm9uaWtDbGllbnQuanM/YzVkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyMy0yMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BTFBfVE9LRU5fVFlQRVMgPSBleHBvcnRzLldzRW5kcG9pbnQgPSBleHBvcnRzLlBsdWdpbkVuZHBvaW50ID0gZXhwb3J0cy5Mb2thZElkRW5kcG9pbnQgPSBleHBvcnRzLlRva2VuSWRFbmRwb2ludCA9IGV4cG9ydHMuU2NyaXB0RW5kcG9pbnQgPSBleHBvcnRzLkNocm9uaWtDbGllbnQgPSBleHBvcnRzLnNvcnROb2Rlc0J5TGF0ZW5jeSA9IGV4cG9ydHMubWVhc3VyZVdlYnNvY2tldExhdGVuY3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IHZvaWQgMDtcbmNvbnN0IGVjYXNoYWRkcmpzXzEgPSByZXF1aXJlKFwiZWNhc2hhZGRyanNcIik7XG5jb25zdCBpc29tb3JwaGljX3dzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImlzb21vcnBoaWMtd3NcIikpO1xuY29uc3QgcHJvdG8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3Byb3RvL2Nocm9uaWtcIikpO1xuY29uc3QgZmFpbG92ZXJQcm94eV8xID0gcmVxdWlyZShcIi4vZmFpbG92ZXJQcm94eVwiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvblwiKTtcbnZhciBDb25uZWN0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25TdHJhdGVneSkge1xuICAgIENvbm5lY3Rpb25TdHJhdGVneVtcIkNsb3Nlc3RGaXJzdFwiXSA9IFwiQ0xPU0VTVF9GSVJTVFwiO1xuICAgIENvbm5lY3Rpb25TdHJhdGVneVtcIkFzT3JkZXJlZFwiXSA9IFwiQVNfT1JERVJFRFwiO1xufSkoQ29ubmVjdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ29ubmVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbmNvbnN0IFdFQlNPQ0tFVF9USU1FT1VUX01TID0gMTAwMDtcbi8qKlxuICogTWVhc3VyZXMgY29ubmVjdGlvbiBsYXRlbmN5IHRvIGEgZ2l2ZW4gV2ViU29ja2V0IFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHdzVXJsIFdlYlNvY2tldCBVUkwgdG8gdGVzdCBjb25uZWN0aW9uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBSZXR1cm5zIGxhdGVuY3kgaW4gbWlsbGlzZWNvbmRzLCBvciBJbmZpbml0eSBpZiBjb25uZWN0aW9uIHRpbWVzIG91dCBvciBmYWlsc1xuICovXG5hc3luYyBmdW5jdGlvbiBtZWFzdXJlV2Vic29ja2V0TGF0ZW5jeSh3c1VybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dEZhaWx1cmUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRlc3RXcy5jbG9zZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZShJbmZpbml0eSk7XG4gICAgICAgIH0sIFdFQlNPQ0tFVF9USU1FT1VUX01TKTtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgdGVzdFdzID0gbmV3IGlzb21vcnBoaWNfd3NfMS5kZWZhdWx0KHdzVXJsKTtcbiAgICAgICAgdGVzdFdzLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0ZXN0V3MuY2xvc2UoKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0RmFpbHVyZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShJbmZpbml0eSk7XG4gICAgICAgIH07XG4gICAgICAgIHRlc3RXcy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsYXRlbmN5ID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIHRlc3RXcy5jbG9zZSgpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRGYWlsdXJlKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGxhdGVuY3kpO1xuICAgICAgICB9O1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH0pO1xufVxuZXhwb3J0cy5tZWFzdXJlV2Vic29ja2V0TGF0ZW5jeSA9IG1lYXN1cmVXZWJzb2NrZXRMYXRlbmN5O1xuLyoqXG4gKiBTb3J0IG5vZGVzIGJ5IGxhdGVuY3lcbiAqIEBwYXJhbSB7c3RyaW5nW119IHVybHMgQXJyYXkgb2YgVVJMcyB0byBzb3J0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IEFycmF5IG9mIFVSTHMgc29ydGVkIGJ5IGxhdGVuY3lcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc29ydE5vZGVzQnlMYXRlbmN5KHVybHMpIHtcbiAgICAvLyBDb252ZXJ0IFVSTHMgdXNpbmcgYXBwZW5kV3NVcmxzXG4gICAgY29uc3QgZW5kcG9pbnRzID0gKDAsIGZhaWxvdmVyUHJveHlfMS5hcHBlbmRXc1VybHMpKHVybHMpO1xuICAgIC8vIFRlc3QgbGF0ZW5jeSBvZiBhbGwgZW5kcG9pbnRzIGluIHBhcmFsbGVsXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGVuZHBvaW50cy5tYXAoYXN5bmMgKGVuZHBvaW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhdGVuY3kgPSBhd2FpdCBtZWFzdXJlV2Vic29ja2V0TGF0ZW5jeShlbmRwb2ludC53c1VybCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IGVuZHBvaW50LnVybCxcbiAgICAgICAgICAgIGxhdGVuY3k6IGxhdGVuY3ksXG4gICAgICAgIH07XG4gICAgfSkpO1xuICAgIHJlc3VsdHMuc29ydCgoYSwgYikgPT4gYS5sYXRlbmN5IC0gYi5sYXRlbmN5KTtcbiAgICBjb25zdCBzb3J0ZWRVcmxzID0gcmVzdWx0cy5tYXAociA9PiByLnVybCk7XG4gICAgc29ydGVkVXJscy5mb3JFYWNoKCh1cmwsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzLmZpbmQociA9PiByLnVybCA9PT0gdXJsKTtcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0Py5sYXRlbmN5ID09PSBJbmZpbml0eVxuICAgICAgICAgICAgPyBgICAke2lkeCArIDF9LiAke3VybH0gLSBsYXRlbmN5OiA+JHtNYXRoLnJvdW5kKFdFQlNPQ0tFVF9USU1FT1VUX01TKX1tc2BcbiAgICAgICAgICAgIDogYCAgJHtpZHggKyAxfS4gJHt1cmx9IC0gbGF0ZW5jeTogJHtNYXRoLnJvdW5kKHJlc3VsdD8ubGF0ZW5jeSB8fCAwKX1tc2ApO1xuICAgIH0pO1xuICAgIHJldHVybiBzb3J0ZWRVcmxzO1xufVxuZXhwb3J0cy5zb3J0Tm9kZXNCeUxhdGVuY3kgPSBzb3J0Tm9kZXNCeUxhdGVuY3k7XG4vKipcbiAqIENsaWVudCB0byBhY2Nlc3MgYW4gaW4tbm9kZSBDaHJvbmlrIGluc3RhbmNlLlxuICogUGxhaW4gb2JqZWN0LCB3aXRob3V0IGFueSBjb25uZWN0aW9ucy5cbiAqL1xuY2xhc3MgQ2hyb25pa0NsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudC4gVGhpcyBqdXN0IGNyZWF0ZXMgYW4gb2JqZWN0LCB3aXRob3V0IGFueSBjb25uZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHVybHMgQXJyYXkgb2YgdmFsaWQgdXJscy4gQSB2YWxpZCB1cmwgY29tZXMgd2l0aCBzY2hlbWEgYW5kIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICAgKiBlLmcuICdbJ2h0dHBzOi8vY2hyb25pay5iZS5jYXNoL3hlYzInLCAnaHR0cHM6Ly9jaHJvbmlrLW5hdGl2ZS5mYWJpZW4uY2FzaCddXG4gICAgICogVGhlIGFwcHJvYWNoIG9mIGFjY2VwdGluZyBhbiBhcnJheSBvZiB1cmxzIGFzIGlucHV0IGlzIHRvIGVuc3VyZSByZWR1bmRhbmN5IGlmIHRoZVxuICAgICAqIGZpcnN0IHVybCBlbmNvdW50ZXJzIGRvd250aW1lLlxuICAgICAqIEB0aHJvd3Mge2Vycm9yfSB0aHJvd3MgZXJyb3Igb24gaW52YWxpZCBjb25zdHJ1Y3RvciBpbnB1dHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmxzKSB7XG4gICAgICAgIC8vIEluc3RhbnRpYXRlIEZhaWxvdmVyUHJveHkgd2l0aCB0aGUgdXJscyBhcnJheVxuICAgICAgICB0aGlzLl9wcm94eUludGVyZmFjZSA9IG5ldyBmYWlsb3ZlclByb3h5XzEuRmFpbG92ZXJQcm94eSh1cmxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIENocm9uaWsgY2xpZW50IGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHN0cmF0ZWd5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb25TdHJhdGVneX0gc3RyYXRlZ3kgQ29ubmVjdGlvbiBzdHJhdGVneVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHVybHMgQXJyYXkgb2YgQ2hyb25payBVUkxzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q2hyb25pa0NsaWVudD59IENsaWVudCBpbnN0YW5jZSBjcmVhdGVkIHdpdGggc29ydGVkIFVSTHNcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgdXNlU3RyYXRlZ3koc3RyYXRlZ3ksIHVybHMpIHtcbiAgICAgICAgbGV0IHNvcnRlZFVybHMgPSBbLi4udXJsc107XG4gICAgICAgIC8vIElmIHVzaW5nIENsb3Nlc3RGaXJzdCBzdHJhdGVneSwgc29ydCBub2RlcyBieSBsYXRlbmN5IGZpcnN0XG4gICAgICAgIGlmIChzdHJhdGVneSA9PT0gQ29ubmVjdGlvblN0cmF0ZWd5LkNsb3Nlc3RGaXJzdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3J0ZWRVcmxzID0gYXdhaXQgc29ydE5vZGVzQnlMYXRlbmN5KHVybHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc29ydGluZyBub2RlcyBieSBsYXRlbmN5OicsIGVycm9yLCAnVXNpbmcgb3JpZ2luYWwgb3JkZXI6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaHJvbmlrQ2xpZW50KHNvcnRlZFVybHMpO1xuICAgIH1cbiAgICAvLyBGb3IgdW5pdCB0ZXN0IHZlcmlmaWNhdGlvblxuICAgIHByb3h5SW50ZXJmYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJveHlJbnRlcmZhY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgdGhlIGByYXdUeGAgb24gdGhlIG5ldHdvcmsuXG4gICAgICogSWYgYHNraXBUb2tlbkNoZWNrc2AgaXMgZmFsc2UsIGl0IHdpbGwgYmUgY2hlY2tlZCB0aGF0IHRoZSB0eCBkb2Vzbid0IGJ1cm5cbiAgICAgKiBhbnkgdG9rZW5zIGJlZm9yZSBicm9hZGNhc3RpbmcuXG4gICAgICovXG4gICAgYXN5bmMgYnJvYWRjYXN0VHgocmF3VHgsIHNraXBUb2tlbkNoZWNrcyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBwcm90by5Ccm9hZGNhc3RUeFJlcXVlc3QuZW5jb2RlKHtcbiAgICAgICAgICAgIHJhd1R4OiB0eXBlb2YgcmF3VHggPT09ICdzdHJpbmcnID8gKDAsIGhleF8xLmZyb21IZXgpKHJhd1R4KSA6IHJhd1R4LFxuICAgICAgICAgICAgc2tpcFRva2VuQ2hlY2tzLFxuICAgICAgICB9KS5maW5pc2goKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLnBvc3QoJy9icm9hZGNhc3QtdHgnLCByZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgYnJvYWRjYXN0UmVzcG9uc2UgPSBwcm90by5Ccm9hZGNhc3RUeFJlc3BvbnNlLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4aWQ6ICgwLCBoZXhfMS50b0hleFJldikoYnJvYWRjYXN0UmVzcG9uc2UudHhpZCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgdGhlIGByYXdUeHNgIG9uIHRoZSBuZXR3b3JrLCBvbmx5IGlmIGFsbCBvZiB0aGVtIGFyZSB2YWxpZC5cbiAgICAgKiBJZiBgc2tpcFRva2VuQ2hlY2tzYCBpcyBmYWxzZSwgaXQgd2lsbCBiZSBjaGVja2VkIHRoYXQgdGhlIHR4cyBkb24ndCBidXJuXG4gICAgICogYW55IHRva2VucyBiZWZvcmUgYnJvYWRjYXN0aW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGJyb2FkY2FzdFR4cyhyYXdUeHMsIHNraXBUb2tlbkNoZWNrcyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBwcm90by5Ccm9hZGNhc3RUeHNSZXF1ZXN0LmVuY29kZSh7XG4gICAgICAgICAgICByYXdUeHM6IHJhd1R4cy5tYXAocmF3VHggPT4gdHlwZW9mIHJhd1R4ID09PSAnc3RyaW5nJyA/ICgwLCBoZXhfMS5mcm9tSGV4KShyYXdUeCkgOiByYXdUeCksXG4gICAgICAgICAgICBza2lwVG9rZW5DaGVja3MsXG4gICAgICAgIH0pLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UucG9zdCgnL2Jyb2FkY2FzdC10eHMnLCByZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgYnJvYWRjYXN0UmVzcG9uc2UgPSBwcm90by5Ccm9hZGNhc3RUeHNSZXNwb25zZS5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eGlkczogYnJvYWRjYXN0UmVzcG9uc2UudHhpZHMubWFwKGhleF8xLnRvSGV4UmV2KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFZhbGlkYXRlIGEgdHggYnkgcmF3dHhcbiAgICAgKiAgVGhpcyBpcyBhIHNvcnQgb2YgcHJlZmxpZ2h0IGNoZWNrIGJlZm9yZSBicm9hZGNhc3RpbmcgYSB0eFxuICAgICAqICBBbGxvd3MgdXMgdG9cbiAgICAgKiAgLSBjaGVjayBiZWZvcmUgYnJvYWRjYXN0IGlmIGEgdHggdW5pbnRlbnRpb25hbGx5IGJ1cm5zIHRva2Vuc1xuICAgICAqL1xuICAgIGFzeW5jIHZhbGlkYXRlUmF3VHgocmF3VHgpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgaW5wdXRcbiAgICAgICAgaWYgKHR5cGVvZiByYXdUeCAhPT0gJ3N0cmluZycgJiYgIShyYXdUeCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICAvLyBVc2VyIGhhcyBjYWxsZWQgdmFsaWRhdGVSYXdUeCB3aXRoIGludmFsaWQgaW5wdXQsIG5vIG5lZWQgdG8gdXNlIGNocm9uaWtcbiAgICAgICAgICAgIC8vIHRvIHZhbGlkYXRlIHRoaXMgcmF3VHhcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmF3VHggbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYSBVaW50OEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHByb3RvLlJhd1R4LmVuY29kZSh7XG4gICAgICAgICAgICByYXdUeDogdHlwZW9mIHJhd1R4ID09PSAnc3RyaW5nJyA/ICgwLCBoZXhfMS5mcm9tSGV4KShyYXdUeCkgOiByYXdUeCxcbiAgICAgICAgfSkuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5wb3N0KCcvdmFsaWRhdGUtdHgnLCByZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVSZXNwb25zZSA9IHByb3RvLlR4LmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1R4KHZhbGlkYXRlUmVzcG9uc2UpO1xuICAgIH1cbiAgICAvKiogRmV0Y2ggY3VycmVudCBpbmZvIG9mIHRoZSBibG9ja2NoYWluLCBzdWNoIGFzIHRpcCBoYXNoIGFuZCBoZWlnaHQuICovXG4gICAgYXN5bmMgYmxvY2tjaGFpbkluZm8oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5nZXQoYC9ibG9ja2NoYWluLWluZm9gKTtcbiAgICAgICAgY29uc3QgYmxvY2tjaGFpbkluZm8gPSBwcm90by5CbG9ja2NoYWluSW5mby5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9CbG9ja2NoYWluSW5mbyhibG9ja2NoYWluSW5mbyk7XG4gICAgfVxuICAgIC8qKiBGZXRjaCBpbmZvIGFib3V0IHRoZSBjdXJyZW50IHJ1bm5pbmcgY2hyb25payBzZXJ2ZXIgKi9cbiAgICBhc3luYyBjaHJvbmlrSW5mbygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL2Nocm9uaWstaW5mb2ApO1xuICAgICAgICBjb25zdCBjaHJvbmlrU2VydmVySW5mbyA9IHByb3RvLkNocm9uaWtJbmZvLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb0Nocm9uaWtJbmZvKGNocm9uaWtTZXJ2ZXJJbmZvKTtcbiAgICB9XG4gICAgLyoqIEZldGNoIHRoZSBibG9jayBnaXZlbiBoYXNoIG9yIGhlaWdodC4gKi9cbiAgICBhc3luYyBibG9jayhoYXNoT3JIZWlnaHQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL2Jsb2NrLyR7aGFzaE9ySGVpZ2h0fWApO1xuICAgICAgICBjb25zdCBibG9jayA9IHByb3RvLkJsb2NrLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb0Jsb2NrKGJsb2NrKTtcbiAgICB9XG4gICAgLyoqIEZldGNoIHRoZSB0eCBoaXN0b3J5IG9mIGEgYmxvY2sgZ2l2ZW4gaGFzaCBvciBoZWlnaHQuICovXG4gICAgYXN5bmMgYmxvY2tUeHMoaGFzaE9ySGVpZ2h0LCBwYWdlID0gMCwgLy8gR2V0IHRoZSBmaXJzdCBwYWdlIGlmIHVuc3BlY2lmaWVkXG4gICAgcGFnZVNpemUgPSAyNSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UuZ2V0KGAvYmxvY2stdHhzLyR7aGFzaE9ySGVpZ2h0fT9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgICAgIGNvbnN0IGJsb2NrVHhzID0gcHJvdG8uVHhIaXN0b3J5UGFnZS5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9UeEhpc3RvcnlQYWdlKGJsb2NrVHhzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggYmxvY2sgaW5mbyBvZiBhIHJhbmdlIG9mIGJsb2Nrcy5cbiAgICAgKiBgc3RhcnRIZWlnaHRgIGFuZCBgZW5kSGVpZ2h0YCBhcmUgaW5jbHVzaXZlIHJhbmdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBibG9ja3Moc3RhcnRIZWlnaHQsIGVuZEhlaWdodCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UuZ2V0KGAvYmxvY2tzLyR7c3RhcnRIZWlnaHR9LyR7ZW5kSGVpZ2h0fWApO1xuICAgICAgICBjb25zdCBibG9ja3MgPSBwcm90by5CbG9ja3MuZGVjb2RlKGRhdGEpO1xuICAgICAgICByZXR1cm4gYmxvY2tzLmJsb2Nrcy5tYXAoY29udmVydFRvQmxvY2tJbmZvKTtcbiAgICB9XG4gICAgLyoqIEZldGNoIHRva2VuIGluZm8gYW5kIHN0YXRzIGdpdmVuIHRoZSB0b2tlbklkLiAqL1xuICAgIGFzeW5jIHRva2VuKHRva2VuSWQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL3Rva2VuLyR7dG9rZW5JZH1gKTtcbiAgICAgICAgY29uc3QgdG9rZW5JbmZvID0gcHJvdG8uVG9rZW5JbmZvLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1Rva2VuSW5mbyh0b2tlbkluZm8pO1xuICAgIH1cbiAgICAvKiogRmV0Y2ggdHggZGV0YWlscyBnaXZlbiB0aGUgdHhpZC4gKi9cbiAgICBhc3luYyB0eCh0eGlkKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5nZXQoYC90eC8ke3R4aWR9YCk7XG4gICAgICAgIGNvbnN0IHR4ID0gcHJvdG8uVHguZGVjb2RlKGRhdGEpO1xuICAgICAgICByZXR1cm4gY29udmVydFRvVHgodHgpO1xuICAgIH1cbiAgICAvKiogRmV0Y2ggdHggZGV0YWlscyBnaXZlbiB0aGUgdHhpZC4gKi9cbiAgICBhc3luYyByYXdUeCh0eGlkKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5nZXQoYC9yYXctdHgvJHt0eGlkfWApO1xuICAgICAgICBjb25zdCByYXdUeCA9IHByb3RvLlJhd1R4LmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1Jhd1R4KHJhd1R4KTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBvYmplY3QgdGhhdCBhbGxvd3MgZmV0Y2hpbmcgaW5mbyBhYm91dCBhIGdpdmVuIHRva2VuICovXG4gICAgdG9rZW5JZCh0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5JZEVuZHBvaW50KHRoaXMuX3Byb3h5SW50ZXJmYWNlLCB0b2tlbklkKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBvYmplY3QgdGhhdCBhbGxvd3MgZmV0Y2hpbmcgaW5mbyBhYm91dCBhIGdpdmVuIGxva2FkSWQgKi9cbiAgICBsb2thZElkKGxva2FkSWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2thZElkRW5kcG9pbnQodGhpcy5fcHJveHlJbnRlcmZhY2UsIGxva2FkSWQpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIG9iamVjdCB0aGF0IGFsbG93cyBmZXRjaGluZyBpbmZvIGFib3V0IGEgZ2l2ZW4gcGx1Z2luICovXG4gICAgcGx1Z2luKHBsdWdpbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbHVnaW5FbmRwb2ludCh0aGlzLl9wcm94eUludGVyZmFjZSwgcGx1Z2luTmFtZSk7XG4gICAgfVxuICAgIC8qKiBDcmVhdGUgb2JqZWN0IHRoYXQgYWxsb3dzIGZldGNoaW5nIHNjcmlwdCBoaXN0b3J5IG9yIFVUWE9zLiAqL1xuICAgIHNjcmlwdChzY3JpcHRUeXBlLCBzY3JpcHRQYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NyaXB0RW5kcG9pbnQodGhpcy5fcHJveHlJbnRlcmZhY2UsIHNjcmlwdFR5cGUsIHNjcmlwdFBheWxvYWQpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIG9iamVjdCB0aGF0IGFsbG93cyBmZXRjaGluZyBzY3JpcHQgaGlzdG9yeSBvciBVVFhPcyBieSBwMnBraCBvciBwMnNoIGFkZHJlc3MgKi9cbiAgICBhZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBoYXNoIH0gPSAoMCwgZWNhc2hhZGRyanNfMS5kZWNvZGVDYXNoQWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBuZXcgU2NyaXB0RW5kcG9pbnQodGhpcy5fcHJveHlJbnRlcmZhY2UsIHR5cGUsIGhhc2gpO1xuICAgIH1cbiAgICAvKiogT3BlbiBhIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIGxpc3RlbiBmb3IgdXBkYXRlcy4gKi9cbiAgICB3cyhjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXc0VuZHBvaW50KHRoaXMuX3Byb3h5SW50ZXJmYWNlLCBjb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb25pa0NsaWVudCA9IENocm9uaWtDbGllbnQ7XG4vKiogQWxsb3dzIGZldGNoaW5nIHNjcmlwdCBoaXN0b3J5IGFuZCBVVFhPcy4gKi9cbmNsYXNzIFNjcmlwdEVuZHBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm94eUludGVyZmFjZSwgc2NyaXB0VHlwZSwgc2NyaXB0UGF5bG9hZCkge1xuICAgICAgICB0aGlzLl9wcm94eUludGVyZmFjZSA9IHByb3h5SW50ZXJmYWNlO1xuICAgICAgICB0aGlzLl9zY3JpcHRUeXBlID0gc2NyaXB0VHlwZTtcbiAgICAgICAgdGhpcy5fc2NyaXB0UGF5bG9hZCA9IHNjcmlwdFBheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHR4IGhpc3Rvcnkgb2YgdGhpcyBzY3JpcHQsIGluIGFudGktY2hyb25vbG9naWNhbCBvcmRlci5cbiAgICAgKiBUaGlzIG1lYW5zIGl0J3Mgb3JkZXJlZCBieSBmaXJzdC1zZWVuIGZpcnN0LCBpLmUuIFR4SGlzdG9yeVBhZ2UudHhzWzBdXG4gICAgICogd2lsbCBiZSB0aGUgbW9zdCByZWNlbnQgdHguIElmIHRoZSB0eCBoYXNuJ3QgYmVlbiBzZWVuXG4gICAgICogYnkgdGhlIGluZGV4ZXIgYmVmb3JlLCBpdCdzIG9yZGVyZWQgYnkgdGhlIGJsb2NrIHRpbWVzdGFtcC5cbiAgICAgKiBAcGFyYW0gcGFnZSBQYWdlIGluZGV4IG9mIHRoZSB0eCBoaXN0b3J5LlxuICAgICAqIEBwYXJhbSBwYWdlU2l6ZSBOdW1iZXIgb2YgdHhzIHBlciBwYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGhpc3RvcnkocGFnZSA9IDAsIC8vIEdldCB0aGUgZmlyc3QgcGFnZSBpZiB1bnNwZWNpZmllZFxuICAgIHBhZ2VTaXplID0gMjUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL3NjcmlwdC8ke3RoaXMuX3NjcmlwdFR5cGV9LyR7dGhpcy5fc2NyaXB0UGF5bG9hZH0vaGlzdG9yeT9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlQYWdlID0gcHJvdG8uVHhIaXN0b3J5UGFnZS5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eHM6IGhpc3RvcnlQYWdlLnR4cy5tYXAoY29udmVydFRvVHgpLFxuICAgICAgICAgICAgbnVtUGFnZXM6IGhpc3RvcnlQYWdlLm51bVBhZ2VzLFxuICAgICAgICAgICAgbnVtVHhzOiBoaXN0b3J5UGFnZS5udW1UeHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIGNvbmZpcm1lZCB0eCBoaXN0b3J5IG9mIHRoaXMgc2NyaXB0LCBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIgb24gdGhlIGJsb2NrY2hhaW4uXG4gICAgICogQHBhcmFtIHBhZ2UgUGFnZSBpbmRleCBvZiB0aGUgdHggaGlzdG9yeS5cbiAgICAgKiBAcGFyYW0gcGFnZVNpemUgTnVtYmVyIG9mIHR4cyBwZXIgcGFnZS5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtZWRUeHMocGFnZSA9IDAsIC8vIEdldCB0aGUgZmlyc3QgcGFnZSBpZiB1bnNwZWNpZmllZFxuICAgIHBhZ2VTaXplID0gMjUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL3NjcmlwdC8ke3RoaXMuX3NjcmlwdFR5cGV9LyR7dGhpcy5fc2NyaXB0UGF5bG9hZH0vY29uZmlybWVkLXR4cz9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlQYWdlID0gcHJvdG8uVHhIaXN0b3J5UGFnZS5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eHM6IGhpc3RvcnlQYWdlLnR4cy5tYXAoY29udmVydFRvVHgpLFxuICAgICAgICAgICAgbnVtUGFnZXM6IGhpc3RvcnlQYWdlLm51bVBhZ2VzLFxuICAgICAgICAgICAgbnVtVHhzOiBoaXN0b3J5UGFnZS5udW1UeHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHVuY29uZmlybWVkIHR4IGhpc3Rvcnkgb2YgdGhpcyBzY3JpcHQsIGluIGNocm9ub2xvZ2ljYWwgb3JkZXIuXG4gICAgICogQHBhcmFtIHBhZ2UgUGFnZSBpbmRleCBvZiB0aGUgdHggaGlzdG9yeS5cbiAgICAgKiBAcGFyYW0gcGFnZVNpemUgTnVtYmVyIG9mIHR4cyBwZXIgcGFnZS5cbiAgICAgKi9cbiAgICBhc3luYyB1bmNvbmZpcm1lZFR4cyhwYWdlID0gMCwgLy8gR2V0IHRoZSBmaXJzdCBwYWdlIGlmIHVuc3BlY2lmaWVkXG4gICAgcGFnZVNpemUgPSAyNSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UuZ2V0KGAvc2NyaXB0LyR7dGhpcy5fc2NyaXB0VHlwZX0vJHt0aGlzLl9zY3JpcHRQYXlsb2FkfS91bmNvbmZpcm1lZC10eHM/cGFnZT0ke3BhZ2V9JnBhZ2Vfc2l6ZT0ke3BhZ2VTaXplfWApO1xuICAgICAgICBjb25zdCBoaXN0b3J5UGFnZSA9IHByb3RvLlR4SGlzdG9yeVBhZ2UuZGVjb2RlKGRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhzOiBoaXN0b3J5UGFnZS50eHMubWFwKGNvbnZlcnRUb1R4KSxcbiAgICAgICAgICAgIG51bVBhZ2VzOiBoaXN0b3J5UGFnZS5udW1QYWdlcyxcbiAgICAgICAgICAgIG51bVR4czogaGlzdG9yeVBhZ2UubnVtVHhzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBjdXJyZW50IFVUWE8gc2V0IGZvciB0aGlzIHNjcmlwdC5cbiAgICAgKiBJdCBpcyBncm91cGVkIGJ5IG91dHB1dCBzY3JpcHQsIGluIGNhc2UgYSBzY3JpcHQgdHlwZSBjYW4gbWF0Y2ggbXVsdGlwbGVcbiAgICAgKiBkaWZmZXJlbnQgb3V0cHV0IHNjcmlwdHMgKGUuZy4gVGFwcm9vdCBvbiBMb3R1cykuXG4gICAgICovXG4gICAgYXN5bmMgdXR4b3MoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5nZXQoYC9zY3JpcHQvJHt0aGlzLl9zY3JpcHRUeXBlfS8ke3RoaXMuX3NjcmlwdFBheWxvYWR9L3V0eG9zYCk7XG4gICAgICAgIGNvbnN0IHNjcmlwdFV0eG9zID0gcHJvdG8uU2NyaXB0VXR4b3MuZGVjb2RlKGRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3V0cHV0U2NyaXB0OiAoMCwgaGV4XzEudG9IZXgpKHNjcmlwdFV0eG9zLnNjcmlwdCksXG4gICAgICAgICAgICB1dHhvczogc2NyaXB0VXR4b3MudXR4b3MubWFwKGNvbnZlcnRUb1NjcmlwdFV0eG8pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU2NyaXB0RW5kcG9pbnQgPSBTY3JpcHRFbmRwb2ludDtcbi8qKiBBbGxvd3MgZmV0Y2hpbmcgdG9rZW5JZCBjb25maXJtZWRUeHMsIHVuY29uZmlybWVkVHhzLCBoaXN0b3J5LCBhbmQgVVRYT3MuICovXG5jbGFzcyBUb2tlbklkRW5kcG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3h5SW50ZXJmYWNlLCB0b2tlbklkKSB7XG4gICAgICAgIHRoaXMuX3Byb3h5SW50ZXJmYWNlID0gcHJveHlJbnRlcmZhY2U7XG4gICAgICAgIHRoaXMuX3Rva2VuSWQgPSB0b2tlbklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSB0eCBoaXN0b3J5IG9mIHRoaXMgdG9rZW5JZCwgaW4gYW50aS1jaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAqIEBwYXJhbSBwYWdlIFBhZ2UgaW5kZXggb2YgdGhlIHR4IGhpc3RvcnkuXG4gICAgICogQHBhcmFtIHBhZ2VTaXplIE51bWJlciBvZiB0eHMgcGVyIHBhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgaGlzdG9yeShwYWdlID0gMCwgLy8gR2V0IHRoZSBmaXJzdCBwYWdlIGlmIHVuc3BlY2lmaWVkXG4gICAgcGFnZVNpemUgPSAyNSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UuZ2V0KGAvdG9rZW4taWQvJHt0aGlzLl90b2tlbklkfS9oaXN0b3J5P3BhZ2U9JHtwYWdlfSZwYWdlX3NpemU9JHtwYWdlU2l6ZX1gKTtcbiAgICAgICAgY29uc3QgaGlzdG9yeVBhZ2UgPSBwcm90by5UeEhpc3RvcnlQYWdlLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4czogaGlzdG9yeVBhZ2UudHhzLm1hcChjb252ZXJ0VG9UeCksXG4gICAgICAgICAgICBudW1QYWdlczogaGlzdG9yeVBhZ2UubnVtUGFnZXMsXG4gICAgICAgICAgICBudW1UeHM6IGhpc3RvcnlQYWdlLm51bVR4cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgY29uZmlybWVkIHR4IGhpc3Rvcnkgb2YgdGhpcyB0b2tlbklkLCBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIgb24gdGhlIGJsb2NrY2hhaW4uXG4gICAgICogQHBhcmFtIHBhZ2UgUGFnZSBpbmRleCBvZiB0aGUgdHggaGlzdG9yeS5cbiAgICAgKiBAcGFyYW0gcGFnZVNpemUgTnVtYmVyIG9mIHR4cyBwZXIgcGFnZS5cbiAgICAgKi9cbiAgICBhc3luYyBjb25maXJtZWRUeHMocGFnZSA9IDAsIC8vIEdldCB0aGUgZmlyc3QgcGFnZSBpZiB1bnNwZWNpZmllZFxuICAgIHBhZ2VTaXplID0gMjUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL3Rva2VuLWlkLyR7dGhpcy5fdG9rZW5JZH0vY29uZmlybWVkLXR4cz9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlQYWdlID0gcHJvdG8uVHhIaXN0b3J5UGFnZS5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eHM6IGhpc3RvcnlQYWdlLnR4cy5tYXAoY29udmVydFRvVHgpLFxuICAgICAgICAgICAgbnVtUGFnZXM6IGhpc3RvcnlQYWdlLm51bVBhZ2VzLFxuICAgICAgICAgICAgbnVtVHhzOiBoaXN0b3J5UGFnZS5udW1UeHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHVuY29uZmlybWVkIHR4IGhpc3Rvcnkgb2YgdGhpcyB0b2tlbklkLCBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyLlxuICAgICAqIEBwYXJhbSBwYWdlIFBhZ2UgaW5kZXggb2YgdGhlIHR4IGhpc3RvcnkuXG4gICAgICogQHBhcmFtIHBhZ2VTaXplIE51bWJlciBvZiB0eHMgcGVyIHBhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgdW5jb25maXJtZWRUeHMocGFnZSA9IDAsIC8vIEdldCB0aGUgZmlyc3QgcGFnZSBpZiB1bnNwZWNpZmllZFxuICAgIHBhZ2VTaXplID0gMjUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL3Rva2VuLWlkLyR7dGhpcy5fdG9rZW5JZH0vdW5jb25maXJtZWQtdHhzP3BhZ2U9JHtwYWdlfSZwYWdlX3NpemU9JHtwYWdlU2l6ZX1gKTtcbiAgICAgICAgY29uc3QgaGlzdG9yeVBhZ2UgPSBwcm90by5UeEhpc3RvcnlQYWdlLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4czogaGlzdG9yeVBhZ2UudHhzLm1hcChjb252ZXJ0VG9UeCksXG4gICAgICAgICAgICBudW1QYWdlczogaGlzdG9yeVBhZ2UubnVtUGFnZXMsXG4gICAgICAgICAgICBudW1UeHM6IGhpc3RvcnlQYWdlLm51bVR4cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgY3VycmVudCBVVFhPIHNldCBmb3IgdGhpcyB0b2tlbklkLlxuICAgICAqL1xuICAgIGFzeW5jIHV0eG9zKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UuZ2V0KGAvdG9rZW4taWQvJHt0aGlzLl90b2tlbklkfS91dHhvc2ApO1xuICAgICAgICBjb25zdCB1dHhvcyA9IHByb3RvLlV0eG9zLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuSWQ6IHRoaXMuX3Rva2VuSWQsXG4gICAgICAgICAgICB1dHhvczogdXR4b3MudXR4b3MubWFwKGNvbnZlcnRUb1V0eG8pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVG9rZW5JZEVuZHBvaW50ID0gVG9rZW5JZEVuZHBvaW50O1xuLyoqIEFsbG93cyBmZXRjaGluZyBsb2thZElkIGNvbmZpcm1lZFR4cywgdW5jb25maXJtZWRUeHMsIGFuZCBoaXN0b3J5LiAqL1xuY2xhc3MgTG9rYWRJZEVuZHBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm94eUludGVyZmFjZSwgbG9rYWRJZCkge1xuICAgICAgICB0aGlzLl9wcm94eUludGVyZmFjZSA9IHByb3h5SW50ZXJmYWNlO1xuICAgICAgICB0aGlzLl9sb2thZElkID0gbG9rYWRJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgdHggaGlzdG9yeSBvZiB0aGlzIHRva2VuSWQsIGluIGFudGktY2hyb25vbG9naWNhbCBvcmRlci5cbiAgICAgKiBAcGFyYW0gcGFnZSBQYWdlIGluZGV4IG9mIHRoZSB0eCBoaXN0b3J5LlxuICAgICAqIEBwYXJhbSBwYWdlU2l6ZSBOdW1iZXIgb2YgdHhzIHBlciBwYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGhpc3RvcnkocGFnZSA9IDAsIC8vIEdldCB0aGUgZmlyc3QgcGFnZSBpZiB1bnNwZWNpZmllZFxuICAgIHBhZ2VTaXplID0gMjUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL2xva2FkLWlkLyR7dGhpcy5fbG9rYWRJZH0vaGlzdG9yeT9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlQYWdlID0gcHJvdG8uVHhIaXN0b3J5UGFnZS5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eHM6IGhpc3RvcnlQYWdlLnR4cy5tYXAoY29udmVydFRvVHgpLFxuICAgICAgICAgICAgbnVtUGFnZXM6IGhpc3RvcnlQYWdlLm51bVBhZ2VzLFxuICAgICAgICAgICAgbnVtVHhzOiBoaXN0b3J5UGFnZS5udW1UeHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIGNvbmZpcm1lZCB0eCBoaXN0b3J5IG9mIHRoaXMgdG9rZW5JZCwgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyIG9uIHRoZSBibG9ja2NoYWluLlxuICAgICAqIEBwYXJhbSBwYWdlIFBhZ2UgaW5kZXggb2YgdGhlIHR4IGhpc3RvcnkuXG4gICAgICogQHBhcmFtIHBhZ2VTaXplIE51bWJlciBvZiB0eHMgcGVyIHBhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWVkVHhzKHBhZ2UgPSAwLCAvLyBHZXQgdGhlIGZpcnN0IHBhZ2UgaWYgdW5zcGVjaWZpZWRcbiAgICBwYWdlU2l6ZSA9IDI1KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5nZXQoYC9sb2thZC1pZC8ke3RoaXMuX2xva2FkSWR9L2NvbmZpcm1lZC10eHM/cGFnZT0ke3BhZ2V9JnBhZ2Vfc2l6ZT0ke3BhZ2VTaXplfWApO1xuICAgICAgICBjb25zdCBoaXN0b3J5UGFnZSA9IHByb3RvLlR4SGlzdG9yeVBhZ2UuZGVjb2RlKGRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhzOiBoaXN0b3J5UGFnZS50eHMubWFwKGNvbnZlcnRUb1R4KSxcbiAgICAgICAgICAgIG51bVBhZ2VzOiBoaXN0b3J5UGFnZS5udW1QYWdlcyxcbiAgICAgICAgICAgIG51bVR4czogaGlzdG9yeVBhZ2UubnVtVHhzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSB1bmNvbmZpcm1lZCB0eCBoaXN0b3J5IG9mIHRoaXMgdG9rZW5JZCwgaW4gY2hyb25vbG9naWNhbCBvcmRlci5cbiAgICAgKiBAcGFyYW0gcGFnZSBQYWdlIGluZGV4IG9mIHRoZSB0eCBoaXN0b3J5LlxuICAgICAqIEBwYXJhbSBwYWdlU2l6ZSBOdW1iZXIgb2YgdHhzIHBlciBwYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHVuY29uZmlybWVkVHhzKHBhZ2UgPSAwLCAvLyBHZXQgdGhlIGZpcnN0IHBhZ2UgaWYgdW5zcGVjaWZpZWRcbiAgICBwYWdlU2l6ZSA9IDI1KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5nZXQoYC9sb2thZC1pZC8ke3RoaXMuX2xva2FkSWR9L3VuY29uZmlybWVkLXR4cz9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlQYWdlID0gcHJvdG8uVHhIaXN0b3J5UGFnZS5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eHM6IGhpc3RvcnlQYWdlLnR4cy5tYXAoY29udmVydFRvVHgpLFxuICAgICAgICAgICAgbnVtUGFnZXM6IGhpc3RvcnlQYWdlLm51bVBhZ2VzLFxuICAgICAgICAgICAgbnVtVHhzOiBoaXN0b3J5UGFnZS5udW1UeHMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Mb2thZElkRW5kcG9pbnQgPSBMb2thZElkRW5kcG9pbnQ7XG4vKiogQWxsb3dzIGZldGNoaW5nIHBsdWdpbiBVVFhPcy4gKi9cbmNsYXNzIFBsdWdpbkVuZHBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm94eUludGVyZmFjZSwgcGx1Z2luTmFtZSkge1xuICAgICAgICB0aGlzLl9wcm94eUludGVyZmFjZSA9IHByb3h5SW50ZXJmYWNlO1xuICAgICAgICB0aGlzLl9wbHVnaW5OYW1lID0gcGx1Z2luTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgY3VycmVudCBVVFhPIHNldCBmb3IgdGhpcyBwbHVnaW4gZ3JvdXAuXG4gICAgICovXG4gICAgYXN5bmMgdXR4b3MoZ3JvdXBIZXgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3Byb3h5SW50ZXJmYWNlLmdldChgL3BsdWdpbi8ke3RoaXMuX3BsdWdpbk5hbWV9LyR7Z3JvdXBIZXh9L3V0eG9zYCk7XG4gICAgICAgIGNvbnN0IHV0eG9zID0gcHJvdG8uVXR4b3MuZGVjb2RlKGRhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGx1Z2luTmFtZTogdGhpcy5fcGx1Z2luTmFtZSxcbiAgICAgICAgICAgIGdyb3VwSGV4LFxuICAgICAgICAgICAgdXR4b3M6IHV0eG9zLnV0eG9zLm1hcChjb252ZXJ0VG9VdHhvKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBncm91cHMgb2YgdGhpcyBwbHVnaW4uXG4gICAgICovXG4gICAgYXN5bmMgZ3JvdXBzKHByZWZpeEhleCwgc3RhcnRIZXgsIHBhZ2VTaXplKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocHJlZml4SGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5LnNldCgncHJlZml4JywgcHJlZml4SGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRIZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnkuc2V0KCdzdGFydCcsIHN0YXJ0SGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnkuc2V0KCdwYWdlX3NpemUnLCBwYWdlU2l6ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UuZ2V0KGAvcGx1Z2luLyR7dGhpcy5fcGx1Z2luTmFtZX0vZ3JvdXBzPyR7cXVlcnkudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gcHJvdG8uUGx1Z2luR3JvdXBzLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1BsdWdpbkdyb3Vwcyhncm91cHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSB0eCBoaXN0b3J5IG9mIHRoaXMgZ3JvdXBIZXggZm9yIHRoaXMgcGx1Z2luLCBpbiBhbnRpLWNocm9ub2xvZ2ljYWwgb3JkZXIuXG4gICAgICogQHBhcmFtIGdyb3VwSGV4IGdyb3VwIGFzIGEgbG93ZXJjYXNlIGhleCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gcGFnZSBQYWdlIGluZGV4IG9mIHRoZSB0eCBoaXN0b3J5LlxuICAgICAqIEBwYXJhbSBwYWdlU2l6ZSBOdW1iZXIgb2YgdHhzIHBlciBwYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIGhpc3RvcnkoZ3JvdXBIZXgsIHBhZ2UgPSAwLCAvLyBHZXQgdGhlIGZpcnN0IHBhZ2UgaWYgdW5zcGVjaWZpZWRcbiAgICBwYWdlU2l6ZSA9IDI1KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5nZXQoYC9wbHVnaW4vJHt0aGlzLl9wbHVnaW5OYW1lfS8ke2dyb3VwSGV4fS9oaXN0b3J5P3BhZ2U9JHtwYWdlfSZwYWdlX3NpemU9JHtwYWdlU2l6ZX1gKTtcbiAgICAgICAgY29uc3QgaGlzdG9yeVBhZ2UgPSBwcm90by5UeEhpc3RvcnlQYWdlLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4czogaGlzdG9yeVBhZ2UudHhzLm1hcChjb252ZXJ0VG9UeCksXG4gICAgICAgICAgICBudW1QYWdlczogaGlzdG9yeVBhZ2UubnVtUGFnZXMsXG4gICAgICAgICAgICBudW1UeHM6IGhpc3RvcnlQYWdlLm51bVR4cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgY29uZmlybWVkIHR4IGhpc3Rvcnkgb2YgdGhpcyBncm91cEhleCBmb3IgdGhpcyBwbHVnaW4sIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhciBvbiB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKiBAcGFyYW0gZ3JvdXBIZXggZ3JvdXAgYXMgYSBsb3dlcmNhc2UgaGV4IHN0cmluZ1xuICAgICAqIEBwYXJhbSBwYWdlIFBhZ2UgaW5kZXggb2YgdGhlIHR4IGhpc3RvcnkuXG4gICAgICogQHBhcmFtIHBhZ2VTaXplIE51bWJlciBvZiB0eHMgcGVyIHBhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgY29uZmlybWVkVHhzKGdyb3VwSGV4LCBwYWdlID0gMCwgLy8gR2V0IHRoZSBmaXJzdCBwYWdlIGlmIHVuc3BlY2lmaWVkXG4gICAgcGFnZVNpemUgPSAyNSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UuZ2V0KGAvcGx1Z2luLyR7dGhpcy5fcGx1Z2luTmFtZX0vJHtncm91cEhleH0vY29uZmlybWVkLXR4cz9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlQYWdlID0gcHJvdG8uVHhIaXN0b3J5UGFnZS5kZWNvZGUoZGF0YSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eHM6IGhpc3RvcnlQYWdlLnR4cy5tYXAoY29udmVydFRvVHgpLFxuICAgICAgICAgICAgbnVtUGFnZXM6IGhpc3RvcnlQYWdlLm51bVBhZ2VzLFxuICAgICAgICAgICAgbnVtVHhzOiBoaXN0b3J5UGFnZS5udW1UeHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHVuY29uZmlybWVkIHR4IGhpc3Rvcnkgb2YgdGhpcyBncm91cEhleCBmb3IgdGhpcyBwbHVnaW4sIGluIGNocm9ub2xvZ2ljYWwgb3JkZXIuXG4gICAgICogQHBhcmFtIGdyb3VwSGV4IGdyb3VwIGFzIGEgbG93ZXJjYXNlIGhleCBzdHJpbmdcbiAgICAgKiBAcGFyYW0gcGFnZSBQYWdlIGluZGV4IG9mIHRoZSB0eCBoaXN0b3J5LlxuICAgICAqIEBwYXJhbSBwYWdlU2l6ZSBOdW1iZXIgb2YgdHhzIHBlciBwYWdlLlxuICAgICAqL1xuICAgIGFzeW5jIHVuY29uZmlybWVkVHhzKGdyb3VwSGV4LCBwYWdlID0gMCwgLy8gR2V0IHRoZSBmaXJzdCBwYWdlIGlmIHVuc3BlY2lmaWVkXG4gICAgcGFnZVNpemUgPSAyNSkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fcHJveHlJbnRlcmZhY2UuZ2V0KGAvcGx1Z2luLyR7dGhpcy5fcGx1Z2luTmFtZX0vJHtncm91cEhleH0vdW5jb25maXJtZWQtdHhzP3BhZ2U9JHtwYWdlfSZwYWdlX3NpemU9JHtwYWdlU2l6ZX1gKTtcbiAgICAgICAgY29uc3QgaGlzdG9yeVBhZ2UgPSBwcm90by5UeEhpc3RvcnlQYWdlLmRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4czogaGlzdG9yeVBhZ2UudHhzLm1hcChjb252ZXJ0VG9UeCksXG4gICAgICAgICAgICBudW1QYWdlczogaGlzdG9yeVBhZ2UubnVtUGFnZXMsXG4gICAgICAgICAgICBudW1UeHM6IGhpc3RvcnlQYWdlLm51bVR4cyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlBsdWdpbkVuZHBvaW50ID0gUGx1Z2luRW5kcG9pbnQ7XG4vKiogV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gQ2hyb25pay4gKi9cbmNsYXNzIFdzRW5kcG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3h5SW50ZXJmYWNlLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UgPSBjb25maWcub25NZXNzYWdlO1xuICAgICAgICB0aGlzLm9uQ29ubmVjdCA9IGNvbmZpZy5vbkNvbm5lY3Q7XG4gICAgICAgIHRoaXMub25SZWNvbm5lY3QgPSBjb25maWcub25SZWNvbm5lY3Q7XG4gICAgICAgIHRoaXMub25FbmQgPSBjb25maWcub25FbmQ7XG4gICAgICAgIHRoaXMuYXV0b1JlY29ubmVjdCA9XG4gICAgICAgICAgICBjb25maWcuYXV0b1JlY29ubmVjdCAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmF1dG9SZWNvbm5lY3QgOiB0cnVlO1xuICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3VicyA9IHtcbiAgICAgICAgICAgIHNjcmlwdHM6IFtdLFxuICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHR4aWRzOiBbXSxcbiAgICAgICAgICAgIGxva2FkSWRzOiBbXSxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtdLFxuICAgICAgICAgICAgYmxvY2tzOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcHJveHlJbnRlcmZhY2UgPSBwcm94eUludGVyZmFjZTtcbiAgICB9XG4gICAgLyoqIFdhaXQgZm9yIHRoZSBXZWJTb2NrZXQgdG8gYmUgY29ubmVjdGVkLiAqL1xuICAgIGFzeW5jIHdhaXRGb3JPcGVuKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9wcm94eUludGVyZmFjZS5jb25uZWN0V3ModGhpcyk7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYmxvY2sgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBzdWJzY3JpYmVUb0Jsb2NrcygpIHtcbiAgICAgICAgdGhpcy5zdWJzLmJsb2NrcyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlID09PSBpc29tb3JwaGljX3dzXzEuZGVmYXVsdC5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJVbnN1YkJsb2NrcyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBibG9jayBtZXNzYWdlc1xuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlRnJvbUJsb2NrcygpIHtcbiAgICAgICAgdGhpcy5zdWJzLmJsb2NrcyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gaXNvbW9ycGhpY193c18xLmRlZmF1bHQuT1BFTikge1xuICAgICAgICAgICAgdGhpcy5fc3ViVW5zdWJCbG9ja3ModHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBnaXZlbiBzY3JpcHQgdHlwZSBhbmQgcGF5bG9hZC5cbiAgICAgKiBGb3IgXCJwMnBraFwiLCBgc2NyaXB0UGF5bG9hZGAgaXMgdGhlIDIwIGJ5dGUgcHVibGljIGtleSBoYXNoLlxuICAgICAqL1xuICAgIHN1YnNjcmliZVRvU2NyaXB0KHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgLy8gQnVpbGQgc3ViIGFjY29yZGluZyB0byBjaHJvbmlrIGV4cGVjdGVkIHR5cGVcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgc2NyaXB0VHlwZTogdHlwZSxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIGFkZCBpbnZhbGlkIHN1YnMgdG8gd3Muc3Vic1xuICAgICAgICBjb25zdCBzY3JpcHRTdWJzY3JpcHRpb25WYWxpZGF0aW9uQ2hlY2sgPSAoMCwgdmFsaWRhdGlvbl8xLmlzVmFsaWRXc1N1YnNjcmlwdGlvbikoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHNjcmlwdFN1YnNjcmlwdGlvblZhbGlkYXRpb25DaGVjayAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gaXNWYWxpZFdzU3Vic2NyaXB0aW9uIHJldHVybnMgc3RyaW5nIGVycm9yIG1zZyBpZiB0aGUgc3ViIGlzIGludmFsaWRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzY3JpcHRTdWJzY3JpcHRpb25WYWxpZGF0aW9uQ2hlY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vicy5zY3JpcHRzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IGlzb21vcnBoaWNfd3NfMS5kZWZhdWx0Lk9QRU4pIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YlVuc3ViU2NyaXB0KGZhbHNlLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBnaXZlbiBzY3JpcHQgdHlwZSBhbmQgcGF5bG9hZC4gKi9cbiAgICB1bnN1YnNjcmliZUZyb21TY3JpcHQodHlwZSwgcGF5bG9hZCkge1xuICAgICAgICAvLyBCdWlsZCBzdWIgYWNjb3JkaW5nIHRvIGNocm9uaWsgZXhwZWN0ZWQgdHlwZVxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBzY3JpcHRUeXBlOiB0eXBlLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRmluZCB0aGUgcmVxdWVzdGVkIHVuc3ViIHNjcmlwdCBhbmQgcmVtb3ZlIGl0XG4gICAgICAgIGNvbnN0IHVuc3ViSW5kZXggPSB0aGlzLnN1YnMuc2NyaXB0cy5maW5kSW5kZXgoc3ViID0+IHN1Yi5zY3JpcHRUeXBlID09PSB0eXBlICYmIHN1Yi5wYXlsb2FkID09PSBwYXlsb2FkKTtcbiAgICAgICAgaWYgKHVuc3ViSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW5ub3QgZmluZCB0aGlzIHN1YnNjcmlwdGlvbiBpbiB0aGlzLnN1YnMsIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCBhbiBhcHAgZGV2ZWxvcGVyIHRoaW5raW5nIHRoZXkgaGF2ZSB1bnN1YnNjcmliZWQgZnJvbSBzb21ldGhpbmdcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZXhpc3Rpbmcgc3ViIGF0ICR7dHlwZX0sICR7cGF5bG9hZH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlcXVlc3RlZCBzdWJzY3JpcHRpb24gZnJvbSB0aGlzLnN1YnNcbiAgICAgICAgdGhpcy5zdWJzLnNjcmlwdHMuc3BsaWNlKHVuc3ViSW5kZXgsIDEpO1xuICAgICAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gaXNvbW9ycGhpY193c18xLmRlZmF1bHQuT1BFTikge1xuICAgICAgICAgICAgdGhpcy5fc3ViVW5zdWJTY3JpcHQodHJ1ZSwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYW4gYWRkcmVzc1xuICAgICAqIE1ldGhvZCBjYW4gYmUgdXNlZCBmb3IgcDJwa2ggb3IgcDJzaCBhZGRyZXNzZXNcbiAgICAgKi9cbiAgICBzdWJzY3JpYmVUb0FkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICAvLyBHZXQgdHlwZSBhbmQgaGFzaFxuICAgICAgICBjb25zdCB7IHR5cGUsIGhhc2ggfSA9ICgwLCBlY2FzaGFkZHJqc18xLmRlY29kZUNhc2hBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHNjcmlwdFxuICAgICAgICB0aGlzLnN1YnNjcmliZVRvU2NyaXB0KHR5cGUsIGhhc2gpO1xuICAgIH1cbiAgICAvKiogVW5zdWJzY3JpYmUgZnJvbSB0aGUgZ2l2ZW4gYWRkcmVzcyAqL1xuICAgIHVuc3Vic2NyaWJlRnJvbUFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICAvLyBHZXQgdHlwZSBhbmQgaGFzaFxuICAgICAgICBjb25zdCB7IHR5cGUsIGhhc2ggfSA9ICgwLCBlY2FzaGFkZHJqc18xLmRlY29kZUNhc2hBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgLy8gVW5zdWJzY3JpYmUgZnJvbSBzY3JpcHRcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUZyb21TY3JpcHQodHlwZSwgaGFzaCk7XG4gICAgfVxuICAgIC8qKiBTdWJzY3JpYmUgdG8gYSBsb2thZElkICovXG4gICAgc3Vic2NyaWJlVG9Mb2thZElkKGxva2FkSWQpIHtcbiAgICAgICAgKDAsIHZhbGlkYXRpb25fMS52ZXJpZnlMb2thZElkKShsb2thZElkKTtcbiAgICAgICAgLy8gVXBkYXRlIHdzLnN1YnMgdG8gaW5jbHVkZSB0aGlzIGxva2FkSWRcbiAgICAgICAgdGhpcy5zdWJzLmxva2FkSWRzLnB1c2gobG9rYWRJZCk7XG4gICAgICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlID09PSBpc29tb3JwaGljX3dzXzEuZGVmYXVsdC5PUEVOKSB7XG4gICAgICAgICAgICAvLyBTZW5kIHN1YnNjcmliZSBtc2cgdG8gY2hyb25payBzZXJ2ZXJcbiAgICAgICAgICAgIHRoaXMuX3N1YlVuc3ViTG9rYWRJZChmYWxzZSwgbG9rYWRJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGdpdmVuIGxva2FkSWQgKi9cbiAgICB1bnN1YnNjcmliZUZyb21Mb2thZElkKGxva2FkSWQpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgcmVxdWVzdGVkIHVuc3ViIGxva2FkSWQgYW5kIHJlbW92ZSBpdFxuICAgICAgICBjb25zdCB1bnN1YkluZGV4ID0gdGhpcy5zdWJzLmxva2FkSWRzLmZpbmRJbmRleCh0aGlzTG9rYWRJZCA9PiB0aGlzTG9rYWRJZCA9PT0gbG9rYWRJZCk7XG4gICAgICAgIGlmICh1bnN1YkluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgY2Fubm90IGZpbmQgdGhpcyBzdWJzY3JpcHRpb24gaW4gdGhpcy5zdWJzLmxva2FkSWRzLCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgYW4gYXBwIGRldmVsb3BlciB0aGlua2luZyB0aGV5IGhhdmUgdW5zdWJzY3JpYmVkIGZyb20gc29tZXRoaW5nIGlmIG5vIGFjdGlvbiBoYXBwZW5lZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBleGlzdGluZyBzdWIgYXQgbG9rYWRJZCBcIiR7bG9rYWRJZH1cImApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcmVxdWVzdGVkIGxva2FkSWQgc3Vic2NyaXB0aW9uIGZyb20gdGhpcy5zdWJzLmxva2FkSWRzXG4gICAgICAgIHRoaXMuc3Vicy5sb2thZElkcy5zcGxpY2UodW5zdWJJbmRleCwgMSk7XG4gICAgICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlID09PSBpc29tb3JwaGljX3dzXzEuZGVmYXVsdC5PUEVOKSB7XG4gICAgICAgICAgICAvLyBTZW5kIHVuc3Vic2NyaWJlIG1zZyB0byBjaHJvbmlrIHNlcnZlclxuICAgICAgICAgICAgdGhpcy5fc3ViVW5zdWJMb2thZElkKHRydWUsIGxva2FkSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTdWJzY3JpYmUgdG8gYSB0b2tlbklkICovXG4gICAgc3Vic2NyaWJlVG9Ub2tlbklkKHRva2VuSWQpIHtcbiAgICAgICAgKDAsIHZhbGlkYXRpb25fMS52ZXJpZnlUb2tlbklkKSh0b2tlbklkKTtcbiAgICAgICAgLy8gVXBkYXRlIHdzLnN1YnMgdG8gaW5jbHVkZSB0aGlzIHRva2VuSWRcbiAgICAgICAgdGhpcy5zdWJzLnRva2Vucy5wdXNoKHRva2VuSWQpO1xuICAgICAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gaXNvbW9ycGhpY193c18xLmRlZmF1bHQuT1BFTikge1xuICAgICAgICAgICAgLy8gU2VuZCBzdWJzY3JpYmUgbXNnIHRvIGNocm9uaWsgc2VydmVyXG4gICAgICAgICAgICB0aGlzLl9zdWJVbnN1YlRva2VuKGZhbHNlLCB0b2tlbklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogVW5zdWJzY3JpYmUgZnJvbSB0aGUgZ2l2ZW4gdG9rZW5JZCAqL1xuICAgIHVuc3Vic2NyaWJlRnJvbVRva2VuSWQodG9rZW5JZCkge1xuICAgICAgICAvLyBGaW5kIHRoZSByZXF1ZXN0ZWQgdW5zdWIgdG9rZW5JZCBhbmQgcmVtb3ZlIGl0XG4gICAgICAgIGNvbnN0IHVuc3ViSW5kZXggPSB0aGlzLnN1YnMudG9rZW5zLmZpbmRJbmRleCh0aGlzVG9rZW5JZCA9PiB0aGlzVG9rZW5JZCA9PT0gdG9rZW5JZCk7XG4gICAgICAgIGlmICh1bnN1YkluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgY2Fubm90IGZpbmQgdGhpcyBzdWJzY3JpcHRpb24gaW4gdGhpcy5zdWJzLnRva2VucywgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IGFuIGFwcCBkZXZlbG9wZXIgdGhpbmtpbmcgdGhleSBoYXZlIHVuc3Vic2NyaWJlZCBmcm9tIHNvbWV0aGluZyBpZiBubyBhY3Rpb24gaGFwcGVuZWRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZXhpc3Rpbmcgc3ViIGF0IHRva2VuSWQgXCIke3Rva2VuSWR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlcXVlc3RlZCB0b2tlbklkIHN1YnNjcmlwdGlvbiBmcm9tIHRoaXMuc3Vicy50b2tlbnNcbiAgICAgICAgdGhpcy5zdWJzLnRva2Vucy5zcGxpY2UodW5zdWJJbmRleCwgMSk7XG4gICAgICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlID09PSBpc29tb3JwaGljX3dzXzEuZGVmYXVsdC5PUEVOKSB7XG4gICAgICAgICAgICAvLyBTZW5kIHVuc3Vic2NyaWJlIG1zZyB0byBjaHJvbmlrIHNlcnZlclxuICAgICAgICAgICAgdGhpcy5fc3ViVW5zdWJUb2tlbih0cnVlLCB0b2tlbklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogU3Vic2NyaWJlIHRvIGEgcGx1Z2luICovXG4gICAgc3Vic2NyaWJlVG9QbHVnaW4ocGx1Z2luTmFtZSwgZ3JvdXApIHtcbiAgICAgICAgLy8gQnVpbGQgc3ViIGFjY29yZGluZyB0byBjaHJvbmlrIGV4cGVjdGVkIHR5cGVcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgcGx1Z2luTmFtZSxcbiAgICAgICAgICAgIGdyb3VwLFxuICAgICAgICB9O1xuICAgICAgICAoMCwgdmFsaWRhdGlvbl8xLnZlcmlmeVBsdWdpblN1YnNjcmlwdGlvbikoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgLy8gVXBkYXRlIHdzLnN1YnMgdG8gaW5jbHVkZSB0aGlzIHBsdWdpblxuICAgICAgICB0aGlzLnN1YnMucGx1Z2lucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlID09PSBpc29tb3JwaGljX3dzXzEuZGVmYXVsdC5PUEVOKSB7XG4gICAgICAgICAgICAvLyBTZW5kIHN1YnNjcmliZSBtc2cgdG8gY2hyb25payBzZXJ2ZXJcbiAgICAgICAgICAgIHRoaXMuX3N1YlVuc3ViUGx1Z2luKGZhbHNlLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBnaXZlbiBwbHVnaW4gKi9cbiAgICB1bnN1YnNjcmliZUZyb21QbHVnaW4ocGx1Z2luTmFtZSwgZ3JvdXApIHtcbiAgICAgICAgLy8gRmluZCB0aGUgcmVxdWVzdGVkIHVuc3ViIHNjcmlwdCBhbmQgcmVtb3ZlIGl0XG4gICAgICAgIGNvbnN0IHVuc3ViSW5kZXggPSB0aGlzLnN1YnMucGx1Z2lucy5maW5kSW5kZXgoc3ViID0+IHN1Yi5wbHVnaW5OYW1lID09PSBwbHVnaW5OYW1lICYmIHN1Yi5ncm91cCA9PT0gZ3JvdXApO1xuICAgICAgICBpZiAodW5zdWJJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbm5vdCBmaW5kIHRoaXMgc3Vic2NyaXB0aW9uIGluIHRoaXMuc3Vicy5wbHVnaW5zLCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgYW4gYXBwIGRldmVsb3BlciB0aGlua2luZyB0aGV5IGhhdmUgdW5zdWJzY3JpYmVkIGZyb20gc29tZXRoaW5nXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGV4aXN0aW5nIHN1YiBhdCBwbHVnaW5OYW1lPVwiJHtwbHVnaW5OYW1lfVwiLCBncm91cD1cIiR7Z3JvdXB9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlcXVlc3RlZCBzdWJzY3JpcHRpb24gZnJvbSB0aGlzLnN1YnMucGx1Z2luc1xuICAgICAgICB0aGlzLnN1YnMucGx1Z2lucy5zcGxpY2UodW5zdWJJbmRleCwgMSk7XG4gICAgICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlID09PSBpc29tb3JwaGljX3dzXzEuZGVmYXVsdC5PUEVOKSB7XG4gICAgICAgICAgICAvLyBTZW5kIHVuc3Vic2NyaWJlIG1zZyB0byBjaHJvbmlrIHNlcnZlclxuICAgICAgICAgICAgdGhpcy5fc3ViVW5zdWJQbHVnaW4odHJ1ZSwge1xuICAgICAgICAgICAgICAgIHBsdWdpbk5hbWUsXG4gICAgICAgICAgICAgICAgZ3JvdXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogU3Vic2NyaWJlIHRvIGEgdHhpZCAqL1xuICAgIHN1YnNjcmliZVRvVHhpZCh0eGlkKSB7XG4gICAgICAgICgwLCB2YWxpZGF0aW9uXzEudmVyaWZ5VHhpZCkodHhpZCk7XG4gICAgICAgIC8vIFVwZGF0ZSB3cy5zdWJzIHRvIGluY2x1ZGUgdGhpcyB0eGlkXG4gICAgICAgIHRoaXMuc3Vicy50eGlkcy5wdXNoKHR4aWQpO1xuICAgICAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gaXNvbW9ycGhpY193c18xLmRlZmF1bHQuT1BFTikge1xuICAgICAgICAgICAgLy8gU2VuZCBzdWJzY3JpYmUgbXNnIHRvIGNocm9uaWsgc2VydmVyXG4gICAgICAgICAgICB0aGlzLl9zdWJVbnN1YlR4aWQoZmFsc2UsIHR4aWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBVbnN1YnNjcmliZSBmcm9tIHRoZSBnaXZlbiB0eGlkICovXG4gICAgdW5zdWJzY3JpYmVGcm9tVHhpZCh0eGlkKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHJlcXVlc3RlZCB1bnN1YiB0eGlkIGFuZCByZW1vdmUgaXRcbiAgICAgICAgY29uc3QgdW5zdWJJbmRleCA9IHRoaXMuc3Vicy50eGlkcy5maW5kSW5kZXgodGhpc1R4aWQgPT4gdGhpc1R4aWQgPT09IHR4aWQpO1xuICAgICAgICBpZiAodW5zdWJJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbm5vdCBmaW5kIHRoaXMgc3Vic2NyaXB0aW9uIGluIHRoaXMuc3Vicy50eGlkcywgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IGFuIGFwcCBkZXZlbG9wZXIgdGhpbmtpbmcgdGhleSBoYXZlIHVuc3Vic2NyaWJlZCBmcm9tIHNvbWV0aGluZyBpZiBubyBhY3Rpb24gaGFwcGVuZWRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZXhpc3Rpbmcgc3ViIHRvIHR4aWQgXCIke3R4aWR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHJlcXVlc3RlZCB0eGlkIHN1YnNjcmlwdGlvbiBmcm9tIHRoaXMuc3Vicy50eGlkc1xuICAgICAgICB0aGlzLnN1YnMudHhpZHMuc3BsaWNlKHVuc3ViSW5kZXgsIDEpO1xuICAgICAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gaXNvbW9ycGhpY193c18xLmRlZmF1bHQuT1BFTikge1xuICAgICAgICAgICAgLy8gU2VuZCB1bnN1YnNjcmliZSBtc2cgdG8gY2hyb25payBzZXJ2ZXJcbiAgICAgICAgICAgIHRoaXMuX3N1YlVuc3ViVHhpZCh0cnVlLCB0eGlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYW5kIHByZXZlbnQgYW55IGZ1dHVyZSByZWNvbm5lY3Rpb25cbiAgICAgKiBhdHRlbXB0cy5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5tYW51YWxseUNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMud3M/LmNsb3NlKCk7XG4gICAgfVxuICAgIF9zdWJVbnN1YkJsb2Nrcyhpc1Vuc3ViKSB7XG4gICAgICAgIC8vIEJsb2NrcyBzdWJzY3JpcHRpb24gaXMgZW1wdHkgb2JqZWN0XG4gICAgICAgIGNvbnN0IEJMT0NLU19TVUJTQ1JJUFRJT04gPSB7fTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFN1YnNjcmlwdGlvbiA9IHByb3RvLldzU3ViLmVuY29kZSh7XG4gICAgICAgICAgICBpc1Vuc3ViLFxuICAgICAgICAgICAgYmxvY2tzOiBCTE9DS1NfU1VCU0NSSVBUSU9OLFxuICAgICAgICB9KS5maW5pc2goKTtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlOyBfd3MgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5zZW5kKGVuY29kZWRTdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICBfc3ViVW5zdWJTY3JpcHQoaXNVbnN1Yiwgc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIGlzIHRvIGFuIGFkZHJlc3MsIGxlYXZlIHRoZSAnYmxvY2tzJyBrZXkgdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGVuY29kZWRTdWJzY3JpcHRpb24gPSBwcm90by5Xc1N1Yi5lbmNvZGUoe1xuICAgICAgICAgICAgaXNVbnN1YixcbiAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgIHNjcmlwdFR5cGU6IHN1YnNjcmlwdGlvbi5zY3JpcHRUeXBlLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6ICgwLCBoZXhfMS5mcm9tSGV4KShzdWJzY3JpcHRpb24ucGF5bG9hZCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KS5maW5pc2goKTtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlOyBfd3MgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5zZW5kKGVuY29kZWRTdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICBfc3ViVW5zdWJMb2thZElkKGlzVW5zdWIsIGxva2FkSWQpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFN1YnNjcmlwdGlvbiA9IHByb3RvLldzU3ViLmVuY29kZSh7XG4gICAgICAgICAgICBpc1Vuc3ViLFxuICAgICAgICAgICAgbG9rYWRJZDoge1xuICAgICAgICAgICAgICAgIC8vIFVzZXIgaW5wdXQgZm9yIGxva2FkSWQgaXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gQ2hyb25payBleHBlY3RzIGJ5dGVzXG4gICAgICAgICAgICAgICAgbG9rYWRJZDogKDAsIGhleF8xLmZyb21IZXgpKGxva2FkSWQpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkuZmluaXNoKCk7XG4gICAgICAgIGlmICh0aGlzLndzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTsgX3dzIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3Muc2VuZChlbmNvZGVkU3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgX3N1YlVuc3ViVG9rZW4oaXNVbnN1YiwgdG9rZW5JZCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkU3Vic2NyaXB0aW9uID0gcHJvdG8uV3NTdWIuZW5jb2RlKHtcbiAgICAgICAgICAgIGlzVW5zdWIsXG4gICAgICAgICAgICB0b2tlbklkOiB7XG4gICAgICAgICAgICAgICAgdG9rZW5JZDogdG9rZW5JZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLmZpbmlzaCgpO1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU7IF93cyBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLnNlbmQoZW5jb2RlZFN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIF9zdWJVbnN1YlR4aWQoaXNVbnN1YiwgdHhpZCkge1xuICAgICAgICBjb25zdCBlbmNvZGVkU3Vic2NyaXB0aW9uID0gcHJvdG8uV3NTdWIuZW5jb2RlKHtcbiAgICAgICAgICAgIGlzVW5zdWIsXG4gICAgICAgICAgICB0eGlkOiB7XG4gICAgICAgICAgICAgICAgdHhpZDogdHhpZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLmZpbmlzaCgpO1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU7IF93cyBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLnNlbmQoZW5jb2RlZFN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIF9zdWJVbnN1YlBsdWdpbihpc1Vuc3ViLCBwbHVnaW4pIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFN1YnNjcmlwdGlvbiA9IHByb3RvLldzU3ViLmVuY29kZSh7XG4gICAgICAgICAgICBpc1Vuc3ViLFxuICAgICAgICAgICAgcGx1Z2luOiB7XG4gICAgICAgICAgICAgICAgcGx1Z2luTmFtZTogcGx1Z2luLnBsdWdpbk5hbWUsXG4gICAgICAgICAgICAgICAgLy8gVXNlciBpbnB1dCBmb3IgcGx1Z2luIGdyb3VwIGlzIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIENocm9uaWsgZXhwZWN0cyBieXRlc1xuICAgICAgICAgICAgICAgIGdyb3VwOiAoMCwgaGV4XzEuZnJvbUhleCkocGx1Z2luLmdyb3VwKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLmZpbmlzaCgpO1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU7IF93cyBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLnNlbmQoZW5jb2RlZFN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZU1zZyh3c01zZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub25NZXNzYWdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyAvLyBOb2RlSlNcbiAgICAgICAgICAgICAgICB3c01zZy5kYXRhXG4gICAgICAgICAgICA6IC8vIEJyb3dzZXJcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShhd2FpdCB3c01zZy5kYXRhLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICBjb25zdCBtc2cgPSBwcm90by5Xc01zZy5kZWNvZGUoZGF0YSk7XG4gICAgICAgIGlmICh0eXBlb2YgbXNnLmVycm9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoeyB0eXBlOiAnRXJyb3InLCAuLi5tc2cuZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1zZy5ibG9jayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZ0Jsb2NrID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdCbG9jaycsXG4gICAgICAgICAgICAgICAgbXNnVHlwZTogY29udmVydFRvQmxvY2tNc2dUeXBlKG1zZy5ibG9jay5tc2dUeXBlKSxcbiAgICAgICAgICAgICAgICBibG9ja0hhc2g6ICgwLCBoZXhfMS50b0hleFJldikobXNnLmJsb2NrLmJsb2NrSGFzaCksXG4gICAgICAgICAgICAgICAgYmxvY2tIZWlnaHQ6IG1zZy5ibG9jay5ibG9ja0hlaWdodCxcbiAgICAgICAgICAgICAgICBibG9ja1RpbWVzdGFtcDogTnVtYmVyKG1zZy5ibG9jay5ibG9ja1RpbWVzdGFtcCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtc2cuYmxvY2suY29pbmJhc2VEYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG1zZ0Jsb2NrLmNvaW5iYXNlRGF0YSA9IGNvbnZlcnRUb0NvaW5iYXNlRGF0YShtc2cuYmxvY2suY29pbmJhc2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKG1zZ0Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbXNnLnR4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgdHhNc2cgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1R4JyxcbiAgICAgICAgICAgICAgICBtc2dUeXBlOiBjb252ZXJ0VG9UeE1zZ1R5cGUobXNnLnR4Lm1zZ1R5cGUpLFxuICAgICAgICAgICAgICAgIHR4aWQ6ICgwLCBoZXhfMS50b0hleFJldikobXNnLnR4LnR4aWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbXNnLnR4LmZpbmFsaXphdGlvblJlYXNvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0eE1zZy5maW5hbGl6YXRpb25SZWFzb25UeXBlID1cbiAgICAgICAgICAgICAgICAgICAgY29udmVydFRvVHhGaW5hbGl6YXRpb25SZWFzb25UeXBlKG1zZy50eC5maW5hbGl6YXRpb25SZWFzb24uZmluYWxpemF0aW9uVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZSh0eE1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2lsZW50bHkgaWdub3JlZCB1bmtub3duIENocm9uaWsgbWVzc2FnZTonLCBtc2cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Xc0VuZHBvaW50ID0gV3NFbmRwb2ludDtcbmZ1bmN0aW9uIGNvbnZlcnRUb0Jsb2NrY2hhaW5JbmZvKGJsb2NrY2hhaW5JbmZvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGlwSGFzaDogKDAsIGhleF8xLnRvSGV4UmV2KShibG9ja2NoYWluSW5mby50aXBIYXNoKSxcbiAgICAgICAgdGlwSGVpZ2h0OiBibG9ja2NoYWluSW5mby50aXBIZWlnaHQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0Nocm9uaWtJbmZvKGNocm9uaWtJbmZvKSB7XG4gICAgaWYgKGNocm9uaWtJbmZvLnZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nocm9uaWtJbmZvIGhhcyBubyB2ZXJzaW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IGNocm9uaWtJbmZvLnZlcnNpb24ubGVuZ3RoICE9PSAwID8gY2hyb25pa0luZm8udmVyc2lvbiA6ICcnLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9CbG9jayhibG9jaykge1xuICAgIGlmIChibG9jay5ibG9ja0luZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jsb2NrIGhhcyBubyBibG9ja0luZm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmxvY2tJbmZvOiBjb252ZXJ0VG9CbG9ja0luZm8oYmxvY2suYmxvY2tJbmZvKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvVHhIaXN0b3J5UGFnZShibG9ja1R4cykge1xuICAgIGNvbnN0IHsgdHhzLCBudW1QYWdlcywgbnVtVHhzIH0gPSBibG9ja1R4cztcbiAgICBjb25zdCBjb252ZXJ0ZWRUeHMgPSB0eHMubWFwKGNvbnZlcnRUb1R4KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eHM6IGNvbnZlcnRlZFR4cyxcbiAgICAgICAgbnVtUGFnZXMsXG4gICAgICAgIG51bVR4cyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvQmxvY2tJbmZvKGJsb2NrKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYmxvY2ssXG4gICAgICAgIGhhc2g6ICgwLCBoZXhfMS50b0hleFJldikoYmxvY2suaGFzaCksXG4gICAgICAgIHByZXZIYXNoOiAoMCwgaGV4XzEudG9IZXhSZXYpKGJsb2NrLnByZXZIYXNoKSxcbiAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIoYmxvY2sudGltZXN0YW1wKSxcbiAgICAgICAgYmxvY2tTaXplOiBOdW1iZXIoYmxvY2suYmxvY2tTaXplKSxcbiAgICAgICAgbnVtVHhzOiBOdW1iZXIoYmxvY2subnVtVHhzKSxcbiAgICAgICAgbnVtSW5wdXRzOiBOdW1iZXIoYmxvY2subnVtSW5wdXRzKSxcbiAgICAgICAgbnVtT3V0cHV0czogTnVtYmVyKGJsb2NrLm51bU91dHB1dHMpLFxuICAgICAgICBzdW1JbnB1dFNhdHM6IGJsb2NrLnN1bUlucHV0U2F0cyxcbiAgICAgICAgc3VtQ29pbmJhc2VPdXRwdXRTYXRzOiBibG9jay5zdW1Db2luYmFzZU91dHB1dFNhdHMsXG4gICAgICAgIHN1bU5vcm1hbE91dHB1dFNhdHM6IGJsb2NrLnN1bU5vcm1hbE91dHB1dFNhdHMsXG4gICAgICAgIHN1bUJ1cm5lZFNhdHM6IGJsb2NrLnN1bUJ1cm5lZFNhdHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1R4KHR4KSB7XG4gICAgY29uc3QgY29udmVydGVkVHggPSB7XG4gICAgICAgIHR4aWQ6ICgwLCBoZXhfMS50b0hleFJldikodHgudHhpZCksXG4gICAgICAgIHZlcnNpb246IHR4LnZlcnNpb24sXG4gICAgICAgIGlucHV0czogdHguaW5wdXRzLm1hcChjb252ZXJ0VG9UeElucHV0KSxcbiAgICAgICAgb3V0cHV0czogdHgub3V0cHV0cy5tYXAoY29udmVydFRvVHhPdXRwdXQpLFxuICAgICAgICBsb2NrVGltZTogdHgubG9ja1RpbWUsXG4gICAgICAgIHRpbWVGaXJzdFNlZW46IE51bWJlcih0eC50aW1lRmlyc3RTZWVuKSxcbiAgICAgICAgc2l6ZTogdHguc2l6ZSxcbiAgICAgICAgaXNDb2luYmFzZTogdHguaXNDb2luYmFzZSxcbiAgICAgICAgdG9rZW5FbnRyaWVzOiB0eC50b2tlbkVudHJpZXMubWFwKGNvbnZlcnRUb1Rva2VuRW50cnkpLFxuICAgICAgICB0b2tlbkZhaWxlZFBhcnNpbmdzOiB0eC50b2tlbkZhaWxlZFBhcnNpbmdzLm1hcChjb252ZXJ0VG9Ub2tlbkZhaWxlZFBhcnNpbmcpLFxuICAgICAgICB0b2tlblN0YXR1czogY29udmVydFRvVG9rZW5TdGF0dXModHgudG9rZW5TdGF0dXMpLFxuICAgICAgICBpc0ZpbmFsOiB0eC5pc0ZpbmFsLFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiB0eC5ibG9jayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIGJsb2NrIGlmIHRoZSB0eCBpcyBpbiBhIGJsb2NrXG4gICAgICAgIGNvbnZlcnRlZFR4LmJsb2NrID0gY29udmVydFRvQmxvY2tNZXRhKHR4LmJsb2NrKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZFR4O1xufVxuZnVuY3Rpb24gY29udmVydFRvVHhJbnB1dChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5wcmV2T3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvLCBubyBwcmV2T3V0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHR4SW5wdXQgPSB7XG4gICAgICAgIHByZXZPdXQ6IHtcbiAgICAgICAgICAgIHR4aWQ6ICgwLCBoZXhfMS50b0hleFJldikoaW5wdXQucHJldk91dC50eGlkKSxcbiAgICAgICAgICAgIG91dElkeDogaW5wdXQucHJldk91dC5vdXRJZHgsXG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0U2NyaXB0OiAoMCwgaGV4XzEudG9IZXgpKGlucHV0LmlucHV0U2NyaXB0KSxcbiAgICAgICAgc2F0czogaW5wdXQuc2F0cyxcbiAgICAgICAgc2VxdWVuY2VObzogaW5wdXQuc2VxdWVuY2VObyxcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgaW5wdXQudG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgcmV0dXJuIGEgdG9rZW4ga2V5IGlmIHdlIGhhdmUgdG9rZW4gZGF0YSBmb3IgdGhpcyBpbnB1dFxuICAgICAgICB0eElucHV0LnRva2VuID0gY29udmVydFRvVG9rZW4oaW5wdXQudG9rZW4pO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoaW5wdXQucGx1Z2lucykubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBXZSBvbmx5IHJldHVybiBhIHBsdWdpbnMga2V5IGlmIHdlIGhhdmUgcGx1Z2luc1xuICAgICAgICB0eElucHV0LnBsdWdpbnMgPSBjb252ZXJ0VG9QbHVnaW5FbnRyaWVzKGlucHV0LnBsdWdpbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0Lm91dHB1dFNjcmlwdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgaW5wdXQub3V0cHV0U2NyaXB0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ29pbmJhc2UgdHggaW5wdXRzIGRvIG5vdCBoYXZlIGFuIG91dHB1dFNjcmlwdFxuICAgICAgICB0eElucHV0Lm91dHB1dFNjcmlwdCA9ICgwLCBoZXhfMS50b0hleCkoaW5wdXQub3V0cHV0U2NyaXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHR4SW5wdXQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UeE91dHB1dChvdXRwdXQpIHtcbiAgICBjb25zdCB0eE91dHB1dCA9IHtcbiAgICAgICAgc2F0czogQmlnSW50KG91dHB1dC5zYXRzKSxcbiAgICAgICAgb3V0cHV0U2NyaXB0OiAoMCwgaGV4XzEudG9IZXgpKG91dHB1dC5vdXRwdXRTY3JpcHQpLFxuICAgIH07XG4gICAgaWYgKE9iamVjdC5rZXlzKG91dHB1dC5wbHVnaW5zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgcmV0dXJuIGEgcGx1Z2lucyBrZXkgaWYgd2UgaGF2ZSBwbHVnaW5zXG4gICAgICAgIHR4T3V0cHV0LnBsdWdpbnMgPSBjb252ZXJ0VG9QbHVnaW5FbnRyaWVzKG91dHB1dC5wbHVnaW5zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRwdXQudG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgcmV0dXJuIGEgdG9rZW4ga2V5IGlmIHdlIGhhdmUgdG9rZW4gZGF0YSBmb3IgdGhpcyBpbnB1dFxuICAgICAgICB0eE91dHB1dC50b2tlbiA9IGNvbnZlcnRUb1Rva2VuKG91dHB1dC50b2tlbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3V0cHV0LnNwZW50QnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgcmV0dXJuIGEgc3BlbnRCeSBrZXkgaWYgdGhpcyBvdXRwdXQgaGFzIGJlZW4gc3BlbnRcbiAgICAgICAgdHhPdXRwdXQuc3BlbnRCeSA9IHtcbiAgICAgICAgICAgIHR4aWQ6ICgwLCBoZXhfMS50b0hleFJldikob3V0cHV0LnNwZW50QnkudHhpZCksXG4gICAgICAgICAgICBvdXRJZHg6IG91dHB1dC5zcGVudEJ5LmlucHV0SWR4LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdHhPdXRwdXQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9QbHVnaW5FbnRyaWVzKHBsdWdpbnMpIHtcbiAgICBjb25zdCBwbHVnaW5FbnRyaWVzID0ge307XG4gICAgZm9yIChjb25zdCBbcGx1Z2luTmFtZSwgcGx1Z2luXSBvZiBPYmplY3QuZW50cmllcyhwbHVnaW5zKSkge1xuICAgICAgICBpZiAodHlwZW9mIHBsdWdpbk5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGdyb3VwcywgZGF0YSB9ID0gcGx1Z2luO1xuICAgICAgICBwbHVnaW5FbnRyaWVzW3BsdWdpbk5hbWVdID0ge1xuICAgICAgICAgICAgZ3JvdXBzOiBncm91cHMubWFwKGhleF8xLnRvSGV4KSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEubWFwKGhleF8xLnRvSGV4KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbkVudHJpZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9QbHVnaW5Hcm91cHMocHJvdG9QbHVnaW5Hcm91cHMpIHtcbiAgICBjb25zdCB7IGdyb3VwcyB9ID0gcHJvdG9QbHVnaW5Hcm91cHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ3JvdXBzOiBncm91cHMubWFwKGdyb3VwID0+ICh7IGdyb3VwOiAoMCwgaGV4XzEudG9IZXgpKGdyb3VwLmdyb3VwKSB9KSksXG4gICAgICAgIG5leHRTdGFydDogKDAsIGhleF8xLnRvSGV4KShwcm90b1BsdWdpbkdyb3Vwcy5uZXh0U3RhcnQpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9CbG9ja01ldGEoYmxvY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGJsb2NrLmhlaWdodCxcbiAgICAgICAgaGFzaDogKDAsIGhleF8xLnRvSGV4UmV2KShibG9jay5oYXNoKSxcbiAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIoYmxvY2sudGltZXN0YW1wKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvUmF3VHgocmF3VHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByYXdUeDogKDAsIGhleF8xLnRvSGV4KShyYXdUeC5yYXdUeCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1NjcmlwdFV0eG8odXR4bykge1xuICAgIGlmICh1dHhvLm91dHBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVVFhPIG91dHBvaW50IGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBjb25zdCBjb252ZXJ0ZWRTY3JpcHRVdHhvID0ge1xuICAgICAgICBvdXRwb2ludDoge1xuICAgICAgICAgICAgdHhpZDogKDAsIGhleF8xLnRvSGV4UmV2KSh1dHhvLm91dHBvaW50LnR4aWQpLFxuICAgICAgICAgICAgb3V0SWR4OiB1dHhvLm91dHBvaW50Lm91dElkeCxcbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2tIZWlnaHQ6IHV0eG8uYmxvY2tIZWlnaHQsXG4gICAgICAgIGlzQ29pbmJhc2U6IHV0eG8uaXNDb2luYmFzZSxcbiAgICAgICAgc2F0czogQmlnSW50KHV0eG8uc2F0cyksXG4gICAgICAgIGlzRmluYWw6IHV0eG8uaXNGaW5hbCxcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgdXR4by50b2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gV2Ugb25seSByZXR1cm4gYSB0b2tlbiBrZXkgaWYgd2UgaGF2ZSB0b2tlbiBkYXRhIGZvciB0aGlzIGlucHV0XG4gICAgICAgIGNvbnZlcnRlZFNjcmlwdFV0eG8udG9rZW4gPSBjb252ZXJ0VG9Ub2tlbih1dHhvLnRva2VuKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHV0eG8ucGx1Z2lucykubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBXZSBvbmx5IHJldHVybiBhIHBsdWdpbnMga2V5IGlmIHdlIGhhdmUgcGx1Z2luc1xuICAgICAgICBjb252ZXJ0ZWRTY3JpcHRVdHhvLnBsdWdpbnMgPSBjb252ZXJ0VG9QbHVnaW5FbnRyaWVzKHV0eG8ucGx1Z2lucyk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZWRTY3JpcHRVdHhvO1xufVxuZnVuY3Rpb24gY29udmVydFRvVXR4byh1dHhvKSB7XG4gICAgaWYgKHV0eG8ub3V0cG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VUWE8gb3V0cG9pbnQgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnZlcnRlZFV0eG8gPSB7XG4gICAgICAgIG91dHBvaW50OiB7XG4gICAgICAgICAgICB0eGlkOiAoMCwgaGV4XzEudG9IZXhSZXYpKHV0eG8ub3V0cG9pbnQudHhpZCksXG4gICAgICAgICAgICBvdXRJZHg6IHV0eG8ub3V0cG9pbnQub3V0SWR4LFxuICAgICAgICB9LFxuICAgICAgICBibG9ja0hlaWdodDogdXR4by5ibG9ja0hlaWdodCxcbiAgICAgICAgaXNDb2luYmFzZTogdXR4by5pc0NvaW5iYXNlLFxuICAgICAgICBzY3JpcHQ6ICgwLCBoZXhfMS50b0hleCkodXR4by5zY3JpcHQpLFxuICAgICAgICBzYXRzOiBCaWdJbnQodXR4by5zYXRzKSxcbiAgICAgICAgaXNGaW5hbDogdXR4by5pc0ZpbmFsLFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiB1dHhvLnRva2VuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBXZSBvbmx5IHJldHVybiBhIHRva2VuIGtleSBpZiB3ZSBoYXZlIHRva2VuIGRhdGEgZm9yIHRoaXMgaW5wdXRcbiAgICAgICAgY29udmVydGVkVXR4by50b2tlbiA9IGNvbnZlcnRUb1Rva2VuKHV0eG8udG9rZW4pO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModXR4by5wbHVnaW5zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgcmV0dXJuIGEgcGx1Z2lucyBrZXkgaWYgd2UgaGF2ZSBwbHVnaW5zXG4gICAgICAgIGNvbnZlcnRlZFV0eG8ucGx1Z2lucyA9IGNvbnZlcnRUb1BsdWdpbkVudHJpZXModXR4by5wbHVnaW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZFV0eG87XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Ub2tlbkVudHJ5KHRva2VuRW50cnkpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuRW50cnkudG9rZW5UeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBOb3QgZXhwZWN0ZWQgdG8gZXZlciBoYXBwZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjaHJvbmlrIHJldHVybmVkIHVuZGVmaW5lZCB0b2tlbkVudHJ5LnRva2VuVHlwZSBmb3IgdG9rZW5JZCBcIiR7dG9rZW5FbnRyeS50b2tlbklkfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHJldHVybk9iaiA9IHtcbiAgICAgICAgdG9rZW5JZDogdG9rZW5FbnRyeS50b2tlbklkLFxuICAgICAgICB0b2tlblR5cGU6IGNvbnZlcnRUb1Rva2VuVHlwZSh0b2tlbkVudHJ5LnRva2VuVHlwZSksXG4gICAgICAgIHR4VHlwZTogY29udmVydFRvVG9rZW5UeFR5cGUodG9rZW5FbnRyeS50eFR5cGUpLFxuICAgICAgICBpc0ludmFsaWQ6IHRva2VuRW50cnkuaXNJbnZhbGlkLFxuICAgICAgICBidXJuU3VtbWFyeTogdG9rZW5FbnRyeS5idXJuU3VtbWFyeSxcbiAgICAgICAgZmFpbGVkQ29sb3JpbmdzOiB0b2tlbkVudHJ5LmZhaWxlZENvbG9yaW5ncyxcbiAgICAgICAgYWN0dWFsQnVybkF0b21zOiBCaWdJbnQodG9rZW5FbnRyeS5hY3R1YWxCdXJuQXRvbXMpLFxuICAgICAgICBpbnRlbnRpb25hbEJ1cm5BdG9tczogdG9rZW5FbnRyeS5pbnRlbnRpb25hbEJ1cm5BdG9tcyxcbiAgICAgICAgYnVybnNNaW50QmF0b25zOiB0b2tlbkVudHJ5LmJ1cm5zTWludEJhdG9ucyxcbiAgICB9O1xuICAgIGlmICh0b2tlbkVudHJ5Lmdyb3VwVG9rZW5JZCAhPT0gJycpIHtcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIGdyb3VwVG9rZW5JZCBpZiBpdCBpcyBub3QgZW1wdHlcbiAgICAgICAgcmV0dXJuT2JqLmdyb3VwVG9rZW5JZCA9IHRva2VuRW50cnkuZ3JvdXBUb2tlbklkO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuT2JqO1xufVxuZnVuY3Rpb24gY29udmVydFRvVG9rZW5GYWlsZWRQYXJzaW5nKHRva2VuRmFpbGVkUGFyc2luZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHB1c2hkYXRhSWR4OiB0b2tlbkZhaWxlZFBhcnNpbmcucHVzaGRhdGFJZHgsXG4gICAgICAgIGJ5dGVzOiAoMCwgaGV4XzEudG9IZXgpKHRva2VuRmFpbGVkUGFyc2luZy5ieXRlcyksXG4gICAgICAgIGVycm9yOiB0b2tlbkZhaWxlZFBhcnNpbmcuZXJyb3IsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1Rva2VuVHlwZSh0b2tlblR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuVHlwZS5hbHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm90b2NvbDogJ0FMUCcsXG4gICAgICAgICAgICB0eXBlOiBjb252ZXJ0VG9BbHBUb2tlblR5cGUodG9rZW5UeXBlLmFscCksXG4gICAgICAgICAgICBudW1iZXI6IHRva2VuVHlwZS5hbHAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdG9rZW5UeXBlLnNscCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3RvY29sOiAnU0xQJyxcbiAgICAgICAgICAgIHR5cGU6IGNvbnZlcnRUb1NscFRva2VuVHlwZSh0b2tlblR5cGUuc2xwKSxcbiAgICAgICAgICAgIG51bWJlcjogdG9rZW5UeXBlLnNscCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSW4gY2FzZSB0aGUgQ2hyb25payBpbnN0YW5jZSBzdXBwb3J0cyBhIHByb3RvY29sIHRoaXMgY2xpZW50IGRvZXNuJ3RcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm90b2NvbDogJ1VOS05PV04nLFxuICAgICAgICB0eXBlOiAnVU5LTk9XTicsXG4gICAgICAgIG51bWJlcjogMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvU2xwVG9rZW5UeXBlKG1zZ1R5cGUpIHtcbiAgICBjb25zdCBzbHBUb2tlblR5cGUgPSBwcm90by5zbHBUb2tlblR5cGVUb0pTT04obXNnVHlwZSk7XG4gICAgaWYgKGlzU2xwVG9rZW5UeXBlKHNscFRva2VuVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHNscFRva2VuVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICdTTFBfVE9LRU5fVFlQRV9VTktOT1dOJztcbn1cbmZ1bmN0aW9uIGlzU2xwVG9rZW5UeXBlKG1zZ1R5cGUpIHtcbiAgICByZXR1cm4gU0xQX1RPS0VOX1RZUEVTLmluY2x1ZGVzKG1zZ1R5cGUpO1xufVxuZnVuY3Rpb24gY29udmVydFRvQWxwVG9rZW5UeXBlKG1zZ1R5cGUpIHtcbiAgICBjb25zdCBhbHBUb2tlblR5cGUgPSBwcm90by5hbHBUb2tlblR5cGVUb0pTT04obXNnVHlwZSk7XG4gICAgaWYgKGlzQWxwVG9rZW5UeXBlKGFscFRva2VuVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGFscFRva2VuVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICdBTFBfVE9LRU5fVFlQRV9VTktOT1dOJztcbn1cbmZ1bmN0aW9uIGlzQWxwVG9rZW5UeXBlKG1zZ1R5cGUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5BTFBfVE9LRU5fVFlQRVMuaW5jbHVkZXMobXNnVHlwZSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Ub2tlblN0YXR1cyhtc2dUeXBlKSB7XG4gICAgY29uc3QgdG9rZW5TdGF0dXMgPSBwcm90by50b2tlblN0YXR1c1RvSlNPTihtc2dUeXBlKTtcbiAgICBpZiAoaXNUb2tlblN0YXR1cyh0b2tlblN0YXR1cykpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuU3RhdHVzO1xuICAgIH1cbiAgICByZXR1cm4gJ1RPS0VOX1NUQVRVU19VTktOT1dOJztcbn1cbmZ1bmN0aW9uIGlzVG9rZW5TdGF0dXMobXNnVHlwZSkge1xuICAgIHJldHVybiBUT0tFTl9TVEFUVVNfVFlQRVMuaW5jbHVkZXMobXNnVHlwZSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Ub2tlblR4VHlwZShtc2dUeXBlKSB7XG4gICAgY29uc3QgdG9rZW5UeFR5cGUgPSBwcm90by50b2tlblR4VHlwZVRvSlNPTihtc2dUeXBlKTtcbiAgICBpZiAoaXNUb2tlblR4VHlwZSh0b2tlblR4VHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuVHhUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gJ1VOS05PV04nO1xufVxuZnVuY3Rpb24gaXNUb2tlblR4VHlwZShtc2dUeXBlKSB7XG4gICAgcmV0dXJuIFRPS0VOX1RYX1RZUEVfVFlQRVMuaW5jbHVkZXMobXNnVHlwZSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Ub2tlbih0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4udG9rZW5UeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBOb3QgZXhwZWN0ZWQgdG8gZXZlciBoYXBwZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjaHJvbmlrIHJldHVybmVkIHVuZGVmaW5lZCB0b2tlbi50b2tlblR5cGUgZm9yIHRva2VuSWQgXCIke3Rva2VuLnRva2VuSWR9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgY29udmVydGVkVG9rZW4gPSB7XG4gICAgICAgIHRva2VuSWQ6IHRva2VuLnRva2VuSWQsXG4gICAgICAgIHRva2VuVHlwZTogY29udmVydFRvVG9rZW5UeXBlKHRva2VuLnRva2VuVHlwZSksXG4gICAgICAgIGF0b21zOiBCaWdJbnQodG9rZW4uYXRvbXMpLFxuICAgICAgICBpc01pbnRCYXRvbjogdG9rZW4uaXNNaW50QmF0b24sXG4gICAgfTtcbiAgICAvLyBXZSBkbyBub3QgYm90aGVyIGluY2x1ZGluZyBlbnRyeUlkeCBmb3IgdXR4b3MsIHdoZXJlIGl0IGlzIGFsd2F5cyAtMVxuICAgIGlmICh0b2tlbi5lbnRyeUlkeCAhPT0gLTEpIHtcbiAgICAgICAgY29udmVydGVkVG9rZW4uZW50cnlJZHggPSB0b2tlbi5lbnRyeUlkeDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZFRva2VuO1xufVxuZnVuY3Rpb24gY29udmVydFRvQmxvY2tNc2dUeXBlKG1zZ1R5cGUpIHtcbiAgICBjb25zdCBibG9ja01zZ1R5cGUgPSBwcm90by5ibG9ja01zZ1R5cGVUb0pTT04obXNnVHlwZSk7XG4gICAgaWYgKGlzQmxvY2tNc2dUeXBlKGJsb2NrTXNnVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrTXNnVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICdVTlJFQ09HTklaRUQnO1xufVxuZnVuY3Rpb24gaXNCbG9ja01zZ1R5cGUobXNnVHlwZSkge1xuICAgIHJldHVybiBCTEtfTVNHX1RZUEVTLmluY2x1ZGVzKG1zZ1R5cGUpO1xufVxuZnVuY3Rpb24gY29udmVydFRvVHhNc2dUeXBlKG1zZ1R5cGUpIHtcbiAgICBjb25zdCB0eE1zZ1R5cGUgPSBwcm90by50eE1zZ1R5cGVUb0pTT04obXNnVHlwZSk7XG4gICAgaWYgKGlzVHhNc2dUeXBlKHR4TXNnVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHR4TXNnVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICdVTlJFQ09HTklaRUQnO1xufVxuZnVuY3Rpb24gaXNUeE1zZ1R5cGUobXNnVHlwZSkge1xuICAgIHJldHVybiBUWF9NU0dfVFlQRVMuaW5jbHVkZXMobXNnVHlwZSk7XG59XG4vLyBBZGQgY29udmVydGVyIGFuZCB0eXBlIGd1YXJkcyBmb3IgdHggZmluYWxpemF0aW9uIHJlYXNvblxuZnVuY3Rpb24gY29udmVydFRvVHhGaW5hbGl6YXRpb25SZWFzb25UeXBlKHJlYXNvbikge1xuICAgIGNvbnN0IHJlYXNvblN0ciA9IHByb3RvLnR4RmluYWxpemF0aW9uUmVhc29uVHlwZVRvSlNPTihyZWFzb24pO1xuICAgIGlmIChpc1R4RmluYWxpemF0aW9uUmVhc29uVHlwZShyZWFzb25TdHIpKSB7XG4gICAgICAgIHJldHVybiByZWFzb25TdHI7XG4gICAgfVxuICAgIHJldHVybiAnVU5SRUNPR05JWkVEJztcbn1cbmZ1bmN0aW9uIGlzVHhGaW5hbGl6YXRpb25SZWFzb25UeXBlKHJlYXNvbikge1xuICAgIHJldHVybiBUWF9GSU5BTElaQVRJT05fUkVBU09OX1RZUEVTLmluY2x1ZGVzKHJlYXNvbik7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Ub2tlbkluZm8odG9rZW5JbmZvKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbkluZm8udG9rZW5UeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBOb3QgZXhwZWN0ZWQgdG8gZXZlciBoYXBwZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjaHJvbmlrIHJldHVybmVkIHVuZGVmaW5lZCB0b2tlbkluZm8udG9rZW5UeXBlIGZvciB0b2tlbklkIFwiJHt0b2tlbkluZm8udG9rZW5JZH1cImApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRva2VuSW5mby5nZW5lc2lzSW5mbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTm90IGV4cGVjdGVkIHRvIGV2ZXIgaGFwcGVuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2hyb25payByZXR1cm5lZCB1bmRlZmluZWQgdG9rZW5JbmZvLmdlbmVzaXNJbmZvIGZvciB0b2tlbklkIFwiJHt0b2tlbkluZm8udG9rZW5JZH1cImApO1xuICAgIH1cbiAgICAvLyBXZSB1c2UgdG9rZW5UeXBlIHRvIGdldCB0aGUgY29ycmVjdCBzaGFwZSBvZiBnZW5lc2lzSW5mb1xuICAgIGNvbnN0IHRva2VuVHlwZSA9IGNvbnZlcnRUb1Rva2VuVHlwZSh0b2tlbkluZm8udG9rZW5UeXBlKTtcbiAgICBjb25zdCByZXR1cm5lZFRva2VuSW5mbyA9IHtcbiAgICAgICAgdG9rZW5JZDogdG9rZW5JbmZvLnRva2VuSWQsXG4gICAgICAgIHRva2VuVHlwZSxcbiAgICAgICAgdGltZUZpcnN0U2VlbjogTnVtYmVyKHRva2VuSW5mby50aW1lRmlyc3RTZWVuKSxcbiAgICAgICAgZ2VuZXNpc0luZm86IGNvbnZlcnRUb0dlbmVzaXNJbmZvKHRva2VuSW5mby5nZW5lc2lzSW5mbywgdG9rZW5UeXBlKSxcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgdG9rZW5JbmZvLmJsb2NrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBPbmx5IGluY2x1ZGUgYmxvY2sgaWYgdGhlIHR4IGlzIGluIGEgYmxvY2tcbiAgICAgICAgcmV0dXJuZWRUb2tlbkluZm8uYmxvY2sgPSBjb252ZXJ0VG9CbG9ja01ldGEodG9rZW5JbmZvLmJsb2NrKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybmVkVG9rZW5JbmZvO1xufVxuZnVuY3Rpb24gY29udmVydFRvR2VuZXNpc0luZm8oZ2VuZXNpc0luZm8sIHRva2VuVHlwZSkge1xuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICBjb25zdCByZXR1cm5lZEdlbmVzaXNJbmZvID0ge1xuICAgICAgICB0b2tlblRpY2tlcjogZGVjb2Rlci5kZWNvZGUoZ2VuZXNpc0luZm8udG9rZW5UaWNrZXIpLFxuICAgICAgICB0b2tlbk5hbWU6IGRlY29kZXIuZGVjb2RlKGdlbmVzaXNJbmZvLnRva2VuTmFtZSksXG4gICAgICAgIHVybDogZGVjb2Rlci5kZWNvZGUoZ2VuZXNpc0luZm8udXJsKSxcbiAgICAgICAgZGVjaW1hbHM6IGdlbmVzaXNJbmZvLmRlY2ltYWxzLFxuICAgIH07XG4gICAgLy8gQWRkIEFMUCBmaWVsZHMgZm9yIEFMUCB0eXBlcyBvbmx5XG4gICAgaWYgKHRva2VuVHlwZS5wcm90b2NvbCA9PT0gJ0FMUCcpIHtcbiAgICAgICAgcmV0dXJuZWRHZW5lc2lzSW5mby5kYXRhID0gKDAsIGhleF8xLnRvSGV4KShnZW5lc2lzSW5mby5kYXRhKTtcbiAgICAgICAgcmV0dXJuZWRHZW5lc2lzSW5mby5hdXRoUHVia2V5ID0gKDAsIGhleF8xLnRvSGV4KShnZW5lc2lzSW5mby5hdXRoUHVia2V5KTtcbiAgICB9XG4gICAgLy8gQWRkIG1pbnRWYXVsdEhhc2ggZm9yIFNMUCBNaW50IFZhdWx0IG9ubHlcbiAgICBpZiAodG9rZW5UeXBlLnR5cGUgPT09ICdTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxUJykge1xuICAgICAgICByZXR1cm5lZEdlbmVzaXNJbmZvLm1pbnRWYXVsdFNjcmlwdGhhc2ggPSAoMCwgaGV4XzEudG9IZXgpKGdlbmVzaXNJbmZvLm1pbnRWYXVsdFNjcmlwdGhhc2gpO1xuICAgIH1cbiAgICAvLyBBZGQgdXJsIGZvciBTTFAgb25seVxuICAgIGlmICh0b2tlblR5cGUucHJvdG9jb2wgPT09ICdTTFAnKSB7XG4gICAgICAgIHJldHVybmVkR2VuZXNpc0luZm8uaGFzaCA9ICgwLCBoZXhfMS50b0hleCkoZ2VuZXNpc0luZm8uaGFzaCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5lZEdlbmVzaXNJbmZvO1xufVxuZnVuY3Rpb24gY29udmVydFRvQ29pbmJhc2VEYXRhKGNvaW5iYXNlRGF0YSkge1xuICAgIGNvbnN0IHJldHVybmVkQ29pbmJhc2VEYXRhID0ge1xuICAgICAgICBzY3JpcHRzaWc6ICgwLCBoZXhfMS50b0hleCkoY29pbmJhc2VEYXRhLmNvaW5iYXNlU2NyaXB0c2lnKSxcbiAgICAgICAgb3V0cHV0czogY29pbmJhc2VEYXRhLmNvaW5iYXNlT3V0cHV0cy5tYXAoY29udmVydFRvVHhPdXRwdXQpLFxuICAgIH07XG4gICAgcmV0dXJuIHJldHVybmVkQ29pbmJhc2VEYXRhO1xufVxuZXhwb3J0cy5BTFBfVE9LRU5fVFlQRVMgPSBbXG4gICAgJ0FMUF9UT0tFTl9UWVBFX1NUQU5EQVJEJyxcbiAgICAnQUxQX1RPS0VOX1RZUEVfVU5LTk9XTicsXG5dO1xuY29uc3QgU0xQX1RPS0VOX1RZUEVTID0gW1xuICAgICdTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRScsXG4gICAgJ1NMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQnLFxuICAgICdTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQJyxcbiAgICAnU0xQX1RPS0VOX1RZUEVfTkZUMV9DSElMRCcsXG4gICAgJ1NMUF9UT0tFTl9UWVBFX1VOS05PV04nLFxuXTtcbmNvbnN0IFRPS0VOX1NUQVRVU19UWVBFUyA9IFtcbiAgICAnVE9LRU5fU1RBVFVTX05PTl9UT0tFTicsXG4gICAgJ1RPS0VOX1NUQVRVU19OT1JNQUwnLFxuICAgICdUT0tFTl9TVEFUVVNfTk9UX05PUk1BTCcsXG4gICAgJ1RPS0VOX1NUQVRVU19VTktOT1dOJyxcbl07XG5jb25zdCBUT0tFTl9UWF9UWVBFX1RZUEVTID0gW1xuICAgICdOT05FJyxcbiAgICAnVU5LTk9XTicsXG4gICAgJ0dFTkVTSVMnLFxuICAgICdTRU5EJyxcbiAgICAnTUlOVCcsXG4gICAgJ0JVUk4nLFxuXTtcbmNvbnN0IEJMS19NU0dfVFlQRVMgPSBbXG4gICAgJ0JMS19DT05ORUNURUQnLFxuICAgICdCTEtfRElTQ09OTkVDVEVEJyxcbiAgICAnQkxLX0ZJTkFMSVpFRCcsXG4gICAgJ0JMS19JTlZBTElEQVRFRCcsXG4gICAgJ1VOUkVDT0dOSVpFRCcsXG5dO1xuY29uc3QgVFhfTVNHX1RZUEVTID0gW1xuICAgICdUWF9BRERFRF9UT19NRU1QT09MJyxcbiAgICAnVFhfUkVNT1ZFRF9GUk9NX01FTVBPT0wnLFxuICAgICdUWF9DT05GSVJNRUQnLFxuICAgICdUWF9GSU5BTElaRUQnLFxuICAgICdUWF9JTlZBTElEQVRFRCcsXG4gICAgJ1VOUkVDT0dOSVpFRCcsXG5dO1xuY29uc3QgVFhfRklOQUxJWkFUSU9OX1JFQVNPTl9UWVBFUyA9IFtcbiAgICAnVFhfRklOQUxJWkFUSU9OX1JFQVNPTl9QT1NUX0NPTlNFTlNVUycsXG4gICAgJ1RYX0ZJTkFMSVpBVElPTl9SRUFTT05fUFJFX0NPTlNFTlNVUycsXG4gICAgJ1VOUkVDT0dOSVpFRCcsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hyb25pa0NsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2216\n\n}")},2239:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\nmodule.exports = LongBits;\n\nvar util = __webpack_require__(3610);\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = "\\0\\0\\0\\0\\0\\0\\0\\0";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === "number")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIzOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxJQUFpQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0IsNkNBQTZDO0FBQzdDLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcz9hMzg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXJ9IGhpIEhpZ2ggMzIgYml0cywgdW5zaWduZWRcbiAqL1xuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxuXG4gICAgLyoqXG4gICAgICogTG93IGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG59XG5cbi8qKlxuICogWmVybyBiaXRzLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxuICovXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG5cbnplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuXG4vKipcbiAqIFplcm8gaGFzaC5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge251bWJlcn0gUG9zc2libHkgdW5zYWZlIG51bWJlclxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICByZXR1cm4gdXRpbC5Mb25nXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xufTtcblxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEJpdHNcbiAqL1xuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMFxuICAgICxcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0ICAgICAgLFxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICk7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZW5jb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMubG8gID0gKCB0aGlzLmxvIDw8IDEgICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxuICAgICAgICBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICAgPyBwYXJ0MSA9PT0gMFxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcbiAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0XG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxuICAgICAgICAgICAgIDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDhcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2239\n\n}')},2250:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.OP_ROLL = exports.OP_PICK = exports.OP_OVER = exports.OP_NIP = exports.OP_DUP = exports.OP_DROP = exports.OP_DEPTH = exports.OP_IFDUP = exports.OP_2SWAP = exports.OP_2ROT = exports.OP_2OVER = exports.OP_3DUP = exports.OP_2DUP = exports.OP_2DROP = exports.OP_FROMALTSTACK = exports.OP_TOALTSTACK = exports.OP_RETURN = exports.OP_VERIFY = exports.OP_ENDIF = exports.OP_ELSE = exports.OP_VERNOTIF = exports.OP_VERIF = exports.OP_NOTIF = exports.OP_IF = exports.OP_VER = exports.OP_NOP = exports.OP_16 = exports.OP_15 = exports.OP_14 = exports.OP_13 = exports.OP_12 = exports.OP_11 = exports.OP_10 = exports.OP_9 = exports.OP_8 = exports.OP_7 = exports.OP_6 = exports.OP_5 = exports.OP_4 = exports.OP_3 = exports.OP_2 = exports.OP_TRUE = exports.OP_1 = exports.OP_RESERVED = exports.OP_1NEGATE = exports.OP_PUSHDATA4 = exports.OP_PUSHDATA2 = exports.OP_PUSHDATA1 = exports.OP_FALSE = exports.OP_0 = void 0;\nexports.OP_CHECKSIG = exports.OP_CODESEPARATOR = exports.OP_HASH256 = exports.OP_HASH160 = exports.OP_SHA256 = exports.OP_SHA1 = exports.OP_RIPEMD160 = exports.OP_WITHIN = exports.OP_MAX = exports.OP_MIN = exports.OP_GREATERTHANOREQUAL = exports.OP_LESSTHANOREQUAL = exports.OP_GREATERTHAN = exports.OP_LESSTHAN = exports.OP_NUMNOTEQUAL = exports.OP_NUMEQUALVERIFY = exports.OP_NUMEQUAL = exports.OP_BOOLOR = exports.OP_BOOLAND = exports.OP_RSHIFT = exports.OP_LSHIFT = exports.OP_MOD = exports.OP_DIV = exports.OP_MUL = exports.OP_SUB = exports.OP_ADD = exports.OP_0NOTEQUAL = exports.OP_NOT = exports.OP_ABS = exports.OP_NEGATE = exports.OP_2DIV = exports.OP_2MUL = exports.OP_1SUB = exports.OP_1ADD = exports.OP_RESERVED2 = exports.OP_RESERVED1 = exports.OP_EQUALVERIFY = exports.OP_EQUAL = exports.OP_XOR = exports.OP_OR = exports.OP_AND = exports.OP_INVERT = exports.OP_SIZE = exports.OP_BIN2NUM = exports.OP_NUM2BIN = exports.OP_SPLIT = exports.OP_CAT = exports.OP_TUCK = exports.OP_SWAP = exports.OP_ROT = void 0;\nexports.OP_INVALIDOPCODE = exports.OP_PREFIX_END = exports.OP_PREFIX_BEGIN = exports.OP_REVERSEBYTES = exports.OP_CHECKDATASIGVERIFY = exports.OP_CHECKDATASIG = exports.OP_NOP10 = exports.OP_NOP9 = exports.OP_NOP8 = exports.OP_NOP7 = exports.OP_NOP6 = exports.OP_NOP5 = exports.OP_NOP4 = exports.OP_NOP3 = exports.OP_CHECKSEQUENCEVERIFY = exports.OP_NOP2 = exports.OP_CHECKLOCKTIMEVERIFY = exports.OP_NOP1 = exports.OP_CHECKMULTISIGVERIFY = exports.OP_CHECKMULTISIG = exports.OP_CHECKSIGVERIFY = void 0;\n// push value\nexports.OP_0 = 0x00;\nexports.OP_FALSE = exports.OP_0;\nexports.OP_PUSHDATA1 = 0x4c;\nexports.OP_PUSHDATA2 = 0x4d;\nexports.OP_PUSHDATA4 = 0x4e;\nexports.OP_1NEGATE = 0x4f;\nexports.OP_RESERVED = 0x50;\nexports.OP_1 = 0x51;\nexports.OP_TRUE = exports.OP_1;\nexports.OP_2 = 0x52;\nexports.OP_3 = 0x53;\nexports.OP_4 = 0x54;\nexports.OP_5 = 0x55;\nexports.OP_6 = 0x56;\nexports.OP_7 = 0x57;\nexports.OP_8 = 0x58;\nexports.OP_9 = 0x59;\nexports.OP_10 = 0x5a;\nexports.OP_11 = 0x5b;\nexports.OP_12 = 0x5c;\nexports.OP_13 = 0x5d;\nexports.OP_14 = 0x5e;\nexports.OP_15 = 0x5f;\nexports.OP_16 = 0x60;\n// control\nexports.OP_NOP = 0x61;\nexports.OP_VER = 0x62;\nexports.OP_IF = 0x63;\nexports.OP_NOTIF = 0x64;\nexports.OP_VERIF = 0x65;\nexports.OP_VERNOTIF = 0x66;\nexports.OP_ELSE = 0x67;\nexports.OP_ENDIF = 0x68;\nexports.OP_VERIFY = 0x69;\nexports.OP_RETURN = 0x6a;\n// stack ops\nexports.OP_TOALTSTACK = 0x6b;\nexports.OP_FROMALTSTACK = 0x6c;\nexports.OP_2DROP = 0x6d;\nexports.OP_2DUP = 0x6e;\nexports.OP_3DUP = 0x6f;\nexports.OP_2OVER = 0x70;\nexports.OP_2ROT = 0x71;\nexports.OP_2SWAP = 0x72;\nexports.OP_IFDUP = 0x73;\nexports.OP_DEPTH = 0x74;\nexports.OP_DROP = 0x75;\nexports.OP_DUP = 0x76;\nexports.OP_NIP = 0x77;\nexports.OP_OVER = 0x78;\nexports.OP_PICK = 0x79;\nexports.OP_ROLL = 0x7a;\nexports.OP_ROT = 0x7b;\nexports.OP_SWAP = 0x7c;\nexports.OP_TUCK = 0x7d;\n// splice ops\nexports.OP_CAT = 0x7e;\nexports.OP_SPLIT = 0x7f; // after monolith upgrade (May 2018)\nexports.OP_NUM2BIN = 0x80; // after monolith upgrade (May 2018)\nexports.OP_BIN2NUM = 0x81; // after monolith upgrade (May 2018)\nexports.OP_SIZE = 0x82;\n// bit logic\nexports.OP_INVERT = 0x83;\nexports.OP_AND = 0x84;\nexports.OP_OR = 0x85;\nexports.OP_XOR = 0x86;\nexports.OP_EQUAL = 0x87;\nexports.OP_EQUALVERIFY = 0x88;\nexports.OP_RESERVED1 = 0x89;\nexports.OP_RESERVED2 = 0x8a;\n// numeric\nexports.OP_1ADD = 0x8b;\nexports.OP_1SUB = 0x8c;\nexports.OP_2MUL = 0x8d;\nexports.OP_2DIV = 0x8e;\nexports.OP_NEGATE = 0x8f;\nexports.OP_ABS = 0x90;\nexports.OP_NOT = 0x91;\nexports.OP_0NOTEQUAL = 0x92;\nexports.OP_ADD = 0x93;\nexports.OP_SUB = 0x94;\nexports.OP_MUL = 0x95;\nexports.OP_DIV = 0x96;\nexports.OP_MOD = 0x97;\nexports.OP_LSHIFT = 0x98;\nexports.OP_RSHIFT = 0x99;\nexports.OP_BOOLAND = 0x9a;\nexports.OP_BOOLOR = 0x9b;\nexports.OP_NUMEQUAL = 0x9c;\nexports.OP_NUMEQUALVERIFY = 0x9d;\nexports.OP_NUMNOTEQUAL = 0x9e;\nexports.OP_LESSTHAN = 0x9f;\nexports.OP_GREATERTHAN = 0xa0;\nexports.OP_LESSTHANOREQUAL = 0xa1;\nexports.OP_GREATERTHANOREQUAL = 0xa2;\nexports.OP_MIN = 0xa3;\nexports.OP_MAX = 0xa4;\nexports.OP_WITHIN = 0xa5;\n// crypto\nexports.OP_RIPEMD160 = 0xa6;\nexports.OP_SHA1 = 0xa7;\nexports.OP_SHA256 = 0xa8;\nexports.OP_HASH160 = 0xa9;\nexports.OP_HASH256 = 0xaa;\nexports.OP_CODESEPARATOR = 0xab;\nexports.OP_CHECKSIG = 0xac;\nexports.OP_CHECKSIGVERIFY = 0xad;\nexports.OP_CHECKMULTISIG = 0xae;\nexports.OP_CHECKMULTISIGVERIFY = 0xaf;\n// expansion\nexports.OP_NOP1 = 0xb0;\nexports.OP_CHECKLOCKTIMEVERIFY = 0xb1;\nexports.OP_NOP2 = exports.OP_CHECKLOCKTIMEVERIFY;\nexports.OP_CHECKSEQUENCEVERIFY = 0xb2;\nexports.OP_NOP3 = exports.OP_CHECKSEQUENCEVERIFY;\nexports.OP_NOP4 = 0xb3;\nexports.OP_NOP5 = 0xb4;\nexports.OP_NOP6 = 0xb5;\nexports.OP_NOP7 = 0xb6;\nexports.OP_NOP8 = 0xb7;\nexports.OP_NOP9 = 0xb8;\nexports.OP_NOP10 = 0xb9;\n// More crypto\nexports.OP_CHECKDATASIG = 0xba;\nexports.OP_CHECKDATASIGVERIFY = 0xbb;\n// additional byte string operations\nexports.OP_REVERSEBYTES = 0xbc;\n// multi-byte opcodes\nexports.OP_PREFIX_BEGIN = 0xf0;\nexports.OP_PREFIX_END = 0xf7;\nexports.OP_INVALIDOPCODE = 0xff;\n//# sourceMappingURL=opcode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OEI7QUFDOUIsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQjtBQUNBLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3Qvb3Bjb2RlLmpzPzFiODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PUF9ST0xMID0gZXhwb3J0cy5PUF9QSUNLID0gZXhwb3J0cy5PUF9PVkVSID0gZXhwb3J0cy5PUF9OSVAgPSBleHBvcnRzLk9QX0RVUCA9IGV4cG9ydHMuT1BfRFJPUCA9IGV4cG9ydHMuT1BfREVQVEggPSBleHBvcnRzLk9QX0lGRFVQID0gZXhwb3J0cy5PUF8yU1dBUCA9IGV4cG9ydHMuT1BfMlJPVCA9IGV4cG9ydHMuT1BfMk9WRVIgPSBleHBvcnRzLk9QXzNEVVAgPSBleHBvcnRzLk9QXzJEVVAgPSBleHBvcnRzLk9QXzJEUk9QID0gZXhwb3J0cy5PUF9GUk9NQUxUU1RBQ0sgPSBleHBvcnRzLk9QX1RPQUxUU1RBQ0sgPSBleHBvcnRzLk9QX1JFVFVSTiA9IGV4cG9ydHMuT1BfVkVSSUZZID0gZXhwb3J0cy5PUF9FTkRJRiA9IGV4cG9ydHMuT1BfRUxTRSA9IGV4cG9ydHMuT1BfVkVSTk9USUYgPSBleHBvcnRzLk9QX1ZFUklGID0gZXhwb3J0cy5PUF9OT1RJRiA9IGV4cG9ydHMuT1BfSUYgPSBleHBvcnRzLk9QX1ZFUiA9IGV4cG9ydHMuT1BfTk9QID0gZXhwb3J0cy5PUF8xNiA9IGV4cG9ydHMuT1BfMTUgPSBleHBvcnRzLk9QXzE0ID0gZXhwb3J0cy5PUF8xMyA9IGV4cG9ydHMuT1BfMTIgPSBleHBvcnRzLk9QXzExID0gZXhwb3J0cy5PUF8xMCA9IGV4cG9ydHMuT1BfOSA9IGV4cG9ydHMuT1BfOCA9IGV4cG9ydHMuT1BfNyA9IGV4cG9ydHMuT1BfNiA9IGV4cG9ydHMuT1BfNSA9IGV4cG9ydHMuT1BfNCA9IGV4cG9ydHMuT1BfMyA9IGV4cG9ydHMuT1BfMiA9IGV4cG9ydHMuT1BfVFJVRSA9IGV4cG9ydHMuT1BfMSA9IGV4cG9ydHMuT1BfUkVTRVJWRUQgPSBleHBvcnRzLk9QXzFORUdBVEUgPSBleHBvcnRzLk9QX1BVU0hEQVRBNCA9IGV4cG9ydHMuT1BfUFVTSERBVEEyID0gZXhwb3J0cy5PUF9QVVNIREFUQTEgPSBleHBvcnRzLk9QX0ZBTFNFID0gZXhwb3J0cy5PUF8wID0gdm9pZCAwO1xuZXhwb3J0cy5PUF9DSEVDS1NJRyA9IGV4cG9ydHMuT1BfQ09ERVNFUEFSQVRPUiA9IGV4cG9ydHMuT1BfSEFTSDI1NiA9IGV4cG9ydHMuT1BfSEFTSDE2MCA9IGV4cG9ydHMuT1BfU0hBMjU2ID0gZXhwb3J0cy5PUF9TSEExID0gZXhwb3J0cy5PUF9SSVBFTUQxNjAgPSBleHBvcnRzLk9QX1dJVEhJTiA9IGV4cG9ydHMuT1BfTUFYID0gZXhwb3J0cy5PUF9NSU4gPSBleHBvcnRzLk9QX0dSRUFURVJUSEFOT1JFUVVBTCA9IGV4cG9ydHMuT1BfTEVTU1RIQU5PUkVRVUFMID0gZXhwb3J0cy5PUF9HUkVBVEVSVEhBTiA9IGV4cG9ydHMuT1BfTEVTU1RIQU4gPSBleHBvcnRzLk9QX05VTU5PVEVRVUFMID0gZXhwb3J0cy5PUF9OVU1FUVVBTFZFUklGWSA9IGV4cG9ydHMuT1BfTlVNRVFVQUwgPSBleHBvcnRzLk9QX0JPT0xPUiA9IGV4cG9ydHMuT1BfQk9PTEFORCA9IGV4cG9ydHMuT1BfUlNISUZUID0gZXhwb3J0cy5PUF9MU0hJRlQgPSBleHBvcnRzLk9QX01PRCA9IGV4cG9ydHMuT1BfRElWID0gZXhwb3J0cy5PUF9NVUwgPSBleHBvcnRzLk9QX1NVQiA9IGV4cG9ydHMuT1BfQUREID0gZXhwb3J0cy5PUF8wTk9URVFVQUwgPSBleHBvcnRzLk9QX05PVCA9IGV4cG9ydHMuT1BfQUJTID0gZXhwb3J0cy5PUF9ORUdBVEUgPSBleHBvcnRzLk9QXzJESVYgPSBleHBvcnRzLk9QXzJNVUwgPSBleHBvcnRzLk9QXzFTVUIgPSBleHBvcnRzLk9QXzFBREQgPSBleHBvcnRzLk9QX1JFU0VSVkVEMiA9IGV4cG9ydHMuT1BfUkVTRVJWRUQxID0gZXhwb3J0cy5PUF9FUVVBTFZFUklGWSA9IGV4cG9ydHMuT1BfRVFVQUwgPSBleHBvcnRzLk9QX1hPUiA9IGV4cG9ydHMuT1BfT1IgPSBleHBvcnRzLk9QX0FORCA9IGV4cG9ydHMuT1BfSU5WRVJUID0gZXhwb3J0cy5PUF9TSVpFID0gZXhwb3J0cy5PUF9CSU4yTlVNID0gZXhwb3J0cy5PUF9OVU0yQklOID0gZXhwb3J0cy5PUF9TUExJVCA9IGV4cG9ydHMuT1BfQ0FUID0gZXhwb3J0cy5PUF9UVUNLID0gZXhwb3J0cy5PUF9TV0FQID0gZXhwb3J0cy5PUF9ST1QgPSB2b2lkIDA7XG5leHBvcnRzLk9QX0lOVkFMSURPUENPREUgPSBleHBvcnRzLk9QX1BSRUZJWF9FTkQgPSBleHBvcnRzLk9QX1BSRUZJWF9CRUdJTiA9IGV4cG9ydHMuT1BfUkVWRVJTRUJZVEVTID0gZXhwb3J0cy5PUF9DSEVDS0RBVEFTSUdWRVJJRlkgPSBleHBvcnRzLk9QX0NIRUNLREFUQVNJRyA9IGV4cG9ydHMuT1BfTk9QMTAgPSBleHBvcnRzLk9QX05PUDkgPSBleHBvcnRzLk9QX05PUDggPSBleHBvcnRzLk9QX05PUDcgPSBleHBvcnRzLk9QX05PUDYgPSBleHBvcnRzLk9QX05PUDUgPSBleHBvcnRzLk9QX05PUDQgPSBleHBvcnRzLk9QX05PUDMgPSBleHBvcnRzLk9QX0NIRUNLU0VRVUVOQ0VWRVJJRlkgPSBleHBvcnRzLk9QX05PUDIgPSBleHBvcnRzLk9QX0NIRUNLTE9DS1RJTUVWRVJJRlkgPSBleHBvcnRzLk9QX05PUDEgPSBleHBvcnRzLk9QX0NIRUNLTVVMVElTSUdWRVJJRlkgPSBleHBvcnRzLk9QX0NIRUNLTVVMVElTSUcgPSBleHBvcnRzLk9QX0NIRUNLU0lHVkVSSUZZID0gdm9pZCAwO1xuLy8gcHVzaCB2YWx1ZVxuZXhwb3J0cy5PUF8wID0gMHgwMDtcbmV4cG9ydHMuT1BfRkFMU0UgPSBleHBvcnRzLk9QXzA7XG5leHBvcnRzLk9QX1BVU0hEQVRBMSA9IDB4NGM7XG5leHBvcnRzLk9QX1BVU0hEQVRBMiA9IDB4NGQ7XG5leHBvcnRzLk9QX1BVU0hEQVRBNCA9IDB4NGU7XG5leHBvcnRzLk9QXzFORUdBVEUgPSAweDRmO1xuZXhwb3J0cy5PUF9SRVNFUlZFRCA9IDB4NTA7XG5leHBvcnRzLk9QXzEgPSAweDUxO1xuZXhwb3J0cy5PUF9UUlVFID0gZXhwb3J0cy5PUF8xO1xuZXhwb3J0cy5PUF8yID0gMHg1MjtcbmV4cG9ydHMuT1BfMyA9IDB4NTM7XG5leHBvcnRzLk9QXzQgPSAweDU0O1xuZXhwb3J0cy5PUF81ID0gMHg1NTtcbmV4cG9ydHMuT1BfNiA9IDB4NTY7XG5leHBvcnRzLk9QXzcgPSAweDU3O1xuZXhwb3J0cy5PUF84ID0gMHg1ODtcbmV4cG9ydHMuT1BfOSA9IDB4NTk7XG5leHBvcnRzLk9QXzEwID0gMHg1YTtcbmV4cG9ydHMuT1BfMTEgPSAweDViO1xuZXhwb3J0cy5PUF8xMiA9IDB4NWM7XG5leHBvcnRzLk9QXzEzID0gMHg1ZDtcbmV4cG9ydHMuT1BfMTQgPSAweDVlO1xuZXhwb3J0cy5PUF8xNSA9IDB4NWY7XG5leHBvcnRzLk9QXzE2ID0gMHg2MDtcbi8vIGNvbnRyb2xcbmV4cG9ydHMuT1BfTk9QID0gMHg2MTtcbmV4cG9ydHMuT1BfVkVSID0gMHg2MjtcbmV4cG9ydHMuT1BfSUYgPSAweDYzO1xuZXhwb3J0cy5PUF9OT1RJRiA9IDB4NjQ7XG5leHBvcnRzLk9QX1ZFUklGID0gMHg2NTtcbmV4cG9ydHMuT1BfVkVSTk9USUYgPSAweDY2O1xuZXhwb3J0cy5PUF9FTFNFID0gMHg2NztcbmV4cG9ydHMuT1BfRU5ESUYgPSAweDY4O1xuZXhwb3J0cy5PUF9WRVJJRlkgPSAweDY5O1xuZXhwb3J0cy5PUF9SRVRVUk4gPSAweDZhO1xuLy8gc3RhY2sgb3BzXG5leHBvcnRzLk9QX1RPQUxUU1RBQ0sgPSAweDZiO1xuZXhwb3J0cy5PUF9GUk9NQUxUU1RBQ0sgPSAweDZjO1xuZXhwb3J0cy5PUF8yRFJPUCA9IDB4NmQ7XG5leHBvcnRzLk9QXzJEVVAgPSAweDZlO1xuZXhwb3J0cy5PUF8zRFVQID0gMHg2ZjtcbmV4cG9ydHMuT1BfMk9WRVIgPSAweDcwO1xuZXhwb3J0cy5PUF8yUk9UID0gMHg3MTtcbmV4cG9ydHMuT1BfMlNXQVAgPSAweDcyO1xuZXhwb3J0cy5PUF9JRkRVUCA9IDB4NzM7XG5leHBvcnRzLk9QX0RFUFRIID0gMHg3NDtcbmV4cG9ydHMuT1BfRFJPUCA9IDB4NzU7XG5leHBvcnRzLk9QX0RVUCA9IDB4NzY7XG5leHBvcnRzLk9QX05JUCA9IDB4Nzc7XG5leHBvcnRzLk9QX09WRVIgPSAweDc4O1xuZXhwb3J0cy5PUF9QSUNLID0gMHg3OTtcbmV4cG9ydHMuT1BfUk9MTCA9IDB4N2E7XG5leHBvcnRzLk9QX1JPVCA9IDB4N2I7XG5leHBvcnRzLk9QX1NXQVAgPSAweDdjO1xuZXhwb3J0cy5PUF9UVUNLID0gMHg3ZDtcbi8vIHNwbGljZSBvcHNcbmV4cG9ydHMuT1BfQ0FUID0gMHg3ZTtcbmV4cG9ydHMuT1BfU1BMSVQgPSAweDdmOyAvLyBhZnRlciBtb25vbGl0aCB1cGdyYWRlIChNYXkgMjAxOClcbmV4cG9ydHMuT1BfTlVNMkJJTiA9IDB4ODA7IC8vIGFmdGVyIG1vbm9saXRoIHVwZ3JhZGUgKE1heSAyMDE4KVxuZXhwb3J0cy5PUF9CSU4yTlVNID0gMHg4MTsgLy8gYWZ0ZXIgbW9ub2xpdGggdXBncmFkZSAoTWF5IDIwMTgpXG5leHBvcnRzLk9QX1NJWkUgPSAweDgyO1xuLy8gYml0IGxvZ2ljXG5leHBvcnRzLk9QX0lOVkVSVCA9IDB4ODM7XG5leHBvcnRzLk9QX0FORCA9IDB4ODQ7XG5leHBvcnRzLk9QX09SID0gMHg4NTtcbmV4cG9ydHMuT1BfWE9SID0gMHg4NjtcbmV4cG9ydHMuT1BfRVFVQUwgPSAweDg3O1xuZXhwb3J0cy5PUF9FUVVBTFZFUklGWSA9IDB4ODg7XG5leHBvcnRzLk9QX1JFU0VSVkVEMSA9IDB4ODk7XG5leHBvcnRzLk9QX1JFU0VSVkVEMiA9IDB4OGE7XG4vLyBudW1lcmljXG5leHBvcnRzLk9QXzFBREQgPSAweDhiO1xuZXhwb3J0cy5PUF8xU1VCID0gMHg4YztcbmV4cG9ydHMuT1BfMk1VTCA9IDB4OGQ7XG5leHBvcnRzLk9QXzJESVYgPSAweDhlO1xuZXhwb3J0cy5PUF9ORUdBVEUgPSAweDhmO1xuZXhwb3J0cy5PUF9BQlMgPSAweDkwO1xuZXhwb3J0cy5PUF9OT1QgPSAweDkxO1xuZXhwb3J0cy5PUF8wTk9URVFVQUwgPSAweDkyO1xuZXhwb3J0cy5PUF9BREQgPSAweDkzO1xuZXhwb3J0cy5PUF9TVUIgPSAweDk0O1xuZXhwb3J0cy5PUF9NVUwgPSAweDk1O1xuZXhwb3J0cy5PUF9ESVYgPSAweDk2O1xuZXhwb3J0cy5PUF9NT0QgPSAweDk3O1xuZXhwb3J0cy5PUF9MU0hJRlQgPSAweDk4O1xuZXhwb3J0cy5PUF9SU0hJRlQgPSAweDk5O1xuZXhwb3J0cy5PUF9CT09MQU5EID0gMHg5YTtcbmV4cG9ydHMuT1BfQk9PTE9SID0gMHg5YjtcbmV4cG9ydHMuT1BfTlVNRVFVQUwgPSAweDljO1xuZXhwb3J0cy5PUF9OVU1FUVVBTFZFUklGWSA9IDB4OWQ7XG5leHBvcnRzLk9QX05VTU5PVEVRVUFMID0gMHg5ZTtcbmV4cG9ydHMuT1BfTEVTU1RIQU4gPSAweDlmO1xuZXhwb3J0cy5PUF9HUkVBVEVSVEhBTiA9IDB4YTA7XG5leHBvcnRzLk9QX0xFU1NUSEFOT1JFUVVBTCA9IDB4YTE7XG5leHBvcnRzLk9QX0dSRUFURVJUSEFOT1JFUVVBTCA9IDB4YTI7XG5leHBvcnRzLk9QX01JTiA9IDB4YTM7XG5leHBvcnRzLk9QX01BWCA9IDB4YTQ7XG5leHBvcnRzLk9QX1dJVEhJTiA9IDB4YTU7XG4vLyBjcnlwdG9cbmV4cG9ydHMuT1BfUklQRU1EMTYwID0gMHhhNjtcbmV4cG9ydHMuT1BfU0hBMSA9IDB4YTc7XG5leHBvcnRzLk9QX1NIQTI1NiA9IDB4YTg7XG5leHBvcnRzLk9QX0hBU0gxNjAgPSAweGE5O1xuZXhwb3J0cy5PUF9IQVNIMjU2ID0gMHhhYTtcbmV4cG9ydHMuT1BfQ09ERVNFUEFSQVRPUiA9IDB4YWI7XG5leHBvcnRzLk9QX0NIRUNLU0lHID0gMHhhYztcbmV4cG9ydHMuT1BfQ0hFQ0tTSUdWRVJJRlkgPSAweGFkO1xuZXhwb3J0cy5PUF9DSEVDS01VTFRJU0lHID0gMHhhZTtcbmV4cG9ydHMuT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWSA9IDB4YWY7XG4vLyBleHBhbnNpb25cbmV4cG9ydHMuT1BfTk9QMSA9IDB4YjA7XG5leHBvcnRzLk9QX0NIRUNLTE9DS1RJTUVWRVJJRlkgPSAweGIxO1xuZXhwb3J0cy5PUF9OT1AyID0gZXhwb3J0cy5PUF9DSEVDS0xPQ0tUSU1FVkVSSUZZO1xuZXhwb3J0cy5PUF9DSEVDS1NFUVVFTkNFVkVSSUZZID0gMHhiMjtcbmV4cG9ydHMuT1BfTk9QMyA9IGV4cG9ydHMuT1BfQ0hFQ0tTRVFVRU5DRVZFUklGWTtcbmV4cG9ydHMuT1BfTk9QNCA9IDB4YjM7XG5leHBvcnRzLk9QX05PUDUgPSAweGI0O1xuZXhwb3J0cy5PUF9OT1A2ID0gMHhiNTtcbmV4cG9ydHMuT1BfTk9QNyA9IDB4YjY7XG5leHBvcnRzLk9QX05PUDggPSAweGI3O1xuZXhwb3J0cy5PUF9OT1A5ID0gMHhiODtcbmV4cG9ydHMuT1BfTk9QMTAgPSAweGI5O1xuLy8gTW9yZSBjcnlwdG9cbmV4cG9ydHMuT1BfQ0hFQ0tEQVRBU0lHID0gMHhiYTtcbmV4cG9ydHMuT1BfQ0hFQ0tEQVRBU0lHVkVSSUZZID0gMHhiYjtcbi8vIGFkZGl0aW9uYWwgYnl0ZSBzdHJpbmcgb3BlcmF0aW9uc1xuZXhwb3J0cy5PUF9SRVZFUlNFQllURVMgPSAweGJjO1xuLy8gbXVsdGktYnl0ZSBvcGNvZGVzXG5leHBvcnRzLk9QX1BSRUZJWF9CRUdJTiA9IDB4ZjA7XG5leHBvcnRzLk9QX1BSRUZJWF9FTkQgPSAweGY3O1xuZXhwb3J0cy5PUF9JTlZBTElET1BDT0RFID0gMHhmZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wY29kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2250\n\n}')},2260:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OP_RETURN_MAX_BYTES = exports.COINBASE_MATURITY = exports.XEC_TOKEN_AWARE_DERIVATION_PATH = exports.DEFAULT_FEE_SATS_PER_KB = exports.DEFAULT_DUST_SATS = void 0;\n/** Default dust limit on the eCash network. */\nexports.DEFAULT_DUST_SATS = 546n;\n/** Default fee per kB on the eCash network. */\nexports.DEFAULT_FEE_SATS_PER_KB = 1000n;\n/** Derivation path for non-HD token aware XEC wallets, like ecash-wallet or Cashtab */\nexports.XEC_TOKEN_AWARE_DERIVATION_PATH = `m/44'/1899'/0'/0/0`;\n/**\n * Confirmations required before coinbase utxos\n * are spendable\n *\n * On eCash, coinbase utxos may be\n *\n * - mining rewards\n * - staking rewards\n * - IFP rewards\n */\nexports.COINBASE_MATURITY = 100;\n/**\n * As of May 5, 2025, the max bytes permitted in an OP_RETURN\n * output on the eCash (XEC) network\n *\n * NB SLP spec works within this limit, ALP spec supports actions\n * beyond this limit. For now, ecash-wallet is written accounting\n * for this limit in ALP token action validation.\n */\nexports.OP_RETURN_MAX_BYTES = 223;\n//# sourceMappingURL=consts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI2MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyx5QkFBeUIsR0FBRyx1Q0FBdUMsR0FBRywrQkFBK0IsR0FBRyx5QkFBeUI7QUFDL0o7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvY29uc3RzLmpzP2Y2NTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PUF9SRVRVUk5fTUFYX0JZVEVTID0gZXhwb3J0cy5DT0lOQkFTRV9NQVRVUklUWSA9IGV4cG9ydHMuWEVDX1RPS0VOX0FXQVJFX0RFUklWQVRJT05fUEFUSCA9IGV4cG9ydHMuREVGQVVMVF9GRUVfU0FUU19QRVJfS0IgPSBleHBvcnRzLkRFRkFVTFRfRFVTVF9TQVRTID0gdm9pZCAwO1xuLyoqIERlZmF1bHQgZHVzdCBsaW1pdCBvbiB0aGUgZUNhc2ggbmV0d29yay4gKi9cbmV4cG9ydHMuREVGQVVMVF9EVVNUX1NBVFMgPSA1NDZuO1xuLyoqIERlZmF1bHQgZmVlIHBlciBrQiBvbiB0aGUgZUNhc2ggbmV0d29yay4gKi9cbmV4cG9ydHMuREVGQVVMVF9GRUVfU0FUU19QRVJfS0IgPSAxMDAwbjtcbi8qKiBEZXJpdmF0aW9uIHBhdGggZm9yIG5vbi1IRCB0b2tlbiBhd2FyZSBYRUMgd2FsbGV0cywgbGlrZSBlY2FzaC13YWxsZXQgb3IgQ2FzaHRhYiAqL1xuZXhwb3J0cy5YRUNfVE9LRU5fQVdBUkVfREVSSVZBVElPTl9QQVRIID0gYG0vNDQnLzE4OTknLzAnLzAvMGA7XG4vKipcbiAqIENvbmZpcm1hdGlvbnMgcmVxdWlyZWQgYmVmb3JlIGNvaW5iYXNlIHV0eG9zXG4gKiBhcmUgc3BlbmRhYmxlXG4gKlxuICogT24gZUNhc2gsIGNvaW5iYXNlIHV0eG9zIG1heSBiZVxuICpcbiAqIC0gbWluaW5nIHJld2FyZHNcbiAqIC0gc3Rha2luZyByZXdhcmRzXG4gKiAtIElGUCByZXdhcmRzXG4gKi9cbmV4cG9ydHMuQ09JTkJBU0VfTUFUVVJJVFkgPSAxMDA7XG4vKipcbiAqIEFzIG9mIE1heSA1LCAyMDI1LCB0aGUgbWF4IGJ5dGVzIHBlcm1pdHRlZCBpbiBhbiBPUF9SRVRVUk5cbiAqIG91dHB1dCBvbiB0aGUgZUNhc2ggKFhFQykgbmV0d29ya1xuICpcbiAqIE5CIFNMUCBzcGVjIHdvcmtzIHdpdGhpbiB0aGlzIGxpbWl0LCBBTFAgc3BlYyBzdXBwb3J0cyBhY3Rpb25zXG4gKiBiZXlvbmQgdGhpcyBsaW1pdC4gRm9yIG5vdywgZWNhc2gtd2FsbGV0IGlzIHdyaXR0ZW4gYWNjb3VudGluZ1xuICogZm9yIHRoaXMgbGltaXQgaW4gQUxQIHRva2VuIGFjdGlvbiB2YWxpZGF0aW9uLlxuICovXG5leHBvcnRzLk9QX1JFVFVSTl9NQVhfQllURVMgPSAyMjM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2260\n\n}")},2313:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeLegacyAddress = exports.decodeLegacyAddress = exports.LEGACY_VERSION_BYTES = exports.decodeBase58Check = exports.encodeBase58Check = void 0;\nconst hash_1 = __webpack_require__(5632);\nconst b58_ts_1 = __webpack_require__(8583);\nconst hex_1 = __webpack_require__(2938);\n/**\n * Base 58 Check\n */\nconst encodeBase58Check = (data) => {\n    const checksum = (0, hash_1.sha256d)(data);\n    const dataWithChecksum = new Uint8Array(data.length + 4);\n    dataWithChecksum.set(data, 0);\n    dataWithChecksum.set(checksum.subarray(0, 4), data.length);\n    return (0, b58_ts_1.encodeBase58)(dataWithChecksum);\n};\nexports.encodeBase58Check = encodeBase58Check;\nconst decodeBase58Check = (str) => {\n    const dataWithChecksum = (0, b58_ts_1.decodeBase58)(str);\n    const payload = dataWithChecksum.slice(0, -4);\n    const checksum = dataWithChecksum.slice(-4);\n    const expectedChecksum = (0, hash_1.sha256d)(payload);\n    // Ensure the two checksums are equal\n    if ((checksum[0] ^ expectedChecksum[0]) |\n        (checksum[1] ^ expectedChecksum[1]) |\n        (checksum[2] ^ expectedChecksum[2]) |\n        (checksum[3] ^ expectedChecksum[3])) {\n        throw new Error('Invalid checksum');\n    }\n    return payload;\n};\nexports.decodeBase58Check = decodeBase58Check;\n// Length of a valid base58check encoding payload: 1 byte for\n// the version byte plus 20 bytes for a RIPEMD - 160 hash.\nconst BASE_58_CHECK_PAYLOAD_LENGTH = 21;\nexports.LEGACY_VERSION_BYTES = {\n    legacy: {\n        mainnet: { p2pkh: 0, p2sh: 5 },\n        testnet: { p2pkh: 111, p2sh: 196 },\n    },\n};\n// Modeled from https://github.com/ealmansi/bchaddrjs/blob/master/src/bchaddr.js#L193\nconst decodeLegacyAddress = (address) => {\n    try {\n        const payload = (0, exports.decodeBase58Check)(address);\n        if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {\n            throw new Error(`Invalid legacy address: payload length must be ${BASE_58_CHECK_PAYLOAD_LENGTH}`);\n        }\n        const versionByte = payload[0];\n        const hash = (0, hex_1.toHex)(new Uint8Array(payload.slice(1)));\n        switch (versionByte) {\n            case exports.LEGACY_VERSION_BYTES.legacy.mainnet.p2pkh:\n                return {\n                    hash,\n                    type: 'p2pkh',\n                    network: 'mainnet',\n                };\n            case exports.LEGACY_VERSION_BYTES.legacy.mainnet.p2sh:\n                return {\n                    hash,\n                    type: 'p2sh',\n                    network: 'mainnet',\n                };\n            case exports.LEGACY_VERSION_BYTES.legacy.testnet.p2pkh:\n                return {\n                    hash,\n                    type: 'p2pkh',\n                    network: 'testnet',\n                };\n            case exports.LEGACY_VERSION_BYTES.legacy.testnet.p2sh:\n                return {\n                    hash,\n                    type: 'p2sh',\n                    network: 'testnet',\n                };\n            default: {\n                throw new Error(`Invalid legacy address: unrecognized version byte \"${versionByte}\"`);\n            }\n        }\n    }\n    catch {\n        throw new Error(`Invalid legacy address`);\n    }\n};\nexports.decodeLegacyAddress = decodeLegacyAddress;\n/**\n * Encode a legacy address given type and hash\n * For now, this is a stub method that supports only BTC p2pkh and p2sh\n */\nconst encodeLegacyAddress = (hash, type, network = 'mainnet') => {\n    const versionByte = exports.LEGACY_VERSION_BYTES.legacy[network][type];\n    const combined = new Uint8Array(1 + hash.length);\n    combined[0] = versionByte;\n    combined.set(hash, 1);\n    return (0, exports.encodeBase58Check)(combined);\n};\nexports.encodeLegacyAddress = encodeLegacyAddress;\n//# sourceMappingURL=legacyaddr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDaEosZUFBZSxtQkFBTyxDQUFDLElBQVM7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsSUFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsSUFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLHVCQUF1QjtBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZCQUE2QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFlBQVk7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvYWRkcmVzcy9sZWdhY3lhZGRyLmpzPzljMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGVMZWdhY3lBZGRyZXNzID0gZXhwb3J0cy5kZWNvZGVMZWdhY3lBZGRyZXNzID0gZXhwb3J0cy5MRUdBQ1lfVkVSU0lPTl9CWVRFUyA9IGV4cG9ydHMuZGVjb2RlQmFzZTU4Q2hlY2sgPSBleHBvcnRzLmVuY29kZUJhc2U1OENoZWNrID0gdm9pZCAwO1xuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIi4uL2hhc2hcIik7XG5jb25zdCBiNThfdHNfMSA9IHJlcXVpcmUoXCJiNTgtdHNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuLi9pby9oZXhcIik7XG4vKipcbiAqIEJhc2UgNTggQ2hlY2tcbiAqL1xuY29uc3QgZW5jb2RlQmFzZTU4Q2hlY2sgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IGNoZWNrc3VtID0gKDAsIGhhc2hfMS5zaGEyNTZkKShkYXRhKTtcbiAgICBjb25zdCBkYXRhV2l0aENoZWNrc3VtID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyA0KTtcbiAgICBkYXRhV2l0aENoZWNrc3VtLnNldChkYXRhLCAwKTtcbiAgICBkYXRhV2l0aENoZWNrc3VtLnNldChjaGVja3N1bS5zdWJhcnJheSgwLCA0KSwgZGF0YS5sZW5ndGgpO1xuICAgIHJldHVybiAoMCwgYjU4X3RzXzEuZW5jb2RlQmFzZTU4KShkYXRhV2l0aENoZWNrc3VtKTtcbn07XG5leHBvcnRzLmVuY29kZUJhc2U1OENoZWNrID0gZW5jb2RlQmFzZTU4Q2hlY2s7XG5jb25zdCBkZWNvZGVCYXNlNThDaGVjayA9IChzdHIpID0+IHtcbiAgICBjb25zdCBkYXRhV2l0aENoZWNrc3VtID0gKDAsIGI1OF90c18xLmRlY29kZUJhc2U1OCkoc3RyKTtcbiAgICBjb25zdCBwYXlsb2FkID0gZGF0YVdpdGhDaGVja3N1bS5zbGljZSgwLCAtNCk7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBkYXRhV2l0aENoZWNrc3VtLnNsaWNlKC00KTtcbiAgICBjb25zdCBleHBlY3RlZENoZWNrc3VtID0gKDAsIGhhc2hfMS5zaGEyNTZkKShwYXlsb2FkKTtcbiAgICAvLyBFbnN1cmUgdGhlIHR3byBjaGVja3N1bXMgYXJlIGVxdWFsXG4gICAgaWYgKChjaGVja3N1bVswXSBeIGV4cGVjdGVkQ2hlY2tzdW1bMF0pIHxcbiAgICAgICAgKGNoZWNrc3VtWzFdIF4gZXhwZWN0ZWRDaGVja3N1bVsxXSkgfFxuICAgICAgICAoY2hlY2tzdW1bMl0gXiBleHBlY3RlZENoZWNrc3VtWzJdKSB8XG4gICAgICAgIChjaGVja3N1bVszXSBeIGV4cGVjdGVkQ2hlY2tzdW1bM10pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbn07XG5leHBvcnRzLmRlY29kZUJhc2U1OENoZWNrID0gZGVjb2RlQmFzZTU4Q2hlY2s7XG4vLyBMZW5ndGggb2YgYSB2YWxpZCBiYXNlNThjaGVjayBlbmNvZGluZyBwYXlsb2FkOiAxIGJ5dGUgZm9yXG4vLyB0aGUgdmVyc2lvbiBieXRlIHBsdXMgMjAgYnl0ZXMgZm9yIGEgUklQRU1EIC0gMTYwIGhhc2guXG5jb25zdCBCQVNFXzU4X0NIRUNLX1BBWUxPQURfTEVOR1RIID0gMjE7XG5leHBvcnRzLkxFR0FDWV9WRVJTSU9OX0JZVEVTID0ge1xuICAgIGxlZ2FjeToge1xuICAgICAgICBtYWlubmV0OiB7IHAycGtoOiAwLCBwMnNoOiA1IH0sXG4gICAgICAgIHRlc3RuZXQ6IHsgcDJwa2g6IDExMSwgcDJzaDogMTk2IH0sXG4gICAgfSxcbn07XG4vLyBNb2RlbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VhbG1hbnNpL2JjaGFkZHJqcy9ibG9iL21hc3Rlci9zcmMvYmNoYWRkci5qcyNMMTkzXG5jb25zdCBkZWNvZGVMZWdhY3lBZGRyZXNzID0gKGFkZHJlc3MpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gKDAsIGV4cG9ydHMuZGVjb2RlQmFzZTU4Q2hlY2spKGFkZHJlc3MpO1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggIT09IEJBU0VfNThfQ0hFQ0tfUEFZTE9BRF9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsZWdhY3kgYWRkcmVzczogcGF5bG9hZCBsZW5ndGggbXVzdCBiZSAke0JBU0VfNThfQ0hFQ0tfUEFZTE9BRF9MRU5HVEh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbkJ5dGUgPSBwYXlsb2FkWzBdO1xuICAgICAgICBjb25zdCBoYXNoID0gKDAsIGhleF8xLnRvSGV4KShuZXcgVWludDhBcnJheShwYXlsb2FkLnNsaWNlKDEpKSk7XG4gICAgICAgIHN3aXRjaCAodmVyc2lvbkJ5dGUpIHtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5MRUdBQ1lfVkVSU0lPTl9CWVRFUy5sZWdhY3kubWFpbm5ldC5wMnBraDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncDJwa2gnLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiAnbWFpbm5ldCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5MRUdBQ1lfVkVSU0lPTl9CWVRFUy5sZWdhY3kubWFpbm5ldC5wMnNoOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwMnNoJyxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogJ21haW5uZXQnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuTEVHQUNZX1ZFUlNJT05fQllURVMubGVnYWN5LnRlc3RuZXQucDJwa2g6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3AycGtoJyxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogJ3Rlc3RuZXQnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuTEVHQUNZX1ZFUlNJT05fQllURVMubGVnYWN5LnRlc3RuZXQucDJzaDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncDJzaCcsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcms6ICd0ZXN0bmV0JyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsZWdhY3kgYWRkcmVzczogdW5yZWNvZ25pemVkIHZlcnNpb24gYnl0ZSBcIiR7dmVyc2lvbkJ5dGV9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsZWdhY3kgYWRkcmVzc2ApO1xuICAgIH1cbn07XG5leHBvcnRzLmRlY29kZUxlZ2FjeUFkZHJlc3MgPSBkZWNvZGVMZWdhY3lBZGRyZXNzO1xuLyoqXG4gKiBFbmNvZGUgYSBsZWdhY3kgYWRkcmVzcyBnaXZlbiB0eXBlIGFuZCBoYXNoXG4gKiBGb3Igbm93LCB0aGlzIGlzIGEgc3R1YiBtZXRob2QgdGhhdCBzdXBwb3J0cyBvbmx5IEJUQyBwMnBraCBhbmQgcDJzaFxuICovXG5jb25zdCBlbmNvZGVMZWdhY3lBZGRyZXNzID0gKGhhc2gsIHR5cGUsIG5ldHdvcmsgPSAnbWFpbm5ldCcpID0+IHtcbiAgICBjb25zdCB2ZXJzaW9uQnl0ZSA9IGV4cG9ydHMuTEVHQUNZX1ZFUlNJT05fQllURVMubGVnYWN5W25ldHdvcmtdW3R5cGVdO1xuICAgIGNvbnN0IGNvbWJpbmVkID0gbmV3IFVpbnQ4QXJyYXkoMSArIGhhc2gubGVuZ3RoKTtcbiAgICBjb21iaW5lZFswXSA9IHZlcnNpb25CeXRlO1xuICAgIGNvbWJpbmVkLnNldChoYXNoLCAxKTtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZW5jb2RlQmFzZTU4Q2hlY2spKGNvbWJpbmVkKTtcbn07XG5leHBvcnRzLmVuY29kZUxlZ2FjeUFkZHJlc3MgPSBlbmNvZGVMZWdhY3lBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVnYWN5YWRkci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2313\n\n}")},2318:(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports["default"] = u64;\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMxOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhO0FBQ3pULFdBQVc7QUFDWCxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcz81MjIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b0JpZyA9IGV4cG9ydHMuc2hyU0wgPSBleHBvcnRzLnNoclNIID0gZXhwb3J0cy5yb3RyU0wgPSBleHBvcnRzLnJvdHJTSCA9IGV4cG9ydHMucm90ckJMID0gZXhwb3J0cy5yb3RyQkggPSBleHBvcnRzLnJvdHIzMkwgPSBleHBvcnRzLnJvdHIzMkggPSBleHBvcnRzLnJvdGxTTCA9IGV4cG9ydHMucm90bFNIID0gZXhwb3J0cy5yb3RsQkwgPSBleHBvcnRzLnJvdGxCSCA9IGV4cG9ydHMuYWRkNUwgPSBleHBvcnRzLmFkZDVIID0gZXhwb3J0cy5hZGQ0TCA9IGV4cG9ydHMuYWRkNEggPSBleHBvcnRzLmFkZDNMID0gZXhwb3J0cy5hZGQzSCA9IHZvaWQgMDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5mcm9tQmlnID0gZnJvbUJpZztcbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVycyBmb3IgdTY0LiBCaWdVaW50NjRBcnJheSBpcyB0b28gc2xvdyBhcyBwZXIgMjAyNSwgc28gd2UgaW1wbGVtZW50IGl0IHVzaW5nIFVpbnQzMkFycmF5LlxuICogQHRvZG8gcmUtY2hlY2sgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MjIxMjU4OFxuICogQG1vZHVsZVxuICovXG5jb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0gbHN0Lmxlbmd0aDtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5leHBvcnRzLnRvQmlnID0gdG9CaWc7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5leHBvcnRzLnNoclNIID0gc2hyU0g7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnNoclNMID0gc2hyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdHJTSCA9IHJvdHJTSDtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnJvdHJTTCA9IHJvdHJTTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuZXhwb3J0cy5yb3RyQkggPSByb3RyQkg7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90ckJMID0gcm90ckJMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5leHBvcnRzLnJvdHIzMkggPSByb3RyMzJIO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbmV4cG9ydHMucm90cjMyTCA9IHJvdHIzMkw7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNIID0gcm90bFNIO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNMID0gcm90bFNMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90bEJIID0gcm90bEJIO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCTCA9IHJvdGxCTDtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmV4cG9ydHMuYWRkM0wgPSBhZGQzTDtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQzSCA9IGFkZDNIO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDRMID0gYWRkNEw7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNEggPSBhZGQ0SDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDVMID0gYWRkNUw7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNUggPSBhZGQ1SDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2318\n\n}')},2392:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.bytesToStr = exports.strToBytes = void 0;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n/** Turn a UTF-8 encoded string into a Uint8Array */\nfunction strToBytes(str) {\n    return encoder.encode(str);\n}\nexports.strToBytes = strToBytes;\n/** Turn a Uint8Array into a UTF-8 encoded string */\nfunction bytesToStr(bytes) {\n    return decoder.decode(bytes);\n}\nexports.bytesToStr = bytesToStr;\n//# sourceMappingURL=str.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM5Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9pby9zdHIuanM/Njc2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ5dGVzVG9TdHIgPSBleHBvcnRzLnN0clRvQnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4vKiogVHVybiBhIFVURi04IGVuY29kZWQgc3RyaW5nIGludG8gYSBVaW50OEFycmF5ICovXG5mdW5jdGlvbiBzdHJUb0J5dGVzKHN0cikge1xuICAgIHJldHVybiBlbmNvZGVyLmVuY29kZShzdHIpO1xufVxuZXhwb3J0cy5zdHJUb0J5dGVzID0gc3RyVG9CeXRlcztcbi8qKiBUdXJuIGEgVWludDhBcnJheSBpbnRvIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHIoYnl0ZXMpIHtcbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xufVxuZXhwb3J0cy5ieXRlc1RvU3RyID0gYnl0ZXNUb1N0cjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2392\n\n}')},2607:g=>{"use strict";g.exports=JSON.parse('["abdikace","abeceda","adresa","agrese","akce","aktovka","alej","alkohol","amputace","ananas","andulka","anekdota","anketa","antika","anulovat","archa","arogance","asfalt","asistent","aspirace","astma","astronom","atlas","atletika","atol","autobus","azyl","babka","bachor","bacil","baculka","badatel","bageta","bagr","bahno","bakterie","balada","baletka","balkon","balonek","balvan","balza","bambus","bankomat","barbar","baret","barman","baroko","barva","baterka","batoh","bavlna","bazalka","bazilika","bazuka","bedna","beran","beseda","bestie","beton","bezinka","bezmoc","beztak","bicykl","bidlo","biftek","bikiny","bilance","biograf","biolog","bitva","bizon","blahobyt","blatouch","blecha","bledule","blesk","blikat","blizna","blokovat","bloudit","blud","bobek","bobr","bodlina","bodnout","bohatost","bojkot","bojovat","bokorys","bolest","borec","borovice","bota","boubel","bouchat","bouda","boule","bourat","boxer","bradavka","brambora","branka","bratr","brepta","briketa","brko","brloh","bronz","broskev","brunetka","brusinka","brzda","brzy","bublina","bubnovat","buchta","buditel","budka","budova","bufet","bujarost","bukvice","buldok","bulva","bunda","bunkr","burza","butik","buvol","buzola","bydlet","bylina","bytovka","bzukot","capart","carevna","cedr","cedule","cejch","cejn","cela","celer","celkem","celnice","cenina","cennost","cenovka","centrum","cenzor","cestopis","cetka","chalupa","chapadlo","charita","chata","chechtat","chemie","chichot","chirurg","chlad","chleba","chlubit","chmel","chmura","chobot","chochol","chodba","cholera","chomout","chopit","choroba","chov","chrapot","chrlit","chrt","chrup","chtivost","chudina","chutnat","chvat","chvilka","chvost","chyba","chystat","chytit","cibule","cigareta","cihelna","cihla","cinkot","cirkus","cisterna","citace","citrus","cizinec","cizost","clona","cokoliv","couvat","ctitel","ctnost","cudnost","cuketa","cukr","cupot","cvaknout","cval","cvik","cvrkot","cyklista","daleko","dareba","datel","datum","dcera","debata","dechovka","decibel","deficit","deflace","dekl","dekret","demokrat","deprese","derby","deska","detektiv","dikobraz","diktovat","dioda","diplom","disk","displej","divadlo","divoch","dlaha","dlouho","dluhopis","dnes","dobro","dobytek","docent","dochutit","dodnes","dohled","dohoda","dohra","dojem","dojnice","doklad","dokola","doktor","dokument","dolar","doleva","dolina","doma","dominant","domluvit","domov","donutit","dopad","dopis","doplnit","doposud","doprovod","dopustit","dorazit","dorost","dort","dosah","doslov","dostatek","dosud","dosyta","dotaz","dotek","dotknout","doufat","doutnat","dovozce","dozadu","doznat","dozorce","drahota","drak","dramatik","dravec","draze","drdol","drobnost","drogerie","drozd","drsnost","drtit","drzost","duben","duchovno","dudek","duha","duhovka","dusit","dusno","dutost","dvojice","dvorec","dynamit","ekolog","ekonomie","elektron","elipsa","email","emise","emoce","empatie","epizoda","epocha","epopej","epos","esej","esence","eskorta","eskymo","etiketa","euforie","evoluce","exekuce","exkurze","expedice","exploze","export","extrakt","facka","fajfka","fakulta","fanatik","fantazie","farmacie","favorit","fazole","federace","fejeton","fenka","fialka","figurant","filozof","filtr","finance","finta","fixace","fjord","flanel","flirt","flotila","fond","fosfor","fotbal","fotka","foton","frakce","freska","fronta","fukar","funkce","fyzika","galeje","garant","genetika","geolog","gilotina","glazura","glejt","golem","golfista","gotika","graf","gramofon","granule","grep","gril","grog","groteska","guma","hadice","hadr","hala","halenka","hanba","hanopis","harfa","harpuna","havran","hebkost","hejkal","hejno","hejtman","hektar","helma","hematom","herec","herna","heslo","hezky","historik","hladovka","hlasivky","hlava","hledat","hlen","hlodavec","hloh","hloupost","hltat","hlubina","hluchota","hmat","hmota","hmyz","hnis","hnojivo","hnout","hoblina","hoboj","hoch","hodiny","hodlat","hodnota","hodovat","hojnost","hokej","holinka","holka","holub","homole","honitba","honorace","horal","horda","horizont","horko","horlivec","hormon","hornina","horoskop","horstvo","hospoda","hostina","hotovost","houba","houf","houpat","houska","hovor","hradba","hranice","hravost","hrazda","hrbolek","hrdina","hrdlo","hrdost","hrnek","hrobka","hromada","hrot","hrouda","hrozen","hrstka","hrubost","hryzat","hubenost","hubnout","hudba","hukot","humr","husita","hustota","hvozd","hybnost","hydrant","hygiena","hymna","hysterik","idylka","ihned","ikona","iluze","imunita","infekce","inflace","inkaso","inovace","inspekce","internet","invalida","investor","inzerce","ironie","jablko","jachta","jahoda","jakmile","jakost","jalovec","jantar","jarmark","jaro","jasan","jasno","jatka","javor","jazyk","jedinec","jedle","jednatel","jehlan","jekot","jelen","jelito","jemnost","jenom","jepice","jeseter","jevit","jezdec","jezero","jinak","jindy","jinoch","jiskra","jistota","jitrnice","jizva","jmenovat","jogurt","jurta","kabaret","kabel","kabinet","kachna","kadet","kadidlo","kahan","kajak","kajuta","kakao","kaktus","kalamita","kalhoty","kalibr","kalnost","kamera","kamkoliv","kamna","kanibal","kanoe","kantor","kapalina","kapela","kapitola","kapka","kaple","kapota","kapr","kapusta","kapybara","karamel","karotka","karton","kasa","katalog","katedra","kauce","kauza","kavalec","kazajka","kazeta","kazivost","kdekoliv","kdesi","kedluben","kemp","keramika","kino","klacek","kladivo","klam","klapot","klasika","klaun","klec","klenba","klepat","klesnout","klid","klima","klisna","klobouk","klokan","klopa","kloub","klubovna","klusat","kluzkost","kmen","kmitat","kmotr","kniha","knot","koalice","koberec","kobka","kobliha","kobyla","kocour","kohout","kojenec","kokos","koktejl","kolaps","koleda","kolize","kolo","komando","kometa","komik","komnata","komora","kompas","komunita","konat","koncept","kondice","konec","konfese","kongres","konina","konkurs","kontakt","konzerva","kopanec","kopie","kopnout","koprovka","korbel","korektor","kormidlo","koroptev","korpus","koruna","koryto","korzet","kosatec","kostka","kotel","kotleta","kotoul","koukat","koupelna","kousek","kouzlo","kovboj","koza","kozoroh","krabice","krach","krajina","kralovat","krasopis","kravata","kredit","krejcar","kresba","kreveta","kriket","kritik","krize","krkavec","krmelec","krmivo","krocan","krok","kronika","kropit","kroupa","krovka","krtek","kruhadlo","krupice","krutost","krvinka","krychle","krypta","krystal","kryt","kudlanka","kufr","kujnost","kukla","kulajda","kulich","kulka","kulomet","kultura","kuna","kupodivu","kurt","kurzor","kutil","kvalita","kvasinka","kvestor","kynolog","kyselina","kytara","kytice","kytka","kytovec","kyvadlo","labrador","lachtan","ladnost","laik","lakomec","lamela","lampa","lanovka","lasice","laso","lastura","latinka","lavina","lebka","leckdy","leden","lednice","ledovka","ledvina","legenda","legie","legrace","lehce","lehkost","lehnout","lektvar","lenochod","lentilka","lepenka","lepidlo","letadlo","letec","letmo","letokruh","levhart","levitace","levobok","libra","lichotka","lidojed","lidskost","lihovina","lijavec","lilek","limetka","linie","linka","linoleum","listopad","litina","litovat","lobista","lodivod","logika","logoped","lokalita","loket","lomcovat","lopata","lopuch","lord","losos","lotr","loudal","louh","louka","louskat","lovec","lstivost","lucerna","lucifer","lump","lusk","lustrace","lvice","lyra","lyrika","lysina","madam","madlo","magistr","mahagon","majetek","majitel","majorita","makak","makovice","makrela","malba","malina","malovat","malvice","maminka","mandle","manko","marnost","masakr","maskot","masopust","matice","matrika","maturita","mazanec","mazivo","mazlit","mazurka","mdloba","mechanik","meditace","medovina","melasa","meloun","mentolka","metla","metoda","metr","mezera","migrace","mihnout","mihule","mikina","mikrofon","milenec","milimetr","milost","mimika","mincovna","minibar","minomet","minulost","miska","mistr","mixovat","mladost","mlha","mlhovina","mlok","mlsat","mluvit","mnich","mnohem","mobil","mocnost","modelka","modlitba","mohyla","mokro","molekula","momentka","monarcha","monokl","monstrum","montovat","monzun","mosaz","moskyt","most","motivace","motorka","motyka","moucha","moudrost","mozaika","mozek","mozol","mramor","mravenec","mrkev","mrtvola","mrzet","mrzutost","mstitel","mudrc","muflon","mulat","mumie","munice","muset","mutace","muzeum","muzikant","myslivec","mzda","nabourat","nachytat","nadace","nadbytek","nadhoz","nadobro","nadpis","nahlas","nahnat","nahodile","nahradit","naivita","najednou","najisto","najmout","naklonit","nakonec","nakrmit","nalevo","namazat","namluvit","nanometr","naoko","naopak","naostro","napadat","napevno","naplnit","napnout","naposled","naprosto","narodit","naruby","narychlo","nasadit","nasekat","naslepo","nastat","natolik","navenek","navrch","navzdory","nazvat","nebe","nechat","necky","nedaleko","nedbat","neduh","negace","nehet","nehoda","nejen","nejprve","neklid","nelibost","nemilost","nemoc","neochota","neonka","nepokoj","nerost","nerv","nesmysl","nesoulad","netvor","neuron","nevina","nezvykle","nicota","nijak","nikam","nikdy","nikl","nikterak","nitro","nocleh","nohavice","nominace","nora","norek","nositel","nosnost","nouze","noviny","novota","nozdra","nuda","nudle","nuget","nutit","nutnost","nutrie","nymfa","obal","obarvit","obava","obdiv","obec","obehnat","obejmout","obezita","obhajoba","obilnice","objasnit","objekt","obklopit","oblast","oblek","obliba","obloha","obluda","obnos","obohatit","obojek","obout","obrazec","obrna","obruba","obrys","obsah","obsluha","obstarat","obuv","obvaz","obvinit","obvod","obvykle","obyvatel","obzor","ocas","ocel","ocenit","ochladit","ochota","ochrana","ocitnout","odboj","odbyt","odchod","odcizit","odebrat","odeslat","odevzdat","odezva","odhadce","odhodit","odjet","odjinud","odkaz","odkoupit","odliv","odluka","odmlka","odolnost","odpad","odpis","odplout","odpor","odpustit","odpykat","odrazka","odsoudit","odstup","odsun","odtok","odtud","odvaha","odveta","odvolat","odvracet","odznak","ofina","ofsajd","ohlas","ohnisko","ohrada","ohrozit","ohryzek","okap","okenice","oklika","okno","okouzlit","okovy","okrasa","okres","okrsek","okruh","okupant","okurka","okusit","olejnina","olizovat","omak","omeleta","omezit","omladina","omlouvat","omluva","omyl","onehdy","opakovat","opasek","operace","opice","opilost","opisovat","opora","opozice","opravdu","oproti","orbital","orchestr","orgie","orlice","orloj","ortel","osada","oschnout","osika","osivo","oslava","oslepit","oslnit","oslovit","osnova","osoba","osolit","ospalec","osten","ostraha","ostuda","ostych","osvojit","oteplit","otisk","otop","otrhat","otrlost","otrok","otruby","otvor","ovanout","ovar","oves","ovlivnit","ovoce","oxid","ozdoba","pachatel","pacient","padouch","pahorek","pakt","palanda","palec","palivo","paluba","pamflet","pamlsek","panenka","panika","panna","panovat","panstvo","pantofle","paprika","parketa","parodie","parta","paruka","paryba","paseka","pasivita","pastelka","patent","patrona","pavouk","pazneht","pazourek","pecka","pedagog","pejsek","peklo","peloton","penalta","pendrek","penze","periskop","pero","pestrost","petarda","petice","petrolej","pevnina","pexeso","pianista","piha","pijavice","pikle","piknik","pilina","pilnost","pilulka","pinzeta","pipeta","pisatel","pistole","pitevna","pivnice","pivovar","placenta","plakat","plamen","planeta","plastika","platit","plavidlo","plaz","plech","plemeno","plenta","ples","pletivo","plevel","plivat","plnit","plno","plocha","plodina","plomba","plout","pluk","plyn","pobavit","pobyt","pochod","pocit","poctivec","podat","podcenit","podepsat","podhled","podivit","podklad","podmanit","podnik","podoba","podpora","podraz","podstata","podvod","podzim","poezie","pohanka","pohnutka","pohovor","pohroma","pohyb","pointa","pojistka","pojmout","pokazit","pokles","pokoj","pokrok","pokuta","pokyn","poledne","polibek","polknout","poloha","polynom","pomalu","pominout","pomlka","pomoc","pomsta","pomyslet","ponechat","ponorka","ponurost","popadat","popel","popisek","poplach","poprosit","popsat","popud","poradce","porce","porod","porucha","poryv","posadit","posed","posila","poskok","poslanec","posoudit","pospolu","postava","posudek","posyp","potah","potkan","potlesk","potomek","potrava","potupa","potvora","poukaz","pouto","pouzdro","povaha","povidla","povlak","povoz","povrch","povstat","povyk","povzdech","pozdrav","pozemek","poznatek","pozor","pozvat","pracovat","prahory","praktika","prales","praotec","praporek","prase","pravda","princip","prkno","probudit","procento","prodej","profese","prohra","projekt","prolomit","promile","pronikat","propad","prorok","prosba","proton","proutek","provaz","prskavka","prsten","prudkost","prut","prvek","prvohory","psanec","psovod","pstruh","ptactvo","puberta","puch","pudl","pukavec","puklina","pukrle","pult","pumpa","punc","pupen","pusa","pusinka","pustina","putovat","putyka","pyramida","pysk","pytel","racek","rachot","radiace","radnice","radon","raft","ragby","raketa","rakovina","rameno","rampouch","rande","rarach","rarita","rasovna","rastr","ratolest","razance","razidlo","reagovat","reakce","recept","redaktor","referent","reflex","rejnok","reklama","rekord","rekrut","rektor","reputace","revize","revma","revolver","rezerva","riskovat","riziko","robotika","rodokmen","rohovka","rokle","rokoko","romaneto","ropovod","ropucha","rorejs","rosol","rostlina","rotmistr","rotoped","rotunda","roubenka","roucho","roup","roura","rovina","rovnice","rozbor","rozchod","rozdat","rozeznat","rozhodce","rozinka","rozjezd","rozkaz","rozloha","rozmar","rozpad","rozruch","rozsah","roztok","rozum","rozvod","rubrika","ruchadlo","rukavice","rukopis","ryba","rybolov","rychlost","rydlo","rypadlo","rytina","ryzost","sadista","sahat","sako","samec","samizdat","samota","sanitka","sardinka","sasanka","satelit","sazba","sazenice","sbor","schovat","sebranka","secese","sedadlo","sediment","sedlo","sehnat","sejmout","sekera","sekta","sekunda","sekvoje","semeno","seno","servis","sesadit","seshora","seskok","seslat","sestra","sesuv","sesypat","setba","setina","setkat","setnout","setrvat","sever","seznam","shoda","shrnout","sifon","silnice","sirka","sirotek","sirup","situace","skafandr","skalisko","skanzen","skaut","skeptik","skica","skladba","sklenice","sklo","skluz","skoba","skokan","skoro","skripta","skrz","skupina","skvost","skvrna","slabika","sladidlo","slanina","slast","slavnost","sledovat","slepec","sleva","slezina","slib","slina","sliznice","slon","sloupek","slovo","sluch","sluha","slunce","slupka","slza","smaragd","smetana","smilstvo","smlouva","smog","smrad","smrk","smrtka","smutek","smysl","snad","snaha","snob","sobota","socha","sodovka","sokol","sopka","sotva","souboj","soucit","soudce","souhlas","soulad","soumrak","souprava","soused","soutok","souviset","spalovna","spasitel","spis","splav","spodek","spojenec","spolu","sponzor","spornost","spousta","sprcha","spustit","sranda","sraz","srdce","srna","srnec","srovnat","srpen","srst","srub","stanice","starosta","statika","stavba","stehno","stezka","stodola","stolek","stopa","storno","stoupat","strach","stres","strhnout","strom","struna","studna","stupnice","stvol","styk","subjekt","subtropy","suchar","sudost","sukno","sundat","sunout","surikata","surovina","svah","svalstvo","svetr","svatba","svazek","svisle","svitek","svoboda","svodidlo","svorka","svrab","sykavka","sykot","synek","synovec","sypat","sypkost","syrovost","sysel","sytost","tabletka","tabule","tahoun","tajemno","tajfun","tajga","tajit","tajnost","taktika","tamhle","tampon","tancovat","tanec","tanker","tapeta","tavenina","tazatel","technika","tehdy","tekutina","telefon","temnota","tendence","tenista","tenor","teplota","tepna","teprve","terapie","termoska","textil","ticho","tiskopis","titulek","tkadlec","tkanina","tlapka","tleskat","tlukot","tlupa","tmel","toaleta","topinka","topol","torzo","touha","toulec","tradice","traktor","tramp","trasa","traverza","trefit","trest","trezor","trhavina","trhlina","trochu","trojice","troska","trouba","trpce","trpitel","trpkost","trubec","truchlit","truhlice","trus","trvat","tudy","tuhnout","tuhost","tundra","turista","turnaj","tuzemsko","tvaroh","tvorba","tvrdost","tvrz","tygr","tykev","ubohost","uboze","ubrat","ubrousek","ubrus","ubytovna","ucho","uctivost","udivit","uhradit","ujednat","ujistit","ujmout","ukazatel","uklidnit","uklonit","ukotvit","ukrojit","ulice","ulita","ulovit","umyvadlo","unavit","uniforma","uniknout","upadnout","uplatnit","uplynout","upoutat","upravit","uran","urazit","usednout","usilovat","usmrtit","usnadnit","usnout","usoudit","ustlat","ustrnout","utahovat","utkat","utlumit","utonout","utopenec","utrousit","uvalit","uvolnit","uvozovka","uzdravit","uzel","uzenina","uzlina","uznat","vagon","valcha","valoun","vana","vandal","vanilka","varan","varhany","varovat","vcelku","vchod","vdova","vedro","vegetace","vejce","velbloud","veletrh","velitel","velmoc","velryba","venkov","veranda","verze","veselka","veskrze","vesnice","vespodu","vesta","veterina","veverka","vibrace","vichr","videohra","vidina","vidle","vila","vinice","viset","vitalita","vize","vizitka","vjezd","vklad","vkus","vlajka","vlak","vlasec","vlevo","vlhkost","vliv","vlnovka","vloupat","vnucovat","vnuk","voda","vodivost","vodoznak","vodstvo","vojensky","vojna","vojsko","volant","volba","volit","volno","voskovka","vozidlo","vozovna","vpravo","vrabec","vracet","vrah","vrata","vrba","vrcholek","vrhat","vrstva","vrtule","vsadit","vstoupit","vstup","vtip","vybavit","vybrat","vychovat","vydat","vydra","vyfotit","vyhledat","vyhnout","vyhodit","vyhradit","vyhubit","vyjasnit","vyjet","vyjmout","vyklopit","vykonat","vylekat","vymazat","vymezit","vymizet","vymyslet","vynechat","vynikat","vynutit","vypadat","vyplatit","vypravit","vypustit","vyrazit","vyrovnat","vyrvat","vyslovit","vysoko","vystavit","vysunout","vysypat","vytasit","vytesat","vytratit","vyvinout","vyvolat","vyvrhel","vyzdobit","vyznat","vzadu","vzbudit","vzchopit","vzdor","vzduch","vzdychat","vzestup","vzhledem","vzkaz","vzlykat","vznik","vzorek","vzpoura","vztah","vztek","xylofon","zabrat","zabydlet","zachovat","zadarmo","zadusit","zafoukat","zahltit","zahodit","zahrada","zahynout","zajatec","zajet","zajistit","zaklepat","zakoupit","zalepit","zamezit","zamotat","zamyslet","zanechat","zanikat","zaplatit","zapojit","zapsat","zarazit","zastavit","zasunout","zatajit","zatemnit","zatknout","zaujmout","zavalit","zavelet","zavinit","zavolat","zavrtat","zazvonit","zbavit","zbrusu","zbudovat","zbytek","zdaleka","zdarma","zdatnost","zdivo","zdobit","zdroj","zdvih","zdymadlo","zelenina","zeman","zemina","zeptat","zezadu","zezdola","zhatit","zhltnout","zhluboka","zhotovit","zhruba","zima","zimnice","zjemnit","zklamat","zkoumat","zkratka","zkumavka","zlato","zlehka","zloba","zlom","zlost","zlozvyk","zmapovat","zmar","zmatek","zmije","zmizet","zmocnit","zmodrat","zmrzlina","zmutovat","znak","znalost","znamenat","znovu","zobrazit","zotavit","zoubek","zoufale","zplodit","zpomalit","zprava","zprostit","zprudka","zprvu","zrada","zranit","zrcadlo","zrnitost","zrno","zrovna","zrychlit","zrzavost","zticha","ztratit","zubovina","zubr","zvednout","zvenku","zvesela","zvon","zvrat","zvukovod","zvyk"]')},2623:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nconst sha2_ts_1 = __webpack_require__(7076);\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA256 = sha2_ts_1.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha256 = sha2_ts_1.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA224 = sha2_ts_1.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha224 = sha2_ts_1.sha224;\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYyMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsSUFBVztBQUNyQztBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanM/ZDEyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5TSEEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMuU0hBMjU2ID0gdm9pZCAwO1xuLyoqXG4gKiBTSEEyLTI1NiBhLmsuYS4gc2hhMjU2LiBJbiBKUywgaXQgaXMgdGhlIGZhc3Rlc3QgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKlxuICogVG8gYnJlYWsgc2hhMjU2IHVzaW5nIGJpcnRoZGF5IGF0dGFjaywgYXR0YWNrZXJzIG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcy5cbiAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTIDE4MC00XShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmKS5cbiAqIEBtb2R1bGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IHNoYTJfdHNfMSA9IHJlcXVpcmUoXCIuL3NoYTIuanNcIik7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLlNIQTI1NiA9IHNoYTJfdHNfMS5TSEEyNTY7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLnNoYTI1NiA9IHNoYTJfdHNfMS5zaGEyNTY7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLlNIQTIyNCA9IHNoYTJfdHNfMS5TSEEyMjQ7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLnNoYTIyNCA9IHNoYTJfdHNfMS5zaGEyMjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2623\n\n}')},2726:(__unused_webpack_module,exports)=>{eval("{function hex2rgba (hex) {\n  if (typeof hex === 'number') {\n    hex = hex.toString()\n  }\n\n  if (typeof hex !== 'string') {\n    throw new Error('Color should be defined as hex string')\n  }\n\n  let hexCode = hex.slice().replace('#', '').split('')\n  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n    throw new Error('Invalid hex color: ' + hex)\n  }\n\n  // Convert from short to long form (fff -> ffffff)\n  if (hexCode.length === 3 || hexCode.length === 4) {\n    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n      return [c, c]\n    }))\n  }\n\n  // Add default alpha value\n  if (hexCode.length === 6) hexCode.push('F', 'F')\n\n  const hexValue = parseInt(hexCode.join(''), 16)\n\n  return {\n    r: (hexValue >> 24) & 255,\n    g: (hexValue >> 16) & 255,\n    b: (hexValue >> 8) & 255,\n    a: hexValue & 255,\n    hex: '#' + hexCode.slice(0, 6).join('')\n  }\n}\n\nexports.getOptions = function getOptions (options) {\n  if (!options) options = {}\n  if (!options.color) options.color = {}\n\n  const margin = typeof options.margin === 'undefined' ||\n    options.margin === null ||\n    options.margin < 0\n    ? 4\n    : options.margin\n\n  const width = options.width && options.width >= 21 ? options.width : undefined\n  const scale = options.scale || 4\n\n  return {\n    width: width,\n    scale: width ? 4 : scale,\n    margin: margin,\n    color: {\n      dark: hex2rgba(options.color.dark || '#000000ff'),\n      light: hex2rgba(options.color.light || '#ffffffff')\n    },\n    type: options.type,\n    rendererOpts: options.rendererOpts || {}\n  }\n}\n\nexports.getScale = function getScale (qrSize, opts) {\n  return opts.width && opts.width >= qrSize + opts.margin * 2\n    ? opts.width / (qrSize + opts.margin * 2)\n    : opts.scale\n}\n\nexports.getImageWidth = function getImageWidth (qrSize, opts) {\n  const scale = exports.getScale(qrSize, opts)\n  return Math.floor((qrSize + opts.margin * 2) * scale)\n}\n\nexports.qrToImageData = function qrToImageData (imgData, qr, opts) {\n  const size = qr.modules.size\n  const data = qr.modules.data\n  const scale = exports.getScale(size, opts)\n  const symbolSize = Math.floor((size + opts.margin * 2) * scale)\n  const scaledMargin = opts.margin * scale\n  const palette = [opts.color.light, opts.color.dark]\n\n  for (let i = 0; i < symbolSize; i++) {\n    for (let j = 0; j < symbolSize; j++) {\n      let posDst = (i * symbolSize + j) * 4\n      let pxColor = opts.color.light\n\n      if (i >= scaledMargin && j >= scaledMargin &&\n        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n        const iSrc = Math.floor((i - scaledMargin) / scale)\n        const jSrc = Math.floor((j - scaledMargin) / scale)\n        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0]\n      }\n\n      imgData[posDst++] = pxColor.r\n      imgData[posDst++] = pxColor.g\n      imgData[posDst++] = pxColor.b\n      imgData[posDst] = pxColor.a\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcyNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEMsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9yZW5kZXJlci91dGlscy5qcz80NWJlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGhleDJyZ2JhIChoZXgpIHtcbiAgaWYgKHR5cGVvZiBoZXggPT09ICdudW1iZXInKSB7XG4gICAgaGV4ID0gaGV4LnRvU3RyaW5nKClcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29sb3Igc2hvdWxkIGJlIGRlZmluZWQgYXMgaGV4IHN0cmluZycpXG4gIH1cblxuICBsZXQgaGV4Q29kZSA9IGhleC5zbGljZSgpLnJlcGxhY2UoJyMnLCAnJykuc3BsaXQoJycpXG4gIGlmIChoZXhDb2RlLmxlbmd0aCA8IDMgfHwgaGV4Q29kZS5sZW5ndGggPT09IDUgfHwgaGV4Q29kZS5sZW5ndGggPiA4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBjb2xvcjogJyArIGhleClcbiAgfVxuXG4gIC8vIENvbnZlcnQgZnJvbSBzaG9ydCB0byBsb25nIGZvcm0gKGZmZiAtPiBmZmZmZmYpXG4gIGlmIChoZXhDb2RlLmxlbmd0aCA9PT0gMyB8fCBoZXhDb2RlLmxlbmd0aCA9PT0gNCkge1xuICAgIGhleENvZGUgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBoZXhDb2RlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIFtjLCBjXVxuICAgIH0pKVxuICB9XG5cbiAgLy8gQWRkIGRlZmF1bHQgYWxwaGEgdmFsdWVcbiAgaWYgKGhleENvZGUubGVuZ3RoID09PSA2KSBoZXhDb2RlLnB1c2goJ0YnLCAnRicpXG5cbiAgY29uc3QgaGV4VmFsdWUgPSBwYXJzZUludChoZXhDb2RlLmpvaW4oJycpLCAxNilcblxuICByZXR1cm4ge1xuICAgIHI6IChoZXhWYWx1ZSA+PiAyNCkgJiAyNTUsXG4gICAgZzogKGhleFZhbHVlID4+IDE2KSAmIDI1NSxcbiAgICBiOiAoaGV4VmFsdWUgPj4gOCkgJiAyNTUsXG4gICAgYTogaGV4VmFsdWUgJiAyNTUsXG4gICAgaGV4OiAnIycgKyBoZXhDb2RlLnNsaWNlKDAsIDYpLmpvaW4oJycpXG4gIH1cbn1cblxuZXhwb3J0cy5nZXRPcHRpb25zID0gZnVuY3Rpb24gZ2V0T3B0aW9ucyAob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuICBpZiAoIW9wdGlvbnMuY29sb3IpIG9wdGlvbnMuY29sb3IgPSB7fVxuXG4gIGNvbnN0IG1hcmdpbiA9IHR5cGVvZiBvcHRpb25zLm1hcmdpbiA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICBvcHRpb25zLm1hcmdpbiA9PT0gbnVsbCB8fFxuICAgIG9wdGlvbnMubWFyZ2luIDwgMFxuICAgID8gNFxuICAgIDogb3B0aW9ucy5tYXJnaW5cblxuICBjb25zdCB3aWR0aCA9IG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy53aWR0aCA+PSAyMSA/IG9wdGlvbnMud2lkdGggOiB1bmRlZmluZWRcbiAgY29uc3Qgc2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IDRcblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBzY2FsZTogd2lkdGggPyA0IDogc2NhbGUsXG4gICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgY29sb3I6IHtcbiAgICAgIGRhcms6IGhleDJyZ2JhKG9wdGlvbnMuY29sb3IuZGFyayB8fCAnIzAwMDAwMGZmJyksXG4gICAgICBsaWdodDogaGV4MnJnYmEob3B0aW9ucy5jb2xvci5saWdodCB8fCAnI2ZmZmZmZmZmJylcbiAgICB9LFxuICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcbiAgICByZW5kZXJlck9wdHM6IG9wdGlvbnMucmVuZGVyZXJPcHRzIHx8IHt9XG4gIH1cbn1cblxuZXhwb3J0cy5nZXRTY2FsZSA9IGZ1bmN0aW9uIGdldFNjYWxlIChxclNpemUsIG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMud2lkdGggJiYgb3B0cy53aWR0aCA+PSBxclNpemUgKyBvcHRzLm1hcmdpbiAqIDJcbiAgICA/IG9wdHMud2lkdGggLyAocXJTaXplICsgb3B0cy5tYXJnaW4gKiAyKVxuICAgIDogb3B0cy5zY2FsZVxufVxuXG5leHBvcnRzLmdldEltYWdlV2lkdGggPSBmdW5jdGlvbiBnZXRJbWFnZVdpZHRoIChxclNpemUsIG9wdHMpIHtcbiAgY29uc3Qgc2NhbGUgPSBleHBvcnRzLmdldFNjYWxlKHFyU2l6ZSwgb3B0cylcbiAgcmV0dXJuIE1hdGguZmxvb3IoKHFyU2l6ZSArIG9wdHMubWFyZ2luICogMikgKiBzY2FsZSlcbn1cblxuZXhwb3J0cy5xclRvSW1hZ2VEYXRhID0gZnVuY3Rpb24gcXJUb0ltYWdlRGF0YSAoaW1nRGF0YSwgcXIsIG9wdHMpIHtcbiAgY29uc3Qgc2l6ZSA9IHFyLm1vZHVsZXMuc2l6ZVxuICBjb25zdCBkYXRhID0gcXIubW9kdWxlcy5kYXRhXG4gIGNvbnN0IHNjYWxlID0gZXhwb3J0cy5nZXRTY2FsZShzaXplLCBvcHRzKVxuICBjb25zdCBzeW1ib2xTaXplID0gTWF0aC5mbG9vcigoc2l6ZSArIG9wdHMubWFyZ2luICogMikgKiBzY2FsZSlcbiAgY29uc3Qgc2NhbGVkTWFyZ2luID0gb3B0cy5tYXJnaW4gKiBzY2FsZVxuICBjb25zdCBwYWxldHRlID0gW29wdHMuY29sb3IubGlnaHQsIG9wdHMuY29sb3IuZGFya11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN5bWJvbFNpemU7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3ltYm9sU2l6ZTsgaisrKSB7XG4gICAgICBsZXQgcG9zRHN0ID0gKGkgKiBzeW1ib2xTaXplICsgaikgKiA0XG4gICAgICBsZXQgcHhDb2xvciA9IG9wdHMuY29sb3IubGlnaHRcblxuICAgICAgaWYgKGkgPj0gc2NhbGVkTWFyZ2luICYmIGogPj0gc2NhbGVkTWFyZ2luICYmXG4gICAgICAgIGkgPCBzeW1ib2xTaXplIC0gc2NhbGVkTWFyZ2luICYmIGogPCBzeW1ib2xTaXplIC0gc2NhbGVkTWFyZ2luKSB7XG4gICAgICAgIGNvbnN0IGlTcmMgPSBNYXRoLmZsb29yKChpIC0gc2NhbGVkTWFyZ2luKSAvIHNjYWxlKVxuICAgICAgICBjb25zdCBqU3JjID0gTWF0aC5mbG9vcigoaiAtIHNjYWxlZE1hcmdpbikgLyBzY2FsZSlcbiAgICAgICAgcHhDb2xvciA9IHBhbGV0dGVbZGF0YVtpU3JjICogc2l6ZSArIGpTcmNdID8gMSA6IDBdXG4gICAgICB9XG5cbiAgICAgIGltZ0RhdGFbcG9zRHN0KytdID0gcHhDb2xvci5yXG4gICAgICBpbWdEYXRhW3Bvc0RzdCsrXSA9IHB4Q29sb3IuZ1xuICAgICAgaW1nRGF0YVtwb3NEc3QrK10gPSBweENvbG9yLmJcbiAgICAgIGltZ0RhdGFbcG9zRHN0XSA9IHB4Q29sb3IuYVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2726\n\n}")},2731:(__unused_webpack_module,exports)=>{eval("{const EXP_TABLE = new Uint8Array(512)\nconst LOG_TABLE = new Uint8Array(256)\n/**\n * Precompute the log and anti-log tables for faster computation later\n *\n * For each possible value in the galois field 2^8, we will pre-compute\n * the logarithm and anti-logarithm (exponential) of this value\n *\n * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}\n */\n;(function initTables () {\n  let x = 1\n  for (let i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x\n    LOG_TABLE[x] = i\n\n    x <<= 1 // multiply by 2\n\n    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n    // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n      x ^= 0x11D\n    }\n  }\n\n  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n  // stay inside the bounds (because we will mainly use this table for the multiplication of\n  // two GF numbers, no more).\n  // @see {@link mul}\n  for (let i = 255; i < 512; i++) {\n    EXP_TABLE[i] = EXP_TABLE[i - 255]\n  }\n}())\n\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.log = function log (n) {\n  if (n < 1) throw new Error('log(' + n + ')')\n  return LOG_TABLE[n]\n}\n\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.exp = function exp (n) {\n  return EXP_TABLE[n]\n}\n\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nexports.mul = function mul (x, y) {\n  if (x === 0 || y === 0) return 0\n\n  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n  // @see {@link initTables}\n  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjczMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvY29yZS9nYWxvaXMtZmllbGQuanM/Njk5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFWFBfVEFCTEUgPSBuZXcgVWludDhBcnJheSg1MTIpXG5jb25zdCBMT0dfVEFCTEUgPSBuZXcgVWludDhBcnJheSgyNTYpXG4vKipcbiAqIFByZWNvbXB1dGUgdGhlIGxvZyBhbmQgYW50aS1sb2cgdGFibGVzIGZvciBmYXN0ZXIgY29tcHV0YXRpb24gbGF0ZXJcbiAqXG4gKiBGb3IgZWFjaCBwb3NzaWJsZSB2YWx1ZSBpbiB0aGUgZ2Fsb2lzIGZpZWxkIDJeOCwgd2Ugd2lsbCBwcmUtY29tcHV0ZVxuICogdGhlIGxvZ2FyaXRobSBhbmQgYW50aS1sb2dhcml0aG0gKGV4cG9uZW50aWFsKSBvZiB0aGlzIHZhbHVlXG4gKlxuICogcmVmIHtAbGluayBodHRwczovL2VuLndpa2l2ZXJzaXR5Lm9yZy93aWtpL1JlZWQlRTIlODAlOTNTb2xvbW9uX2NvZGVzX2Zvcl9jb2RlcnMjSW50cm9kdWN0aW9uX3RvX21hdGhlbWF0aWNhbF9maWVsZHN9XG4gKi9cbjsoZnVuY3Rpb24gaW5pdFRhYmxlcyAoKSB7XG4gIGxldCB4ID0gMVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG4gICAgRVhQX1RBQkxFW2ldID0geFxuICAgIExPR19UQUJMRVt4XSA9IGlcblxuICAgIHggPDw9IDEgLy8gbXVsdGlwbHkgYnkgMlxuXG4gICAgLy8gVGhlIFFSIGNvZGUgc3BlY2lmaWNhdGlvbiBzYXlzIHRvIHVzZSBieXRlLXdpc2UgbW9kdWxvIDEwMDAxMTEwMSBhcml0aG1ldGljLlxuICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3aGVuIGEgbnVtYmVyIGlzIDI1NiBvciBsYXJnZXIsIGl0IHNob3VsZCBiZSBYT1JlZCB3aXRoIDB4MTFELlxuICAgIGlmICh4ICYgMHgxMDApIHsgLy8gc2ltaWxhciB0byB4ID49IDI1NiwgYnV0IGEgbG90IGZhc3RlciAoYmVjYXVzZSAweDEwMCA9PSAyNTYpXG4gICAgICB4IF49IDB4MTFEXG4gICAgfVxuICB9XG5cbiAgLy8gT3B0aW1pemF0aW9uOiBkb3VibGUgdGhlIHNpemUgb2YgdGhlIGFudGktbG9nIHRhYmxlIHNvIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBtb2QgMjU1IHRvXG4gIC8vIHN0YXkgaW5zaWRlIHRoZSBib3VuZHMgKGJlY2F1c2Ugd2Ugd2lsbCBtYWlubHkgdXNlIHRoaXMgdGFibGUgZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBvZlxuICAvLyB0d28gR0YgbnVtYmVycywgbm8gbW9yZSkuXG4gIC8vIEBzZWUge0BsaW5rIG11bH1cbiAgZm9yIChsZXQgaSA9IDI1NTsgaSA8IDUxMjsgaSsrKSB7XG4gICAgRVhQX1RBQkxFW2ldID0gRVhQX1RBQkxFW2kgLSAyNTVdXG4gIH1cbn0oKSlcblxuLyoqXG4gKiBSZXR1cm5zIGxvZyB2YWx1ZSBvZiBuIGluc2lkZSBHYWxvaXMgRmllbGRcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbiBsb2cgKG4pIHtcbiAgaWYgKG4gPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ2xvZygnICsgbiArICcpJylcbiAgcmV0dXJuIExPR19UQUJMRVtuXVxufVxuXG4vKipcbiAqIFJldHVybnMgYW50aS1sb2cgdmFsdWUgb2YgbiBpbnNpZGUgR2Fsb2lzIEZpZWxkXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydHMuZXhwID0gZnVuY3Rpb24gZXhwIChuKSB7XG4gIHJldHVybiBFWFBfVEFCTEVbbl1cbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBudW1iZXIgaW5zaWRlIEdhbG9pcyBGaWVsZFxuICpcbiAqIEBwYXJhbSAge051bWJlcn0geFxuICogQHBhcmFtICB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydHMubXVsID0gZnVuY3Rpb24gbXVsICh4LCB5KSB7XG4gIGlmICh4ID09PSAwIHx8IHkgPT09IDApIHJldHVybiAwXG5cbiAgLy8gc2hvdWxkIGJlIEVYUF9UQUJMRVsoTE9HX1RBQkxFW3hdICsgTE9HX1RBQkxFW3ldKSAlIDI1NV0gaWYgRVhQX1RBQkxFIHdhc24ndCBvdmVyc2l6ZWRcbiAgLy8gQHNlZSB7QGxpbmsgaW5pdFRhYmxlc31cbiAgcmV0dXJuIEVYUF9UQUJMRVtMT0dfVEFCTEVbeF0gKyBMT0dfVEFCTEVbeV1dXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2731\n\n}")},2861:(module,exports,__webpack_require__)=>{eval("{/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(8287)\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxJQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUUsY0FBYztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzPzg3MDciXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2861\n\n}")},2938:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2023-2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromHexRev = exports.fromHex = exports.toHexRev = exports.toHex = void 0;\nconst LUT_HEX_4b = [\n    '0',\n    '1',\n    '2',\n    '3',\n    '4',\n    '5',\n    '6',\n    '7',\n    '8',\n    '9',\n    'a',\n    'b',\n    'c',\n    'd',\n    'e',\n    'f',\n];\nconst LUT_HEX_8b = new Array(0x100);\nconst LUT_BIN_8b = {};\nfor (let n = 0; n < 0x100; n++) {\n    const hex = `${LUT_HEX_4b[(n >>> 4) & 0xf]}${LUT_HEX_4b[n & 0xf]}`;\n    LUT_HEX_8b[n] = hex;\n    LUT_BIN_8b[hex] = n;\n}\n// End Pre-Init\nfunction toHex(buffer) {\n    let out = '';\n    for (let idx = 0, edx = buffer.length; idx < edx; ++idx) {\n        out += LUT_HEX_8b[buffer[idx]];\n    }\n    return out;\n}\nexports.toHex = toHex;\nfunction toHexRev(buffer) {\n    let out = '';\n    for (let idx = buffer.length - 1; idx >= 0; --idx) {\n        out += LUT_HEX_8b[buffer[idx]];\n    }\n    return out;\n}\nexports.toHexRev = toHexRev;\nfunction fromHex(str) {\n    if ((str.length & 1) != 0) {\n        throw new Error(`Odd hex length: ${str}`);\n    }\n    const nBytes = str.length >> 1;\n    const array = new Uint8Array(nBytes);\n    for (let idx = 0; idx < str.length; idx += 2) {\n        const pair = str.substring(idx, idx + 2);\n        const byte = LUT_BIN_8b[pair];\n        if (byte === undefined) {\n            throw new Error(`Invalid hex pair: ${pair}, at index ${idx}`);\n        }\n        array[idx >> 1] = byte;\n    }\n    return array;\n}\nexports.fromHex = fromHex;\nfunction fromHexRev(str) {\n    const array = fromHex(str);\n    array.reverse();\n    return array;\n}\nexports.fromHexRev = fromHexRev;\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkzOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxlQUFlLEdBQUcsZ0JBQWdCLEdBQUcsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsbUJBQW1CLDRCQUE0QixFQUFFLG9CQUFvQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUssYUFBYSxJQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvaW8vaGV4LmpzP2M5ZjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjMtMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21IZXhSZXYgPSBleHBvcnRzLmZyb21IZXggPSBleHBvcnRzLnRvSGV4UmV2ID0gZXhwb3J0cy50b0hleCA9IHZvaWQgMDtcbmNvbnN0IExVVF9IRVhfNGIgPSBbXG4gICAgJzAnLFxuICAgICcxJyxcbiAgICAnMicsXG4gICAgJzMnLFxuICAgICc0JyxcbiAgICAnNScsXG4gICAgJzYnLFxuICAgICc3JyxcbiAgICAnOCcsXG4gICAgJzknLFxuICAgICdhJyxcbiAgICAnYicsXG4gICAgJ2MnLFxuICAgICdkJyxcbiAgICAnZScsXG4gICAgJ2YnLFxuXTtcbmNvbnN0IExVVF9IRVhfOGIgPSBuZXcgQXJyYXkoMHgxMDApO1xuY29uc3QgTFVUX0JJTl84YiA9IHt9O1xuZm9yIChsZXQgbiA9IDA7IG4gPCAweDEwMDsgbisrKSB7XG4gICAgY29uc3QgaGV4ID0gYCR7TFVUX0hFWF80YlsobiA+Pj4gNCkgJiAweGZdfSR7TFVUX0hFWF80YltuICYgMHhmXX1gO1xuICAgIExVVF9IRVhfOGJbbl0gPSBoZXg7XG4gICAgTFVUX0JJTl84YltoZXhdID0gbjtcbn1cbi8vIEVuZCBQcmUtSW5pdFxuZnVuY3Rpb24gdG9IZXgoYnVmZmVyKSB7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGZvciAobGV0IGlkeCA9IDAsIGVkeCA9IGJ1ZmZlci5sZW5ndGg7IGlkeCA8IGVkeDsgKytpZHgpIHtcbiAgICAgICAgb3V0ICs9IExVVF9IRVhfOGJbYnVmZmVyW2lkeF1dO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuZnVuY3Rpb24gdG9IZXhSZXYoYnVmZmVyKSB7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGZvciAobGV0IGlkeCA9IGJ1ZmZlci5sZW5ndGggLSAxOyBpZHggPj0gMDsgLS1pZHgpIHtcbiAgICAgICAgb3V0ICs9IExVVF9IRVhfOGJbYnVmZmVyW2lkeF1dO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy50b0hleFJldiA9IHRvSGV4UmV2O1xuZnVuY3Rpb24gZnJvbUhleChzdHIpIHtcbiAgICBpZiAoKHN0ci5sZW5ndGggJiAxKSAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgT2RkIGhleCBsZW5ndGg6ICR7c3RyfWApO1xuICAgIH1cbiAgICBjb25zdCBuQnl0ZXMgPSBzdHIubGVuZ3RoID4+IDE7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShuQnl0ZXMpO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHN0ci5sZW5ndGg7IGlkeCArPSAyKSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBzdHIuc3Vic3RyaW5nKGlkeCwgaWR4ICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBMVVRfQklOXzhiW3BhaXJdO1xuICAgICAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaGV4IHBhaXI6ICR7cGFpcn0sIGF0IGluZGV4ICR7aWR4fWApO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2lkeCA+PiAxXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5mdW5jdGlvbiBmcm9tSGV4UmV2KHN0cikge1xuICAgIGNvbnN0IGFycmF5ID0gZnJvbUhleChzdHIpO1xuICAgIGFycmF5LnJldmVyc2UoKTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmZyb21IZXhSZXYgPSBmcm9tSGV4UmV2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2938\n\n}")},3085:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address = exports.DEFAULT_PREFIX = exports.toLegacyAddress = exports.ECASH_PREFIXES_TESTNET = void 0;\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nconst hex_1 = __webpack_require__(2938);\nconst ecashaddrjs_1 = __webpack_require__(6942);\nconst legacyaddr_1 = __webpack_require__(2313);\nconst script_1 = __webpack_require__(6187);\nexports.ECASH_PREFIXES_TESTNET = ['ectest', 'ecregtest'];\n/**\n * Converts an ecash address in cashaddr format to legacy format\n * Throws if user attempts to convert a legacy address to a legacy address\n * Separated as its own function here for\n *\n * 1 - simpler unit testing\n * 2 - exported for users looking to convert string cashaddr to string legacy addr\n *     without using the Address class\n */\nconst toLegacyAddress = (cashaddress) => {\n    try {\n        // No-op if user is trying to convert legacy to legacy\n        (0, legacyaddr_1.decodeLegacyAddress)(cashaddress);\n        return cashaddress;\n    }\n    catch {\n        // Do nothing with this error since we expect it every time for the function's intended use case\n        // Proceed to convert to legacy\n    }\n    const { prefix, type, hash } = (0, ecashaddrjs_1.decodeCashAddress)(cashaddress);\n    const isTestnet = exports.ECASH_PREFIXES_TESTNET.includes(prefix);\n    // Get correct version byte for legacy format\n    let versionByte;\n    switch (type) {\n        case 'p2pkh':\n            versionByte = isTestnet\n                ? legacyaddr_1.LEGACY_VERSION_BYTES.legacy.testnet.p2pkh\n                : legacyaddr_1.LEGACY_VERSION_BYTES.legacy.mainnet.p2pkh;\n            break;\n        case 'p2sh':\n            versionByte = isTestnet\n                ? legacyaddr_1.LEGACY_VERSION_BYTES.legacy.testnet.p2sh\n                : legacyaddr_1.LEGACY_VERSION_BYTES.legacy.mainnet.p2sh;\n            break;\n        default:\n            throw new Error('Unsupported address type: ' + type);\n    }\n    // Convert hash to Uint8Array\n    const hashArray = (0, hex_1.fromHex)(hash);\n    // Create a new Uint8Array to hold the data\n    const uint8Array = new Uint8Array(1 + hashArray.length);\n    // Set the version byte\n    uint8Array[0] = versionByte;\n    // Set the hash\n    uint8Array.set(hashArray, 1);\n    // Encode to base58check\n    return (0, legacyaddr_1.encodeBase58Check)(uint8Array);\n};\nexports.toLegacyAddress = toLegacyAddress;\nexports.DEFAULT_PREFIX = 'ecash';\n/**\n * Address\n * Stores properties of supported crypto addresses\n * in standard typed structure. Provides methods for\n * easy access of address data in dev-friendly formats.\n * Provides methods for instantiating by type, encoding,\n * script, prefix, and address string of arbitrary encoding.\n *\n * Simplifies conversion between cashaddr prefixes and\n * address encoding types.\n *\n * Address is an ecash-first class. Legacy BTC format\n * is supported to simplify conversion to and from\n * ecash addresses.\n *\n * Address may be extended to support other crypto\n * address formats.\n */\nclass Address {\n    constructor(params) {\n        this.toString = () => {\n            return this.address;\n        };\n        this.legacy = () => new Address({\n            type: this.type,\n            hash: this.hash,\n            address: (0, exports.toLegacyAddress)(this.address),\n            encoding: 'legacy',\n        });\n        /**\n         * Create an Address with cashaddr encoding\n         * from an existing Address\n         */\n        this.cash = () => new Address({\n            type: this.type,\n            hash: this.hash,\n            address: (0, ecashaddrjs_1.encodeCashAddress)(typeof this.prefix !== 'undefined'\n                ? this.prefix\n                : exports.DEFAULT_PREFIX, this.type, this.hash),\n            encoding: 'cashaddr',\n            prefix: typeof this.prefix !== 'undefined'\n                ? this.prefix\n                : exports.DEFAULT_PREFIX,\n        });\n        /**\n         * Create address with specified prefix\n         * from an existing cashaddr-encoding Address\n         */\n        this.withPrefix = (prefix) => {\n            if (this.encoding === 'legacy') {\n                // Take no action for legacy address types\n                throw new Error('withPrefix does not support legacy address types');\n            }\n            if (this.prefix === prefix) {\n                // Take no action if prefix is not changing\n                return this;\n            }\n            return new Address({\n                type: this.type,\n                hash: this.hash,\n                prefix,\n                address: (0, ecashaddrjs_1.encodeCashAddress)(prefix, this.type, this.hash),\n                encoding: 'cashaddr',\n            });\n        };\n        this.toScript = () => {\n            return new script_1.Script((0, hex_1.fromHex)((0, ecashaddrjs_1.getOutputScriptFromTypeAndHash)(this.type, this.hash)));\n        };\n        this.toScriptHex = () => {\n            return (0, ecashaddrjs_1.getOutputScriptFromTypeAndHash)(this.type, this.hash);\n        };\n        const { hash, type, address, encoding } = params;\n        this.hash = hash;\n        this.type = type;\n        this.address = address;\n        this.encoding = encoding;\n        if (typeof params.prefix !== 'undefined') {\n            this.prefix = params.prefix;\n        }\n    }\n}\nexports.Address = Address;\n/**\n * Create a new p2pkh Address from hash\n * cashaddr encoding, ecash: prefix\n */\nAddress.p2pkh = (hash) => new Address({\n    type: 'p2pkh',\n    hash: hash instanceof Uint8Array ? (0, hex_1.toHex)(hash) : hash,\n    prefix: exports.DEFAULT_PREFIX,\n    address: (0, ecashaddrjs_1.encodeCashAddress)(exports.DEFAULT_PREFIX, 'p2pkh', hash),\n    encoding: 'cashaddr',\n});\n/**\n * Create a new p2sh Address from hash\n * cashaddr encoding\n * ecash: prefix\n */\nAddress.p2sh = (hash) => new Address({\n    type: 'p2sh',\n    hash: hash instanceof Uint8Array ? (0, hex_1.toHex)(hash) : hash,\n    prefix: exports.DEFAULT_PREFIX,\n    address: (0, ecashaddrjs_1.encodeCashAddress)(exports.DEFAULT_PREFIX, 'p2sh', hash),\n    encoding: 'cashaddr',\n});\n/**\n * Create a new Address from a given address string\n * address must be valid legacy or cashaddr address\n */\nAddress.parse = (address) => {\n    if ((0, ecashaddrjs_1.isValidCashAddress)(address)) {\n        const { type, hash, prefix } = (0, ecashaddrjs_1.decodeCashAddress)(address);\n        return new Address({\n            type,\n            hash,\n            prefix,\n            encoding: 'cashaddr',\n            address,\n        });\n    }\n    try {\n        const { type, hash } = (0, legacyaddr_1.decodeLegacyAddress)(address);\n        return new Address({\n            type,\n            hash,\n            encoding: 'legacy',\n            address,\n        });\n    }\n    catch {\n        throw new Error('Invalid cashaddr or legacy address');\n    }\n};\n/**\n * Create a new Address from a cashaddr\n * prefix, type, and hash from creating cashaddr\n */\nAddress.fromCashAddress = (address) => {\n    const { type, hash, prefix } = (0, ecashaddrjs_1.decodeCashAddress)(address);\n    return new Address({\n        type,\n        hash,\n        address,\n        encoding: 'cashaddr',\n        prefix,\n    });\n};\n/**\n * Create a new Address from legacy address\n * No prefix for Address created from legacy address\n * type and hash from legacy address\n */\nAddress.fromLegacyAddress = (legacy) => {\n    // Determine addr params from legacy address\n    const { type, hash } = (0, legacyaddr_1.decodeLegacyAddress)(legacy);\n    return new Address({\n        type,\n        hash,\n        address: legacy,\n        encoding: 'legacy',\n    });\n};\n/**\n * Create a new Address from an outputScript as Script\n * type and hash from outputScript\n * cashaddr encoding\n * ecash: prefix\n */\nAddress.fromScript = (script) => {\n    const scriptHex = (0, hex_1.toHex)(script.bytecode);\n    return Address.fromScriptHex(scriptHex);\n};\n/**\n * Create a new Address from an outputScript as hex string\n * type and hash from outputScript\n * cashaddr encoding\n * ecash: prefix\n */\nAddress.fromScriptHex = (scriptHex) => {\n    const { type, hash } = (0, ecashaddrjs_1.getTypeAndHashFromOutputScript)(scriptHex);\n    // Default cashaddr encoding with default prefix\n    const address = (0, ecashaddrjs_1.encodeCashAddress)(exports.DEFAULT_PREFIX, type, hash);\n    const prefix = exports.DEFAULT_PREFIX;\n    return new Address({\n        type,\n        hash,\n        prefix,\n        address,\n        encoding: 'cashaddr',\n    });\n};\n//# sourceMappingURL=address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA4NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsc0JBQXNCLEdBQUcsdUJBQXVCLEdBQUcsOEJBQThCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxJQUFXO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLElBQWE7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsSUFBYztBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFXO0FBQ3BDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9hZGRyZXNzL2FkZHJlc3MuanM/NDJhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWRkcmVzcyA9IGV4cG9ydHMuREVGQVVMVF9QUkVGSVggPSBleHBvcnRzLnRvTGVnYWN5QWRkcmVzcyA9IGV4cG9ydHMuRUNBU0hfUFJFRklYRVNfVEVTVE5FVCA9IHZvaWQgMDtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuLi9pby9oZXhcIik7XG5jb25zdCBlY2FzaGFkZHJqc18xID0gcmVxdWlyZShcImVjYXNoYWRkcmpzXCIpO1xuY29uc3QgbGVnYWN5YWRkcl8xID0gcmVxdWlyZShcIi4vbGVnYWN5YWRkclwiKTtcbmNvbnN0IHNjcmlwdF8xID0gcmVxdWlyZShcIi4uL3NjcmlwdFwiKTtcbmV4cG9ydHMuRUNBU0hfUFJFRklYRVNfVEVTVE5FVCA9IFsnZWN0ZXN0JywgJ2VjcmVndGVzdCddO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBlY2FzaCBhZGRyZXNzIGluIGNhc2hhZGRyIGZvcm1hdCB0byBsZWdhY3kgZm9ybWF0XG4gKiBUaHJvd3MgaWYgdXNlciBhdHRlbXB0cyB0byBjb252ZXJ0IGEgbGVnYWN5IGFkZHJlc3MgdG8gYSBsZWdhY3kgYWRkcmVzc1xuICogU2VwYXJhdGVkIGFzIGl0cyBvd24gZnVuY3Rpb24gaGVyZSBmb3JcbiAqXG4gKiAxIC0gc2ltcGxlciB1bml0IHRlc3RpbmdcbiAqIDIgLSBleHBvcnRlZCBmb3IgdXNlcnMgbG9va2luZyB0byBjb252ZXJ0IHN0cmluZyBjYXNoYWRkciB0byBzdHJpbmcgbGVnYWN5IGFkZHJcbiAqICAgICB3aXRob3V0IHVzaW5nIHRoZSBBZGRyZXNzIGNsYXNzXG4gKi9cbmNvbnN0IHRvTGVnYWN5QWRkcmVzcyA9IChjYXNoYWRkcmVzcykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIE5vLW9wIGlmIHVzZXIgaXMgdHJ5aW5nIHRvIGNvbnZlcnQgbGVnYWN5IHRvIGxlZ2FjeVxuICAgICAgICAoMCwgbGVnYWN5YWRkcl8xLmRlY29kZUxlZ2FjeUFkZHJlc3MpKGNhc2hhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIGNhc2hhZGRyZXNzO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgd2l0aCB0aGlzIGVycm9yIHNpbmNlIHdlIGV4cGVjdCBpdCBldmVyeSB0aW1lIGZvciB0aGUgZnVuY3Rpb24ncyBpbnRlbmRlZCB1c2UgY2FzZVxuICAgICAgICAvLyBQcm9jZWVkIHRvIGNvbnZlcnQgdG8gbGVnYWN5XG4gICAgfVxuICAgIGNvbnN0IHsgcHJlZml4LCB0eXBlLCBoYXNoIH0gPSAoMCwgZWNhc2hhZGRyanNfMS5kZWNvZGVDYXNoQWRkcmVzcykoY2FzaGFkZHJlc3MpO1xuICAgIGNvbnN0IGlzVGVzdG5ldCA9IGV4cG9ydHMuRUNBU0hfUFJFRklYRVNfVEVTVE5FVC5pbmNsdWRlcyhwcmVmaXgpO1xuICAgIC8vIEdldCBjb3JyZWN0IHZlcnNpb24gYnl0ZSBmb3IgbGVnYWN5IGZvcm1hdFxuICAgIGxldCB2ZXJzaW9uQnl0ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncDJwa2gnOlxuICAgICAgICAgICAgdmVyc2lvbkJ5dGUgPSBpc1Rlc3RuZXRcbiAgICAgICAgICAgICAgICA/IGxlZ2FjeWFkZHJfMS5MRUdBQ1lfVkVSU0lPTl9CWVRFUy5sZWdhY3kudGVzdG5ldC5wMnBraFxuICAgICAgICAgICAgICAgIDogbGVnYWN5YWRkcl8xLkxFR0FDWV9WRVJTSU9OX0JZVEVTLmxlZ2FjeS5tYWlubmV0LnAycGtoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Ayc2gnOlxuICAgICAgICAgICAgdmVyc2lvbkJ5dGUgPSBpc1Rlc3RuZXRcbiAgICAgICAgICAgICAgICA/IGxlZ2FjeWFkZHJfMS5MRUdBQ1lfVkVSU0lPTl9CWVRFUy5sZWdhY3kudGVzdG5ldC5wMnNoXG4gICAgICAgICAgICAgICAgOiBsZWdhY3lhZGRyXzEuTEVHQUNZX1ZFUlNJT05fQllURVMubGVnYWN5Lm1haW5uZXQucDJzaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhZGRyZXNzIHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBoYXNoIHRvIFVpbnQ4QXJyYXlcbiAgICBjb25zdCBoYXNoQXJyYXkgPSAoMCwgaGV4XzEuZnJvbUhleCkoaGFzaCk7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IFVpbnQ4QXJyYXkgdG8gaG9sZCB0aGUgZGF0YVxuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgxICsgaGFzaEFycmF5Lmxlbmd0aCk7XG4gICAgLy8gU2V0IHRoZSB2ZXJzaW9uIGJ5dGVcbiAgICB1aW50OEFycmF5WzBdID0gdmVyc2lvbkJ5dGU7XG4gICAgLy8gU2V0IHRoZSBoYXNoXG4gICAgdWludDhBcnJheS5zZXQoaGFzaEFycmF5LCAxKTtcbiAgICAvLyBFbmNvZGUgdG8gYmFzZTU4Y2hlY2tcbiAgICByZXR1cm4gKDAsIGxlZ2FjeWFkZHJfMS5lbmNvZGVCYXNlNThDaGVjaykodWludDhBcnJheSk7XG59O1xuZXhwb3J0cy50b0xlZ2FjeUFkZHJlc3MgPSB0b0xlZ2FjeUFkZHJlc3M7XG5leHBvcnRzLkRFRkFVTFRfUFJFRklYID0gJ2VjYXNoJztcbi8qKlxuICogQWRkcmVzc1xuICogU3RvcmVzIHByb3BlcnRpZXMgb2Ygc3VwcG9ydGVkIGNyeXB0byBhZGRyZXNzZXNcbiAqIGluIHN0YW5kYXJkIHR5cGVkIHN0cnVjdHVyZS4gUHJvdmlkZXMgbWV0aG9kcyBmb3JcbiAqIGVhc3kgYWNjZXNzIG9mIGFkZHJlc3MgZGF0YSBpbiBkZXYtZnJpZW5kbHkgZm9ybWF0cy5cbiAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGluc3RhbnRpYXRpbmcgYnkgdHlwZSwgZW5jb2RpbmcsXG4gKiBzY3JpcHQsIHByZWZpeCwgYW5kIGFkZHJlc3Mgc3RyaW5nIG9mIGFyYml0cmFyeSBlbmNvZGluZy5cbiAqXG4gKiBTaW1wbGlmaWVzIGNvbnZlcnNpb24gYmV0d2VlbiBjYXNoYWRkciBwcmVmaXhlcyBhbmRcbiAqIGFkZHJlc3MgZW5jb2RpbmcgdHlwZXMuXG4gKlxuICogQWRkcmVzcyBpcyBhbiBlY2FzaC1maXJzdCBjbGFzcy4gTGVnYWN5IEJUQyBmb3JtYXRcbiAqIGlzIHN1cHBvcnRlZCB0byBzaW1wbGlmeSBjb252ZXJzaW9uIHRvIGFuZCBmcm9tXG4gKiBlY2FzaCBhZGRyZXNzZXMuXG4gKlxuICogQWRkcmVzcyBtYXkgYmUgZXh0ZW5kZWQgdG8gc3VwcG9ydCBvdGhlciBjcnlwdG9cbiAqIGFkZHJlc3MgZm9ybWF0cy5cbiAqL1xuY2xhc3MgQWRkcmVzcyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxlZ2FjeSA9ICgpID0+IG5ldyBBZGRyZXNzKHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICAgICAgICAgIGFkZHJlc3M6ICgwLCBleHBvcnRzLnRvTGVnYWN5QWRkcmVzcykodGhpcy5hZGRyZXNzKSxcbiAgICAgICAgICAgIGVuY29kaW5nOiAnbGVnYWN5JyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYW4gQWRkcmVzcyB3aXRoIGNhc2hhZGRyIGVuY29kaW5nXG4gICAgICAgICAqIGZyb20gYW4gZXhpc3RpbmcgQWRkcmVzc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYXNoID0gKCkgPT4gbmV3IEFkZHJlc3Moe1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgaGFzaDogdGhpcy5oYXNoLFxuICAgICAgICAgICAgYWRkcmVzczogKDAsIGVjYXNoYWRkcmpzXzEuZW5jb2RlQ2FzaEFkZHJlc3MpKHR5cGVvZiB0aGlzLnByZWZpeCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHRoaXMucHJlZml4XG4gICAgICAgICAgICAgICAgOiBleHBvcnRzLkRFRkFVTFRfUFJFRklYLCB0aGlzLnR5cGUsIHRoaXMuaGFzaCksXG4gICAgICAgICAgICBlbmNvZGluZzogJ2Nhc2hhZGRyJyxcbiAgICAgICAgICAgIHByZWZpeDogdHlwZW9mIHRoaXMucHJlZml4ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5wcmVmaXhcbiAgICAgICAgICAgICAgICA6IGV4cG9ydHMuREVGQVVMVF9QUkVGSVgsXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGFkZHJlc3Mgd2l0aCBzcGVjaWZpZWQgcHJlZml4XG4gICAgICAgICAqIGZyb20gYW4gZXhpc3RpbmcgY2FzaGFkZHItZW5jb2RpbmcgQWRkcmVzc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aXRoUHJlZml4ID0gKHByZWZpeCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5jb2RpbmcgPT09ICdsZWdhY3knKSB7XG4gICAgICAgICAgICAgICAgLy8gVGFrZSBubyBhY3Rpb24gZm9yIGxlZ2FjeSBhZGRyZXNzIHR5cGVzXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aXRoUHJlZml4IGRvZXMgbm90IHN1cHBvcnQgbGVnYWN5IGFkZHJlc3MgdHlwZXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByZWZpeCA9PT0gcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGFrZSBubyBhY3Rpb24gaWYgcHJlZml4IGlzIG5vdCBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgaGFzaDogdGhpcy5oYXNoLFxuICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiAoMCwgZWNhc2hhZGRyanNfMS5lbmNvZGVDYXNoQWRkcmVzcykocHJlZml4LCB0aGlzLnR5cGUsIHRoaXMuaGFzaCksXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6ICdjYXNoYWRkcicsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1NjcmlwdCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc2NyaXB0XzEuU2NyaXB0KCgwLCBoZXhfMS5mcm9tSGV4KSgoMCwgZWNhc2hhZGRyanNfMS5nZXRPdXRwdXRTY3JpcHRGcm9tVHlwZUFuZEhhc2gpKHRoaXMudHlwZSwgdGhpcy5oYXNoKSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRvU2NyaXB0SGV4ID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBlY2FzaGFkZHJqc18xLmdldE91dHB1dFNjcmlwdEZyb21UeXBlQW5kSGFzaCkodGhpcy50eXBlLCB0aGlzLmhhc2gpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGhhc2gsIHR5cGUsIGFkZHJlc3MsIGVuY29kaW5nIH0gPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMucHJlZml4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSBwYXJhbXMucHJlZml4O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHAycGtoIEFkZHJlc3MgZnJvbSBoYXNoXG4gKiBjYXNoYWRkciBlbmNvZGluZywgZWNhc2g6IHByZWZpeFxuICovXG5BZGRyZXNzLnAycGtoID0gKGhhc2gpID0+IG5ldyBBZGRyZXNzKHtcbiAgICB0eXBlOiAncDJwa2gnLFxuICAgIGhhc2g6IGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gKDAsIGhleF8xLnRvSGV4KShoYXNoKSA6IGhhc2gsXG4gICAgcHJlZml4OiBleHBvcnRzLkRFRkFVTFRfUFJFRklYLFxuICAgIGFkZHJlc3M6ICgwLCBlY2FzaGFkZHJqc18xLmVuY29kZUNhc2hBZGRyZXNzKShleHBvcnRzLkRFRkFVTFRfUFJFRklYLCAncDJwa2gnLCBoYXNoKSxcbiAgICBlbmNvZGluZzogJ2Nhc2hhZGRyJyxcbn0pO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcDJzaCBBZGRyZXNzIGZyb20gaGFzaFxuICogY2FzaGFkZHIgZW5jb2RpbmdcbiAqIGVjYXNoOiBwcmVmaXhcbiAqL1xuQWRkcmVzcy5wMnNoID0gKGhhc2gpID0+IG5ldyBBZGRyZXNzKHtcbiAgICB0eXBlOiAncDJzaCcsXG4gICAgaGFzaDogaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyAoMCwgaGV4XzEudG9IZXgpKGhhc2gpIDogaGFzaCxcbiAgICBwcmVmaXg6IGV4cG9ydHMuREVGQVVMVF9QUkVGSVgsXG4gICAgYWRkcmVzczogKDAsIGVjYXNoYWRkcmpzXzEuZW5jb2RlQ2FzaEFkZHJlc3MpKGV4cG9ydHMuREVGQVVMVF9QUkVGSVgsICdwMnNoJywgaGFzaCksXG4gICAgZW5jb2Rpbmc6ICdjYXNoYWRkcicsXG59KTtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IEFkZHJlc3MgZnJvbSBhIGdpdmVuIGFkZHJlc3Mgc3RyaW5nXG4gKiBhZGRyZXNzIG11c3QgYmUgdmFsaWQgbGVnYWN5IG9yIGNhc2hhZGRyIGFkZHJlc3NcbiAqL1xuQWRkcmVzcy5wYXJzZSA9IChhZGRyZXNzKSA9PiB7XG4gICAgaWYgKCgwLCBlY2FzaGFkZHJqc18xLmlzVmFsaWRDYXNoQWRkcmVzcykoYWRkcmVzcykpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBoYXNoLCBwcmVmaXggfSA9ICgwLCBlY2FzaGFkZHJqc18xLmRlY29kZUNhc2hBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICdjYXNoYWRkcicsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBoYXNoIH0gPSAoMCwgbGVnYWN5YWRkcl8xLmRlY29kZUxlZ2FjeUFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3Moe1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICBlbmNvZGluZzogJ2xlZ2FjeScsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2FzaGFkZHIgb3IgbGVnYWN5IGFkZHJlc3MnKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQWRkcmVzcyBmcm9tIGEgY2FzaGFkZHJcbiAqIHByZWZpeCwgdHlwZSwgYW5kIGhhc2ggZnJvbSBjcmVhdGluZyBjYXNoYWRkclxuICovXG5BZGRyZXNzLmZyb21DYXNoQWRkcmVzcyA9IChhZGRyZXNzKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBoYXNoLCBwcmVmaXggfSA9ICgwLCBlY2FzaGFkZHJqc18xLmRlY29kZUNhc2hBZGRyZXNzKShhZGRyZXNzKTtcbiAgICByZXR1cm4gbmV3IEFkZHJlc3Moe1xuICAgICAgICB0eXBlLFxuICAgICAgICBoYXNoLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBlbmNvZGluZzogJ2Nhc2hhZGRyJyxcbiAgICAgICAgcHJlZml4LFxuICAgIH0pO1xufTtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IEFkZHJlc3MgZnJvbSBsZWdhY3kgYWRkcmVzc1xuICogTm8gcHJlZml4IGZvciBBZGRyZXNzIGNyZWF0ZWQgZnJvbSBsZWdhY3kgYWRkcmVzc1xuICogdHlwZSBhbmQgaGFzaCBmcm9tIGxlZ2FjeSBhZGRyZXNzXG4gKi9cbkFkZHJlc3MuZnJvbUxlZ2FjeUFkZHJlc3MgPSAobGVnYWN5KSA9PiB7XG4gICAgLy8gRGV0ZXJtaW5lIGFkZHIgcGFyYW1zIGZyb20gbGVnYWN5IGFkZHJlc3NcbiAgICBjb25zdCB7IHR5cGUsIGhhc2ggfSA9ICgwLCBsZWdhY3lhZGRyXzEuZGVjb2RlTGVnYWN5QWRkcmVzcykobGVnYWN5KTtcbiAgICByZXR1cm4gbmV3IEFkZHJlc3Moe1xuICAgICAgICB0eXBlLFxuICAgICAgICBoYXNoLFxuICAgICAgICBhZGRyZXNzOiBsZWdhY3ksXG4gICAgICAgIGVuY29kaW5nOiAnbGVnYWN5JyxcbiAgICB9KTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBBZGRyZXNzIGZyb20gYW4gb3V0cHV0U2NyaXB0IGFzIFNjcmlwdFxuICogdHlwZSBhbmQgaGFzaCBmcm9tIG91dHB1dFNjcmlwdFxuICogY2FzaGFkZHIgZW5jb2RpbmdcbiAqIGVjYXNoOiBwcmVmaXhcbiAqL1xuQWRkcmVzcy5mcm9tU2NyaXB0ID0gKHNjcmlwdCkgPT4ge1xuICAgIGNvbnN0IHNjcmlwdEhleCA9ICgwLCBoZXhfMS50b0hleCkoc2NyaXB0LmJ5dGVjb2RlKTtcbiAgICByZXR1cm4gQWRkcmVzcy5mcm9tU2NyaXB0SGV4KHNjcmlwdEhleCk7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQWRkcmVzcyBmcm9tIGFuIG91dHB1dFNjcmlwdCBhcyBoZXggc3RyaW5nXG4gKiB0eXBlIGFuZCBoYXNoIGZyb20gb3V0cHV0U2NyaXB0XG4gKiBjYXNoYWRkciBlbmNvZGluZ1xuICogZWNhc2g6IHByZWZpeFxuICovXG5BZGRyZXNzLmZyb21TY3JpcHRIZXggPSAoc2NyaXB0SGV4KSA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBoYXNoIH0gPSAoMCwgZWNhc2hhZGRyanNfMS5nZXRUeXBlQW5kSGFzaEZyb21PdXRwdXRTY3JpcHQpKHNjcmlwdEhleCk7XG4gICAgLy8gRGVmYXVsdCBjYXNoYWRkciBlbmNvZGluZyB3aXRoIGRlZmF1bHQgcHJlZml4XG4gICAgY29uc3QgYWRkcmVzcyA9ICgwLCBlY2FzaGFkZHJqc18xLmVuY29kZUNhc2hBZGRyZXNzKShleHBvcnRzLkRFRkFVTFRfUFJFRklYLCB0eXBlLCBoYXNoKTtcbiAgICBjb25zdCBwcmVmaXggPSBleHBvcnRzLkRFRkFVTFRfUFJFRklYO1xuICAgIHJldHVybiBuZXcgQWRkcmVzcyh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgZW5jb2Rpbmc6ICdjYXNoYWRkcicsXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3085\n\n}")},3158:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = __webpack_require__(6237);\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = __webpack_require__(3610);\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLElBQVU7QUFDL0I7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLElBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcz85NTY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3158\n\n}')},3209:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\n\n// limit of Crypto.getRandomValues()\n// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\nvar MAX_BYTES = 65536\n\n// Node supports requesting up to this number of bytes\n// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48\nvar MAX_UINT32 = 4294967295\n\nfunction oldBrowser () {\n  throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11')\n}\n\nvar Buffer = (__webpack_require__(2861).Buffer)\nvar crypto = __webpack_require__.g.crypto || __webpack_require__.g.msCrypto\n\nif (crypto && crypto.getRandomValues) {\n  module.exports = randomBytes\n} else {\n  module.exports = oldBrowser\n}\n\nfunction randomBytes (size, cb) {\n  // phantomjs needs to throw\n  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')\n\n  var bytes = Buffer.allocUnsafe(size)\n\n  if (size > 0) {  // getRandomValues fails on IE if size == 0\n    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues\n      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n      for (var generated = 0; generated < size; generated += MAX_BYTES) {\n        // buffer.slice automatically checks if the end is past the end of\n        // the buffer so we don't have to here\n        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))\n      }\n    } else {\n      crypto.getRandomValues(bytes)\n    }\n  }\n\n  if (typeof cb === 'function') {\n    return process.nextTick(function () {\n      cb(null, bytes)\n    })\n  }\n\n  return bytes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIwOS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGtDQUE2QjtBQUMxQyxhQUFhLHFCQUFNLFdBQVcscUJBQU07O0FBRXBDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CO0FBQ25CLDRCQUE0QjtBQUM1QjtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9yYW5kb21ieXRlcy9icm93c2VyLmpzPzExZGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGxpbWl0IG9mIENyeXB0by5nZXRSYW5kb21WYWx1ZXMoKVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyeXB0by9nZXRSYW5kb21WYWx1ZXNcbnZhciBNQVhfQllURVMgPSA2NTUzNlxuXG4vLyBOb2RlIHN1cHBvcnRzIHJlcXVlc3RpbmcgdXAgdG8gdGhpcyBudW1iZXIgb2YgYnl0ZXNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21hc3Rlci9saWIvaW50ZXJuYWwvY3J5cHRvL3JhbmRvbS5qcyNMNDhcbnZhciBNQVhfVUlOVDMyID0gNDI5NDk2NzI5NVxuXG5mdW5jdGlvbiBvbGRCcm93c2VyICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblVzZSBDaHJvbWUsIEZpcmVmb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTEnKVxufVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0b1xuXG5pZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByYW5kb21CeXRlc1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBvbGRCcm93c2VyXG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzIChzaXplLCBjYikge1xuICAvLyBwaGFudG9tanMgbmVlZHMgdG8gdGhyb3dcbiAgaWYgKHNpemUgPiBNQVhfVUlOVDMyKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlcycpXG5cbiAgdmFyIGJ5dGVzID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpXG5cbiAgaWYgKHNpemUgPiAwKSB7ICAvLyBnZXRSYW5kb21WYWx1ZXMgZmFpbHMgb24gSUUgaWYgc2l6ZSA9PSAwXG4gICAgaWYgKHNpemUgPiBNQVhfQllURVMpIHsgLy8gdGhpcyBpcyB0aGUgbWF4IGJ5dGVzIGNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIC8vIGNhbiBkbyBhdCBvbmNlIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXNcbiAgICAgIGZvciAodmFyIGdlbmVyYXRlZCA9IDA7IGdlbmVyYXRlZCA8IHNpemU7IGdlbmVyYXRlZCArPSBNQVhfQllURVMpIHtcbiAgICAgICAgLy8gYnVmZmVyLnNsaWNlIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGlmIHRoZSBlbmQgaXMgcGFzdCB0aGUgZW5kIG9mXG4gICAgICAgIC8vIHRoZSBidWZmZXIgc28gd2UgZG9uJ3QgaGF2ZSB0byBoZXJlXG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMuc2xpY2UoZ2VuZXJhdGVkLCBnZW5lcmF0ZWQgKyBNQVhfQllURVMpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBjYihudWxsLCBieXRlcylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3209\n\n}")},3377:(__unused_webpack_module,exports)=>{"use strict";eval('{\n/**\n * @license\n * https://reviews.bitcoinabc.org\n * Copyright (c) 2017-2020 Emilio Almansi\n * Copyright (c) 2023 Bitcoin ABC\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/**\n * Validation utility.\n *\n * @module validation\n */\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nclass ValidationError extends Error {\n    constructor(message) {\n        super(message); // Call the parent constructor\n        this.name = \'ValidationError\'; // Set the error name\n        // If targeting ES5 or earlier, need to set this manually for subclassing to work\n        Object.setPrototypeOf(this, ValidationError.prototype);\n    }\n}\n/**\n * Validates a given condition, throwing a {@link ValidationError} if\n * the given condition does not hold.\n *\n * @static\n * @param condition Condition to validate.\n * @param message Error message in case the condition does not hold.\n */\nfunction validate(condition, message) {\n    if (!condition) {\n        throw new ValidationError(message);\n    }\n}\nexports["default"] = {\n    ValidationError: ValidationError,\n    validate: validate,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM3Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaGFkZHJqcy9kaXN0L3ZhbGlkYXRpb24uanM/Yzc1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIGh0dHBzOi8vcmV2aWV3cy5iaXRjb2luYWJjLm9yZ1xuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMjAgRW1pbGlvIEFsbWFuc2lcbiAqIENvcHlyaWdodCAoYykgMjAyMyBCaXRjb2luIEFCQ1xuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuICogZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFZhbGlkYXRpb24gdXRpbGl0eS5cbiAqXG4gKiBAbW9kdWxlIHZhbGlkYXRpb25cbiAqL1xuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBlbmNvZGluZyBvciBkZWNvZGluZyBmYWlsIGR1ZSB0byBpbnZhbGlkIGlucHV0LlxuICpcbiAqIEBjb25zdHJ1Y3RvciBWYWxpZGF0aW9uRXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIGRlc2NyaXB0aW9uLlxuICovXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG4gICAgICAgIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InOyAvLyBTZXQgdGhlIGVycm9yIG5hbWVcbiAgICAgICAgLy8gSWYgdGFyZ2V0aW5nIEVTNSBvciBlYXJsaWVyLCBuZWVkIHRvIHNldCB0aGlzIG1hbnVhbGx5IGZvciBzdWJjbGFzc2luZyB0byB3b3JrXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBWYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIGdpdmVuIGNvbmRpdGlvbiwgdGhyb3dpbmcgYSB7QGxpbmsgVmFsaWRhdGlvbkVycm9yfSBpZlxuICogdGhlIGdpdmVuIGNvbmRpdGlvbiBkb2VzIG5vdCBob2xkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSBjb25kaXRpb24gQ29uZGl0aW9uIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIG1lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIHRoZSBjb25kaXRpb24gZG9lcyBub3QgaG9sZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgVmFsaWRhdGlvbkVycm9yOiBWYWxpZGF0aW9uRXJyb3IsXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3377\n\n}')},3449:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nmodule.exports = Writer;\n\nvar util      = __webpack_require__(3610);\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzPzBjODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlcldyaXRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIGJhc2U2NCAgICA9IHV0aWwuYmFzZTY0LFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cbiAgICAgKi9cbiAgICB0aGlzLmZuID0gZm47XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBieXRlIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy52YWwgPSB2YWw7IC8vIHR5cGUgdmFyaWVzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBDb3BpZWQgd3JpdGVyIHN0YXRlLlxuICogQG1lbWJlcm9mIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dyaXRlcn0gd3JpdGVyIFdyaXRlciB0byBjb3B5IHN0YXRlIGZyb21cbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhlYWQuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdGFpbC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7U3RhdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV3JpdGVyKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG5cbiAgICAvLyBXaGVuIGEgdmFsdWUgaXMgd3JpdHRlbiwgdGhlIHdyaXRlciBjYWxjdWxhdGVzIGl0cyBieXRlIGxlbmd0aCBhbmQgcHV0cyBpdCBpbnRvIGEgbGlua2VkXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcbiAgICAvLyBidWZmZXJzIG9mIHRoZSBleGFjdCByZXF1aXJlZCBzaXplIGFuZCByZWR1Y2VzIHRoZSBhbW91bnQgb2Ygd29yayB3ZSBoYXZlIHRvIGRvIGNvbXBhcmVkXG4gICAgLy8gdG8gZmlyc3QgY2FsY3VsYXRpbmcgb3ZlciBvYmplY3RzIGFuZCB0aGVuIGVuY29kaW5nIG92ZXIgb2JqZWN0cy4gSW4gb3VyIGNhc2UsIHRoZSBlbmNvZGluZ1xuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXG59XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xuICAgICAgICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcnxXcml0ZXJ9IEEge0BsaW5rIEJ1ZmZlcldyaXRlcn0gd2hlbiBCdWZmZXJzIGFyZSBzdXBwb3J0ZWQsIG90aGVyd2lzZSBhIHtAbGluayBXcml0ZXJ9XG4gKi9cbldyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuLyoqXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcbiAqL1xuV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcbn07XG5cbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XG5cbi8qKlxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHByaXZhdGVcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbCA+Pj49IDc7XG4gICAgfVxuICAgIGJ1Zltwb3NdID0gdmFsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgdmFyaW50IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBleHRlbmRzIE9wXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWwgPSB2YWw7XG59XG5cblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcblZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXG4gICAgLy8gdWludDMyIGlzIGJ5IGZhciB0aGUgbW9zdCBmcmVxdWVudGx5IHVzZWQgb3BlcmF0aW9uIGFuZCBiZW5lZml0cyBzaWduaWZpY2FudGx5IGZyb20gdGhpcy5cbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxuICAgICAgICAgICAgICAgIDwgMTI4ICAgICAgID8gMVxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xuICAgICAgICA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNFxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICB2YWx1ZSkpLmxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMFxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xuICAgICAgICA6IHRoaXMudWludDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgIH1cbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcbiAgICB9XG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGJvb2xpc2ggdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICAmIDI1NTtcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbn07XG5cbnZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0XG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IHZhbHVlIEJ1ZmZlciBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIGlmICghbGVuKVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XG4gICAgcmV0dXJuIGxlblxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcbiAgICAgICAgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICB0aGlzLmxlbiA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5oZWFkICAgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRvIHRoZSBsYXN0IHN0YXRlIGFuZCBhcHBlbmRzIHRoZSBmb3JrIHN0YXRlJ3MgY3VycmVudCB3cml0ZSBsZW5ndGggYXMgYSB2YXJpbnQgZm9sbG93ZWQgYnkgaXRzIG9wZXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXG4gICAgICAgIGxlbiAgPSB0aGlzLmxlbjtcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XG4gICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDsgLy8gc2tpcCBub29wXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gRmluaXNoZWQgYnVmZmVyXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIC8vIHNraXAgbm9vcFxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXG4gICAgICAgIHBvcyAgPSAwO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHJldHVybiBidWY7XG59O1xuXG5Xcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3449\n\n}")},3610:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(8045);\n\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(8839);\n\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(4358);\n\n// float handling accross browsers\nutil.float = __webpack_require__(9410);\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(4153);\n\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(1447);\n\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(9390);\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(2239);\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof __webpack_require__.g !== "undefined"\n                   && __webpack_require__.g\n                   && __webpack_require__.g.process\n                   && __webpack_require__.g.process.versions\n                   && __webpack_require__.g.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && __webpack_require__.g\n           || typeof window !== "undefined" && window\n           || typeof self   !== "undefined" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === "string" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === "object";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node\'s typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node\'s Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire("buffer").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === "number"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === "undefined"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js\'s Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire("long");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, "message", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, "stack", { value: new Error().stack || "" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + ": " + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log("decoded so far: " + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError("ProtocolError");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof\'s present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof\'s present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3\'s JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzP2U5MzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IGV4cG9ydHM7XG5cbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XG5cbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcblxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcblxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcblxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xuXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcblxuLyoqXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcblxuLyoqXG4gKiBHbG9iYWwgb2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxuICAgICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuICAgICAgICAgICB8fCB0eXBlb2Ygc2VsZiAgICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblxuLyoqXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7QXJyYXkuPCo+fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdOyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgb2JqZWN0LlxuICogQHR5cGUge09iamVjdH1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKi9cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNzZXQgPVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cbiAqIEBpbnRlcmZhY2UgQnVmZmVyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XG4gKi9cblxuLyoqXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxuICovXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcbiAqL1xudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxuICAgICAgICA6IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbn07XG5cbi8qKlxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XG4gKi9cbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXG4gKiBAaW50ZXJmYWNlIExvbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxuICovXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcbiAqL1xudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIHJldHVybiBkc3Q7XG59XG5cbnV0aWwubWVyZ2UgPSBtZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcblxuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIChDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQ3VzdG9tRXJyb3I7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmFtZTsgfSB9KTtcblxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxuICogQGNsYXNzZGVzYyBFcnJvciBzdWJjbGFzcyBpbmRpY2F0aW5nIGEgcHJvdG9jb2wgc3BlY2lmYyBlcnJvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICAgIE15TWVzc2FnZS5kZWNvZGUoc29tZUJ1ZmZlcik7IC8vIHRocm93cyBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcbiAqICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIHNvIGZhcjogXCIgKyBKU09OLnN0cmluZ2lmeShlLmluc3RhbmNlKSk7XG4gKiB9XG4gKi9cbnV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcblxuLyoqXG4gKiBTbyBmYXIgZGVjb2RlZCBtZXNzYWdlIGluc3RhbmNlLlxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cbiAqL1xuXG4vKipcbiAqIEEgT25lT2YgZ2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mR2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mR2V0dGVyfSBVbmJvdW5kIGdldHRlclxuICovXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZTZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZlNldHRlcn0gVW5ib3VuZCBzZXR0ZXJcbiAqL1xudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gb3B0aW9ucyB1c2VkIGZvciB7QGxpbmsgTWVzc2FnZSN0b0pTT059IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcbiAqXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xuICogLSBCeXRlcyBiZWNvbWUgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXG4gKiAtIFJlcGVhdGVkIGZpZWxkcyBiZWNvbWUgYXJyYXlzXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXG4gKlxuICogQHR5cGUge0lDb252ZXJzaW9uT3B0aW9uc31cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXG4gKi9cbnV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBqc29uOiB0cnVlXG59O1xuXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQnVmZmVyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIG5vZGUgNC54IGJ1ZmZlcnMgYXJlIGluY29tcGF0aWJsZSAmIGltbXV0YWJsZVxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgICB9O1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3610\n\n}')},3650:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ecc: () => (/* binding */ Ecc),\n/* harmony export */   Sha256H: () => (/* binding */ Sha256H),\n/* harmony export */   Sha512H: () => (/* binding */ Sha512H),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   initSync: () => (/* binding */ initSync),\n/* harmony export */   publicKeyCryptoAlgoSupported: () => (/* binding */ publicKeyCryptoAlgoSupported),\n/* harmony export */   publicKeyCryptoVerify: () => (/* binding */ publicKeyCryptoVerify),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha256d: () => (/* binding */ sha256d),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   shaRmd160: () => (/* binding */ shaRmd160)\n/* harmony export */ });\nlet wasm;\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n/**\n* Verify a signature for the given cryptographic algorithm.\n* Intended to be used in X509 certificate verification.\n* Throw an exception if the algorithm is not supported.\n* @param {string} algo_oid\n* @param {string | undefined} params\n* @param {Uint8Array} sig\n* @param {Uint8Array} msg\n* @param {Uint8Array} pk\n*/\nfunction publicKeyCryptoVerify(algo_oid, params, sig, msg, pk) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(algo_oid, wasm.__wbindgen_export_0, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(params) ? 0 : passStringToWasm0(params, wasm.__wbindgen_export_0, wasm.__wbindgen_export_2);\n        var len1 = WASM_VECTOR_LEN;\n        const ptr2 = passArray8ToWasm0(sig, wasm.__wbindgen_export_0);\n        const len2 = WASM_VECTOR_LEN;\n        const ptr3 = passArray8ToWasm0(msg, wasm.__wbindgen_export_0);\n        const len3 = WASM_VECTOR_LEN;\n        const ptr4 = passArray8ToWasm0(pk, wasm.__wbindgen_export_0);\n        const len4 = WASM_VECTOR_LEN;\n        wasm.publicKeyCryptoVerify(retptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Throw an exception if the given algo is not supported, otherwise do nothing.\n* @param {string} algo_oid\n* @param {string | undefined} [params]\n*/\nfunction publicKeyCryptoAlgoSupported(algo_oid, params) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passStringToWasm0(algo_oid, wasm.__wbindgen_export_0, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        var ptr1 = isLikeNone(params) ? 0 : passStringToWasm0(params, wasm.__wbindgen_export_0, wasm.__wbindgen_export_2);\n        var len1 = WASM_VECTOR_LEN;\n        wasm.publicKeyCryptoAlgoSupported(retptr, ptr0, len0, ptr1, len1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Calculate SHA512(data).\n* @param {Uint8Array} data\n* @returns {Uint8Array}\n*/\nfunction sha512(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_export_0);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.sha512(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Calculate SHA256(SHA256(data)).\n* @param {Uint8Array} data\n* @returns {Uint8Array}\n*/\nfunction sha256d(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_export_0);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.sha256d(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Calculate SHA256(data).\n* @param {Uint8Array} data\n* @returns {Uint8Array}\n*/\nfunction sha256(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_export_0);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.sha256(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Calculate RIPEMD160(SHA256(data)), commonly used as address hash.\n* @param {Uint8Array} data\n* @returns {Uint8Array}\n*/\nfunction shaRmd160(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_export_0);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.shaRmd160(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nconst EccFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_ecc_free(ptr >>> 0));\n/**\n* ECC signatures with libsecp256k1.\n*/\nclass Ecc {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        EccFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ecc_free(ptr);\n    }\n    /**\n    * Create a new Ecc instance.\n    */\n    constructor() {\n        const ret = wasm.ecc_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Derive a public key from secret key.\n    * @param {Uint8Array} seckey\n    * @returns {Uint8Array}\n    */\n    derivePubkey(seckey) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(seckey, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.ecc_derivePubkey(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v2 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign an ECDSA signature.\n    * @param {Uint8Array} seckey\n    * @param {Uint8Array} msg\n    * @returns {Uint8Array}\n    */\n    ecdsaSign(seckey, msg) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(seckey, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(msg, wasm.__wbindgen_export_0);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.ecc_ecdsaSign(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v3 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v3;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Verify an ECDSA signature.\n    * @param {Uint8Array} sig\n    * @param {Uint8Array} msg\n    * @param {Uint8Array} pk\n    */\n    ecdsaVerify(sig, msg, pk) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(sig, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(msg, wasm.__wbindgen_export_0);\n            const len1 = WASM_VECTOR_LEN;\n            const ptr2 = passArray8ToWasm0(pk, wasm.__wbindgen_export_0);\n            const len2 = WASM_VECTOR_LEN;\n            wasm.ecc_ecdsaVerify(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Sign a Schnorr signature.\n    * @param {Uint8Array} seckey\n    * @param {Uint8Array} msg\n    * @returns {Uint8Array}\n    */\n    schnorrSign(seckey, msg) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(seckey, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(msg, wasm.__wbindgen_export_0);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.ecc_schnorrSign(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v3 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v3;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Verify a Schnorr signature.\n    * @param {Uint8Array} sig\n    * @param {Uint8Array} msg\n    * @param {Uint8Array} pk\n    */\n    schnorrVerify(sig, msg, pk) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(sig, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(msg, wasm.__wbindgen_export_0);\n            const len1 = WASM_VECTOR_LEN;\n            const ptr2 = passArray8ToWasm0(pk, wasm.__wbindgen_export_0);\n            const len2 = WASM_VECTOR_LEN;\n            wasm.ecc_schnorrVerify(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Return whether the given secret key is valid, i.e. whether is of correct\n    * length (32 bytes) and is on the curve.\n    * @param {Uint8Array} seckey\n    * @returns {boolean}\n    */\n    isValidSeckey(seckey) {\n        const ptr0 = passArray8ToWasm0(seckey, wasm.__wbindgen_export_0);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.ecc_isValidSeckey(this.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * Add a scalar to a secret key.\n    * @param {Uint8Array} a\n    * @param {Uint8Array} b\n    * @returns {Uint8Array}\n    */\n    seckeyAdd(a, b) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(a, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(b, wasm.__wbindgen_export_0);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.ecc_seckeyAdd(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v3 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v3;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Add a scalar to a public key (adding G*b).\n    * @param {Uint8Array} a\n    * @param {Uint8Array} b\n    * @returns {Uint8Array}\n    */\n    pubkeyAdd(a, b) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(a, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(b, wasm.__wbindgen_export_0);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.ecc_pubkeyAdd(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v3 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v3;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a compact ECDSA signature (65 bytes), which allows reconstructing\n    * the used public key.\n    * The format is one header byte, followed by two times 32 bytes for the\n    * serialized r and s values.\n    * The header byte: 0x1B = first key with even y,\n    *                  0x1C = first key with odd y,\n    *                  0x1D = second key with even y,\n    *                  0x1E = second key with odd y,\n    *                  add 0x04 for compressed keys.\n    * @param {Uint8Array} seckey\n    * @param {Uint8Array} msg\n    * @returns {Uint8Array}\n    */\n    signRecoverable(seckey, msg) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(seckey, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(msg, wasm.__wbindgen_export_0);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.ecc_signRecoverable(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v3 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v3;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Recover the public key of a signature signed by signRecoverable.\n    * @param {Uint8Array} sig\n    * @param {Uint8Array} msg\n    * @returns {Uint8Array}\n    */\n    recoverSig(sig, msg) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(sig, wasm.__wbindgen_export_0);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passArray8ToWasm0(msg, wasm.__wbindgen_export_0);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.ecc_recoverSig(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v3 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v3;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst Sha256HFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_sha256h_free(ptr >>> 0));\n/**\n* Instance to calculate SHA256 in a streaming fashion\n*/\nclass Sha256H {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Sha256H.prototype);\n        obj.__wbg_ptr = ptr;\n        Sha256HFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Sha256HFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_sha256h_free(ptr);\n    }\n    /**\n    * Create new hasher instance\n    */\n    constructor() {\n        const ret = wasm.sha256h_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Feed bytes into the hasher\n    * @param {Uint8Array} data\n    */\n    update(data) {\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_export_0);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.sha256h_update(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * Finalize the hash and return the result\n    * @returns {Uint8Array}\n    */\n    finalize() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sha256h_finalize(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Clone the hasher\n    * @returns {Sha256H}\n    */\n    clone() {\n        const ret = wasm.sha256h_clone(this.__wbg_ptr);\n        return Sha256H.__wrap(ret);\n    }\n}\n\nconst Sha512HFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_sha512h_free(ptr >>> 0));\n/**\n* Instance to calculate SHA512 in a streaming fashion\n*/\nclass Sha512H {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Sha512H.prototype);\n        obj.__wbg_ptr = ptr;\n        Sha512HFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        Sha512HFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_sha512h_free(ptr);\n    }\n    /**\n    * Create new hasher instance\n    */\n    constructor() {\n        const ret = wasm.sha512h_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Feed bytes into the hasher\n    * @param {Uint8Array} data\n    */\n    update(data) {\n        const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_export_0);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.sha512h_update(this.__wbg_ptr, ptr0, len0);\n    }\n    /**\n    * Finalize the hash and return the result\n    * @returns {Uint8Array}\n    */\n    finalize() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.sha512h_finalize(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_export_1(r0, r1 * 1, 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Clone the hasher\n    * @returns {Sha512H}\n    */\n    clone() {\n        const ret = wasm.sha512h_clone(this.__wbg_ptr);\n        return Sha512H.__wrap(ret);\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedInt32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n    if (wasm !== undefined) return wasm;\n\n    if (typeof input === 'undefined') {\n        input = new URL(/* asset import */ __webpack_require__(674), __webpack_require__.b);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__wbg_init);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsY0FBYyxZQUFZO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLGNBQWMsWUFBWTtBQUMxQixjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixjQUFjLFlBQVk7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsY0FBYyxZQUFZO0FBQzFCLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixjQUFjLFlBQVk7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QjtBQUNBOztBQUVtQjtBQUNuQixpRUFBZSxVQUFVLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L2ZmaS9lY2FzaF9saWJfd2FzbV9icm93c2VyLmpzP2Q2YzEiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHdhc207XG5cbmNvbnN0IGNhY2hlZFRleHREZWNvZGVyID0gKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBpZ25vcmVCT006IHRydWUsIGZhdGFsOiB0cnVlIH0pIDogeyBkZWNvZGU6ICgpID0+IHsgdGhyb3cgRXJyb3IoJ1RleHREZWNvZGVyIG5vdCBhdmFpbGFibGUnKSB9IH0gKTtcblxuaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcpIHsgY2FjaGVkVGV4dERlY29kZXIuZGVjb2RlKCk7IH07XG5cbmxldCBjYWNoZWRVaW50OE1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50OE1lbW9yeTAoKSB7XG4gICAgaWYgKGNhY2hlZFVpbnQ4TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWRVaW50OE1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OE1lbW9yeTAgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkVWludDhNZW1vcnkwO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tV2FzbTAocHRyLCBsZW4pIHtcbiAgICBwdHIgPSBwdHIgPj4+IDA7XG4gICAgcmV0dXJuIGNhY2hlZFRleHREZWNvZGVyLmRlY29kZShnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGxlbikpO1xufVxuXG5jb25zdCBoZWFwID0gbmV3IEFycmF5KDEyOCkuZmlsbCh1bmRlZmluZWQpO1xuXG5oZWFwLnB1c2godW5kZWZpbmVkLCBudWxsLCB0cnVlLCBmYWxzZSk7XG5cbmxldCBoZWFwX25leHQgPSBoZWFwLmxlbmd0aDtcblxuZnVuY3Rpb24gYWRkSGVhcE9iamVjdChvYmopIHtcbiAgICBpZiAoaGVhcF9uZXh0ID09PSBoZWFwLmxlbmd0aCkgaGVhcC5wdXNoKGhlYXAubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgaWR4ID0gaGVhcF9uZXh0O1xuICAgIGhlYXBfbmV4dCA9IGhlYXBbaWR4XTtcblxuICAgIGhlYXBbaWR4XSA9IG9iajtcbiAgICByZXR1cm4gaWR4O1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuZnVuY3Rpb24gcGFzc0FycmF5OFRvV2FzbTAoYXJnLCBtYWxsb2MpIHtcbiAgICBjb25zdCBwdHIgPSBtYWxsb2MoYXJnLmxlbmd0aCAqIDEsIDEpID4+PiAwO1xuICAgIGdldFVpbnQ4TWVtb3J5MCgpLnNldChhcmcsIHB0ciAvIDEpO1xuICAgIFdBU01fVkVDVE9SX0xFTiA9IGFyZy5sZW5ndGg7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxubGV0IGNhY2hlZEludDMyTWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEludDMyTWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkSW50MzJNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZEludDMyTWVtb3J5MC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhY2hlZEludDMyTWVtb3J5MCA9IG5ldyBJbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRJbnQzMk1lbW9yeTA7XG59XG5cbmZ1bmN0aW9uIGdldE9iamVjdChpZHgpIHsgcmV0dXJuIGhlYXBbaWR4XTsgfVxuXG5mdW5jdGlvbiBkcm9wT2JqZWN0KGlkeCkge1xuICAgIGlmIChpZHggPCAxMzIpIHJldHVybjtcbiAgICBoZWFwW2lkeF0gPSBoZWFwX25leHQ7XG4gICAgaGVhcF9uZXh0ID0gaWR4O1xufVxuXG5mdW5jdGlvbiB0YWtlT2JqZWN0KGlkeCkge1xuICAgIGNvbnN0IHJldCA9IGdldE9iamVjdChpZHgpO1xuICAgIGRyb3BPYmplY3QoaWR4KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXRBcnJheVU4RnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgLyAxLCBwdHIgLyAxICsgbGVuKTtcbn1cblxuY29uc3QgY2FjaGVkVGV4dEVuY29kZXIgPSAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKSA6IHsgZW5jb2RlOiAoKSA9PiB7IHRocm93IEVycm9yKCdUZXh0RW5jb2RlciBub3QgYXZhaWxhYmxlJykgfSB9ICk7XG5cbmNvbnN0IGVuY29kZVN0cmluZyA9ICh0eXBlb2YgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKGFyZywgdmlldyk7XG59XG4gICAgOiBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgdmlldy5zZXQoYnVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuXG4gICAgaWYgKHJlYWxsb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgsIDEpID4+PiAwO1xuICAgICAgICBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGJ1Zi5sZW5ndGgpLnNldChidWYpO1xuICAgICAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBidWYubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGxldCBsZW4gPSBhcmcubGVuZ3RoO1xuICAgIGxldCBwdHIgPSBtYWxsb2MobGVuLCAxKSA+Pj4gMDtcblxuICAgIGNvbnN0IG1lbSA9IGdldFVpbnQ4TWVtb3J5MCgpO1xuXG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gYXJnLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgaWYgKGNvZGUgPiAweDdGKSBicmVhaztcbiAgICAgICAgbWVtW3B0ciArIG9mZnNldF0gPSBjb2RlO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXQgIT09IGxlbikge1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBwdHIgPSByZWFsbG9jKHB0ciwgbGVuLCBsZW4gPSBvZmZzZXQgKyBhcmcubGVuZ3RoICogMywgMSkgPj4+IDA7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBnZXRVaW50OE1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICAgIGNvbnN0IHJldCA9IGVuY29kZVN0cmluZyhhcmcsIHZpZXcpO1xuXG4gICAgICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgb2Zmc2V0LCAxKSA+Pj4gMDtcbiAgICB9XG5cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxuZnVuY3Rpb24gaXNMaWtlTm9uZSh4KSB7XG4gICAgcmV0dXJuIHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsO1xufVxuLyoqXG4qIFZlcmlmeSBhIHNpZ25hdHVyZSBmb3IgdGhlIGdpdmVuIGNyeXB0b2dyYXBoaWMgYWxnb3JpdGhtLlxuKiBJbnRlbmRlZCB0byBiZSB1c2VkIGluIFg1MDkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uLlxuKiBUaHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIGFsZ29yaXRobSBpcyBub3Qgc3VwcG9ydGVkLlxuKiBAcGFyYW0ge3N0cmluZ30gYWxnb19vaWRcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHBhcmFtc1xuKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHNpZ1xuKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1zZ1xuKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHBrXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHB1YmxpY0tleUNyeXB0b1ZlcmlmeShhbGdvX29pZCwgcGFyYW1zLCBzaWcsIG1zZywgcGspIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NTdHJpbmdUb1dhc20wKGFsZ29fb2lkLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzAsIHdhc20uX193YmluZGdlbl9leHBvcnRfMik7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHZhciBwdHIxID0gaXNMaWtlTm9uZShwYXJhbXMpID8gMCA6IHBhc3NTdHJpbmdUb1dhc20wKHBhcmFtcywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzIpO1xuICAgICAgICB2YXIgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMiA9IHBhc3NBcnJheThUb1dhc20wKHNpZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgY29uc3QgbGVuMiA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyMyA9IHBhc3NBcnJheThUb1dhc20wKG1zZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgY29uc3QgbGVuMyA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcHRyNCA9IHBhc3NBcnJheThUb1dhc20wKHBrLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICBjb25zdCBsZW40ID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnB1YmxpY0tleUNyeXB0b1ZlcmlmeShyZXRwdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIsIHB0cjMsIGxlbjMsIHB0cjQsIGxlbjQpO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG4vKipcbiogVGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBnaXZlbiBhbGdvIGlzIG5vdCBzdXBwb3J0ZWQsIG90aGVyd2lzZSBkbyBub3RoaW5nLlxuKiBAcGFyYW0ge3N0cmluZ30gYWxnb19vaWRcbiogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtwYXJhbXNdXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHB1YmxpY0tleUNyeXB0b0FsZ29TdXBwb3J0ZWQoYWxnb19vaWQsIHBhcmFtcykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICBjb25zdCBwdHIwID0gcGFzc1N0cmluZ1RvV2FzbTAoYWxnb19vaWQsIHdhc20uX193YmluZGdlbl9leHBvcnRfMCwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8yKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgdmFyIHB0cjEgPSBpc0xpa2VOb25lKHBhcmFtcykgPyAwIDogcGFzc1N0cmluZ1RvV2FzbTAocGFyYW1zLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzAsIHdhc20uX193YmluZGdlbl9leHBvcnRfMik7XG4gICAgICAgIHZhciBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnB1YmxpY0tleUNyeXB0b0FsZ29TdXBwb3J0ZWQocmV0cHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIGlmIChyMSkge1xuICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIENhbGN1bGF0ZSBTSEE1MTIoZGF0YSkuXG4qIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiovXG5leHBvcnQgZnVuY3Rpb24gc2hhNTEyKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9leHBvcnRfMCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uc2hhNTEyKHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgdjIgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8xKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICByZXR1cm4gdjI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBDYWxjdWxhdGUgU0hBMjU2KFNIQTI1NihkYXRhKSkuXG4qIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2ZChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnNoYTI1NmQocmV0cHRyLCBwdHIwLCBsZW4wKTtcbiAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgIHZhciB2MiA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzEocjAsIHIxICogMSwgMSk7XG4gICAgICAgIHJldHVybiB2MjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgIH1cbn1cblxuLyoqXG4qIENhbGN1bGF0ZSBTSEEyNTYoZGF0YSkuXG4qIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKGRhdGEsIHdhc20uX193YmluZGdlbl9leHBvcnRfMCk7XG4gICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgIHdhc20uc2hhMjU2KHJldHB0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICB2YXIgdjIgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8xKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICByZXR1cm4gdjI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICB9XG59XG5cbi8qKlxuKiBDYWxjdWxhdGUgUklQRU1EMTYwKFNIQTI1NihkYXRhKSksIGNvbW1vbmx5IHVzZWQgYXMgYWRkcmVzcyBoYXNoLlxuKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYVJtZDE2MChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnNoYVJtZDE2MChyZXRwdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgdmFyIHYyID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMShyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgcmV0dXJuIHYyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgfVxufVxuXG5jb25zdCBFY2NGaW5hbGl6YXRpb24gPSAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJylcbiAgICA/IHsgcmVnaXN0ZXI6ICgpID0+IHt9LCB1bnJlZ2lzdGVyOiAoKSA9PiB7fSB9XG4gICAgOiBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkocHRyID0+IHdhc20uX193YmdfZWNjX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiogRUNDIHNpZ25hdHVyZXMgd2l0aCBsaWJzZWNwMjU2azEuXG4qL1xuZXhwb3J0IGNsYXNzIEVjYyB7XG5cbiAgICBfX2Rlc3Ryb3lfaW50b19yYXcoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX193YmdfcHRyO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IDA7XG4gICAgICAgIEVjY0ZpbmFsaXphdGlvbi51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHRyO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHRoaXMuX19kZXN0cm95X2ludG9fcmF3KCk7XG4gICAgICAgIHdhc20uX193YmdfZWNjX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDcmVhdGUgYSBuZXcgRWNjIGluc3RhbmNlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uZWNjX25ldygpO1xuICAgICAgICB0aGlzLl9fd2JnX3B0ciA9IHJldCA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIHNlY3JldCBrZXkuXG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHNlY2tleVxuICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgKi9cbiAgICBkZXJpdmVQdWJrZXkoc2Vja2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChzZWNrZXksIHdhc20uX193YmluZGdlbl9leHBvcnRfMCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5lY2NfZGVyaXZlUHVia2V5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjApO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjIgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMShyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBTaWduIGFuIEVDRFNBIHNpZ25hdHVyZS5cbiAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2Vja2V5XG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1zZ1xuICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgKi9cbiAgICBlY2RzYVNpZ24oc2Vja2V5LCBtc2cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKHNlY2tleSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5OFRvV2FzbTAobXNnLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uZWNjX2VjZHNhU2lnbihyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYzID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzEocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogVmVyaWZ5IGFuIEVDRFNBIHNpZ25hdHVyZS5cbiAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2lnXG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1zZ1xuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwa1xuICAgICovXG4gICAgZWNkc2FWZXJpZnkoc2lnLCBtc2csIHBrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChzaWcsIHdhc20uX193YmluZGdlbl9leHBvcnRfMCk7XG4gICAgICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NBcnJheThUb1dhc20wKG1zZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIyID0gcGFzc0FycmF5OFRvV2FzbTAocGssIHdhc20uX193YmluZGdlbl9leHBvcnRfMCk7XG4gICAgICAgICAgICBjb25zdCBsZW4yID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICAgICAgd2FzbS5lY2NfZWNkc2FWZXJpZnkocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMik7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICBpZiAocjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBTaWduIGEgU2Nobm9yciBzaWduYXR1cmUuXG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHNlY2tleVxuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBtc2dcbiAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICovXG4gICAgc2Nobm9yclNpZ24oc2Vja2V5LCBtc2cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKHNlY2tleSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5OFRvV2FzbTAobXNnLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uZWNjX3NjaG5vcnJTaWduKHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgdmFyIHIyID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDJdO1xuICAgICAgICAgICAgdmFyIHIzID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDNdO1xuICAgICAgICAgICAgaWYgKHIzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdjMgPSBnZXRBcnJheVU4RnJvbVdhc20wKHIwLCByMSkuc2xpY2UoKTtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9leHBvcnRfMShyMCwgcjEgKiAxLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB2MztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBWZXJpZnkgYSBTY2hub3JyIHNpZ25hdHVyZS5cbiAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2lnXG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1zZ1xuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwa1xuICAgICovXG4gICAgc2Nobm9yclZlcmlmeShzaWcsIG1zZywgcGspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKHNpZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5OFRvV2FzbTAobXNnLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHB0cjIgPSBwYXNzQXJyYXk4VG9XYXNtMChwaywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjIgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmVjY19zY2hub3JyVmVyaWZ5KHJldHB0ciwgdGhpcy5fX3diZ19wdHIsIHB0cjAsIGxlbjAsIHB0cjEsIGxlbjEsIHB0cjIsIGxlbjIpO1xuICAgICAgICAgICAgdmFyIHIwID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDBdO1xuICAgICAgICAgICAgdmFyIHIxID0gZ2V0SW50MzJNZW1vcnkwKClbcmV0cHRyIC8gNCArIDFdO1xuICAgICAgICAgICAgaWYgKHIxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGFrZU9iamVjdChyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIHNlY3JldCBrZXkgaXMgdmFsaWQsIGkuZS4gd2hldGhlciBpcyBvZiBjb3JyZWN0XG4gICAgKiBsZW5ndGggKDMyIGJ5dGVzKSBhbmQgaXMgb24gdGhlIGN1cnZlLlxuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBzZWNrZXlcbiAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICovXG4gICAgaXNWYWxpZFNlY2tleShzZWNrZXkpIHtcbiAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKHNlY2tleSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgY29uc3QgcmV0ID0gd2FzbS5lY2NfaXNWYWxpZFNlY2tleSh0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCk7XG4gICAgICAgIHJldHVybiByZXQgIT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICogQWRkIGEgc2NhbGFyIHRvIGEgc2VjcmV0IGtleS5cbiAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYVxuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBiXG4gICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAqL1xuICAgIHNlY2tleUFkZChhLCBiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChhLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICAgICAgY29uc3QgbGVuMCA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIGNvbnN0IHB0cjEgPSBwYXNzQXJyYXk4VG9XYXNtMChiLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uZWNjX3NlY2tleUFkZChyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYzID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzEocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogQWRkIGEgc2NhbGFyIHRvIGEgcHVibGljIGtleSAoYWRkaW5nIEcqYikuXG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFcbiAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYlxuICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgKi9cbiAgICBwdWJrZXlBZGQoYSwgYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cHRyID0gd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKC0xNik7XG4gICAgICAgICAgICBjb25zdCBwdHIwID0gcGFzc0FycmF5OFRvV2FzbTAoYSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5OFRvV2FzbTAoYiwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjEgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICB3YXNtLmVjY19wdWJrZXlBZGQocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2MyA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8xKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYzO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIENyZWF0ZSBhIGNvbXBhY3QgRUNEU0Egc2lnbmF0dXJlICg2NSBieXRlcyksIHdoaWNoIGFsbG93cyByZWNvbnN0cnVjdGluZ1xuICAgICogdGhlIHVzZWQgcHVibGljIGtleS5cbiAgICAqIFRoZSBmb3JtYXQgaXMgb25lIGhlYWRlciBieXRlLCBmb2xsb3dlZCBieSB0d28gdGltZXMgMzIgYnl0ZXMgZm9yIHRoZVxuICAgICogc2VyaWFsaXplZCByIGFuZCBzIHZhbHVlcy5cbiAgICAqIFRoZSBoZWFkZXIgYnl0ZTogMHgxQiA9IGZpcnN0IGtleSB3aXRoIGV2ZW4geSxcbiAgICAqICAgICAgICAgICAgICAgICAgMHgxQyA9IGZpcnN0IGtleSB3aXRoIG9kZCB5LFxuICAgICogICAgICAgICAgICAgICAgICAweDFEID0gc2Vjb25kIGtleSB3aXRoIGV2ZW4geSxcbiAgICAqICAgICAgICAgICAgICAgICAgMHgxRSA9IHNlY29uZCBrZXkgd2l0aCBvZGQgeSxcbiAgICAqICAgICAgICAgICAgICAgICAgYWRkIDB4MDQgZm9yIGNvbXByZXNzZWQga2V5cy5cbiAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2Vja2V5XG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1zZ1xuICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAgKi9cbiAgICBzaWduUmVjb3ZlcmFibGUoc2Vja2V5LCBtc2cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKHNlY2tleSwgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5OFRvV2FzbTAobXNnLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uZWNjX3NpZ25SZWNvdmVyYWJsZShyZXRwdHIsIHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wLCBwdHIxLCBsZW4xKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciByMiA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAyXTtcbiAgICAgICAgICAgIHZhciByMyA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAzXTtcbiAgICAgICAgICAgIGlmIChyMykge1xuICAgICAgICAgICAgICAgIHRocm93IHRha2VPYmplY3QocjIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYzID0gZ2V0QXJyYXlVOEZyb21XYXNtMChyMCwgcjEpLnNsaWNlKCk7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzEocjAsIHIxICogMSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdjM7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogUmVjb3ZlciB0aGUgcHVibGljIGtleSBvZiBhIHNpZ25hdHVyZSBzaWduZWQgYnkgc2lnblJlY292ZXJhYmxlLlxuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBzaWdcbiAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gbXNnXG4gICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAqL1xuICAgIHJlY292ZXJTaWcoc2lnLCBtc2cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHB0ciA9IHdhc20uX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcigtMTYpO1xuICAgICAgICAgICAgY29uc3QgcHRyMCA9IHBhc3NBcnJheThUb1dhc20wKHNpZywgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8wKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbjAgPSBXQVNNX1ZFQ1RPUl9MRU47XG4gICAgICAgICAgICBjb25zdCBwdHIxID0gcGFzc0FycmF5OFRvV2FzbTAobXNnLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICAgICAgY29uc3QgbGVuMSA9IFdBU01fVkVDVE9SX0xFTjtcbiAgICAgICAgICAgIHdhc20uZWNjX3JlY292ZXJTaWcocmV0cHRyLCB0aGlzLl9fd2JnX3B0ciwgcHRyMCwgbGVuMCwgcHRyMSwgbGVuMSk7XG4gICAgICAgICAgICB2YXIgcjAgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMF07XG4gICAgICAgICAgICB2YXIgcjEgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMV07XG4gICAgICAgICAgICB2YXIgcjIgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgMl07XG4gICAgICAgICAgICB2YXIgcjMgPSBnZXRJbnQzMk1lbW9yeTAoKVtyZXRwdHIgLyA0ICsgM107XG4gICAgICAgICAgICBpZiAocjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0YWtlT2JqZWN0KHIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2MyA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8xKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYzO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgU2hhMjU2SEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zaGEyNTZoX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiogSW5zdGFuY2UgdG8gY2FsY3VsYXRlIFNIQTI1NiBpbiBhIHN0cmVhbWluZyBmYXNoaW9uXG4qL1xuZXhwb3J0IGNsYXNzIFNoYTI1Nkgge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNoYTI1NkgucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2hhMjU2SEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTaGEyNTZIRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zaGEyNTZoX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDcmVhdGUgbmV3IGhhc2hlciBpbnN0YW5jZVxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2hhMjU2aF9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEZlZWQgYnl0ZXMgaW50byB0aGUgaGFzaGVyXG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAgICAqL1xuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnNoYTI1NmhfdXBkYXRlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBGaW5hbGl6ZSB0aGUgaGFzaCBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICovXG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2hhMjU2aF9maW5hbGl6ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8xKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIENsb25lIHRoZSBoYXNoZXJcbiAgICAqIEByZXR1cm5zIHtTaGEyNTZIfVxuICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2hhMjU2aF9jbG9uZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTaGEyNTZILl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuY29uc3QgU2hhNTEySEZpbmFsaXphdGlvbiA9ICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKVxuICAgID8geyByZWdpc3RlcjogKCkgPT4ge30sIHVucmVnaXN0ZXI6ICgpID0+IHt9IH1cbiAgICA6IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShwdHIgPT4gd2FzbS5fX3diZ19zaGE1MTJoX2ZyZWUocHRyID4+PiAwKSk7XG4vKipcbiogSW5zdGFuY2UgdG8gY2FsY3VsYXRlIFNIQTUxMiBpbiBhIHN0cmVhbWluZyBmYXNoaW9uXG4qL1xuZXhwb3J0IGNsYXNzIFNoYTUxMkgge1xuXG4gICAgc3RhdGljIF9fd3JhcChwdHIpIHtcbiAgICAgICAgcHRyID0gcHRyID4+PiAwO1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKFNoYTUxMkgucHJvdG90eXBlKTtcbiAgICAgICAgb2JqLl9fd2JnX3B0ciA9IHB0cjtcbiAgICAgICAgU2hhNTEySEZpbmFsaXphdGlvbi5yZWdpc3RlcihvYmosIG9iai5fX3diZ19wdHIsIG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX19kZXN0cm95X2ludG9fcmF3KCkge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLl9fd2JnX3B0cjtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSAwO1xuICAgICAgICBTaGE1MTJIRmluYWxpemF0aW9uLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgY29uc3QgcHRyID0gdGhpcy5fX2Rlc3Ryb3lfaW50b19yYXcoKTtcbiAgICAgICAgd2FzbS5fX3diZ19zaGE1MTJoX2ZyZWUocHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDcmVhdGUgbmV3IGhhc2hlciBpbnN0YW5jZVxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2hhNTEyaF9uZXcoKTtcbiAgICAgICAgdGhpcy5fX3diZ19wdHIgPSByZXQgPj4+IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEZlZWQgYnl0ZXMgaW50byB0aGUgaGFzaGVyXG4gICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAgICAqL1xuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHB0cjAgPSBwYXNzQXJyYXk4VG9XYXNtMChkYXRhLCB3YXNtLl9fd2JpbmRnZW5fZXhwb3J0XzApO1xuICAgICAgICBjb25zdCBsZW4wID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICB3YXNtLnNoYTUxMmhfdXBkYXRlKHRoaXMuX193YmdfcHRyLCBwdHIwLCBsZW4wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBGaW5hbGl6ZSB0aGUgaGFzaCBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICovXG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXRwdHIgPSB3YXNtLl9fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIoLTE2KTtcbiAgICAgICAgICAgIHdhc20uc2hhNTEyaF9maW5hbGl6ZShyZXRwdHIsIHRoaXMuX193YmdfcHRyKTtcbiAgICAgICAgICAgIHZhciByMCA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAwXTtcbiAgICAgICAgICAgIHZhciByMSA9IGdldEludDMyTWVtb3J5MCgpW3JldHB0ciAvIDQgKyAxXTtcbiAgICAgICAgICAgIHZhciB2MSA9IGdldEFycmF5VThGcm9tV2FzbTAocjAsIHIxKS5zbGljZSgpO1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2V4cG9ydF8xKHIwLCByMSAqIDEsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHYxO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgd2FzbS5fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyKDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIENsb25lIHRoZSBoYXNoZXJcbiAgICAqIEByZXR1cm5zIHtTaGE1MTJIfVxuICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHdhc20uc2hhNTEyaF9jbG9uZSh0aGlzLl9fd2JnX3B0cik7XG4gICAgICAgIHJldHVybiBTaGE1MTJILl9fd3JhcChyZXQpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX193YmdfbG9hZChtb2R1bGUsIGltcG9ydHMpIHtcbiAgICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAnZnVuY3Rpb24nICYmIG1vZHVsZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kdWxlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSAhPSAnYXBwbGljYXRpb24vd2FzbScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nYCBmYWlsZWQgYmVjYXVzZSB5b3VyIHNlcnZlciBkb2VzIG5vdCBzZXJ2ZSB3YXNtIHdpdGggYGFwcGxpY2F0aW9uL3dhc21gIE1JTUUgdHlwZS4gRmFsbGluZyBiYWNrIHRvIGBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZWAgd2hpY2ggaXMgc2xvd2VyLiBPcmlnaW5hbCBlcnJvcjpcXG5cIiwgZSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgbW9kdWxlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShieXRlcywgaW1wb3J0cyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGluc3RhbmNlLCBtb2R1bGUgfTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfX3diZ19nZXRfaW1wb3J0cygpIHtcbiAgICBjb25zdCBpbXBvcnRzID0ge307XG4gICAgaW1wb3J0cy53YmcgPSB7fTtcbiAgICBpbXBvcnRzLndiZy5fX3diaW5kZ2VuX3N0cmluZ19uZXcgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IGdldFN0cmluZ0Zyb21XYXNtMChhcmcwLCBhcmcxKTtcbiAgICAgICAgcmV0dXJuIGFkZEhlYXBPYmplY3QocmV0KTtcbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JpbmRnZW5fdGhyb3cgPSBmdW5jdGlvbihhcmcwLCBhcmcxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihnZXRTdHJpbmdGcm9tV2FzbTAoYXJnMCwgYXJnMSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW1wb3J0cztcbn1cblxuZnVuY3Rpb24gX193YmdfaW5pdF9tZW1vcnkoaW1wb3J0cywgbWF5YmVfbWVtb3J5KSB7XG5cbn1cblxuZnVuY3Rpb24gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgd2FzbSA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgX193YmdfaW5pdC5fX3diaW5kZ2VuX3dhc21fbW9kdWxlID0gbW9kdWxlO1xuICAgIGNhY2hlZEludDMyTWVtb3J5MCA9IG51bGw7XG4gICAgY2FjaGVkVWludDhNZW1vcnkwID0gbnVsbDtcblxuXG4gICAgcmV0dXJuIHdhc207XG59XG5cbmZ1bmN0aW9uIGluaXRTeW5jKG1vZHVsZSkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG4gICAgY29uc3QgaW1wb3J0cyA9IF9fd2JnX2dldF9pbXBvcnRzKCk7XG5cbiAgICBfX3diZ19pbml0X21lbW9yeShpbXBvcnRzKTtcblxuICAgIGlmICghKG1vZHVsZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZSkpIHtcbiAgICAgICAgbW9kdWxlID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShtb2R1bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX193YmdfaW5pdChpbnB1dCkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW5wdXQgPSBuZXcgVVJMKCdlY2FzaF9saWJfd2FzbV9iZ19icm93c2VyLndhc20nLCBpbXBvcnQubWV0YS51cmwpO1xuICAgIH1cbiAgICBjb25zdCBpbXBvcnRzID0gX193YmdfZ2V0X2ltcG9ydHMoKTtcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8ICh0eXBlb2YgUmVxdWVzdCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHx8ICh0eXBlb2YgVVJMID09PSAnZnVuY3Rpb24nICYmIGlucHV0IGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBpbnB1dCA9IGZldGNoKGlucHV0KTtcbiAgICB9XG5cbiAgICBfX3diZ19pbml0X21lbW9yeShpbXBvcnRzKTtcblxuICAgIGNvbnN0IHsgaW5zdGFuY2UsIG1vZHVsZSB9ID0gYXdhaXQgX193YmdfbG9hZChhd2FpdCBpbnB1dCwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuZXhwb3J0IHsgaW5pdFN5bmMgfVxuZXhwb3J0IGRlZmF1bHQgX193YmdfaW5pdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3650\n\n}")},3678:function(module){eval("{/*!\n * pulltorefreshjs v0.1.22\n * (c) Rafael Soto\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, function () { 'use strict';\n\n  var _shared = {\n    pullStartY: null,\n    pullMoveY: null,\n    handlers: [],\n    styleEl: null,\n    events: null,\n    dist: 0,\n    state: 'pending',\n    timeout: null,\n    distResisted: 0,\n    supportsPassive: false,\n    supportsPointerEvents: typeof window !== 'undefined' && !!window.PointerEvent\n  };\n\n  try {\n    window.addEventListener('test', null, {\n      get passive() {\n        // eslint-disable-line getter-return\n        _shared.supportsPassive = true;\n      }\n\n    });\n  } catch (e) {// do nothing\n  }\n\n  function setupDOM(handler) {\n    if (!handler.ptrElement) {\n      var ptr = document.createElement('div');\n\n      if (handler.mainElement !== document.body) {\n        handler.mainElement.parentNode.insertBefore(ptr, handler.mainElement);\n      } else {\n        document.body.insertBefore(ptr, document.body.firstChild);\n      }\n\n      ptr.classList.add(((handler.classPrefix) + \"ptr\"));\n      ptr.innerHTML = handler.getMarkup().replace(/__PREFIX__/g, handler.classPrefix);\n      handler.ptrElement = ptr;\n\n      if (typeof handler.onInit === 'function') {\n        handler.onInit(handler);\n      } // Add the css styles to the style node, and then\n      // insert it into the dom\n\n\n      if (!_shared.styleEl) {\n        _shared.styleEl = document.createElement('style');\n\n        _shared.styleEl.setAttribute('id', 'pull-to-refresh-js-style');\n\n        document.head.appendChild(_shared.styleEl);\n      }\n\n      _shared.styleEl.textContent = handler.getStyles().replace(/__PREFIX__/g, handler.classPrefix).replace(/\\s+/g, ' ');\n    }\n\n    return handler;\n  }\n\n  function onReset(handler) {\n    if (!handler.ptrElement) { return; }\n    handler.ptrElement.classList.remove(((handler.classPrefix) + \"refresh\"));\n    handler.ptrElement.style[handler.cssProp] = '0px';\n    setTimeout(function () {\n      // remove previous ptr-element from DOM\n      if (handler.ptrElement && handler.ptrElement.parentNode) {\n        handler.ptrElement.parentNode.removeChild(handler.ptrElement);\n        handler.ptrElement = null;\n      } // reset state\n\n\n      _shared.state = 'pending';\n    }, handler.refreshTimeout);\n  }\n\n  function update(handler) {\n    var iconEl = handler.ptrElement.querySelector((\".\" + (handler.classPrefix) + \"icon\"));\n    var textEl = handler.ptrElement.querySelector((\".\" + (handler.classPrefix) + \"text\"));\n\n    if (iconEl) {\n      if (_shared.state === 'refreshing') {\n        iconEl.innerHTML = handler.iconRefreshing;\n      } else {\n        iconEl.innerHTML = handler.iconArrow;\n      }\n    }\n\n    if (textEl) {\n      if (_shared.state === 'releasing') {\n        textEl.innerHTML = handler.instructionsReleaseToRefresh;\n      }\n\n      if (_shared.state === 'pulling' || _shared.state === 'pending') {\n        textEl.innerHTML = handler.instructionsPullToRefresh;\n      }\n\n      if (_shared.state === 'refreshing') {\n        textEl.innerHTML = handler.instructionsRefreshing;\n      }\n    }\n  }\n\n  var _ptr = {\n    setupDOM: setupDOM,\n    onReset: onReset,\n    update: update\n  };\n\n  var _timeout;\n\n  var screenY = function screenY(event) {\n    if (_shared.pointerEventsEnabled && _shared.supportsPointerEvents) {\n      return event.screenY;\n    }\n\n    return event.touches[0].screenY;\n  };\n\n  var _setupEvents = (function () {\n    var _el;\n\n    function _onTouchStart(e) {\n      // here, we must pick a handler first, and then append their html/css on the DOM\n      var target = _shared.handlers.filter(function (h) { return h.contains(e.target); })[0];\n\n      _shared.enable = !!target;\n\n      if (target && _shared.state === 'pending') {\n        _el = _ptr.setupDOM(target);\n\n        if (target.shouldPullToRefresh()) {\n          _shared.pullStartY = screenY(e);\n        }\n\n        clearTimeout(_shared.timeout);\n\n        _ptr.update(target);\n      }\n    }\n\n    function _onTouchMove(e) {\n      if (!(_el && _el.ptrElement && _shared.enable)) {\n        return;\n      }\n\n      if (!_shared.pullStartY) {\n        if (_el.shouldPullToRefresh()) {\n          _shared.pullStartY = screenY(e);\n        }\n      } else {\n        _shared.pullMoveY = screenY(e);\n      }\n\n      if (_shared.state === 'refreshing') {\n        if (e.cancelable && _el.shouldPullToRefresh() && _shared.pullStartY < _shared.pullMoveY) {\n          e.preventDefault();\n        }\n\n        return;\n      }\n\n      if (_shared.state === 'pending') {\n        _el.ptrElement.classList.add(((_el.classPrefix) + \"pull\"));\n\n        _shared.state = 'pulling';\n\n        _ptr.update(_el);\n      }\n\n      if (_shared.pullStartY && _shared.pullMoveY) {\n        _shared.dist = _shared.pullMoveY - _shared.pullStartY;\n      }\n\n      _shared.distExtra = _shared.dist - _el.distIgnore;\n\n      if (_shared.distExtra > 0) {\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n\n        _el.ptrElement.style[_el.cssProp] = (_shared.distResisted) + \"px\";\n        _shared.distResisted = _el.resistanceFunction(_shared.distExtra / _el.distThreshold) * Math.min(_el.distMax, _shared.distExtra);\n\n        if (_shared.state === 'pulling' && _shared.distResisted > _el.distThreshold) {\n          _el.ptrElement.classList.add(((_el.classPrefix) + \"release\"));\n\n          _shared.state = 'releasing';\n\n          _ptr.update(_el);\n        }\n\n        if (_shared.state === 'releasing' && _shared.distResisted < _el.distThreshold) {\n          _el.ptrElement.classList.remove(((_el.classPrefix) + \"release\"));\n\n          _shared.state = 'pulling';\n\n          _ptr.update(_el);\n        }\n      }\n    }\n\n    function _onTouchEnd() {\n      if (!(_el && _el.ptrElement && _shared.enable)) {\n        return;\n      } // wait 1/2 sec before unmounting...\n\n\n      clearTimeout(_timeout);\n      _timeout = setTimeout(function () {\n        if (_el && _el.ptrElement && _shared.state === 'pending') {\n          _ptr.onReset(_el);\n        }\n      }, 500);\n\n      if (_shared.state === 'releasing' && _shared.distResisted > _el.distThreshold) {\n        _shared.state = 'refreshing';\n        _el.ptrElement.style[_el.cssProp] = (_el.distReload) + \"px\";\n\n        _el.ptrElement.classList.add(((_el.classPrefix) + \"refresh\"));\n\n        _shared.timeout = setTimeout(function () {\n          var retval = _el.onRefresh(function () { return _ptr.onReset(_el); });\n\n          if (retval && typeof retval.then === 'function') {\n            retval.then(function () { return _ptr.onReset(_el); });\n          }\n\n          if (!retval && !_el.onRefresh.length) {\n            _ptr.onReset(_el);\n          }\n        }, _el.refreshTimeout);\n      } else {\n        if (_shared.state === 'refreshing') {\n          return;\n        }\n\n        _el.ptrElement.style[_el.cssProp] = '0px';\n        _shared.state = 'pending';\n      }\n\n      _ptr.update(_el);\n\n      _el.ptrElement.classList.remove(((_el.classPrefix) + \"release\"));\n\n      _el.ptrElement.classList.remove(((_el.classPrefix) + \"pull\"));\n\n      _shared.pullStartY = _shared.pullMoveY = null;\n      _shared.dist = _shared.distResisted = 0;\n    }\n\n    function _onScroll() {\n      if (_el) {\n        _el.mainElement.classList.toggle(((_el.classPrefix) + \"top\"), _el.shouldPullToRefresh());\n      }\n    }\n\n    var _passiveSettings = _shared.supportsPassive ? {\n      passive: _shared.passive || false\n    } : undefined;\n\n    if (_shared.pointerEventsEnabled && _shared.supportsPointerEvents) {\n      window.addEventListener('pointerup', _onTouchEnd);\n      window.addEventListener('pointerdown', _onTouchStart);\n      window.addEventListener('pointermove', _onTouchMove, _passiveSettings);\n    } else {\n      window.addEventListener('touchend', _onTouchEnd);\n      window.addEventListener('touchstart', _onTouchStart);\n      window.addEventListener('touchmove', _onTouchMove, _passiveSettings);\n    }\n\n    window.addEventListener('scroll', _onScroll);\n    return {\n      onTouchEnd: _onTouchEnd,\n      onTouchStart: _onTouchStart,\n      onTouchMove: _onTouchMove,\n      onScroll: _onScroll,\n\n      destroy: function destroy() {\n        if (_shared.pointerEventsEnabled && _shared.supportsPointerEvents) {\n          window.removeEventListener('pointerdown', _onTouchStart);\n          window.removeEventListener('pointerup', _onTouchEnd);\n          window.removeEventListener('pointermove', _onTouchMove, _passiveSettings);\n        } else {\n          window.removeEventListener('touchstart', _onTouchStart);\n          window.removeEventListener('touchend', _onTouchEnd);\n          window.removeEventListener('touchmove', _onTouchMove, _passiveSettings);\n        }\n\n        window.removeEventListener('scroll', _onScroll);\n      }\n\n    };\n  });\n\n  var _ptrMarkup = \"\\n<div class=\\\"__PREFIX__box\\\">\\n  <div class=\\\"__PREFIX__content\\\">\\n    <div class=\\\"__PREFIX__icon\\\"></div>\\n    <div class=\\\"__PREFIX__text\\\"></div>\\n  </div>\\n</div>\\n\";\n\n  var _ptrStyles = \"\\n.__PREFIX__ptr {\\n  box-shadow: inset 0 -3px 5px rgba(0, 0, 0, 0.12);\\n  pointer-events: none;\\n  font-size: 0.85em;\\n  font-weight: bold;\\n  top: 0;\\n  height: 0;\\n  transition: height 0.3s, min-height 0.3s;\\n  text-align: center;\\n  width: 100%;\\n  overflow: hidden;\\n  display: flex;\\n  align-items: flex-end;\\n  align-content: stretch;\\n}\\n\\n.__PREFIX__box {\\n  padding: 10px;\\n  flex-basis: 100%;\\n}\\n\\n.__PREFIX__pull {\\n  transition: none;\\n}\\n\\n.__PREFIX__text {\\n  margin-top: .33em;\\n  color: rgba(0, 0, 0, 0.3);\\n}\\n\\n.__PREFIX__icon {\\n  color: rgba(0, 0, 0, 0.3);\\n  transition: transform .3s;\\n}\\n\\n/*\\nWhen at the top of the page, disable vertical overscroll so passive touch\\nlisteners can take over.\\n*/\\n.__PREFIX__top {\\n  touch-action: pan-x pan-down pinch-zoom;\\n}\\n\\n.__PREFIX__release .__PREFIX__icon {\\n  transform: rotate(180deg);\\n}\\n\";\n\n  var _defaults = {\n    distThreshold: 60,\n    distMax: 80,\n    distReload: 50,\n    distIgnore: 0,\n    mainElement: 'body',\n    triggerElement: 'body',\n    ptrElement: '.ptr',\n    classPrefix: 'ptr--',\n    cssProp: 'min-height',\n    iconArrow: '&#8675;',\n    iconRefreshing: '&hellip;',\n    instructionsPullToRefresh: 'Pull down to refresh',\n    instructionsReleaseToRefresh: 'Release to refresh',\n    instructionsRefreshing: 'Refreshing',\n    refreshTimeout: 500,\n    getMarkup: function () { return _ptrMarkup; },\n    getStyles: function () { return _ptrStyles; },\n    onInit: function () {},\n    onRefresh: function () { return location.reload(); },\n    resistanceFunction: function (t) { return Math.min(1, t / 2.5); },\n    shouldPullToRefresh: function () { return !window.scrollY; }\n  };\n\n  var _methods = ['mainElement', 'ptrElement', 'triggerElement'];\n  var _setupHandler = (function (options) {\n    var _handler = {}; // merge options with defaults\n\n    Object.keys(_defaults).forEach(function (key) {\n      _handler[key] = options[key] || _defaults[key];\n    }); // normalize timeout value, even if it is zero\n\n    _handler.refreshTimeout = typeof options.refreshTimeout === 'number' ? options.refreshTimeout : _defaults.refreshTimeout; // normalize elements\n\n    _methods.forEach(function (method) {\n      if (typeof _handler[method] === 'string') {\n        _handler[method] = document.querySelector(_handler[method]);\n      }\n    }); // attach events lazily\n\n\n    if (!_shared.events) {\n      _shared.events = _setupEvents();\n    }\n\n    _handler.contains = function (target) {\n      return _handler.triggerElement.contains(target);\n    };\n\n    _handler.destroy = function () {\n      // stop pending any pending callbacks\n      clearTimeout(_shared.timeout); // remove handler from shared state\n\n      var offset = _shared.handlers.indexOf(_handler);\n\n      _shared.handlers.splice(offset, 1);\n    };\n\n    return _handler;\n  });\n\n  var index = {\n    setPassiveMode: function setPassiveMode(isPassive) {\n      _shared.passive = isPassive;\n    },\n\n    setPointerEventsMode: function setPointerEventsMode(isEnabled) {\n      _shared.pointerEventsEnabled = isEnabled;\n    },\n\n    destroyAll: function destroyAll() {\n      if (_shared.events) {\n        _shared.events.destroy();\n\n        _shared.events = null;\n      }\n\n      _shared.handlers.forEach(function (h) {\n        h.destroy();\n      });\n    },\n\n    init: function init(options) {\n      if ( options === void 0 ) options = {};\n\n      var handler = _setupHandler(options);\n\n      _shared.handlers.push(handler);\n\n      return handler;\n    },\n\n    // export utils for testing\n    _: {\n      setupHandler: _setupHandler,\n      setupEvents: _setupEvents,\n      setupDOM: _ptr.setupDOM,\n      onReset: _ptr.onReset,\n      update: _ptr.update\n    }\n  };\n\n  return index;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsNkJBQTZCLG9CQUFvQjtBQUNqRCw2QkFBNkIsb0JBQW9CO0FBQ2pELDBCQUEwQjtBQUMxQiw2QkFBNkIsMkJBQTJCO0FBQ3hELHVDQUF1Qyw4QkFBOEI7QUFDckUsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsOEhBQThIOztBQUU5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcHVsbHRvcmVmcmVzaGpzL2Rpc3QvaW5kZXgudW1kLmpzP2ViNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBwdWxsdG9yZWZyZXNoanMgdjAuMS4yMlxuICogKGMpIFJhZmFlbCBTb3RvXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuUHVsbFRvUmVmcmVzaCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfc2hhcmVkID0ge1xuICAgIHB1bGxTdGFydFk6IG51bGwsXG4gICAgcHVsbE1vdmVZOiBudWxsLFxuICAgIGhhbmRsZXJzOiBbXSxcbiAgICBzdHlsZUVsOiBudWxsLFxuICAgIGV2ZW50czogbnVsbCxcbiAgICBkaXN0OiAwLFxuICAgIHN0YXRlOiAncGVuZGluZycsXG4gICAgdGltZW91dDogbnVsbCxcbiAgICBkaXN0UmVzaXN0ZWQ6IDAsXG4gICAgc3VwcG9ydHNQYXNzaXZlOiBmYWxzZSxcbiAgICBzdXBwb3J0c1BvaW50ZXJFdmVudHM6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93LlBvaW50ZXJFdmVudFxuICB9O1xuXG4gIHRyeSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXG4gICAgICAgIF9zaGFyZWQuc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7Ly8gZG8gbm90aGluZ1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXBET00oaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlci5wdHJFbGVtZW50KSB7XG4gICAgICB2YXIgcHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGlmIChoYW5kbGVyLm1haW5FbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGhhbmRsZXIubWFpbkVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocHRyLCBoYW5kbGVyLm1haW5FbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKHB0ciwgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcHRyLmNsYXNzTGlzdC5hZGQoKChoYW5kbGVyLmNsYXNzUHJlZml4KSArIFwicHRyXCIpKTtcbiAgICAgIHB0ci5pbm5lckhUTUwgPSBoYW5kbGVyLmdldE1hcmt1cCgpLnJlcGxhY2UoL19fUFJFRklYX18vZywgaGFuZGxlci5jbGFzc1ByZWZpeCk7XG4gICAgICBoYW5kbGVyLnB0ckVsZW1lbnQgPSBwdHI7XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlci5vbkluaXQoaGFuZGxlcik7XG4gICAgICB9IC8vIEFkZCB0aGUgY3NzIHN0eWxlcyB0byB0aGUgc3R5bGUgbm9kZSwgYW5kIHRoZW5cbiAgICAgIC8vIGluc2VydCBpdCBpbnRvIHRoZSBkb21cblxuXG4gICAgICBpZiAoIV9zaGFyZWQuc3R5bGVFbCkge1xuICAgICAgICBfc2hhcmVkLnN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gICAgICAgIF9zaGFyZWQuc3R5bGVFbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3B1bGwtdG8tcmVmcmVzaC1qcy1zdHlsZScpO1xuXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoX3NoYXJlZC5zdHlsZUVsKTtcbiAgICAgIH1cblxuICAgICAgX3NoYXJlZC5zdHlsZUVsLnRleHRDb250ZW50ID0gaGFuZGxlci5nZXRTdHlsZXMoKS5yZXBsYWNlKC9fX1BSRUZJWF9fL2csIGhhbmRsZXIuY2xhc3NQcmVmaXgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUmVzZXQoaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlci5wdHJFbGVtZW50KSB7IHJldHVybjsgfVxuICAgIGhhbmRsZXIucHRyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCgoaGFuZGxlci5jbGFzc1ByZWZpeCkgKyBcInJlZnJlc2hcIikpO1xuICAgIGhhbmRsZXIucHRyRWxlbWVudC5zdHlsZVtoYW5kbGVyLmNzc1Byb3BdID0gJzBweCc7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyByZW1vdmUgcHJldmlvdXMgcHRyLWVsZW1lbnQgZnJvbSBET01cbiAgICAgIGlmIChoYW5kbGVyLnB0ckVsZW1lbnQgJiYgaGFuZGxlci5wdHJFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgaGFuZGxlci5wdHJFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGFuZGxlci5wdHJFbGVtZW50KTtcbiAgICAgICAgaGFuZGxlci5wdHJFbGVtZW50ID0gbnVsbDtcbiAgICAgIH0gLy8gcmVzZXQgc3RhdGVcblxuXG4gICAgICBfc2hhcmVkLnN0YXRlID0gJ3BlbmRpbmcnO1xuICAgIH0sIGhhbmRsZXIucmVmcmVzaFRpbWVvdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGhhbmRsZXIpIHtcbiAgICB2YXIgaWNvbkVsID0gaGFuZGxlci5wdHJFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoKFwiLlwiICsgKGhhbmRsZXIuY2xhc3NQcmVmaXgpICsgXCJpY29uXCIpKTtcbiAgICB2YXIgdGV4dEVsID0gaGFuZGxlci5wdHJFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoKFwiLlwiICsgKGhhbmRsZXIuY2xhc3NQcmVmaXgpICsgXCJ0ZXh0XCIpKTtcblxuICAgIGlmIChpY29uRWwpIHtcbiAgICAgIGlmIChfc2hhcmVkLnN0YXRlID09PSAncmVmcmVzaGluZycpIHtcbiAgICAgICAgaWNvbkVsLmlubmVySFRNTCA9IGhhbmRsZXIuaWNvblJlZnJlc2hpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpY29uRWwuaW5uZXJIVE1MID0gaGFuZGxlci5pY29uQXJyb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHRFbCkge1xuICAgICAgaWYgKF9zaGFyZWQuc3RhdGUgPT09ICdyZWxlYXNpbmcnKSB7XG4gICAgICAgIHRleHRFbC5pbm5lckhUTUwgPSBoYW5kbGVyLmluc3RydWN0aW9uc1JlbGVhc2VUb1JlZnJlc2g7XG4gICAgICB9XG5cbiAgICAgIGlmIChfc2hhcmVkLnN0YXRlID09PSAncHVsbGluZycgfHwgX3NoYXJlZC5zdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIHRleHRFbC5pbm5lckhUTUwgPSBoYW5kbGVyLmluc3RydWN0aW9uc1B1bGxUb1JlZnJlc2g7XG4gICAgICB9XG5cbiAgICAgIGlmIChfc2hhcmVkLnN0YXRlID09PSAncmVmcmVzaGluZycpIHtcbiAgICAgICAgdGV4dEVsLmlubmVySFRNTCA9IGhhbmRsZXIuaW5zdHJ1Y3Rpb25zUmVmcmVzaGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgX3B0ciA9IHtcbiAgICBzZXR1cERPTTogc2V0dXBET00sXG4gICAgb25SZXNldDogb25SZXNldCxcbiAgICB1cGRhdGU6IHVwZGF0ZVxuICB9O1xuXG4gIHZhciBfdGltZW91dDtcblxuICB2YXIgc2NyZWVuWSA9IGZ1bmN0aW9uIHNjcmVlblkoZXZlbnQpIHtcbiAgICBpZiAoX3NoYXJlZC5wb2ludGVyRXZlbnRzRW5hYmxlZCAmJiBfc2hhcmVkLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xuICAgICAgcmV0dXJuIGV2ZW50LnNjcmVlblk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50LnRvdWNoZXNbMF0uc2NyZWVuWTtcbiAgfTtcblxuICB2YXIgX3NldHVwRXZlbnRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2VsO1xuXG4gICAgZnVuY3Rpb24gX29uVG91Y2hTdGFydChlKSB7XG4gICAgICAvLyBoZXJlLCB3ZSBtdXN0IHBpY2sgYSBoYW5kbGVyIGZpcnN0LCBhbmQgdGhlbiBhcHBlbmQgdGhlaXIgaHRtbC9jc3Mgb24gdGhlIERPTVxuICAgICAgdmFyIHRhcmdldCA9IF9zaGFyZWQuaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChoKSB7IHJldHVybiBoLmNvbnRhaW5zKGUudGFyZ2V0KTsgfSlbMF07XG5cbiAgICAgIF9zaGFyZWQuZW5hYmxlID0gISF0YXJnZXQ7XG5cbiAgICAgIGlmICh0YXJnZXQgJiYgX3NoYXJlZC5zdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIF9lbCA9IF9wdHIuc2V0dXBET00odGFyZ2V0KTtcblxuICAgICAgICBpZiAodGFyZ2V0LnNob3VsZFB1bGxUb1JlZnJlc2goKSkge1xuICAgICAgICAgIF9zaGFyZWQucHVsbFN0YXJ0WSA9IHNjcmVlblkoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQoX3NoYXJlZC50aW1lb3V0KTtcblxuICAgICAgICBfcHRyLnVwZGF0ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vblRvdWNoTW92ZShlKSB7XG4gICAgICBpZiAoIShfZWwgJiYgX2VsLnB0ckVsZW1lbnQgJiYgX3NoYXJlZC5lbmFibGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFfc2hhcmVkLnB1bGxTdGFydFkpIHtcbiAgICAgICAgaWYgKF9lbC5zaG91bGRQdWxsVG9SZWZyZXNoKCkpIHtcbiAgICAgICAgICBfc2hhcmVkLnB1bGxTdGFydFkgPSBzY3JlZW5ZKGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc2hhcmVkLnB1bGxNb3ZlWSA9IHNjcmVlblkoZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfc2hhcmVkLnN0YXRlID09PSAncmVmcmVzaGluZycpIHtcbiAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSAmJiBfZWwuc2hvdWxkUHVsbFRvUmVmcmVzaCgpICYmIF9zaGFyZWQucHVsbFN0YXJ0WSA8IF9zaGFyZWQucHVsbE1vdmVZKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3NoYXJlZC5zdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIF9lbC5wdHJFbGVtZW50LmNsYXNzTGlzdC5hZGQoKChfZWwuY2xhc3NQcmVmaXgpICsgXCJwdWxsXCIpKTtcblxuICAgICAgICBfc2hhcmVkLnN0YXRlID0gJ3B1bGxpbmcnO1xuXG4gICAgICAgIF9wdHIudXBkYXRlKF9lbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfc2hhcmVkLnB1bGxTdGFydFkgJiYgX3NoYXJlZC5wdWxsTW92ZVkpIHtcbiAgICAgICAgX3NoYXJlZC5kaXN0ID0gX3NoYXJlZC5wdWxsTW92ZVkgLSBfc2hhcmVkLnB1bGxTdGFydFk7XG4gICAgICB9XG5cbiAgICAgIF9zaGFyZWQuZGlzdEV4dHJhID0gX3NoYXJlZC5kaXN0IC0gX2VsLmRpc3RJZ25vcmU7XG5cbiAgICAgIGlmIChfc2hhcmVkLmRpc3RFeHRyYSA+IDApIHtcbiAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9lbC5wdHJFbGVtZW50LnN0eWxlW19lbC5jc3NQcm9wXSA9IChfc2hhcmVkLmRpc3RSZXNpc3RlZCkgKyBcInB4XCI7XG4gICAgICAgIF9zaGFyZWQuZGlzdFJlc2lzdGVkID0gX2VsLnJlc2lzdGFuY2VGdW5jdGlvbihfc2hhcmVkLmRpc3RFeHRyYSAvIF9lbC5kaXN0VGhyZXNob2xkKSAqIE1hdGgubWluKF9lbC5kaXN0TWF4LCBfc2hhcmVkLmRpc3RFeHRyYSk7XG5cbiAgICAgICAgaWYgKF9zaGFyZWQuc3RhdGUgPT09ICdwdWxsaW5nJyAmJiBfc2hhcmVkLmRpc3RSZXNpc3RlZCA+IF9lbC5kaXN0VGhyZXNob2xkKSB7XG4gICAgICAgICAgX2VsLnB0ckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgoKF9lbC5jbGFzc1ByZWZpeCkgKyBcInJlbGVhc2VcIikpO1xuXG4gICAgICAgICAgX3NoYXJlZC5zdGF0ZSA9ICdyZWxlYXNpbmcnO1xuXG4gICAgICAgICAgX3B0ci51cGRhdGUoX2VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfc2hhcmVkLnN0YXRlID09PSAncmVsZWFzaW5nJyAmJiBfc2hhcmVkLmRpc3RSZXNpc3RlZCA8IF9lbC5kaXN0VGhyZXNob2xkKSB7XG4gICAgICAgICAgX2VsLnB0ckVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgoKF9lbC5jbGFzc1ByZWZpeCkgKyBcInJlbGVhc2VcIikpO1xuXG4gICAgICAgICAgX3NoYXJlZC5zdGF0ZSA9ICdwdWxsaW5nJztcblxuICAgICAgICAgIF9wdHIudXBkYXRlKF9lbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb25Ub3VjaEVuZCgpIHtcbiAgICAgIGlmICghKF9lbCAmJiBfZWwucHRyRWxlbWVudCAmJiBfc2hhcmVkLmVuYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB3YWl0IDEvMiBzZWMgYmVmb3JlIHVubW91bnRpbmcuLi5cblxuXG4gICAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXQpO1xuICAgICAgX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF9lbCAmJiBfZWwucHRyRWxlbWVudCAmJiBfc2hhcmVkLnN0YXRlID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICBfcHRyLm9uUmVzZXQoX2VsKTtcbiAgICAgICAgfVxuICAgICAgfSwgNTAwKTtcblxuICAgICAgaWYgKF9zaGFyZWQuc3RhdGUgPT09ICdyZWxlYXNpbmcnICYmIF9zaGFyZWQuZGlzdFJlc2lzdGVkID4gX2VsLmRpc3RUaHJlc2hvbGQpIHtcbiAgICAgICAgX3NoYXJlZC5zdGF0ZSA9ICdyZWZyZXNoaW5nJztcbiAgICAgICAgX2VsLnB0ckVsZW1lbnQuc3R5bGVbX2VsLmNzc1Byb3BdID0gKF9lbC5kaXN0UmVsb2FkKSArIFwicHhcIjtcblxuICAgICAgICBfZWwucHRyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCgoX2VsLmNsYXNzUHJlZml4KSArIFwicmVmcmVzaFwiKSk7XG5cbiAgICAgICAgX3NoYXJlZC50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJldHZhbCA9IF9lbC5vblJlZnJlc2goZnVuY3Rpb24gKCkgeyByZXR1cm4gX3B0ci5vblJlc2V0KF9lbCk7IH0pO1xuXG4gICAgICAgICAgaWYgKHJldHZhbCAmJiB0eXBlb2YgcmV0dmFsLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHZhbC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9wdHIub25SZXNldChfZWwpOyB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXJldHZhbCAmJiAhX2VsLm9uUmVmcmVzaC5sZW5ndGgpIHtcbiAgICAgICAgICAgIF9wdHIub25SZXNldChfZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2VsLnJlZnJlc2hUaW1lb3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfc2hhcmVkLnN0YXRlID09PSAncmVmcmVzaGluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfZWwucHRyRWxlbWVudC5zdHlsZVtfZWwuY3NzUHJvcF0gPSAnMHB4JztcbiAgICAgICAgX3NoYXJlZC5zdGF0ZSA9ICdwZW5kaW5nJztcbiAgICAgIH1cblxuICAgICAgX3B0ci51cGRhdGUoX2VsKTtcblxuICAgICAgX2VsLnB0ckVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgoKF9lbC5jbGFzc1ByZWZpeCkgKyBcInJlbGVhc2VcIikpO1xuXG4gICAgICBfZWwucHRyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCgoX2VsLmNsYXNzUHJlZml4KSArIFwicHVsbFwiKSk7XG5cbiAgICAgIF9zaGFyZWQucHVsbFN0YXJ0WSA9IF9zaGFyZWQucHVsbE1vdmVZID0gbnVsbDtcbiAgICAgIF9zaGFyZWQuZGlzdCA9IF9zaGFyZWQuZGlzdFJlc2lzdGVkID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gICAgICBpZiAoX2VsKSB7XG4gICAgICAgIF9lbC5tYWluRWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCgoX2VsLmNsYXNzUHJlZml4KSArIFwidG9wXCIpLCBfZWwuc2hvdWxkUHVsbFRvUmVmcmVzaCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX3Bhc3NpdmVTZXR0aW5ncyA9IF9zaGFyZWQuc3VwcG9ydHNQYXNzaXZlID8ge1xuICAgICAgcGFzc2l2ZTogX3NoYXJlZC5wYXNzaXZlIHx8IGZhbHNlXG4gICAgfSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChfc2hhcmVkLnBvaW50ZXJFdmVudHNFbmFibGVkICYmIF9zaGFyZWQuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgX29uVG91Y2hFbmQpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgX29uVG91Y2hTdGFydCk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBfb25Ub3VjaE1vdmUsIF9wYXNzaXZlU2V0dGluZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBfb25Ub3VjaEVuZCk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIF9vblRvdWNoU3RhcnQpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9vblRvdWNoTW92ZSwgX3Bhc3NpdmVTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF9vblNjcm9sbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uVG91Y2hFbmQ6IF9vblRvdWNoRW5kLFxuICAgICAgb25Ub3VjaFN0YXJ0OiBfb25Ub3VjaFN0YXJ0LFxuICAgICAgb25Ub3VjaE1vdmU6IF9vblRvdWNoTW92ZSxcbiAgICAgIG9uU2Nyb2xsOiBfb25TY3JvbGwsXG5cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmIChfc2hhcmVkLnBvaW50ZXJFdmVudHNFbmFibGVkICYmIF9zaGFyZWQuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgX29uVG91Y2hTdGFydCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIF9vblRvdWNoRW5kKTtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBfb25Ub3VjaE1vdmUsIF9wYXNzaXZlU2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgX29uVG91Y2hTdGFydCk7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgX29uVG91Y2hFbmQpO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfb25Ub3VjaE1vdmUsIF9wYXNzaXZlU2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF9vblNjcm9sbCk7XG4gICAgICB9XG5cbiAgICB9O1xuICB9KTtcblxuICB2YXIgX3B0ck1hcmt1cCA9IFwiXFxuPGRpdiBjbGFzcz1cXFwiX19QUkVGSVhfX2JveFxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJfX1BSRUZJWF9fY29udGVudFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIl9fUFJFRklYX19pY29uXFxcIj48L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiX19QUkVGSVhfX3RleHRcXFwiPjwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG5cbiAgdmFyIF9wdHJTdHlsZXMgPSBcIlxcbi5fX1BSRUZJWF9fcHRyIHtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgLTNweCA1cHggcmdiYSgwLCAwLCAwLCAwLjEyKTtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgZm9udC1zaXplOiAwLjg1ZW07XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRvcDogMDtcXG4gIGhlaWdodDogMDtcXG4gIHRyYW5zaXRpb246IGhlaWdodCAwLjNzLCBtaW4taGVpZ2h0IDAuM3M7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB3aWR0aDogMTAwJTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbiAgYWxpZ24tY29udGVudDogc3RyZXRjaDtcXG59XFxuXFxuLl9fUFJFRklYX19ib3gge1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGZsZXgtYmFzaXM6IDEwMCU7XFxufVxcblxcbi5fX1BSRUZJWF9fcHVsbCB7XFxuICB0cmFuc2l0aW9uOiBub25lO1xcbn1cXG5cXG4uX19QUkVGSVhfX3RleHQge1xcbiAgbWFyZ2luLXRvcDogLjMzZW07XFxuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjMpO1xcbn1cXG5cXG4uX19QUkVGSVhfX2ljb24ge1xcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4zKTtcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAuM3M7XFxufVxcblxcbi8qXFxuV2hlbiBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlLCBkaXNhYmxlIHZlcnRpY2FsIG92ZXJzY3JvbGwgc28gcGFzc2l2ZSB0b3VjaFxcbmxpc3RlbmVycyBjYW4gdGFrZSBvdmVyLlxcbiovXFxuLl9fUFJFRklYX190b3Age1xcbiAgdG91Y2gtYWN0aW9uOiBwYW4teCBwYW4tZG93biBwaW5jaC16b29tO1xcbn1cXG5cXG4uX19QUkVGSVhfX3JlbGVhc2UgLl9fUFJFRklYX19pY29uIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxufVxcblwiO1xuXG4gIHZhciBfZGVmYXVsdHMgPSB7XG4gICAgZGlzdFRocmVzaG9sZDogNjAsXG4gICAgZGlzdE1heDogODAsXG4gICAgZGlzdFJlbG9hZDogNTAsXG4gICAgZGlzdElnbm9yZTogMCxcbiAgICBtYWluRWxlbWVudDogJ2JvZHknLFxuICAgIHRyaWdnZXJFbGVtZW50OiAnYm9keScsXG4gICAgcHRyRWxlbWVudDogJy5wdHInLFxuICAgIGNsYXNzUHJlZml4OiAncHRyLS0nLFxuICAgIGNzc1Byb3A6ICdtaW4taGVpZ2h0JyxcbiAgICBpY29uQXJyb3c6ICcmIzg2NzU7JyxcbiAgICBpY29uUmVmcmVzaGluZzogJyZoZWxsaXA7JyxcbiAgICBpbnN0cnVjdGlvbnNQdWxsVG9SZWZyZXNoOiAnUHVsbCBkb3duIHRvIHJlZnJlc2gnLFxuICAgIGluc3RydWN0aW9uc1JlbGVhc2VUb1JlZnJlc2g6ICdSZWxlYXNlIHRvIHJlZnJlc2gnLFxuICAgIGluc3RydWN0aW9uc1JlZnJlc2hpbmc6ICdSZWZyZXNoaW5nJyxcbiAgICByZWZyZXNoVGltZW91dDogNTAwLFxuICAgIGdldE1hcmt1cDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3B0ck1hcmt1cDsgfSxcbiAgICBnZXRTdHlsZXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9wdHJTdHlsZXM7IH0sXG4gICAgb25Jbml0OiBmdW5jdGlvbiAoKSB7fSxcbiAgICBvblJlZnJlc2g6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvY2F0aW9uLnJlbG9hZCgpOyB9LFxuICAgIHJlc2lzdGFuY2VGdW5jdGlvbjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgubWluKDEsIHQgLyAyLjUpOyB9LFxuICAgIHNob3VsZFB1bGxUb1JlZnJlc2g6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF3aW5kb3cuc2Nyb2xsWTsgfVxuICB9O1xuXG4gIHZhciBfbWV0aG9kcyA9IFsnbWFpbkVsZW1lbnQnLCAncHRyRWxlbWVudCcsICd0cmlnZ2VyRWxlbWVudCddO1xuICB2YXIgX3NldHVwSGFuZGxlciA9IChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfaGFuZGxlciA9IHt9OyAvLyBtZXJnZSBvcHRpb25zIHdpdGggZGVmYXVsdHNcblxuICAgIE9iamVjdC5rZXlzKF9kZWZhdWx0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfaGFuZGxlcltrZXldID0gb3B0aW9uc1trZXldIHx8IF9kZWZhdWx0c1trZXldO1xuICAgIH0pOyAvLyBub3JtYWxpemUgdGltZW91dCB2YWx1ZSwgZXZlbiBpZiBpdCBpcyB6ZXJvXG5cbiAgICBfaGFuZGxlci5yZWZyZXNoVGltZW91dCA9IHR5cGVvZiBvcHRpb25zLnJlZnJlc2hUaW1lb3V0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucmVmcmVzaFRpbWVvdXQgOiBfZGVmYXVsdHMucmVmcmVzaFRpbWVvdXQ7IC8vIG5vcm1hbGl6ZSBlbGVtZW50c1xuXG4gICAgX21ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBpZiAodHlwZW9mIF9oYW5kbGVyW21ldGhvZF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIF9oYW5kbGVyW21ldGhvZF0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKF9oYW5kbGVyW21ldGhvZF0pO1xuICAgICAgfVxuICAgIH0pOyAvLyBhdHRhY2ggZXZlbnRzIGxhemlseVxuXG5cbiAgICBpZiAoIV9zaGFyZWQuZXZlbnRzKSB7XG4gICAgICBfc2hhcmVkLmV2ZW50cyA9IF9zZXR1cEV2ZW50cygpO1xuICAgIH1cblxuICAgIF9oYW5kbGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIF9oYW5kbGVyLnRyaWdnZXJFbGVtZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgfTtcblxuICAgIF9oYW5kbGVyLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzdG9wIHBlbmRpbmcgYW55IHBlbmRpbmcgY2FsbGJhY2tzXG4gICAgICBjbGVhclRpbWVvdXQoX3NoYXJlZC50aW1lb3V0KTsgLy8gcmVtb3ZlIGhhbmRsZXIgZnJvbSBzaGFyZWQgc3RhdGVcblxuICAgICAgdmFyIG9mZnNldCA9IF9zaGFyZWQuaGFuZGxlcnMuaW5kZXhPZihfaGFuZGxlcik7XG5cbiAgICAgIF9zaGFyZWQuaGFuZGxlcnMuc3BsaWNlKG9mZnNldCwgMSk7XG4gICAgfTtcblxuICAgIHJldHVybiBfaGFuZGxlcjtcbiAgfSk7XG5cbiAgdmFyIGluZGV4ID0ge1xuICAgIHNldFBhc3NpdmVNb2RlOiBmdW5jdGlvbiBzZXRQYXNzaXZlTW9kZShpc1Bhc3NpdmUpIHtcbiAgICAgIF9zaGFyZWQucGFzc2l2ZSA9IGlzUGFzc2l2ZTtcbiAgICB9LFxuXG4gICAgc2V0UG9pbnRlckV2ZW50c01vZGU6IGZ1bmN0aW9uIHNldFBvaW50ZXJFdmVudHNNb2RlKGlzRW5hYmxlZCkge1xuICAgICAgX3NoYXJlZC5wb2ludGVyRXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZDtcbiAgICB9LFxuXG4gICAgZGVzdHJveUFsbDogZnVuY3Rpb24gZGVzdHJveUFsbCgpIHtcbiAgICAgIGlmIChfc2hhcmVkLmV2ZW50cykge1xuICAgICAgICBfc2hhcmVkLmV2ZW50cy5kZXN0cm95KCk7XG5cbiAgICAgICAgX3NoYXJlZC5ldmVudHMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfc2hhcmVkLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgaC5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgICAgdmFyIGhhbmRsZXIgPSBfc2V0dXBIYW5kbGVyKG9wdGlvbnMpO1xuXG4gICAgICBfc2hhcmVkLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG5cbiAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvLyBleHBvcnQgdXRpbHMgZm9yIHRlc3RpbmdcbiAgICBfOiB7XG4gICAgICBzZXR1cEhhbmRsZXI6IF9zZXR1cEhhbmRsZXIsXG4gICAgICBzZXR1cEV2ZW50czogX3NldHVwRXZlbnRzLFxuICAgICAgc2V0dXBET006IF9wdHIuc2V0dXBET00sXG4gICAgICBvblJlc2V0OiBfcHRyLm9uUmVzZXQsXG4gICAgICB1cGRhdGU6IF9wdHIudXBkYXRlXG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBpbmRleDtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3678\n\n}")},3771:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.hmacSha512 = exports.hmacSha256 = exports.Hmac = void 0;\nconst hash_1 = __webpack_require__(5632);\nclass Hmac {\n    constructor(hashFactory, blockLength, key) {\n        this.oHash = hashFactory();\n        this.iHash = hashFactory();\n        const pad = new Uint8Array(blockLength);\n        if (key.length > blockLength) {\n            const hasher = hashFactory();\n            hasher.update(key);\n            key = hasher.finalize();\n        }\n        pad.set(key, 0);\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        this.iHash.update(pad);\n        for (let i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(data) {\n        this.iHash.update(data);\n    }\n    digest() {\n        this.oHash.update(this.iHash.finalize());\n        const hash = this.oHash.finalize();\n        this.iHash.free();\n        this.oHash.free();\n        return hash;\n    }\n    clone() {\n        const clone = Object.create(Object.getPrototypeOf(this), {});\n        clone.oHash = this.oHash.clone();\n        clone.iHash = this.iHash.clone();\n        return clone;\n    }\n    free() {\n        this.iHash.free();\n        this.oHash.free();\n    }\n}\nexports.Hmac = Hmac;\nfunction hmacSha256(key, data) {\n    const hmac = new Hmac(hash_1.sha256Hasher, 64, key);\n    hmac.update(data);\n    return hmac.digest();\n}\nexports.hmacSha256 = hmacSha256;\nfunction hmacSha512(key, data) {\n    const hmac = new Hmac(hash_1.sha512Hasher, 128, key);\n    hmac.update(data);\n    return hmac.digest();\n}\nexports.hmacSha512 = hmacSha512;\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc3MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxZQUFZO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQyxJQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvaG1hYy5qcz8wMjBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI1IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaG1hY1NoYTUxMiA9IGV4cG9ydHMuaG1hY1NoYTI1NiA9IGV4cG9ydHMuSG1hYyA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5jbGFzcyBIbWFjIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoRmFjdG9yeSwgYmxvY2tMZW5ndGgsIGtleSkge1xuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaEZhY3RvcnkoKTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2hGYWN0b3J5KCk7XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuZ3RoKTtcbiAgICAgICAgaWYgKGtleS5sZW5ndGggPiBibG9ja0xlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaGFzaGVyID0gaGFzaEZhY3RvcnkoKTtcbiAgICAgICAgICAgIGhhc2hlci51cGRhdGUoa2V5KTtcbiAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHBhZC5zZXQoa2V5LCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGRhdGEpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHRoaXMuaUhhc2guZmluYWxpemUoKSk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLm9IYXNoLmZpbmFsaXplKCk7XG4gICAgICAgIHRoaXMuaUhhc2guZnJlZSgpO1xuICAgICAgICB0aGlzLm9IYXNoLmZyZWUoKTtcbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSk7XG4gICAgICAgIGNsb25lLm9IYXNoID0gdGhpcy5vSGFzaC5jbG9uZSgpO1xuICAgICAgICBjbG9uZS5pSGFzaCA9IHRoaXMuaUhhc2guY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cbiAgICBmcmVlKCkge1xuICAgICAgICB0aGlzLmlIYXNoLmZyZWUoKTtcbiAgICAgICAgdGhpcy5vSGFzaC5mcmVlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IbWFjID0gSG1hYztcbmZ1bmN0aW9uIGhtYWNTaGEyNTYoa2V5LCBkYXRhKSB7XG4gICAgY29uc3QgaG1hYyA9IG5ldyBIbWFjKGhhc2hfMS5zaGEyNTZIYXNoZXIsIDY0LCBrZXkpO1xuICAgIGhtYWMudXBkYXRlKGRhdGEpO1xuICAgIHJldHVybiBobWFjLmRpZ2VzdCgpO1xufVxuZXhwb3J0cy5obWFjU2hhMjU2ID0gaG1hY1NoYTI1NjtcbmZ1bmN0aW9uIGhtYWNTaGE1MTIoa2V5LCBkYXRhKSB7XG4gICAgY29uc3QgaG1hYyA9IG5ldyBIbWFjKGhhc2hfMS5zaGE1MTJIYXNoZXIsIDEyOCwga2V5KTtcbiAgICBobWFjLnVwZGF0ZShkYXRhKTtcbiAgICByZXR1cm4gaG1hYy5kaWdlc3QoKTtcbn1cbmV4cG9ydHMuaG1hY1NoYTUxMiA9IGhtYWNTaGE1MTI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3771\n\n}')},3799:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Ecc = exports.__setEcc = exports.EccDummy = void 0;\n/** Dummy Ecc impl that always returns 0, useful for measuring tx size */\nclass EccDummy {\n    derivePubkey(_seckey) {\n        return new Uint8Array(33);\n    }\n    ecdsaSign(_seckey, _msg) {\n        return new Uint8Array(73);\n    }\n    ecdsaVerify(_sig, _msg, _pk) { }\n    schnorrSign(_seckey, _msg) {\n        return new Uint8Array(64);\n    }\n    schnorrVerify(_sig, _msg, _pk) { }\n    isValidSeckey(_seckey) {\n        return false;\n    }\n    seckeyAdd(_a, _b) {\n        return new Uint8Array(32);\n    }\n    pubkeyAdd(_a, _b) {\n        return new Uint8Array(32);\n    }\n    signRecoverable(_seckey, _msg) {\n        return new Uint8Array(65);\n    }\n    recoverSig(_sig, _msg) {\n        return new Uint8Array(33);\n    }\n    compressPk(_pk) {\n        return new Uint8Array(33);\n    }\n}\nexports.EccDummy = EccDummy;\nconst ECC = {};\nfunction __setEcc(ecc) {\n    ECC.ecc = ecc;\n}\nexports.__setEcc = __setEcc;\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass Ecc {\n    /** Derive a public key from secret key. */\n    derivePubkey(seckey) {\n        return ECC.ecc.derivePubkey(seckey);\n    }\n    /** Sign an ECDSA signature. msg needs to be a 32-byte hash */\n    ecdsaSign(seckey, msg) {\n        return ECC.ecc.ecdsaSign(seckey, msg);\n    }\n    /**\n     * Verify an ECDSA signature. msg needs to be a 32-byte hash.\n     * Throws an exception if the signature is invalid.\n     **/\n    ecdsaVerify(sig, msg, pk) {\n        ECC.ecc?.ecdsaVerify(sig, msg, pk);\n    }\n    /** Sign a Schnorr signature. msg needs to be a 32-byte hash */\n    schnorrSign(seckey, msg) {\n        return ECC.ecc.schnorrSign(seckey, msg);\n    }\n    /**\n     * Verify a Schnorr signature. msg needs to be a 32-byte hash.\n     * Throws an exception if the signature is invalid.\n     **/\n    schnorrVerify(sig, msg, pk) {\n        ECC.ecc?.schnorrVerify(sig, msg, pk);\n    }\n    /**\n     * Return whether the given secret key is valid, i.e. whether is of correct\n     * length (32 bytes) and is on the curve.\n     */\n    isValidSeckey(seckey) {\n        return ECC.ecc.isValidSeckey(seckey);\n    }\n    /** Add a scalar to a secret key */\n    seckeyAdd(a, b) {\n        return ECC.ecc.seckeyAdd(a, b);\n    }\n    /** Add a scalar to a public key (adding G*b) */\n    pubkeyAdd(a, b) {\n        return ECC.ecc.pubkeyAdd(a, b);\n    }\n    signRecoverable(seckey, msg) {\n        return ECC.ecc.signRecoverable(seckey, msg);\n    }\n    recoverSig(sig, msg) {\n        return ECC.ecc.recoverSig(sig, msg);\n    }\n    compressPk(pk) {\n        if (pk[0] != 0x04) {\n            throw new Error('Uncompressed pubkey must start with 0x04');\n        }\n        const compressedPk = new Uint8Array(33);\n        compressedPk[0] = 0x02 | (pk[64] & 0x01);\n        compressedPk.set(pk.slice(1, 33), 1);\n        return compressedPk;\n    }\n}\nexports.Ecc = Ecc;\n//# sourceMappingURL=ecc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc5OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvZWNjLmpzPzY3MjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FY2MgPSBleHBvcnRzLl9fc2V0RWNjID0gZXhwb3J0cy5FY2NEdW1teSA9IHZvaWQgMDtcbi8qKiBEdW1teSBFY2MgaW1wbCB0aGF0IGFsd2F5cyByZXR1cm5zIDAsIHVzZWZ1bCBmb3IgbWVhc3VyaW5nIHR4IHNpemUgKi9cbmNsYXNzIEVjY0R1bW15IHtcbiAgICBkZXJpdmVQdWJrZXkoX3NlY2tleSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMzMpO1xuICAgIH1cbiAgICBlY2RzYVNpZ24oX3NlY2tleSwgX21zZykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoNzMpO1xuICAgIH1cbiAgICBlY2RzYVZlcmlmeShfc2lnLCBfbXNnLCBfcGspIHsgfVxuICAgIHNjaG5vcnJTaWduKF9zZWNrZXksIF9tc2cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICB9XG4gICAgc2Nobm9yclZlcmlmeShfc2lnLCBfbXNnLCBfcGspIHsgfVxuICAgIGlzVmFsaWRTZWNrZXkoX3NlY2tleSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlY2tleUFkZChfYSwgX2IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICB9XG4gICAgcHVia2V5QWRkKF9hLCBfYikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIH1cbiAgICBzaWduUmVjb3ZlcmFibGUoX3NlY2tleSwgX21zZykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoNjUpO1xuICAgIH1cbiAgICByZWNvdmVyU2lnKF9zaWcsIF9tc2cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDMzKTtcbiAgICB9XG4gICAgY29tcHJlc3NQayhfcGspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDMzKTtcbiAgICB9XG59XG5leHBvcnRzLkVjY0R1bW15ID0gRWNjRHVtbXk7XG5jb25zdCBFQ0MgPSB7fTtcbmZ1bmN0aW9uIF9fc2V0RWNjKGVjYykge1xuICAgIEVDQy5lY2MgPSBlY2M7XG59XG5leHBvcnRzLl9fc2V0RWNjID0gX19zZXRFY2M7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nXG5jbGFzcyBFY2Mge1xuICAgIC8qKiBEZXJpdmUgYSBwdWJsaWMga2V5IGZyb20gc2VjcmV0IGtleS4gKi9cbiAgICBkZXJpdmVQdWJrZXkoc2Vja2V5KSB7XG4gICAgICAgIHJldHVybiBFQ0MuZWNjLmRlcml2ZVB1YmtleShzZWNrZXkpO1xuICAgIH1cbiAgICAvKiogU2lnbiBhbiBFQ0RTQSBzaWduYXR1cmUuIG1zZyBuZWVkcyB0byBiZSBhIDMyLWJ5dGUgaGFzaCAqL1xuICAgIGVjZHNhU2lnbihzZWNrZXksIG1zZykge1xuICAgICAgICByZXR1cm4gRUNDLmVjYy5lY2RzYVNpZ24oc2Vja2V5LCBtc2cpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgYW4gRUNEU0Egc2lnbmF0dXJlLiBtc2cgbmVlZHMgdG8gYmUgYSAzMi1ieXRlIGhhc2guXG4gICAgICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgc2lnbmF0dXJlIGlzIGludmFsaWQuXG4gICAgICoqL1xuICAgIGVjZHNhVmVyaWZ5KHNpZywgbXNnLCBwaykge1xuICAgICAgICBFQ0MuZWNjPy5lY2RzYVZlcmlmeShzaWcsIG1zZywgcGspO1xuICAgIH1cbiAgICAvKiogU2lnbiBhIFNjaG5vcnIgc2lnbmF0dXJlLiBtc2cgbmVlZHMgdG8gYmUgYSAzMi1ieXRlIGhhc2ggKi9cbiAgICBzY2hub3JyU2lnbihzZWNrZXksIG1zZykge1xuICAgICAgICByZXR1cm4gRUNDLmVjYy5zY2hub3JyU2lnbihzZWNrZXksIG1zZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBhIFNjaG5vcnIgc2lnbmF0dXJlLiBtc2cgbmVlZHMgdG8gYmUgYSAzMi1ieXRlIGhhc2guXG4gICAgICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgc2lnbmF0dXJlIGlzIGludmFsaWQuXG4gICAgICoqL1xuICAgIHNjaG5vcnJWZXJpZnkoc2lnLCBtc2csIHBrKSB7XG4gICAgICAgIEVDQy5lY2M/LnNjaG5vcnJWZXJpZnkoc2lnLCBtc2csIHBrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHdoZXRoZXIgdGhlIGdpdmVuIHNlY3JldCBrZXkgaXMgdmFsaWQsIGkuZS4gd2hldGhlciBpcyBvZiBjb3JyZWN0XG4gICAgICogbGVuZ3RoICgzMiBieXRlcykgYW5kIGlzIG9uIHRoZSBjdXJ2ZS5cbiAgICAgKi9cbiAgICBpc1ZhbGlkU2Vja2V5KHNlY2tleSkge1xuICAgICAgICByZXR1cm4gRUNDLmVjYy5pc1ZhbGlkU2Vja2V5KHNlY2tleSk7XG4gICAgfVxuICAgIC8qKiBBZGQgYSBzY2FsYXIgdG8gYSBzZWNyZXQga2V5ICovXG4gICAgc2Vja2V5QWRkKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIEVDQy5lY2Muc2Vja2V5QWRkKGEsIGIpO1xuICAgIH1cbiAgICAvKiogQWRkIGEgc2NhbGFyIHRvIGEgcHVibGljIGtleSAoYWRkaW5nIEcqYikgKi9cbiAgICBwdWJrZXlBZGQoYSwgYikge1xuICAgICAgICByZXR1cm4gRUNDLmVjYy5wdWJrZXlBZGQoYSwgYik7XG4gICAgfVxuICAgIHNpZ25SZWNvdmVyYWJsZShzZWNrZXksIG1zZykge1xuICAgICAgICByZXR1cm4gRUNDLmVjYy5zaWduUmVjb3ZlcmFibGUoc2Vja2V5LCBtc2cpO1xuICAgIH1cbiAgICByZWNvdmVyU2lnKHNpZywgbXNnKSB7XG4gICAgICAgIHJldHVybiBFQ0MuZWNjLnJlY292ZXJTaWcoc2lnLCBtc2cpO1xuICAgIH1cbiAgICBjb21wcmVzc1BrKHBrKSB7XG4gICAgICAgIGlmIChwa1swXSAhPSAweDA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY29tcHJlc3NlZCBwdWJrZXkgbXVzdCBzdGFydCB3aXRoIDB4MDQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wcmVzc2VkUGsgPSBuZXcgVWludDhBcnJheSgzMyk7XG4gICAgICAgIGNvbXByZXNzZWRQa1swXSA9IDB4MDIgfCAocGtbNjRdICYgMHgwMSk7XG4gICAgICAgIGNvbXByZXNzZWRQay5zZXQocGsuc2xpY2UoMSwgMzMpLCAxKTtcbiAgICAgICAgcmV0dXJuIGNvbXByZXNzZWRQaztcbiAgICB9XG59XG5leHBvcnRzLkVjYyA9IEVjYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVjYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3799\n\n}")},4004:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseEmppScript = exports.emppScript = void 0;\nconst op_js_1 = __webpack_require__(243);\nconst opcode_js_1 = __webpack_require__(2250);\nconst script_js_1 = __webpack_require__(6187);\n/** Build an eMPP OP_RETURN script with the given pushdata */\nfunction emppScript(pushdata) {\n    if (pushdata.find(pushdata => pushdata.length == 0) !== undefined) {\n        throw new Error('Pushdata cannot be empty');\n    }\n    return script_js_1.Script.fromOps([\n        opcode_js_1.OP_RETURN,\n        opcode_js_1.OP_RESERVED,\n        ...pushdata.map(pushdataOpEmpp),\n    ]);\n}\nexports.emppScript = emppScript;\nfunction pushdataOpEmpp(pushdata) {\n    if (pushdata.length < opcode_js_1.OP_PUSHDATA1) {\n        return {\n            opcode: pushdata.length,\n            data: pushdata,\n        };\n    }\n    return (0, op_js_1.pushBytesOp)(pushdata);\n}\n/**\n * Parse a script for EMPP push(es)\n *\n * EMPP may encode multiple pushdatas in a single OP_RETURN script\n *\n * input script is a valid EMPP OP_RETURN    => returns an array of EMPP pushdata(s)\n * input script is not an EMPP OP_RETURN     => returns undefined\n * input script is an invalid EMPP OP_RETURN => throws\n */\nfunction parseEmppScript(script) {\n    const ops = script.ops();\n    const opreturnOp = ops.next();\n    if (opreturnOp === undefined ||\n        (0, op_js_1.isPushOp)(opreturnOp) ||\n        opreturnOp !== opcode_js_1.OP_RETURN) {\n        return undefined;\n    }\n    const opreservedOp = ops.next();\n    if (opreservedOp === undefined ||\n        (0, op_js_1.isPushOp)(opreservedOp) ||\n        opreservedOp !== opcode_js_1.OP_RESERVED) {\n        return undefined;\n    }\n    const pushdata = [];\n    let op = undefined;\n    while ((op = ops.next()) !== undefined) {\n        if (!(0, op_js_1.isPushOp)(op)) {\n            throw new Error('eMPP allows only push ops');\n        }\n        if (op.data.length === 0) {\n            throw new Error(\"eMPP doesn't allow empty pushdata\");\n        }\n        pushdata.push(op.data);\n    }\n    return pushdata;\n}\nexports.parseEmppScript = parseEmppScript;\n//# sourceMappingURL=empp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAwNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxrQkFBa0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsR0FBVTtBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyxJQUFjO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLElBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L3Rva2VuL2VtcHAuanM/MDMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlRW1wcFNjcmlwdCA9IGV4cG9ydHMuZW1wcFNjcmlwdCA9IHZvaWQgMDtcbmNvbnN0IG9wX2pzXzEgPSByZXF1aXJlKFwiLi4vb3AuanNcIik7XG5jb25zdCBvcGNvZGVfanNfMSA9IHJlcXVpcmUoXCIuLi9vcGNvZGUuanNcIik7XG5jb25zdCBzY3JpcHRfanNfMSA9IHJlcXVpcmUoXCIuLi9zY3JpcHQuanNcIik7XG4vKiogQnVpbGQgYW4gZU1QUCBPUF9SRVRVUk4gc2NyaXB0IHdpdGggdGhlIGdpdmVuIHB1c2hkYXRhICovXG5mdW5jdGlvbiBlbXBwU2NyaXB0KHB1c2hkYXRhKSB7XG4gICAgaWYgKHB1c2hkYXRhLmZpbmQocHVzaGRhdGEgPT4gcHVzaGRhdGEubGVuZ3RoID09IDApICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQdXNoZGF0YSBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjcmlwdF9qc18xLlNjcmlwdC5mcm9tT3BzKFtcbiAgICAgICAgb3Bjb2RlX2pzXzEuT1BfUkVUVVJOLFxuICAgICAgICBvcGNvZGVfanNfMS5PUF9SRVNFUlZFRCxcbiAgICAgICAgLi4ucHVzaGRhdGEubWFwKHB1c2hkYXRhT3BFbXBwKSxcbiAgICBdKTtcbn1cbmV4cG9ydHMuZW1wcFNjcmlwdCA9IGVtcHBTY3JpcHQ7XG5mdW5jdGlvbiBwdXNoZGF0YU9wRW1wcChwdXNoZGF0YSkge1xuICAgIGlmIChwdXNoZGF0YS5sZW5ndGggPCBvcGNvZGVfanNfMS5PUF9QVVNIREFUQTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wY29kZTogcHVzaGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgZGF0YTogcHVzaGRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgb3BfanNfMS5wdXNoQnl0ZXNPcCkocHVzaGRhdGEpO1xufVxuLyoqXG4gKiBQYXJzZSBhIHNjcmlwdCBmb3IgRU1QUCBwdXNoKGVzKVxuICpcbiAqIEVNUFAgbWF5IGVuY29kZSBtdWx0aXBsZSBwdXNoZGF0YXMgaW4gYSBzaW5nbGUgT1BfUkVUVVJOIHNjcmlwdFxuICpcbiAqIGlucHV0IHNjcmlwdCBpcyBhIHZhbGlkIEVNUFAgT1BfUkVUVVJOICAgID0+IHJldHVybnMgYW4gYXJyYXkgb2YgRU1QUCBwdXNoZGF0YShzKVxuICogaW5wdXQgc2NyaXB0IGlzIG5vdCBhbiBFTVBQIE9QX1JFVFVSTiAgICAgPT4gcmV0dXJucyB1bmRlZmluZWRcbiAqIGlucHV0IHNjcmlwdCBpcyBhbiBpbnZhbGlkIEVNUFAgT1BfUkVUVVJOID0+IHRocm93c1xuICovXG5mdW5jdGlvbiBwYXJzZUVtcHBTY3JpcHQoc2NyaXB0KSB7XG4gICAgY29uc3Qgb3BzID0gc2NyaXB0Lm9wcygpO1xuICAgIGNvbnN0IG9wcmV0dXJuT3AgPSBvcHMubmV4dCgpO1xuICAgIGlmIChvcHJldHVybk9wID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKDAsIG9wX2pzXzEuaXNQdXNoT3ApKG9wcmV0dXJuT3ApIHx8XG4gICAgICAgIG9wcmV0dXJuT3AgIT09IG9wY29kZV9qc18xLk9QX1JFVFVSTikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBvcHJlc2VydmVkT3AgPSBvcHMubmV4dCgpO1xuICAgIGlmIChvcHJlc2VydmVkT3AgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoMCwgb3BfanNfMS5pc1B1c2hPcCkob3ByZXNlcnZlZE9wKSB8fFxuICAgICAgICBvcHJlc2VydmVkT3AgIT09IG9wY29kZV9qc18xLk9QX1JFU0VSVkVEKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHB1c2hkYXRhID0gW107XG4gICAgbGV0IG9wID0gdW5kZWZpbmVkO1xuICAgIHdoaWxlICgob3AgPSBvcHMubmV4dCgpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghKDAsIG9wX2pzXzEuaXNQdXNoT3ApKG9wKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlTVBQIGFsbG93cyBvbmx5IHB1c2ggb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlTVBQIGRvZXNuJ3QgYWxsb3cgZW1wdHkgcHVzaGRhdGFcIik7XG4gICAgICAgIH1cbiAgICAgICAgcHVzaGRhdGEucHVzaChvcC5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1c2hkYXRhO1xufVxuZXhwb3J0cy5wYXJzZUVtcHBTY3JpcHQgPSBwYXJzZUVtcHBTY3JpcHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXBwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4004\n\n}")},4153:module=>{"use strict";eval('{\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE1My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanM/ZDQ2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBpbnF1aXJlO1xyXG5cclxuLyoqXHJcbiAqIFJlcXVpcmVzIGEgbW9kdWxlIG9ubHkgaWYgYXZhaWxhYmxlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSBNb2R1bGUgdG8gcmVxdWlyZVxyXG4gKiBAcmV0dXJucyB7P09iamVjdH0gUmVxdWlyZWQgbW9kdWxlIGlmIGF2YWlsYWJsZSBhbmQgbm90IGVtcHR5LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG1vZCA9IGV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcclxuICAgICAgICBpZiAobW9kICYmIChtb2QubGVuZ3RoIHx8IE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlcclxuICAgICAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4153\n\n}')},4357:(module,__unused_webpack_exports,__webpack_require__)=>{eval("{const Mode = __webpack_require__(208)\n\nfunction NumericData (data) {\n  this.mode = Mode.NUMERIC\n  this.data = data.toString()\n}\n\nNumericData.getBitsLength = function getBitsLength (length) {\n  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)\n}\n\nNumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nNumericData.prototype.getBitsLength = function getBitsLength () {\n  return NumericData.getBitsLength(this.data.length)\n}\n\nNumericData.prototype.write = function write (bitBuffer) {\n  let i, group, value\n\n  // The input data string is divided into groups of three digits,\n  // and each group is converted to its 10-bit binary equivalent.\n  for (i = 0; i + 3 <= this.data.length; i += 3) {\n    group = this.data.substr(i, 3)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, 10)\n  }\n\n  // If the number of input digits is not an exact multiple of three,\n  // the final one or two digits are converted to 4 or 7 bits respectively.\n  const remainingNum = this.data.length - i\n  if (remainingNum > 0) {\n    group = this.data.substr(i)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, remainingNum * 3 + 1)\n  }\n}\n\nmodule.exports = NumericData\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsR0FBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywyQkFBMkI7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvY29yZS9udW1lcmljLWRhdGEuanM/ZGQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNb2RlID0gcmVxdWlyZSgnLi9tb2RlJylcblxuZnVuY3Rpb24gTnVtZXJpY0RhdGEgKGRhdGEpIHtcbiAgdGhpcy5tb2RlID0gTW9kZS5OVU1FUklDXG4gIHRoaXMuZGF0YSA9IGRhdGEudG9TdHJpbmcoKVxufVxuXG5OdW1lcmljRGF0YS5nZXRCaXRzTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Qml0c0xlbmd0aCAobGVuZ3RoKSB7XG4gIHJldHVybiAxMCAqIE1hdGguZmxvb3IobGVuZ3RoIC8gMykgKyAoKGxlbmd0aCAlIDMpID8gKChsZW5ndGggJSAzKSAqIDMgKyAxKSA6IDApXG59XG5cbk51bWVyaWNEYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aFxufVxuXG5OdW1lcmljRGF0YS5wcm90b3R5cGUuZ2V0Qml0c0xlbmd0aCA9IGZ1bmN0aW9uIGdldEJpdHNMZW5ndGggKCkge1xuICByZXR1cm4gTnVtZXJpY0RhdGEuZ2V0Qml0c0xlbmd0aCh0aGlzLmRhdGEubGVuZ3RoKVxufVxuXG5OdW1lcmljRGF0YS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoYml0QnVmZmVyKSB7XG4gIGxldCBpLCBncm91cCwgdmFsdWVcblxuICAvLyBUaGUgaW5wdXQgZGF0YSBzdHJpbmcgaXMgZGl2aWRlZCBpbnRvIGdyb3VwcyBvZiB0aHJlZSBkaWdpdHMsXG4gIC8vIGFuZCBlYWNoIGdyb3VwIGlzIGNvbnZlcnRlZCB0byBpdHMgMTAtYml0IGJpbmFyeSBlcXVpdmFsZW50LlxuICBmb3IgKGkgPSAwOyBpICsgMyA8PSB0aGlzLmRhdGEubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBncm91cCA9IHRoaXMuZGF0YS5zdWJzdHIoaSwgMylcbiAgICB2YWx1ZSA9IHBhcnNlSW50KGdyb3VwLCAxMClcblxuICAgIGJpdEJ1ZmZlci5wdXQodmFsdWUsIDEwKVxuICB9XG5cbiAgLy8gSWYgdGhlIG51bWJlciBvZiBpbnB1dCBkaWdpdHMgaXMgbm90IGFuIGV4YWN0IG11bHRpcGxlIG9mIHRocmVlLFxuICAvLyB0aGUgZmluYWwgb25lIG9yIHR3byBkaWdpdHMgYXJlIGNvbnZlcnRlZCB0byA0IG9yIDcgYml0cyByZXNwZWN0aXZlbHkuXG4gIGNvbnN0IHJlbWFpbmluZ051bSA9IHRoaXMuZGF0YS5sZW5ndGggLSBpXG4gIGlmIChyZW1haW5pbmdOdW0gPiAwKSB7XG4gICAgZ3JvdXAgPSB0aGlzLmRhdGEuc3Vic3RyKGkpXG4gICAgdmFsdWUgPSBwYXJzZUludChncm91cCwgMTApXG5cbiAgICBiaXRCdWZmZXIucHV0KHZhbHVlLCByZW1haW5pbmdOdW0gKiAzICsgMSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWVyaWNEYXRhXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4357\n\n}")},4358:module=>{"use strict";eval("{\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzPzY4OTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBBIG1pbmltYWwgZXZlbnQgZW1pdHRlci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gTGlzdGVuZXJcclxuICogQHBhcmFtIHsqfSBbY3R4XSBMaXN0ZW5lciBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XHJcbiAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcclxuICAgICAgICBmbiAgOiBmbixcclxuICAgICAgICBjdHggOiBjdHggfHwgdGhpc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIG9yIGFueSBtYXRjaGluZyBsaXN0ZW5lcnMgaWYgYXJndW1lbnRzIGFyZSBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2dF0gRXZlbnQgbmFtZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGlmIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb2YgYGV2dGAgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcclxuICAgIGlmIChldnQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0cyBhbiBldmVudCBieSBjYWxsaW5nIGl0cyBsaXN0ZW5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4358\n\n}")},4394:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nvar protobuf = exports;\n\n/**\n * Build type, one of `"full"`, `"light"` or `"minimal"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = "minimal";\n\n// Serialization\nprotobuf.Writer       = __webpack_require__(3449);\nprotobuf.BufferWriter = __webpack_require__(818);\nprotobuf.Reader       = __webpack_require__(6237);\nprotobuf.BufferReader = __webpack_require__(3158);\n\n// Utility\nprotobuf.util         = __webpack_require__(3610);\nprotobuf.rpc          = __webpack_require__(5047);\nprotobuf.roots        = __webpack_require__(4529);\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM5NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFVO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLEdBQWlCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLElBQVU7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsSUFBaUI7O0FBRWpEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsSUFBZ0I7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMsSUFBTztBQUN2Qyx3QkFBd0IsbUJBQU8sQ0FBQyxJQUFTO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcz82YzMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4394\n\n}')},4529:module=>{"use strict";eval('{\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require("./compiled.js");\n *\n * // in any subsequent module:\n * var root = protobuf.roots["myroot"];\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUyOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcz8wNjRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBOYW1lZCByb290cy5cbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4529\n\n}')},4565:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const Utils = __webpack_require__(6886)\n\nconst G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)\nconst G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)\nconst G15_BCH = Utils.getBCHDigit(G15)\n\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nexports.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {\n  const data = ((errorCorrectionLevel.bit << 3) | mask)\n  let d = data << 10\n\n  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {\n    d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH))\n  }\n\n  // xor final data with mask pattern in order to ensure that\n  // no combination of Error Correction Level and data mask pattern\n  // will result in an all-zero data string\n  return ((data << 10) | d) ^ G15_MASK\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU2NS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSw2QkFBNkI7QUFDekM7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9jb3JlL2Zvcm1hdC1pbmZvLmpzPzk1ODIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcblxuY29uc3QgRzE1ID0gKDEgPDwgMTApIHwgKDEgPDwgOCkgfCAoMSA8PCA1KSB8ICgxIDw8IDQpIHwgKDEgPDwgMikgfCAoMSA8PCAxKSB8ICgxIDw8IDApXG5jb25zdCBHMTVfTUFTSyA9ICgxIDw8IDE0KSB8ICgxIDw8IDEyKSB8ICgxIDw8IDEwKSB8ICgxIDw8IDQpIHwgKDEgPDwgMSlcbmNvbnN0IEcxNV9CQ0ggPSBVdGlscy5nZXRCQ0hEaWdpdChHMTUpXG5cbi8qKlxuICogUmV0dXJucyBmb3JtYXQgaW5mb3JtYXRpb24gd2l0aCByZWxhdGl2ZSBlcnJvciBjb3JyZWN0aW9uIGJpdHNcbiAqXG4gKiBUaGUgZm9ybWF0IGluZm9ybWF0aW9uIGlzIGEgMTUtYml0IHNlcXVlbmNlIGNvbnRhaW5pbmcgNSBkYXRhIGJpdHMsXG4gKiB3aXRoIDEwIGVycm9yIGNvcnJlY3Rpb24gYml0cyBjYWxjdWxhdGVkIHVzaW5nIHRoZSAoMTUsIDUpIEJDSCBjb2RlLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gZXJyb3JDb3JyZWN0aW9uTGV2ZWwgRXJyb3IgY29ycmVjdGlvbiBsZXZlbFxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNrICAgICAgICAgICAgICAgICBNYXNrIHBhdHRlcm5cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgRW5jb2RlZCBmb3JtYXQgaW5mb3JtYXRpb24gYml0c1xuICovXG5leHBvcnRzLmdldEVuY29kZWRCaXRzID0gZnVuY3Rpb24gZ2V0RW5jb2RlZEJpdHMgKGVycm9yQ29ycmVjdGlvbkxldmVsLCBtYXNrKSB7XG4gIGNvbnN0IGRhdGEgPSAoKGVycm9yQ29ycmVjdGlvbkxldmVsLmJpdCA8PCAzKSB8IG1hc2spXG4gIGxldCBkID0gZGF0YSA8PCAxMFxuXG4gIHdoaWxlIChVdGlscy5nZXRCQ0hEaWdpdChkKSAtIEcxNV9CQ0ggPj0gMCkge1xuICAgIGQgXj0gKEcxNSA8PCAoVXRpbHMuZ2V0QkNIRGlnaXQoZCkgLSBHMTVfQkNIKSlcbiAgfVxuXG4gIC8vIHhvciBmaW5hbCBkYXRhIHdpdGggbWFzayBwYXR0ZXJuIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0XG4gIC8vIG5vIGNvbWJpbmF0aW9uIG9mIEVycm9yIENvcnJlY3Rpb24gTGV2ZWwgYW5kIGRhdGEgbWFzayBwYXR0ZXJuXG4gIC8vIHdpbGwgcmVzdWx0IGluIGFuIGFsbC16ZXJvIGRhdGEgc3RyaW5nXG4gIHJldHVybiAoKGRhdGEgPDwgMTApIHwgZCkgXiBHMTVfTUFTS1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4565\n\n}")},4606:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=output.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYwNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvcGF5bWVudC9vdXRwdXQuanM/MjI5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNSBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXRwdXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4606\n\n}')},4713:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const GF = __webpack_require__(2731)\n\n/**\n * Multiplies two polynomials inside Galois Field\n *\n * @param  {Uint8Array} p1 Polynomial\n * @param  {Uint8Array} p2 Polynomial\n * @return {Uint8Array}    Product of p1 and p2\n */\nexports.mul = function mul (p1, p2) {\n  const coeff = new Uint8Array(p1.length + p2.length - 1)\n\n  for (let i = 0; i < p1.length; i++) {\n    for (let j = 0; j < p2.length; j++) {\n      coeff[i + j] ^= GF.mul(p1[i], p2[j])\n    }\n  }\n\n  return coeff\n}\n\n/**\n * Calculate the remainder of polynomials division\n *\n * @param  {Uint8Array} divident Polynomial\n * @param  {Uint8Array} divisor  Polynomial\n * @return {Uint8Array}          Remainder\n */\nexports.mod = function mod (divident, divisor) {\n  let result = new Uint8Array(divident)\n\n  while ((result.length - divisor.length) >= 0) {\n    const coeff = result[0]\n\n    for (let i = 0; i < divisor.length; i++) {\n      result[i] ^= GF.mul(divisor[i], coeff)\n    }\n\n    // remove all zeros from buffer head\n    let offset = 0\n    while (offset < result.length && result[offset] === 0) offset++\n    result = result.slice(offset)\n  }\n\n  return result\n}\n\n/**\n * Generate an irreducible generator polynomial of specified degree\n * (used by Reed-Solomon encoder)\n *\n * @param  {Number} degree Degree of the generator polynomial\n * @return {Uint8Array}    Buffer containing polynomial coefficients\n */\nexports.generateECPolynomial = function generateECPolynomial (degree) {\n  let poly = new Uint8Array([1])\n  for (let i = 0; i < degree; i++) {\n    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))\n  }\n\n  return poly\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcxMy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBZ0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEIsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsV0FBVztBQUNYOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEIsWUFBWSxxQkFBcUI7QUFDakM7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksZUFBZTtBQUMzQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9jb3JlL3BvbHlub21pYWwuanM/MjczMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBHRiA9IHJlcXVpcmUoJy4vZ2Fsb2lzLWZpZWxkJylcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBwb2x5bm9taWFscyBpbnNpZGUgR2Fsb2lzIEZpZWxkXG4gKlxuICogQHBhcmFtICB7VWludDhBcnJheX0gcDEgUG9seW5vbWlhbFxuICogQHBhcmFtICB7VWludDhBcnJheX0gcDIgUG9seW5vbWlhbFxuICogQHJldHVybiB7VWludDhBcnJheX0gICAgUHJvZHVjdCBvZiBwMSBhbmQgcDJcbiAqL1xuZXhwb3J0cy5tdWwgPSBmdW5jdGlvbiBtdWwgKHAxLCBwMikge1xuICBjb25zdCBjb2VmZiA9IG5ldyBVaW50OEFycmF5KHAxLmxlbmd0aCArIHAyLmxlbmd0aCAtIDEpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwMS5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcDIubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvZWZmW2kgKyBqXSBePSBHRi5tdWwocDFbaV0sIHAyW2pdKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2VmZlxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcmVtYWluZGVyIG9mIHBvbHlub21pYWxzIGRpdmlzaW9uXG4gKlxuICogQHBhcmFtICB7VWludDhBcnJheX0gZGl2aWRlbnQgUG9seW5vbWlhbFxuICogQHBhcmFtICB7VWludDhBcnJheX0gZGl2aXNvciAgUG9seW5vbWlhbFxuICogQHJldHVybiB7VWludDhBcnJheX0gICAgICAgICAgUmVtYWluZGVyXG4gKi9cbmV4cG9ydHMubW9kID0gZnVuY3Rpb24gbW9kIChkaXZpZGVudCwgZGl2aXNvcikge1xuICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGl2aWRlbnQpXG5cbiAgd2hpbGUgKChyZXN1bHQubGVuZ3RoIC0gZGl2aXNvci5sZW5ndGgpID49IDApIHtcbiAgICBjb25zdCBjb2VmZiA9IHJlc3VsdFswXVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXZpc29yLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gXj0gR0YubXVsKGRpdmlzb3JbaV0sIGNvZWZmKVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwgemVyb3MgZnJvbSBidWZmZXIgaGVhZFxuICAgIGxldCBvZmZzZXQgPSAwXG4gICAgd2hpbGUgKG9mZnNldCA8IHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W29mZnNldF0gPT09IDApIG9mZnNldCsrXG4gICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKG9mZnNldClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBpcnJlZHVjaWJsZSBnZW5lcmF0b3IgcG9seW5vbWlhbCBvZiBzcGVjaWZpZWQgZGVncmVlXG4gKiAodXNlZCBieSBSZWVkLVNvbG9tb24gZW5jb2RlcilcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZSBEZWdyZWUgb2YgdGhlIGdlbmVyYXRvciBwb2x5bm9taWFsXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSAgICBCdWZmZXIgY29udGFpbmluZyBwb2x5bm9taWFsIGNvZWZmaWNpZW50c1xuICovXG5leHBvcnRzLmdlbmVyYXRlRUNQb2x5bm9taWFsID0gZnVuY3Rpb24gZ2VuZXJhdGVFQ1BvbHlub21pYWwgKGRlZ3JlZSkge1xuICBsZXQgcG9seSA9IG5ldyBVaW50OEFycmF5KFsxXSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWU7IGkrKykge1xuICAgIHBvbHkgPSBleHBvcnRzLm11bChwb2x5LCBuZXcgVWludDhBcnJheShbMSwgR0YuZXhwKGkpXSkpXG4gIH1cblxuICByZXR1cm4gcG9seVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4713\n\n}")},4764:(module,__unused_webpack_exports,__webpack_require__)=>{eval("{const Polynomial = __webpack_require__(4713)\n\nfunction ReedSolomonEncoder (degree) {\n  this.genPoly = undefined\n  this.degree = degree\n\n  if (this.degree) this.initialize(this.degree)\n}\n\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize (degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree\n  this.genPoly = Polynomial.generateECPolynomial(this.degree)\n}\n\n/**\n * Encodes a chunk of data\n *\n * @param  {Uint8Array} data Buffer containing input data\n * @return {Uint8Array}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode (data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized')\n  }\n\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  const paddedData = new Uint8Array(data.length + this.degree)\n  paddedData.set(data)\n\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  const remainder = Polynomial.mod(paddedData, this.genPoly)\n\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  const start = this.degree - remainder.length\n  if (start > 0) {\n    const buff = new Uint8Array(this.degree)\n    buff.set(remainder, start)\n\n    return buff\n  }\n\n  return remainder\n}\n\nmodule.exports = ReedSolomonEncoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc2NC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxJQUFjOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9jb3JlL3JlZWQtc29sb21vbi1lbmNvZGVyLmpzPzhkMjMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUG9seW5vbWlhbCA9IHJlcXVpcmUoJy4vcG9seW5vbWlhbCcpXG5cbmZ1bmN0aW9uIFJlZWRTb2xvbW9uRW5jb2RlciAoZGVncmVlKSB7XG4gIHRoaXMuZ2VuUG9seSA9IHVuZGVmaW5lZFxuICB0aGlzLmRlZ3JlZSA9IGRlZ3JlZVxuXG4gIGlmICh0aGlzLmRlZ3JlZSkgdGhpcy5pbml0aWFsaXplKHRoaXMuZGVncmVlKVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGVuY29kZXIuXG4gKiBUaGUgaW5wdXQgcGFyYW0gc2hvdWxkIGNvcnJlc3BvbmQgdG8gdGhlIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkcy5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRlZ3JlZVxuICovXG5SZWVkU29sb21vbkVuY29kZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplIChkZWdyZWUpIHtcbiAgLy8gY3JlYXRlIGFuIGlycmVkdWNpYmxlIGdlbmVyYXRvciBwb2x5bm9taWFsXG4gIHRoaXMuZGVncmVlID0gZGVncmVlXG4gIHRoaXMuZ2VuUG9seSA9IFBvbHlub21pYWwuZ2VuZXJhdGVFQ1BvbHlub21pYWwodGhpcy5kZWdyZWUpXG59XG5cbi8qKlxuICogRW5jb2RlcyBhIGNodW5rIG9mIGRhdGFcbiAqXG4gKiBAcGFyYW0gIHtVaW50OEFycmF5fSBkYXRhIEJ1ZmZlciBjb250YWluaW5nIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9ICAgICAgQnVmZmVyIGNvbnRhaW5pbmcgZW5jb2RlZCBkYXRhXG4gKi9cblJlZWRTb2xvbW9uRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlIChkYXRhKSB7XG4gIGlmICghdGhpcy5nZW5Qb2x5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGVyIG5vdCBpbml0aWFsaXplZCcpXG4gIH1cblxuICAvLyBDYWxjdWxhdGUgRUMgZm9yIHRoaXMgZGF0YSBibG9ja1xuICAvLyBleHRlbmRzIGRhdGEgc2l6ZSB0byBkYXRhK2dlblBvbHkgc2l6ZVxuICBjb25zdCBwYWRkZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyB0aGlzLmRlZ3JlZSlcbiAgcGFkZGVkRGF0YS5zZXQoZGF0YSlcblxuICAvLyBUaGUgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMgYXJlIHRoZSByZW1haW5kZXIgYWZ0ZXIgZGl2aWRpbmcgdGhlIGRhdGEgY29kZXdvcmRzXG4gIC8vIGJ5IGEgZ2VuZXJhdG9yIHBvbHlub21pYWxcbiAgY29uc3QgcmVtYWluZGVyID0gUG9seW5vbWlhbC5tb2QocGFkZGVkRGF0YSwgdGhpcy5nZW5Qb2x5KVxuXG4gIC8vIHJldHVybiBFQyBkYXRhIGJsb2NrcyAobGFzdCBuIGJ5dGUsIHdoZXJlIG4gaXMgdGhlIGRlZ3JlZSBvZiBnZW5Qb2x5KVxuICAvLyBJZiBjb2VmZmljaWVudHMgbnVtYmVyIGluIHJlbWFpbmRlciBhcmUgbGVzcyB0aGFuIGdlblBvbHkgZGVncmVlLFxuICAvLyBwYWQgd2l0aCAwcyB0byB0aGUgbGVmdCB0byByZWFjaCB0aGUgbmVlZGVkIG51bWJlciBvZiBjb2VmZmljaWVudHNcbiAgY29uc3Qgc3RhcnQgPSB0aGlzLmRlZ3JlZSAtIHJlbWFpbmRlci5sZW5ndGhcbiAgaWYgKHN0YXJ0ID4gMCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheSh0aGlzLmRlZ3JlZSlcbiAgICBidWZmLnNldChyZW1haW5kZXIsIHN0YXJ0KVxuXG4gICAgcmV0dXJuIGJ1ZmZcbiAgfVxuXG4gIHJldHVybiByZW1haW5kZXJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWVkU29sb21vbkVuY29kZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4764\n\n}")},4861:(module,__unused_webpack_exports,__webpack_require__)=>{eval("{const Mode = __webpack_require__(208)\nconst Utils = __webpack_require__(6886)\n\nfunction KanjiData (data) {\n  this.mode = Mode.KANJI\n  this.data = data\n}\n\nKanjiData.getBitsLength = function getBitsLength (length) {\n  return length * 13\n}\n\nKanjiData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nKanjiData.prototype.getBitsLength = function getBitsLength () {\n  return KanjiData.getBitsLength(this.data.length)\n}\n\nKanjiData.prototype.write = function (bitBuffer) {\n  let i\n\n  // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n  // These byte values are shifted from the JIS X 0208 values.\n  // JIS X 0208 gives details of the shift coded representation.\n  for (i = 0; i < this.data.length; i++) {\n    let value = Utils.toSJIS(this.data[i])\n\n    // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n    if (value >= 0x8140 && value <= 0x9FFC) {\n      // Subtract 0x8140 from Shift JIS value\n      value -= 0x8140\n\n    // For characters with Shift JIS values from 0xE040 to 0xEBBF\n    } else if (value >= 0xE040 && value <= 0xEBBF) {\n      // Subtract 0xC140 from Shift JIS value\n      value -= 0xC140\n    } else {\n      throw new Error(\n        'Invalid SJIS character: ' + this.data[i] + '\\n' +\n        'Make sure your charset is UTF-8')\n    }\n\n    // Multiply most significant byte of result by 0xC0\n    // and add least significant byte to product\n    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff)\n\n    // Convert result to a 13-bit binary string\n    bitBuffer.put(value, 13)\n  }\n}\n\nmodule.exports = KanjiData\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsR0FBUTtBQUM3QixjQUFjLG1CQUFPLENBQUMsSUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9jb3JlL2thbmppLWRhdGEuanM/MmYzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNb2RlID0gcmVxdWlyZSgnLi9tb2RlJylcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmZ1bmN0aW9uIEthbmppRGF0YSAoZGF0YSkge1xuICB0aGlzLm1vZGUgPSBNb2RlLktBTkpJXG4gIHRoaXMuZGF0YSA9IGRhdGFcbn1cblxuS2FuamlEYXRhLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoIChsZW5ndGgpIHtcbiAgcmV0dXJuIGxlbmd0aCAqIDEzXG59XG5cbkthbmppRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGhcbn1cblxuS2FuamlEYXRhLnByb3RvdHlwZS5nZXRCaXRzTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Qml0c0xlbmd0aCAoKSB7XG4gIHJldHVybiBLYW5qaURhdGEuZ2V0Qml0c0xlbmd0aCh0aGlzLmRhdGEubGVuZ3RoKVxufVxuXG5LYW5qaURhdGEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJpdEJ1ZmZlcikge1xuICBsZXQgaVxuXG4gIC8vIEluIHRoZSBTaGlmdCBKSVMgc3lzdGVtLCBLYW5qaSBjaGFyYWN0ZXJzIGFyZSByZXByZXNlbnRlZCBieSBhIHR3byBieXRlIGNvbWJpbmF0aW9uLlxuICAvLyBUaGVzZSBieXRlIHZhbHVlcyBhcmUgc2hpZnRlZCBmcm9tIHRoZSBKSVMgWCAwMjA4IHZhbHVlcy5cbiAgLy8gSklTIFggMDIwOCBnaXZlcyBkZXRhaWxzIG9mIHRoZSBzaGlmdCBjb2RlZCByZXByZXNlbnRhdGlvbi5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGxldCB2YWx1ZSA9IFV0aWxzLnRvU0pJUyh0aGlzLmRhdGFbaV0pXG5cbiAgICAvLyBGb3IgY2hhcmFjdGVycyB3aXRoIFNoaWZ0IEpJUyB2YWx1ZXMgZnJvbSAweDgxNDAgdG8gMHg5RkZDOlxuICAgIGlmICh2YWx1ZSA+PSAweDgxNDAgJiYgdmFsdWUgPD0gMHg5RkZDKSB7XG4gICAgICAvLyBTdWJ0cmFjdCAweDgxNDAgZnJvbSBTaGlmdCBKSVMgdmFsdWVcbiAgICAgIHZhbHVlIC09IDB4ODE0MFxuXG4gICAgLy8gRm9yIGNoYXJhY3RlcnMgd2l0aCBTaGlmdCBKSVMgdmFsdWVzIGZyb20gMHhFMDQwIHRvIDB4RUJCRlxuICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gMHhFMDQwICYmIHZhbHVlIDw9IDB4RUJCRikge1xuICAgICAgLy8gU3VidHJhY3QgMHhDMTQwIGZyb20gU2hpZnQgSklTIHZhbHVlXG4gICAgICB2YWx1ZSAtPSAweEMxNDBcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSW52YWxpZCBTSklTIGNoYXJhY3RlcjogJyArIHRoaXMuZGF0YVtpXSArICdcXG4nICtcbiAgICAgICAgJ01ha2Ugc3VyZSB5b3VyIGNoYXJzZXQgaXMgVVRGLTgnKVxuICAgIH1cblxuICAgIC8vIE11bHRpcGx5IG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvZiByZXN1bHQgYnkgMHhDMFxuICAgIC8vIGFuZCBhZGQgbGVhc3Qgc2lnbmlmaWNhbnQgYnl0ZSB0byBwcm9kdWN0XG4gICAgdmFsdWUgPSAoKCh2YWx1ZSA+Pj4gOCkgJiAweGZmKSAqIDB4QzApICsgKHZhbHVlICYgMHhmZilcblxuICAgIC8vIENvbnZlcnQgcmVzdWx0IHRvIGEgMTMtYml0IGJpbmFyeSBzdHJpbmdcbiAgICBiaXRCdWZmZXIucHV0KHZhbHVlLCAxMylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEthbmppRGF0YVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4861\n\n}")},4964:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseSlp = void 0;\nconst str_js_1 = __webpack_require__(2392);\nconst hex_js_1 = __webpack_require__(2938);\nconst opcode_js_1 = __webpack_require__(2250);\nconst op_js_1 = __webpack_require__(243);\nconst common_js_1 = __webpack_require__(5467);\nconst slp_js_1 = __webpack_require__(8737);\n/**\n * Parse the given SLP OP_RETURN Script.\n *\n * For data that's clearly not SLP it will return `undefined`.\n * For example, if the OP_RETURN or LOKAD ID is missing.\n *\n * For an unknown token type, it'll return SlpUnknown.\n *\n * For a known token type, it'll parse the remaining data, or throw an error if\n * the format is invalid or if there's an unknown tx type.\n *\n * This behavior mirrors that of Chronik for consistency.\n **/\nfunction parseSlp(opreturnScript) {\n    const ops = opreturnScript.ops();\n    const opreturnOp = ops.next();\n    // Return undefined if not OP_RETURN\n    if (opreturnOp === undefined ||\n        (0, op_js_1.isPushOp)(opreturnOp) ||\n        opreturnOp !== opcode_js_1.OP_RETURN) {\n        return undefined;\n    }\n    // Return undefined if LOKAD ID is not \"SLP\\0\"\n    const lokadId = ops.next();\n    if (lokadId === undefined || !(0, op_js_1.isPushOp)(lokadId)) {\n        return undefined;\n    }\n    if ((0, str_js_1.bytesToStr)(lokadId.data) !== slp_js_1.SLP_LOKAD_ID_STR) {\n        return undefined;\n    }\n    // Parse token type\n    const tokenTypeBytes = nextBytes(ops);\n    if (tokenTypeBytes === undefined) {\n        throw new Error('Missing tokenType');\n    }\n    if (tokenTypeBytes.length !== 1) {\n        throw new Error('tokenType must be exactly 1 byte');\n    }\n    const tokenType = tokenTypeBytes[0];\n    if (tokenType !== slp_js_1.SLP_FUNGIBLE &&\n        tokenType !== slp_js_1.SLP_MINT_VAULT &&\n        tokenType !== slp_js_1.SLP_NFT1_GROUP &&\n        tokenType !== slp_js_1.SLP_NFT1_CHILD) {\n        return {\n            txType: common_js_1.UNKNOWN_STR,\n            tokenType,\n        };\n    }\n    // Parse tx type (GENESIS, MINT, SEND, BURN)\n    const txTypeBytes = nextBytes(ops);\n    if (txTypeBytes === undefined) {\n        throw new Error('Missing txType');\n    }\n    const txType = (0, str_js_1.bytesToStr)(txTypeBytes);\n    // Handle tx type specific parsing.\n    // Advances the `ops` Script iterator\n    switch (txType) {\n        case common_js_1.GENESIS_STR:\n            return nextGenesis(ops, tokenType);\n        case common_js_1.MINT_STR:\n            return nextMint(ops, tokenType);\n        case common_js_1.SEND_STR:\n            return nextSend(ops, tokenType);\n        case common_js_1.BURN_STR:\n            return nextBurn(ops, tokenType);\n        default:\n            throw new Error('Unknown txType');\n    }\n}\nexports.parseSlp = parseSlp;\nfunction nextGenesis(ops, tokenType) {\n    // Parse genesis info\n    const tokenTicker = (0, str_js_1.bytesToStr)(nextBytesRequired(ops, 'tokenTicker'));\n    const tokenName = (0, str_js_1.bytesToStr)(nextBytesRequired(ops, 'tokenName'));\n    const url = (0, str_js_1.bytesToStr)(nextBytesRequired(ops, 'url'));\n    const hash = nextBytesRequired(ops, 'hash');\n    if (hash.length !== 0 && hash.length !== slp_js_1.SLP_GENESIS_HASH_NUM_BYTES) {\n        throw new Error(`hash must be either 0 or ${slp_js_1.SLP_GENESIS_HASH_NUM_BYTES} bytes`);\n    }\n    const decimalsBytes = nextBytesRequired(ops, 'decimals');\n    if (decimalsBytes.length !== 1) {\n        throw new Error('decimals must be exactly 1 byte');\n    }\n    const decimals = decimalsBytes[0];\n    if (decimals > common_js_1.MAX_DECIMALS) {\n        throw new Error(`decimals must be at most ${common_js_1.MAX_DECIMALS}`);\n    }\n    // Parse mint data\n    let mintVaultScripthash = undefined;\n    let mintBatonOutIdx = undefined;\n    if (tokenType === slp_js_1.SLP_MINT_VAULT) {\n        const scripthashBytes = nextBytesRequired(ops, 'mintVaultScripthash');\n        if (scripthashBytes.length !== slp_js_1.SLP_MINT_VAULT_SCRIPTHASH_NUM_BYTES) {\n            throw new Error(`mintVaultScripthash must be exactly ${slp_js_1.SLP_MINT_VAULT_SCRIPTHASH_NUM_BYTES} ` +\n                'bytes long');\n        }\n        mintVaultScripthash = (0, hex_js_1.toHex)(scripthashBytes);\n    }\n    else {\n        mintBatonOutIdx = nextMintOutIdx(ops, tokenType);\n    }\n    const initialAtoms = parseSlpAtoms(nextBytesRequired(ops, 'initialAtoms'));\n    nextEnd(ops, 'GENESIS');\n    return {\n        txType: common_js_1.GENESIS_STR,\n        tokenType,\n        genesisInfo: {\n            tokenTicker,\n            tokenName,\n            url,\n            hash: hash.length !== 0 ? (0, hex_js_1.toHex)(hash) : undefined,\n            mintVaultScripthash,\n            decimals,\n        },\n        initialAtoms,\n        mintBatonOutIdx,\n    };\n}\nfunction nextMint(ops, tokenType) {\n    const tokenId = nextTokenId(ops);\n    if (tokenType === slp_js_1.SLP_MINT_VAULT) {\n        const additionalAtomsArray = nextSlpAtomsArray(ops);\n        return {\n            txType: common_js_1.MINT_STR,\n            tokenType,\n            tokenId,\n            additionalAtomsArray,\n        };\n    }\n    else if (tokenType === slp_js_1.SLP_NFT1_CHILD) {\n        throw new Error('SLP_NFT1_CHILD cannot have MINT transactions');\n    }\n    else {\n        const mintBatonOutIdx = nextMintOutIdx(ops, tokenType);\n        const additionalAtoms = parseSlpAtoms(nextBytesRequired(ops, 'additionalAtoms'));\n        nextEnd(ops, 'MINT');\n        return {\n            txType: common_js_1.MINT_STR,\n            tokenType,\n            tokenId,\n            additionalAtoms,\n            mintBatonOutIdx,\n        };\n    }\n}\nfunction nextSend(ops, tokenType) {\n    const tokenId = nextTokenId(ops);\n    const sendAtomsArray = nextSlpAtomsArray(ops);\n    return {\n        txType: common_js_1.SEND_STR,\n        tokenType,\n        tokenId,\n        sendAtomsArray,\n    };\n}\nfunction nextBurn(ops, tokenType) {\n    const tokenId = nextTokenId(ops);\n    const burnAtoms = parseSlpAtoms(nextBytesRequired(ops, 'burnAtoms'));\n    nextEnd(ops, 'BURN');\n    return {\n        txType: common_js_1.BURN_STR,\n        tokenType,\n        tokenId,\n        burnAtoms,\n    };\n}\nfunction nextBytes(iter) {\n    const op = iter.next();\n    if (op === undefined) {\n        return undefined;\n    }\n    if (!(0, op_js_1.isPushOp)(op)) {\n        throw new Error('SLP only supports push-ops');\n    }\n    return op.data;\n}\nfunction nextBytesRequired(iter, name) {\n    const bytes = nextBytes(iter);\n    if (bytes === undefined) {\n        throw new Error('Missing ' + name);\n    }\n    return bytes;\n}\nfunction nextMintOutIdx(iter, tokenType) {\n    const outIdxBytes = nextBytesRequired(iter, 'mintBatonOutIdx');\n    if (outIdxBytes.length > 1) {\n        throw new Error('mintBatonOutIdx must be at most 1 byte long');\n    }\n    if (outIdxBytes.length === 1) {\n        if (tokenType === slp_js_1.SLP_NFT1_CHILD) {\n            throw new Error('SLP_NFT1_CHILD cannot have a mint baton');\n        }\n        const mintBatonOutIdx = outIdxBytes[0];\n        if (mintBatonOutIdx < 2) {\n            throw new Error('mintBatonOutIdx must be at least 2');\n        }\n        return mintBatonOutIdx;\n    }\n    return undefined;\n}\nfunction nextTokenId(iter) {\n    const tokenIdBytes = nextBytesRequired(iter, 'tokenId');\n    if (tokenIdBytes.length !== common_js_1.TOKEN_ID_NUM_BYTES) {\n        throw new Error(`tokenId must be exactly ${common_js_1.TOKEN_ID_NUM_BYTES} bytes long`);\n    }\n    // Note: SLP token ID endianness is big-endian\n    return (0, hex_js_1.toHex)(tokenIdBytes);\n}\nfunction nextSlpAtomsArray(iter) {\n    const atomsArray = [];\n    let bytes = undefined;\n    while ((bytes = nextBytes(iter)) !== undefined) {\n        atomsArray.push(parseSlpAtoms(bytes));\n    }\n    if (atomsArray.length === 0) {\n        throw new Error('atomsArray cannot be empty');\n    }\n    if (atomsArray.length > slp_js_1.SLP_MAX_SEND_OUTPUTS) {\n        throw new Error(`atomsArray can at most be ${slp_js_1.SLP_MAX_SEND_OUTPUTS} items long`);\n    }\n    return atomsArray;\n}\nfunction nextEnd(iter, txType) {\n    if (iter.next() !== undefined) {\n        throw new Error(`Superfluous ${txType} bytes`);\n    }\n}\nfunction parseSlpAtoms(bytes) {\n    if (bytes.length !== slp_js_1.SLP_ATOMS_NUM_BYTES) {\n        throw new Error(`SLP atoms must be exactly ${slp_js_1.SLP_ATOMS_NUM_BYTES} bytes long`);\n    }\n    let number = 0n;\n    for (let i = 0; i < slp_js_1.SLP_ATOMS_NUM_BYTES; ++i) {\n        number <<= 8n;\n        number |= BigInt(bytes[i]);\n    }\n    return number;\n}\n//# sourceMappingURL=slp.parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk2NC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsaUJBQWlCLG1CQUFPLENBQUMsSUFBYztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFjO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLElBQWM7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsR0FBVTtBQUNsQyxvQkFBb0IsbUJBQU8sQ0FBQyxJQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLElBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFDQUFxQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsOENBQThDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsK0JBQStCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw4QkFBOEI7QUFDbkY7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC90b2tlbi9zbHAucGFyc2UuanM/ZDY1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNSBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlU2xwID0gdm9pZCAwO1xuY29uc3Qgc3RyX2pzXzEgPSByZXF1aXJlKFwiLi4vaW8vc3RyLmpzXCIpO1xuY29uc3QgaGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vaW8vaGV4LmpzXCIpO1xuY29uc3Qgb3Bjb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vb3Bjb2RlLmpzXCIpO1xuY29uc3Qgb3BfanNfMSA9IHJlcXVpcmUoXCIuLi9vcC5qc1wiKTtcbmNvbnN0IGNvbW1vbl9qc18xID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuY29uc3Qgc2xwX2pzXzEgPSByZXF1aXJlKFwiLi9zbHAuanNcIik7XG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBTTFAgT1BfUkVUVVJOIFNjcmlwdC5cbiAqXG4gKiBGb3IgZGF0YSB0aGF0J3MgY2xlYXJseSBub3QgU0xQIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBPUF9SRVRVUk4gb3IgTE9LQUQgSUQgaXMgbWlzc2luZy5cbiAqXG4gKiBGb3IgYW4gdW5rbm93biB0b2tlbiB0eXBlLCBpdCdsbCByZXR1cm4gU2xwVW5rbm93bi5cbiAqXG4gKiBGb3IgYSBrbm93biB0b2tlbiB0eXBlLCBpdCdsbCBwYXJzZSB0aGUgcmVtYWluaW5nIGRhdGEsIG9yIHRocm93IGFuIGVycm9yIGlmXG4gKiB0aGUgZm9ybWF0IGlzIGludmFsaWQgb3IgaWYgdGhlcmUncyBhbiB1bmtub3duIHR4IHR5cGUuXG4gKlxuICogVGhpcyBiZWhhdmlvciBtaXJyb3JzIHRoYXQgb2YgQ2hyb25payBmb3IgY29uc2lzdGVuY3kuXG4gKiovXG5mdW5jdGlvbiBwYXJzZVNscChvcHJldHVyblNjcmlwdCkge1xuICAgIGNvbnN0IG9wcyA9IG9wcmV0dXJuU2NyaXB0Lm9wcygpO1xuICAgIGNvbnN0IG9wcmV0dXJuT3AgPSBvcHMubmV4dCgpO1xuICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgbm90IE9QX1JFVFVSTlxuICAgIGlmIChvcHJldHVybk9wID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKDAsIG9wX2pzXzEuaXNQdXNoT3ApKG9wcmV0dXJuT3ApIHx8XG4gICAgICAgIG9wcmV0dXJuT3AgIT09IG9wY29kZV9qc18xLk9QX1JFVFVSTikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGlmIExPS0FEIElEIGlzIG5vdCBcIlNMUFxcMFwiXG4gICAgY29uc3QgbG9rYWRJZCA9IG9wcy5uZXh0KCk7XG4gICAgaWYgKGxva2FkSWQgPT09IHVuZGVmaW5lZCB8fCAhKDAsIG9wX2pzXzEuaXNQdXNoT3ApKGxva2FkSWQpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICgoMCwgc3RyX2pzXzEuYnl0ZXNUb1N0cikobG9rYWRJZC5kYXRhKSAhPT0gc2xwX2pzXzEuU0xQX0xPS0FEX0lEX1NUUikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBQYXJzZSB0b2tlbiB0eXBlXG4gICAgY29uc3QgdG9rZW5UeXBlQnl0ZXMgPSBuZXh0Qnl0ZXMob3BzKTtcbiAgICBpZiAodG9rZW5UeXBlQnl0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdG9rZW5UeXBlJyk7XG4gICAgfVxuICAgIGlmICh0b2tlblR5cGVCeXRlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlblR5cGUgbXVzdCBiZSBleGFjdGx5IDEgYnl0ZScpO1xuICAgIH1cbiAgICBjb25zdCB0b2tlblR5cGUgPSB0b2tlblR5cGVCeXRlc1swXTtcbiAgICBpZiAodG9rZW5UeXBlICE9PSBzbHBfanNfMS5TTFBfRlVOR0lCTEUgJiZcbiAgICAgICAgdG9rZW5UeXBlICE9PSBzbHBfanNfMS5TTFBfTUlOVF9WQVVMVCAmJlxuICAgICAgICB0b2tlblR5cGUgIT09IHNscF9qc18xLlNMUF9ORlQxX0dST1VQICYmXG4gICAgICAgIHRva2VuVHlwZSAhPT0gc2xwX2pzXzEuU0xQX05GVDFfQ0hJTEQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4VHlwZTogY29tbW9uX2pzXzEuVU5LTk9XTl9TVFIsXG4gICAgICAgICAgICB0b2tlblR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFBhcnNlIHR4IHR5cGUgKEdFTkVTSVMsIE1JTlQsIFNFTkQsIEJVUk4pXG4gICAgY29uc3QgdHhUeXBlQnl0ZXMgPSBuZXh0Qnl0ZXMob3BzKTtcbiAgICBpZiAodHhUeXBlQnl0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHhUeXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IHR4VHlwZSA9ICgwLCBzdHJfanNfMS5ieXRlc1RvU3RyKSh0eFR5cGVCeXRlcyk7XG4gICAgLy8gSGFuZGxlIHR4IHR5cGUgc3BlY2lmaWMgcGFyc2luZy5cbiAgICAvLyBBZHZhbmNlcyB0aGUgYG9wc2AgU2NyaXB0IGl0ZXJhdG9yXG4gICAgc3dpdGNoICh0eFR5cGUpIHtcbiAgICAgICAgY2FzZSBjb21tb25fanNfMS5HRU5FU0lTX1NUUjpcbiAgICAgICAgICAgIHJldHVybiBuZXh0R2VuZXNpcyhvcHMsIHRva2VuVHlwZSk7XG4gICAgICAgIGNhc2UgY29tbW9uX2pzXzEuTUlOVF9TVFI6XG4gICAgICAgICAgICByZXR1cm4gbmV4dE1pbnQob3BzLCB0b2tlblR5cGUpO1xuICAgICAgICBjYXNlIGNvbW1vbl9qc18xLlNFTkRfU1RSOlxuICAgICAgICAgICAgcmV0dXJuIG5leHRTZW5kKG9wcywgdG9rZW5UeXBlKTtcbiAgICAgICAgY2FzZSBjb21tb25fanNfMS5CVVJOX1NUUjpcbiAgICAgICAgICAgIHJldHVybiBuZXh0QnVybihvcHMsIHRva2VuVHlwZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHhUeXBlJyk7XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZVNscCA9IHBhcnNlU2xwO1xuZnVuY3Rpb24gbmV4dEdlbmVzaXMob3BzLCB0b2tlblR5cGUpIHtcbiAgICAvLyBQYXJzZSBnZW5lc2lzIGluZm9cbiAgICBjb25zdCB0b2tlblRpY2tlciA9ICgwLCBzdHJfanNfMS5ieXRlc1RvU3RyKShuZXh0Qnl0ZXNSZXF1aXJlZChvcHMsICd0b2tlblRpY2tlcicpKTtcbiAgICBjb25zdCB0b2tlbk5hbWUgPSAoMCwgc3RyX2pzXzEuYnl0ZXNUb1N0cikobmV4dEJ5dGVzUmVxdWlyZWQob3BzLCAndG9rZW5OYW1lJykpO1xuICAgIGNvbnN0IHVybCA9ICgwLCBzdHJfanNfMS5ieXRlc1RvU3RyKShuZXh0Qnl0ZXNSZXF1aXJlZChvcHMsICd1cmwnKSk7XG4gICAgY29uc3QgaGFzaCA9IG5leHRCeXRlc1JlcXVpcmVkKG9wcywgJ2hhc2gnKTtcbiAgICBpZiAoaGFzaC5sZW5ndGggIT09IDAgJiYgaGFzaC5sZW5ndGggIT09IHNscF9qc18xLlNMUF9HRU5FU0lTX0hBU0hfTlVNX0JZVEVTKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaCBtdXN0IGJlIGVpdGhlciAwIG9yICR7c2xwX2pzXzEuU0xQX0dFTkVTSVNfSEFTSF9OVU1fQllURVN9IGJ5dGVzYCk7XG4gICAgfVxuICAgIGNvbnN0IGRlY2ltYWxzQnl0ZXMgPSBuZXh0Qnl0ZXNSZXF1aXJlZChvcHMsICdkZWNpbWFscycpO1xuICAgIGlmIChkZWNpbWFsc0J5dGVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY2ltYWxzIG11c3QgYmUgZXhhY3RseSAxIGJ5dGUnKTtcbiAgICB9XG4gICAgY29uc3QgZGVjaW1hbHMgPSBkZWNpbWFsc0J5dGVzWzBdO1xuICAgIGlmIChkZWNpbWFscyA+IGNvbW1vbl9qc18xLk1BWF9ERUNJTUFMUykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRlY2ltYWxzIG11c3QgYmUgYXQgbW9zdCAke2NvbW1vbl9qc18xLk1BWF9ERUNJTUFMU31gKTtcbiAgICB9XG4gICAgLy8gUGFyc2UgbWludCBkYXRhXG4gICAgbGV0IG1pbnRWYXVsdFNjcmlwdGhhc2ggPSB1bmRlZmluZWQ7XG4gICAgbGV0IG1pbnRCYXRvbk91dElkeCA9IHVuZGVmaW5lZDtcbiAgICBpZiAodG9rZW5UeXBlID09PSBzbHBfanNfMS5TTFBfTUlOVF9WQVVMVCkge1xuICAgICAgICBjb25zdCBzY3JpcHRoYXNoQnl0ZXMgPSBuZXh0Qnl0ZXNSZXF1aXJlZChvcHMsICdtaW50VmF1bHRTY3JpcHRoYXNoJyk7XG4gICAgICAgIGlmIChzY3JpcHRoYXNoQnl0ZXMubGVuZ3RoICE9PSBzbHBfanNfMS5TTFBfTUlOVF9WQVVMVF9TQ1JJUFRIQVNIX05VTV9CWVRFUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaW50VmF1bHRTY3JpcHRoYXNoIG11c3QgYmUgZXhhY3RseSAke3NscF9qc18xLlNMUF9NSU5UX1ZBVUxUX1NDUklQVEhBU0hfTlVNX0JZVEVTfSBgICtcbiAgICAgICAgICAgICAgICAnYnl0ZXMgbG9uZycpO1xuICAgICAgICB9XG4gICAgICAgIG1pbnRWYXVsdFNjcmlwdGhhc2ggPSAoMCwgaGV4X2pzXzEudG9IZXgpKHNjcmlwdGhhc2hCeXRlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtaW50QmF0b25PdXRJZHggPSBuZXh0TWludE91dElkeChvcHMsIHRva2VuVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWxBdG9tcyA9IHBhcnNlU2xwQXRvbXMobmV4dEJ5dGVzUmVxdWlyZWQob3BzLCAnaW5pdGlhbEF0b21zJykpO1xuICAgIG5leHRFbmQob3BzLCAnR0VORVNJUycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR4VHlwZTogY29tbW9uX2pzXzEuR0VORVNJU19TVFIsXG4gICAgICAgIHRva2VuVHlwZSxcbiAgICAgICAgZ2VuZXNpc0luZm86IHtcbiAgICAgICAgICAgIHRva2VuVGlja2VyLFxuICAgICAgICAgICAgdG9rZW5OYW1lLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgaGFzaDogaGFzaC5sZW5ndGggIT09IDAgPyAoMCwgaGV4X2pzXzEudG9IZXgpKGhhc2gpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWludFZhdWx0U2NyaXB0aGFzaCxcbiAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICB9LFxuICAgICAgICBpbml0aWFsQXRvbXMsXG4gICAgICAgIG1pbnRCYXRvbk91dElkeCxcbiAgICB9O1xufVxuZnVuY3Rpb24gbmV4dE1pbnQob3BzLCB0b2tlblR5cGUpIHtcbiAgICBjb25zdCB0b2tlbklkID0gbmV4dFRva2VuSWQob3BzKTtcbiAgICBpZiAodG9rZW5UeXBlID09PSBzbHBfanNfMS5TTFBfTUlOVF9WQVVMVCkge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsQXRvbXNBcnJheSA9IG5leHRTbHBBdG9tc0FycmF5KG9wcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eFR5cGU6IGNvbW1vbl9qc18xLk1JTlRfU1RSLFxuICAgICAgICAgICAgdG9rZW5UeXBlLFxuICAgICAgICAgICAgdG9rZW5JZCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxBdG9tc0FycmF5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0b2tlblR5cGUgPT09IHNscF9qc18xLlNMUF9ORlQxX0NISUxEKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU0xQX05GVDFfQ0hJTEQgY2Fubm90IGhhdmUgTUlOVCB0cmFuc2FjdGlvbnMnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pbnRCYXRvbk91dElkeCA9IG5leHRNaW50T3V0SWR4KG9wcywgdG9rZW5UeXBlKTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbEF0b21zID0gcGFyc2VTbHBBdG9tcyhuZXh0Qnl0ZXNSZXF1aXJlZChvcHMsICdhZGRpdGlvbmFsQXRvbXMnKSk7XG4gICAgICAgIG5leHRFbmQob3BzLCAnTUlOVCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhUeXBlOiBjb21tb25fanNfMS5NSU5UX1NUUixcbiAgICAgICAgICAgIHRva2VuVHlwZSxcbiAgICAgICAgICAgIHRva2VuSWQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsQXRvbXMsXG4gICAgICAgICAgICBtaW50QmF0b25PdXRJZHgsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dFNlbmQob3BzLCB0b2tlblR5cGUpIHtcbiAgICBjb25zdCB0b2tlbklkID0gbmV4dFRva2VuSWQob3BzKTtcbiAgICBjb25zdCBzZW5kQXRvbXNBcnJheSA9IG5leHRTbHBBdG9tc0FycmF5KG9wcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhUeXBlOiBjb21tb25fanNfMS5TRU5EX1NUUixcbiAgICAgICAgdG9rZW5UeXBlLFxuICAgICAgICB0b2tlbklkLFxuICAgICAgICBzZW5kQXRvbXNBcnJheSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbmV4dEJ1cm4ob3BzLCB0b2tlblR5cGUpIHtcbiAgICBjb25zdCB0b2tlbklkID0gbmV4dFRva2VuSWQob3BzKTtcbiAgICBjb25zdCBidXJuQXRvbXMgPSBwYXJzZVNscEF0b21zKG5leHRCeXRlc1JlcXVpcmVkKG9wcywgJ2J1cm5BdG9tcycpKTtcbiAgICBuZXh0RW5kKG9wcywgJ0JVUk4nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eFR5cGU6IGNvbW1vbl9qc18xLkJVUk5fU1RSLFxuICAgICAgICB0b2tlblR5cGUsXG4gICAgICAgIHRva2VuSWQsXG4gICAgICAgIGJ1cm5BdG9tcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gbmV4dEJ5dGVzKGl0ZXIpIHtcbiAgICBjb25zdCBvcCA9IGl0ZXIubmV4dCgpO1xuICAgIGlmIChvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghKDAsIG9wX2pzXzEuaXNQdXNoT3ApKG9wKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NMUCBvbmx5IHN1cHBvcnRzIHB1c2gtb3BzJyk7XG4gICAgfVxuICAgIHJldHVybiBvcC5kYXRhO1xufVxuZnVuY3Rpb24gbmV4dEJ5dGVzUmVxdWlyZWQoaXRlciwgbmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV4dEJ5dGVzKGl0ZXIpO1xuICAgIGlmIChieXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyAnICsgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIG5leHRNaW50T3V0SWR4KGl0ZXIsIHRva2VuVHlwZSkge1xuICAgIGNvbnN0IG91dElkeEJ5dGVzID0gbmV4dEJ5dGVzUmVxdWlyZWQoaXRlciwgJ21pbnRCYXRvbk91dElkeCcpO1xuICAgIGlmIChvdXRJZHhCeXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWludEJhdG9uT3V0SWR4IG11c3QgYmUgYXQgbW9zdCAxIGJ5dGUgbG9uZycpO1xuICAgIH1cbiAgICBpZiAob3V0SWR4Qnl0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0b2tlblR5cGUgPT09IHNscF9qc18xLlNMUF9ORlQxX0NISUxEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NMUF9ORlQxX0NISUxEIGNhbm5vdCBoYXZlIGEgbWludCBiYXRvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbnRCYXRvbk91dElkeCA9IG91dElkeEJ5dGVzWzBdO1xuICAgICAgICBpZiAobWludEJhdG9uT3V0SWR4IDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW50QmF0b25PdXRJZHggbXVzdCBiZSBhdCBsZWFzdCAyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbnRCYXRvbk91dElkeDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIG5leHRUb2tlbklkKGl0ZXIpIHtcbiAgICBjb25zdCB0b2tlbklkQnl0ZXMgPSBuZXh0Qnl0ZXNSZXF1aXJlZChpdGVyLCAndG9rZW5JZCcpO1xuICAgIGlmICh0b2tlbklkQnl0ZXMubGVuZ3RoICE9PSBjb21tb25fanNfMS5UT0tFTl9JRF9OVU1fQllURVMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0b2tlbklkIG11c3QgYmUgZXhhY3RseSAke2NvbW1vbl9qc18xLlRPS0VOX0lEX05VTV9CWVRFU30gYnl0ZXMgbG9uZ2ApO1xuICAgIH1cbiAgICAvLyBOb3RlOiBTTFAgdG9rZW4gSUQgZW5kaWFubmVzcyBpcyBiaWctZW5kaWFuXG4gICAgcmV0dXJuICgwLCBoZXhfanNfMS50b0hleCkodG9rZW5JZEJ5dGVzKTtcbn1cbmZ1bmN0aW9uIG5leHRTbHBBdG9tc0FycmF5KGl0ZXIpIHtcbiAgICBjb25zdCBhdG9tc0FycmF5ID0gW107XG4gICAgbGV0IGJ5dGVzID0gdW5kZWZpbmVkO1xuICAgIHdoaWxlICgoYnl0ZXMgPSBuZXh0Qnl0ZXMoaXRlcikpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXRvbXNBcnJheS5wdXNoKHBhcnNlU2xwQXRvbXMoYnl0ZXMpKTtcbiAgICB9XG4gICAgaWYgKGF0b21zQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXRvbXNBcnJheSBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKGF0b21zQXJyYXkubGVuZ3RoID4gc2xwX2pzXzEuU0xQX01BWF9TRU5EX09VVFBVVFMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdG9tc0FycmF5IGNhbiBhdCBtb3N0IGJlICR7c2xwX2pzXzEuU0xQX01BWF9TRU5EX09VVFBVVFN9IGl0ZW1zIGxvbmdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0b21zQXJyYXk7XG59XG5mdW5jdGlvbiBuZXh0RW5kKGl0ZXIsIHR4VHlwZSkge1xuICAgIGlmIChpdGVyLm5leHQoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3VwZXJmbHVvdXMgJHt0eFR5cGV9IGJ5dGVzYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VTbHBBdG9tcyhieXRlcykge1xuICAgIGlmIChieXRlcy5sZW5ndGggIT09IHNscF9qc18xLlNMUF9BVE9NU19OVU1fQllURVMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTTFAgYXRvbXMgbXVzdCBiZSBleGFjdGx5ICR7c2xwX2pzXzEuU0xQX0FUT01TX05VTV9CWVRFU30gYnl0ZXMgbG9uZ2ApO1xuICAgIH1cbiAgICBsZXQgbnVtYmVyID0gMG47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbHBfanNfMS5TTFBfQVRPTVNfTlVNX0JZVEVTOyArK2kpIHtcbiAgICAgICAgbnVtYmVyIDw8PSA4bjtcbiAgICAgICAgbnVtYmVyIHw9IEJpZ0ludChieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBudW1iZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbHAucGFyc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4964\n\n}")},5019:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.x509 = exports.asn1 = void 0;\nexports.asn1 = __importStar(__webpack_require__(602));\nexports.x509 = __importStar(__webpack_require__(9003));\n// We classify these types as payment, since we have various Output types\n// already in the namespace (TxOutput, TxBuilderOutput, etc)\n__exportStar(__webpack_require__(9693), exports);\n__exportStar(__webpack_require__(4606), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAxOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLFlBQVk7QUFDM0IsWUFBWSxnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQy9DLFlBQVksZ0JBQWdCLG1CQUFPLENBQUMsSUFBVztBQUMvQztBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLElBQWE7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLElBQWE7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L3BheW1lbnQvaW5kZXguanM/OTM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNSBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLng1MDkgPSBleHBvcnRzLmFzbjEgPSB2b2lkIDA7XG5leHBvcnRzLmFzbjEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYXNuMS5qc1wiKSk7XG5leHBvcnRzLng1MDkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4veDUwOS5qc1wiKSk7XG4vLyBXZSBjbGFzc2lmeSB0aGVzZSB0eXBlcyBhcyBwYXltZW50LCBzaW5jZSB3ZSBoYXZlIHZhcmlvdXMgT3V0cHV0IHR5cGVzXG4vLyBhbHJlYWR5IGluIHRoZSBuYW1lc3BhY2UgKFR4T3V0cHV0LCBUeEJ1aWxkZXJPdXRwdXQsIGV0Yylcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hY3Rpb24uanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL291dHB1dC5qc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5019\n\n}')},5040:g=>{"use strict";g.exports=JSON.parse('["abaisser","abandon","abdiquer","abeille","abolir","aborder","aboutir","aboyer","abrasif","abreuver","abriter","abroger","abrupt","absence","absolu","absurde","abusif","abyssal","académie","acajou","acarien","accabler","accepter","acclamer","accolade","accroche","accuser","acerbe","achat","acheter","aciduler","acier","acompte","acquérir","acronyme","acteur","actif","actuel","adepte","adéquat","adhésif","adjectif","adjuger","admettre","admirer","adopter","adorer","adoucir","adresse","adroit","adulte","adverbe","aérer","aéronef","affaire","affecter","affiche","affreux","affubler","agacer","agencer","agile","agiter","agrafer","agréable","agrume","aider","aiguille","ailier","aimable","aisance","ajouter","ajuster","alarmer","alchimie","alerte","algèbre","algue","aliéner","aliment","alléger","alliage","allouer","allumer","alourdir","alpaga","altesse","alvéole","amateur","ambigu","ambre","aménager","amertume","amidon","amiral","amorcer","amour","amovible","amphibie","ampleur","amusant","analyse","anaphore","anarchie","anatomie","ancien","anéantir","angle","angoisse","anguleux","animal","annexer","annonce","annuel","anodin","anomalie","anonyme","anormal","antenne","antidote","anxieux","apaiser","apéritif","aplanir","apologie","appareil","appeler","apporter","appuyer","aquarium","aqueduc","arbitre","arbuste","ardeur","ardoise","argent","arlequin","armature","armement","armoire","armure","arpenter","arracher","arriver","arroser","arsenic","artériel","article","aspect","asphalte","aspirer","assaut","asservir","assiette","associer","assurer","asticot","astre","astuce","atelier","atome","atrium","atroce","attaque","attentif","attirer","attraper","aubaine","auberge","audace","audible","augurer","aurore","automne","autruche","avaler","avancer","avarice","avenir","averse","aveugle","aviateur","avide","avion","aviser","avoine","avouer","avril","axial","axiome","badge","bafouer","bagage","baguette","baignade","balancer","balcon","baleine","balisage","bambin","bancaire","bandage","banlieue","bannière","banquier","barbier","baril","baron","barque","barrage","bassin","bastion","bataille","bateau","batterie","baudrier","bavarder","belette","bélier","belote","bénéfice","berceau","berger","berline","bermuda","besace","besogne","bétail","beurre","biberon","bicycle","bidule","bijou","bilan","bilingue","billard","binaire","biologie","biopsie","biotype","biscuit","bison","bistouri","bitume","bizarre","blafard","blague","blanchir","blessant","blinder","blond","bloquer","blouson","bobard","bobine","boire","boiser","bolide","bonbon","bondir","bonheur","bonifier","bonus","bordure","borne","botte","boucle","boueux","bougie","boulon","bouquin","bourse","boussole","boutique","boxeur","branche","brasier","brave","brebis","brèche","breuvage","bricoler","brigade","brillant","brioche","brique","brochure","broder","bronzer","brousse","broyeur","brume","brusque","brutal","bruyant","buffle","buisson","bulletin","bureau","burin","bustier","butiner","butoir","buvable","buvette","cabanon","cabine","cachette","cadeau","cadre","caféine","caillou","caisson","calculer","calepin","calibre","calmer","calomnie","calvaire","camarade","caméra","camion","campagne","canal","caneton","canon","cantine","canular","capable","caporal","caprice","capsule","capter","capuche","carabine","carbone","caresser","caribou","carnage","carotte","carreau","carton","cascade","casier","casque","cassure","causer","caution","cavalier","caverne","caviar","cédille","ceinture","céleste","cellule","cendrier","censurer","central","cercle","cérébral","cerise","cerner","cerveau","cesser","chagrin","chaise","chaleur","chambre","chance","chapitre","charbon","chasseur","chaton","chausson","chavirer","chemise","chenille","chéquier","chercher","cheval","chien","chiffre","chignon","chimère","chiot","chlorure","chocolat","choisir","chose","chouette","chrome","chute","cigare","cigogne","cimenter","cinéma","cintrer","circuler","cirer","cirque","citerne","citoyen","citron","civil","clairon","clameur","claquer","classe","clavier","client","cligner","climat","clivage","cloche","clonage","cloporte","cobalt","cobra","cocasse","cocotier","coder","codifier","coffre","cogner","cohésion","coiffer","coincer","colère","colibri","colline","colmater","colonel","combat","comédie","commande","compact","concert","conduire","confier","congeler","connoter","consonne","contact","convexe","copain","copie","corail","corbeau","cordage","corniche","corpus","correct","cortège","cosmique","costume","coton","coude","coupure","courage","couteau","couvrir","coyote","crabe","crainte","cravate","crayon","créature","créditer","crémeux","creuser","crevette","cribler","crier","cristal","critère","croire","croquer","crotale","crucial","cruel","crypter","cubique","cueillir","cuillère","cuisine","cuivre","culminer","cultiver","cumuler","cupide","curatif","curseur","cyanure","cycle","cylindre","cynique","daigner","damier","danger","danseur","dauphin","débattre","débiter","déborder","débrider","débutant","décaler","décembre","déchirer","décider","déclarer","décorer","décrire","décupler","dédale","déductif","déesse","défensif","défiler","défrayer","dégager","dégivrer","déglutir","dégrafer","déjeuner","délice","déloger","demander","demeurer","démolir","dénicher","dénouer","dentelle","dénuder","départ","dépenser","déphaser","déplacer","déposer","déranger","dérober","désastre","descente","désert","désigner","désobéir","dessiner","destrier","détacher","détester","détourer","détresse","devancer","devenir","deviner","devoir","diable","dialogue","diamant","dicter","différer","digérer","digital","digne","diluer","dimanche","diminuer","dioxyde","directif","diriger","discuter","disposer","dissiper","distance","divertir","diviser","docile","docteur","dogme","doigt","domaine","domicile","dompter","donateur","donjon","donner","dopamine","dortoir","dorure","dosage","doseur","dossier","dotation","douanier","double","douceur","douter","doyen","dragon","draper","dresser","dribbler","droiture","duperie","duplexe","durable","durcir","dynastie","éblouir","écarter","écharpe","échelle","éclairer","éclipse","éclore","écluse","école","économie","écorce","écouter","écraser","écrémer","écrivain","écrou","écume","écureuil","édifier","éduquer","effacer","effectif","effigie","effort","effrayer","effusion","égaliser","égarer","éjecter","élaborer","élargir","électron","élégant","éléphant","élève","éligible","élitisme","éloge","élucider","éluder","emballer","embellir","embryon","émeraude","émission","emmener","émotion","émouvoir","empereur","employer","emporter","emprise","émulsion","encadrer","enchère","enclave","encoche","endiguer","endosser","endroit","enduire","énergie","enfance","enfermer","enfouir","engager","engin","englober","énigme","enjamber","enjeu","enlever","ennemi","ennuyeux","enrichir","enrobage","enseigne","entasser","entendre","entier","entourer","entraver","énumérer","envahir","enviable","envoyer","enzyme","éolien","épaissir","épargne","épatant","épaule","épicerie","épidémie","épier","épilogue","épine","épisode","épitaphe","époque","épreuve","éprouver","épuisant","équerre","équipe","ériger","érosion","erreur","éruption","escalier","espadon","espèce","espiègle","espoir","esprit","esquiver","essayer","essence","essieu","essorer","estime","estomac","estrade","étagère","étaler","étanche","étatique","éteindre","étendoir","éternel","éthanol","éthique","ethnie","étirer","étoffer","étoile","étonnant","étourdir","étrange","étroit","étude","euphorie","évaluer","évasion","éventail","évidence","éviter","évolutif","évoquer","exact","exagérer","exaucer","exceller","excitant","exclusif","excuse","exécuter","exemple","exercer","exhaler","exhorter","exigence","exiler","exister","exotique","expédier","explorer","exposer","exprimer","exquis","extensif","extraire","exulter","fable","fabuleux","facette","facile","facture","faiblir","falaise","fameux","famille","farceur","farfelu","farine","farouche","fasciner","fatal","fatigue","faucon","fautif","faveur","favori","fébrile","féconder","fédérer","félin","femme","fémur","fendoir","féodal","fermer","féroce","ferveur","festival","feuille","feutre","février","fiasco","ficeler","fictif","fidèle","figure","filature","filetage","filière","filleul","filmer","filou","filtrer","financer","finir","fiole","firme","fissure","fixer","flairer","flamme","flasque","flatteur","fléau","flèche","fleur","flexion","flocon","flore","fluctuer","fluide","fluvial","folie","fonderie","fongible","fontaine","forcer","forgeron","formuler","fortune","fossile","foudre","fougère","fouiller","foulure","fourmi","fragile","fraise","franchir","frapper","frayeur","frégate","freiner","frelon","frémir","frénésie","frère","friable","friction","frisson","frivole","froid","fromage","frontal","frotter","fruit","fugitif","fuite","fureur","furieux","furtif","fusion","futur","gagner","galaxie","galerie","gambader","garantir","gardien","garnir","garrigue","gazelle","gazon","géant","gélatine","gélule","gendarme","général","génie","genou","gentil","géologie","géomètre","géranium","germe","gestuel","geyser","gibier","gicler","girafe","givre","glace","glaive","glisser","globe","gloire","glorieux","golfeur","gomme","gonfler","gorge","gorille","goudron","gouffre","goulot","goupille","gourmand","goutte","graduel","graffiti","graine","grand","grappin","gratuit","gravir","grenat","griffure","griller","grimper","grogner","gronder","grotte","groupe","gruger","grutier","gruyère","guépard","guerrier","guide","guimauve","guitare","gustatif","gymnaste","gyrostat","habitude","hachoir","halte","hameau","hangar","hanneton","haricot","harmonie","harpon","hasard","hélium","hématome","herbe","hérisson","hermine","héron","hésiter","heureux","hiberner","hibou","hilarant","histoire","hiver","homard","hommage","homogène","honneur","honorer","honteux","horde","horizon","horloge","hormone","horrible","houleux","housse","hublot","huileux","humain","humble","humide","humour","hurler","hydromel","hygiène","hymne","hypnose","idylle","ignorer","iguane","illicite","illusion","image","imbiber","imiter","immense","immobile","immuable","impact","impérial","implorer","imposer","imprimer","imputer","incarner","incendie","incident","incliner","incolore","indexer","indice","inductif","inédit","ineptie","inexact","infini","infliger","informer","infusion","ingérer","inhaler","inhiber","injecter","injure","innocent","inoculer","inonder","inscrire","insecte","insigne","insolite","inspirer","instinct","insulter","intact","intense","intime","intrigue","intuitif","inutile","invasion","inventer","inviter","invoquer","ironique","irradier","irréel","irriter","isoler","ivoire","ivresse","jaguar","jaillir","jambe","janvier","jardin","jauger","jaune","javelot","jetable","jeton","jeudi","jeunesse","joindre","joncher","jongler","joueur","jouissif","journal","jovial","joyau","joyeux","jubiler","jugement","junior","jupon","juriste","justice","juteux","juvénile","kayak","kimono","kiosque","label","labial","labourer","lacérer","lactose","lagune","laine","laisser","laitier","lambeau","lamelle","lampe","lanceur","langage","lanterne","lapin","largeur","larme","laurier","lavabo","lavoir","lecture","légal","léger","légume","lessive","lettre","levier","lexique","lézard","liasse","libérer","libre","licence","licorne","liège","lièvre","ligature","ligoter","ligue","limer","limite","limonade","limpide","linéaire","lingot","lionceau","liquide","lisière","lister","lithium","litige","littoral","livreur","logique","lointain","loisir","lombric","loterie","louer","lourd","loutre","louve","loyal","lubie","lucide","lucratif","lueur","lugubre","luisant","lumière","lunaire","lundi","luron","lutter","luxueux","machine","magasin","magenta","magique","maigre","maillon","maintien","mairie","maison","majorer","malaxer","maléfice","malheur","malice","mallette","mammouth","mandater","maniable","manquant","manteau","manuel","marathon","marbre","marchand","mardi","maritime","marqueur","marron","marteler","mascotte","massif","matériel","matière","matraque","maudire","maussade","mauve","maximal","méchant","méconnu","médaille","médecin","méditer","méduse","meilleur","mélange","mélodie","membre","mémoire","menacer","mener","menhir","mensonge","mentor","mercredi","mérite","merle","messager","mesure","métal","météore","méthode","métier","meuble","miauler","microbe","miette","mignon","migrer","milieu","million","mimique","mince","minéral","minimal","minorer","minute","miracle","miroiter","missile","mixte","mobile","moderne","moelleux","mondial","moniteur","monnaie","monotone","monstre","montagne","monument","moqueur","morceau","morsure","mortier","moteur","motif","mouche","moufle","moulin","mousson","mouton","mouvant","multiple","munition","muraille","murène","murmure","muscle","muséum","musicien","mutation","muter","mutuel","myriade","myrtille","mystère","mythique","nageur","nappe","narquois","narrer","natation","nation","nature","naufrage","nautique","navire","nébuleux","nectar","néfaste","négation","négliger","négocier","neige","nerveux","nettoyer","neurone","neutron","neveu","niche","nickel","nitrate","niveau","noble","nocif","nocturne","noirceur","noisette","nomade","nombreux","nommer","normatif","notable","notifier","notoire","nourrir","nouveau","novateur","novembre","novice","nuage","nuancer","nuire","nuisible","numéro","nuptial","nuque","nutritif","obéir","objectif","obliger","obscur","observer","obstacle","obtenir","obturer","occasion","occuper","océan","octobre","octroyer","octupler","oculaire","odeur","odorant","offenser","officier","offrir","ogive","oiseau","oisillon","olfactif","olivier","ombrage","omettre","onctueux","onduler","onéreux","onirique","opale","opaque","opérer","opinion","opportun","opprimer","opter","optique","orageux","orange","orbite","ordonner","oreille","organe","orgueil","orifice","ornement","orque","ortie","osciller","osmose","ossature","otarie","ouragan","ourson","outil","outrager","ouvrage","ovation","oxyde","oxygène","ozone","paisible","palace","palmarès","palourde","palper","panache","panda","pangolin","paniquer","panneau","panorama","pantalon","papaye","papier","papoter","papyrus","paradoxe","parcelle","paresse","parfumer","parler","parole","parrain","parsemer","partager","parure","parvenir","passion","pastèque","paternel","patience","patron","pavillon","pavoiser","payer","paysage","peigne","peintre","pelage","pélican","pelle","pelouse","peluche","pendule","pénétrer","pénible","pensif","pénurie","pépite","péplum","perdrix","perforer","période","permuter","perplexe","persil","perte","peser","pétale","petit","pétrir","peuple","pharaon","phobie","phoque","photon","phrase","physique","piano","pictural","pièce","pierre","pieuvre","pilote","pinceau","pipette","piquer","pirogue","piscine","piston","pivoter","pixel","pizza","placard","plafond","plaisir","planer","plaque","plastron","plateau","pleurer","plexus","pliage","plomb","plonger","pluie","plumage","pochette","poésie","poète","pointe","poirier","poisson","poivre","polaire","policier","pollen","polygone","pommade","pompier","ponctuel","pondérer","poney","portique","position","posséder","posture","potager","poteau","potion","pouce","poulain","poumon","pourpre","poussin","pouvoir","prairie","pratique","précieux","prédire","préfixe","prélude","prénom","présence","prétexte","prévoir","primitif","prince","prison","priver","problème","procéder","prodige","profond","progrès","proie","projeter","prologue","promener","propre","prospère","protéger","prouesse","proverbe","prudence","pruneau","psychose","public","puceron","puiser","pulpe","pulsar","punaise","punitif","pupitre","purifier","puzzle","pyramide","quasar","querelle","question","quiétude","quitter","quotient","racine","raconter","radieux","ragondin","raideur","raisin","ralentir","rallonge","ramasser","rapide","rasage","ratisser","ravager","ravin","rayonner","réactif","réagir","réaliser","réanimer","recevoir","réciter","réclamer","récolter","recruter","reculer","recycler","rédiger","redouter","refaire","réflexe","réformer","refrain","refuge","régalien","région","réglage","régulier","réitérer","rejeter","rejouer","relatif","relever","relief","remarque","remède","remise","remonter","remplir","remuer","renard","renfort","renifler","renoncer","rentrer","renvoi","replier","reporter","reprise","reptile","requin","réserve","résineux","résoudre","respect","rester","résultat","rétablir","retenir","réticule","retomber","retracer","réunion","réussir","revanche","revivre","révolte","révulsif","richesse","rideau","rieur","rigide","rigoler","rincer","riposter","risible","risque","rituel","rival","rivière","rocheux","romance","rompre","ronce","rondin","roseau","rosier","rotatif","rotor","rotule","rouge","rouille","rouleau","routine","royaume","ruban","rubis","ruche","ruelle","rugueux","ruiner","ruisseau","ruser","rustique","rythme","sabler","saboter","sabre","sacoche","safari","sagesse","saisir","salade","salive","salon","saluer","samedi","sanction","sanglier","sarcasme","sardine","saturer","saugrenu","saumon","sauter","sauvage","savant","savonner","scalpel","scandale","scélérat","scénario","sceptre","schéma","science","scinder","score","scrutin","sculpter","séance","sécable","sécher","secouer","sécréter","sédatif","séduire","seigneur","séjour","sélectif","semaine","sembler","semence","séminal","sénateur","sensible","sentence","séparer","séquence","serein","sergent","sérieux","serrure","sérum","service","sésame","sévir","sevrage","sextuple","sidéral","siècle","siéger","siffler","sigle","signal","silence","silicium","simple","sincère","sinistre","siphon","sirop","sismique","situer","skier","social","socle","sodium","soigneux","soldat","soleil","solitude","soluble","sombre","sommeil","somnoler","sonde","songeur","sonnette","sonore","sorcier","sortir","sosie","sottise","soucieux","soudure","souffle","soulever","soupape","source","soutirer","souvenir","spacieux","spatial","spécial","sphère","spiral","stable","station","sternum","stimulus","stipuler","strict","studieux","stupeur","styliste","sublime","substrat","subtil","subvenir","succès","sucre","suffixe","suggérer","suiveur","sulfate","superbe","supplier","surface","suricate","surmener","surprise","sursaut","survie","suspect","syllabe","symbole","symétrie","synapse","syntaxe","système","tabac","tablier","tactile","tailler","talent","talisman","talonner","tambour","tamiser","tangible","tapis","taquiner","tarder","tarif","tartine","tasse","tatami","tatouage","taupe","taureau","taxer","témoin","temporel","tenaille","tendre","teneur","tenir","tension","terminer","terne","terrible","tétine","texte","thème","théorie","thérapie","thorax","tibia","tiède","timide","tirelire","tiroir","tissu","titane","titre","tituber","toboggan","tolérant","tomate","tonique","tonneau","toponyme","torche","tordre","tornade","torpille","torrent","torse","tortue","totem","toucher","tournage","tousser","toxine","traction","trafic","tragique","trahir","train","trancher","travail","trèfle","tremper","trésor","treuil","triage","tribunal","tricoter","trilogie","triomphe","tripler","triturer","trivial","trombone","tronc","tropical","troupeau","tuile","tulipe","tumulte","tunnel","turbine","tuteur","tutoyer","tuyau","tympan","typhon","typique","tyran","ubuesque","ultime","ultrason","unanime","unifier","union","unique","unitaire","univers","uranium","urbain","urticant","usage","usine","usuel","usure","utile","utopie","vacarme","vaccin","vagabond","vague","vaillant","vaincre","vaisseau","valable","valise","vallon","valve","vampire","vanille","vapeur","varier","vaseux","vassal","vaste","vecteur","vedette","végétal","véhicule","veinard","véloce","vendredi","vénérer","venger","venimeux","ventouse","verdure","vérin","vernir","verrou","verser","vertu","veston","vétéran","vétuste","vexant","vexer","viaduc","viande","victoire","vidange","vidéo","vignette","vigueur","vilain","village","vinaigre","violon","vipère","virement","virtuose","virus","visage","viseur","vision","visqueux","visuel","vital","vitesse","viticole","vitrine","vivace","vivipare","vocation","voguer","voile","voisin","voiture","volaille","volcan","voltiger","volume","vorace","vortex","voter","vouloir","voyage","voyelle","wagon","xénon","yacht","zèbre","zénith","zeste","zoologie"]')},5047:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code\n *         throw Error("no such method");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn\'t been an error\n * @returns {undefined}\n */\n\nrpc.Service = __webpack_require__(7595);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA0Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLHNCQUFzQjtBQUN2RDtBQUNBLFVBQVU7QUFDVixXQUFXLG1DQUFtQyxZQUFZLElBQUk7QUFDOUQsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pEO0FBQ0EsVUFBVTtBQUNWLFdBQVcsWUFBWTtBQUN2QixXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLElBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcz8wMWIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5047\n\n}')},5056:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute("nonce", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsY0FBYyxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanM/ZGRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5056\n\n}')},5072:module=>{"use strict";eval('{\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = "".concat(id, " ").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA3Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5072\n\n}')},5145:(__unused_webpack_module,exports)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE0NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0by5qcz9kMTZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSB2b2lkIDA7XG5leHBvcnRzLmNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5145\n\n}")},5376:g=>{"use strict";g.exports=JSON.parse('["ábaco","abdomen","abeja","abierto","abogado","abono","aborto","abrazo","abrir","abuelo","abuso","acabar","academia","acceso","acción","aceite","acelga","acento","aceptar","ácido","aclarar","acné","acoger","acoso","activo","acto","actriz","actuar","acudir","acuerdo","acusar","adicto","admitir","adoptar","adorno","aduana","adulto","aéreo","afectar","afición","afinar","afirmar","ágil","agitar","agonía","agosto","agotar","agregar","agrio","agua","agudo","águila","aguja","ahogo","ahorro","aire","aislar","ajedrez","ajeno","ajuste","alacrán","alambre","alarma","alba","álbum","alcalde","aldea","alegre","alejar","alerta","aleta","alfiler","alga","algodón","aliado","aliento","alivio","alma","almeja","almíbar","altar","alteza","altivo","alto","altura","alumno","alzar","amable","amante","amapola","amargo","amasar","ámbar","ámbito","ameno","amigo","amistad","amor","amparo","amplio","ancho","anciano","ancla","andar","andén","anemia","ángulo","anillo","ánimo","anís","anotar","antena","antiguo","antojo","anual","anular","anuncio","añadir","añejo","año","apagar","aparato","apetito","apio","aplicar","apodo","aporte","apoyo","aprender","aprobar","apuesta","apuro","arado","araña","arar","árbitro","árbol","arbusto","archivo","arco","arder","ardilla","arduo","área","árido","aries","armonía","arnés","aroma","arpa","arpón","arreglo","arroz","arruga","arte","artista","asa","asado","asalto","ascenso","asegurar","aseo","asesor","asiento","asilo","asistir","asno","asombro","áspero","astilla","astro","astuto","asumir","asunto","atajo","ataque","atar","atento","ateo","ático","atleta","átomo","atraer","atroz","atún","audaz","audio","auge","aula","aumento","ausente","autor","aval","avance","avaro","ave","avellana","avena","avestruz","avión","aviso","ayer","ayuda","ayuno","azafrán","azar","azote","azúcar","azufre","azul","baba","babor","bache","bahía","baile","bajar","balanza","balcón","balde","bambú","banco","banda","baño","barba","barco","barniz","barro","báscula","bastón","basura","batalla","batería","batir","batuta","baúl","bazar","bebé","bebida","bello","besar","beso","bestia","bicho","bien","bingo","blanco","bloque","blusa","boa","bobina","bobo","boca","bocina","boda","bodega","boina","bola","bolero","bolsa","bomba","bondad","bonito","bono","bonsái","borde","borrar","bosque","bote","botín","bóveda","bozal","bravo","brazo","brecha","breve","brillo","brinco","brisa","broca","broma","bronce","brote","bruja","brusco","bruto","buceo","bucle","bueno","buey","bufanda","bufón","búho","buitre","bulto","burbuja","burla","burro","buscar","butaca","buzón","caballo","cabeza","cabina","cabra","cacao","cadáver","cadena","caer","café","caída","caimán","caja","cajón","cal","calamar","calcio","caldo","calidad","calle","calma","calor","calvo","cama","cambio","camello","camino","campo","cáncer","candil","canela","canguro","canica","canto","caña","cañón","caoba","caos","capaz","capitán","capote","captar","capucha","cara","carbón","cárcel","careta","carga","cariño","carne","carpeta","carro","carta","casa","casco","casero","caspa","castor","catorce","catre","caudal","causa","cazo","cebolla","ceder","cedro","celda","célebre","celoso","célula","cemento","ceniza","centro","cerca","cerdo","cereza","cero","cerrar","certeza","césped","cetro","chacal","chaleco","champú","chancla","chapa","charla","chico","chiste","chivo","choque","choza","chuleta","chupar","ciclón","ciego","cielo","cien","cierto","cifra","cigarro","cima","cinco","cine","cinta","ciprés","circo","ciruela","cisne","cita","ciudad","clamor","clan","claro","clase","clave","cliente","clima","clínica","cobre","cocción","cochino","cocina","coco","código","codo","cofre","coger","cohete","cojín","cojo","cola","colcha","colegio","colgar","colina","collar","colmo","columna","combate","comer","comida","cómodo","compra","conde","conejo","conga","conocer","consejo","contar","copa","copia","corazón","corbata","corcho","cordón","corona","correr","coser","cosmos","costa","cráneo","cráter","crear","crecer","creído","crema","cría","crimen","cripta","crisis","cromo","crónica","croqueta","crudo","cruz","cuadro","cuarto","cuatro","cubo","cubrir","cuchara","cuello","cuento","cuerda","cuesta","cueva","cuidar","culebra","culpa","culto","cumbre","cumplir","cuna","cuneta","cuota","cupón","cúpula","curar","curioso","curso","curva","cutis","dama","danza","dar","dardo","dátil","deber","débil","década","decir","dedo","defensa","definir","dejar","delfín","delgado","delito","demora","denso","dental","deporte","derecho","derrota","desayuno","deseo","desfile","desnudo","destino","desvío","detalle","detener","deuda","día","diablo","diadema","diamante","diana","diario","dibujo","dictar","diente","dieta","diez","difícil","digno","dilema","diluir","dinero","directo","dirigir","disco","diseño","disfraz","diva","divino","doble","doce","dolor","domingo","don","donar","dorado","dormir","dorso","dos","dosis","dragón","droga","ducha","duda","duelo","dueño","dulce","dúo","duque","durar","dureza","duro","ébano","ebrio","echar","eco","ecuador","edad","edición","edificio","editor","educar","efecto","eficaz","eje","ejemplo","elefante","elegir","elemento","elevar","elipse","élite","elixir","elogio","eludir","embudo","emitir","emoción","empate","empeño","empleo","empresa","enano","encargo","enchufe","encía","enemigo","enero","enfado","enfermo","engaño","enigma","enlace","enorme","enredo","ensayo","enseñar","entero","entrar","envase","envío","época","equipo","erizo","escala","escena","escolar","escribir","escudo","esencia","esfera","esfuerzo","espada","espejo","espía","esposa","espuma","esquí","estar","este","estilo","estufa","etapa","eterno","ética","etnia","evadir","evaluar","evento","evitar","exacto","examen","exceso","excusa","exento","exigir","exilio","existir","éxito","experto","explicar","exponer","extremo","fábrica","fábula","fachada","fácil","factor","faena","faja","falda","fallo","falso","faltar","fama","familia","famoso","faraón","farmacia","farol","farsa","fase","fatiga","fauna","favor","fax","febrero","fecha","feliz","feo","feria","feroz","fértil","fervor","festín","fiable","fianza","fiar","fibra","ficción","ficha","fideo","fiebre","fiel","fiera","fiesta","figura","fijar","fijo","fila","filete","filial","filtro","fin","finca","fingir","finito","firma","flaco","flauta","flecha","flor","flota","fluir","flujo","flúor","fobia","foca","fogata","fogón","folio","folleto","fondo","forma","forro","fortuna","forzar","fosa","foto","fracaso","frágil","franja","frase","fraude","freír","freno","fresa","frío","frito","fruta","fuego","fuente","fuerza","fuga","fumar","función","funda","furgón","furia","fusil","fútbol","futuro","gacela","gafas","gaita","gajo","gala","galería","gallo","gamba","ganar","gancho","ganga","ganso","garaje","garza","gasolina","gastar","gato","gavilán","gemelo","gemir","gen","género","genio","gente","geranio","gerente","germen","gesto","gigante","gimnasio","girar","giro","glaciar","globo","gloria","gol","golfo","goloso","golpe","goma","gordo","gorila","gorra","gota","goteo","gozar","grada","gráfico","grano","grasa","gratis","grave","grieta","grillo","gripe","gris","grito","grosor","grúa","grueso","grumo","grupo","guante","guapo","guardia","guerra","guía","guiño","guion","guiso","guitarra","gusano","gustar","haber","hábil","hablar","hacer","hacha","hada","hallar","hamaca","harina","haz","hazaña","hebilla","hebra","hecho","helado","helio","hembra","herir","hermano","héroe","hervir","hielo","hierro","hígado","higiene","hijo","himno","historia","hocico","hogar","hoguera","hoja","hombre","hongo","honor","honra","hora","hormiga","horno","hostil","hoyo","hueco","huelga","huerta","hueso","huevo","huida","huir","humano","húmedo","humilde","humo","hundir","huracán","hurto","icono","ideal","idioma","ídolo","iglesia","iglú","igual","ilegal","ilusión","imagen","imán","imitar","impar","imperio","imponer","impulso","incapaz","índice","inerte","infiel","informe","ingenio","inicio","inmenso","inmune","innato","insecto","instante","interés","íntimo","intuir","inútil","invierno","ira","iris","ironía","isla","islote","jabalí","jabón","jamón","jarabe","jardín","jarra","jaula","jazmín","jefe","jeringa","jinete","jornada","joroba","joven","joya","juerga","jueves","juez","jugador","jugo","juguete","juicio","junco","jungla","junio","juntar","júpiter","jurar","justo","juvenil","juzgar","kilo","koala","labio","lacio","lacra","lado","ladrón","lagarto","lágrima","laguna","laico","lamer","lámina","lámpara","lana","lancha","langosta","lanza","lápiz","largo","larva","lástima","lata","látex","latir","laurel","lavar","lazo","leal","lección","leche","lector","leer","legión","legumbre","lejano","lengua","lento","leña","león","leopardo","lesión","letal","letra","leve","leyenda","libertad","libro","licor","líder","lidiar","lienzo","liga","ligero","lima","límite","limón","limpio","lince","lindo","línea","lingote","lino","linterna","líquido","liso","lista","litera","litio","litro","llaga","llama","llanto","llave","llegar","llenar","llevar","llorar","llover","lluvia","lobo","loción","loco","locura","lógica","logro","lombriz","lomo","lonja","lote","lucha","lucir","lugar","lujo","luna","lunes","lupa","lustro","luto","luz","maceta","macho","madera","madre","maduro","maestro","mafia","magia","mago","maíz","maldad","maleta","malla","malo","mamá","mambo","mamut","manco","mando","manejar","manga","maniquí","manjar","mano","manso","manta","mañana","mapa","máquina","mar","marco","marea","marfil","margen","marido","mármol","marrón","martes","marzo","masa","máscara","masivo","matar","materia","matiz","matriz","máximo","mayor","mazorca","mecha","medalla","medio","médula","mejilla","mejor","melena","melón","memoria","menor","mensaje","mente","menú","mercado","merengue","mérito","mes","mesón","meta","meter","método","metro","mezcla","miedo","miel","miembro","miga","mil","milagro","militar","millón","mimo","mina","minero","mínimo","minuto","miope","mirar","misa","miseria","misil","mismo","mitad","mito","mochila","moción","moda","modelo","moho","mojar","molde","moler","molino","momento","momia","monarca","moneda","monja","monto","moño","morada","morder","moreno","morir","morro","morsa","mortal","mosca","mostrar","motivo","mover","móvil","mozo","mucho","mudar","mueble","muela","muerte","muestra","mugre","mujer","mula","muleta","multa","mundo","muñeca","mural","muro","músculo","museo","musgo","música","muslo","nácar","nación","nadar","naipe","naranja","nariz","narrar","nasal","natal","nativo","natural","náusea","naval","nave","navidad","necio","néctar","negar","negocio","negro","neón","nervio","neto","neutro","nevar","nevera","nicho","nido","niebla","nieto","niñez","niño","nítido","nivel","nobleza","noche","nómina","noria","norma","norte","nota","noticia","novato","novela","novio","nube","nuca","núcleo","nudillo","nudo","nuera","nueve","nuez","nulo","número","nutria","oasis","obeso","obispo","objeto","obra","obrero","observar","obtener","obvio","oca","ocaso","océano","ochenta","ocho","ocio","ocre","octavo","octubre","oculto","ocupar","ocurrir","odiar","odio","odisea","oeste","ofensa","oferta","oficio","ofrecer","ogro","oído","oír","ojo","ola","oleada","olfato","olivo","olla","olmo","olor","olvido","ombligo","onda","onza","opaco","opción","ópera","opinar","oponer","optar","óptica","opuesto","oración","orador","oral","órbita","orca","orden","oreja","órgano","orgía","orgullo","oriente","origen","orilla","oro","orquesta","oruga","osadía","oscuro","osezno","oso","ostra","otoño","otro","oveja","óvulo","óxido","oxígeno","oyente","ozono","pacto","padre","paella","página","pago","país","pájaro","palabra","palco","paleta","pálido","palma","paloma","palpar","pan","panal","pánico","pantera","pañuelo","papá","papel","papilla","paquete","parar","parcela","pared","parir","paro","párpado","parque","párrafo","parte","pasar","paseo","pasión","paso","pasta","pata","patio","patria","pausa","pauta","pavo","payaso","peatón","pecado","pecera","pecho","pedal","pedir","pegar","peine","pelar","peldaño","pelea","peligro","pellejo","pelo","peluca","pena","pensar","peñón","peón","peor","pepino","pequeño","pera","percha","perder","pereza","perfil","perico","perla","permiso","perro","persona","pesa","pesca","pésimo","pestaña","pétalo","petróleo","pez","pezuña","picar","pichón","pie","piedra","pierna","pieza","pijama","pilar","piloto","pimienta","pino","pintor","pinza","piña","piojo","pipa","pirata","pisar","piscina","piso","pista","pitón","pizca","placa","plan","plata","playa","plaza","pleito","pleno","plomo","pluma","plural","pobre","poco","poder","podio","poema","poesía","poeta","polen","policía","pollo","polvo","pomada","pomelo","pomo","pompa","poner","porción","portal","posada","poseer","posible","poste","potencia","potro","pozo","prado","precoz","pregunta","premio","prensa","preso","previo","primo","príncipe","prisión","privar","proa","probar","proceso","producto","proeza","profesor","programa","prole","promesa","pronto","propio","próximo","prueba","público","puchero","pudor","pueblo","puerta","puesto","pulga","pulir","pulmón","pulpo","pulso","puma","punto","puñal","puño","pupa","pupila","puré","quedar","queja","quemar","querer","queso","quieto","química","quince","quitar","rábano","rabia","rabo","ración","radical","raíz","rama","rampa","rancho","rango","rapaz","rápido","rapto","rasgo","raspa","rato","rayo","raza","razón","reacción","realidad","rebaño","rebote","recaer","receta","rechazo","recoger","recreo","recto","recurso","red","redondo","reducir","reflejo","reforma","refrán","refugio","regalo","regir","regla","regreso","rehén","reino","reír","reja","relato","relevo","relieve","relleno","reloj","remar","remedio","remo","rencor","rendir","renta","reparto","repetir","reposo","reptil","res","rescate","resina","respeto","resto","resumen","retiro","retorno","retrato","reunir","revés","revista","rey","rezar","rico","riego","rienda","riesgo","rifa","rígido","rigor","rincón","riñón","río","riqueza","risa","ritmo","rito","rizo","roble","roce","rociar","rodar","rodeo","rodilla","roer","rojizo","rojo","romero","romper","ron","ronco","ronda","ropa","ropero","rosa","rosca","rostro","rotar","rubí","rubor","rudo","rueda","rugir","ruido","ruina","ruleta","rulo","rumbo","rumor","ruptura","ruta","rutina","sábado","saber","sabio","sable","sacar","sagaz","sagrado","sala","saldo","salero","salir","salmón","salón","salsa","salto","salud","salvar","samba","sanción","sandía","sanear","sangre","sanidad","sano","santo","sapo","saque","sardina","sartén","sastre","satán","sauna","saxofón","sección","seco","secreto","secta","sed","seguir","seis","sello","selva","semana","semilla","senda","sensor","señal","señor","separar","sepia","sequía","ser","serie","sermón","servir","sesenta","sesión","seta","setenta","severo","sexo","sexto","sidra","siesta","siete","siglo","signo","sílaba","silbar","silencio","silla","símbolo","simio","sirena","sistema","sitio","situar","sobre","socio","sodio","sol","solapa","soldado","soledad","sólido","soltar","solución","sombra","sondeo","sonido","sonoro","sonrisa","sopa","soplar","soporte","sordo","sorpresa","sorteo","sostén","sótano","suave","subir","suceso","sudor","suegra","suelo","sueño","suerte","sufrir","sujeto","sultán","sumar","superar","suplir","suponer","supremo","sur","surco","sureño","surgir","susto","sutil","tabaco","tabique","tabla","tabú","taco","tacto","tajo","talar","talco","talento","talla","talón","tamaño","tambor","tango","tanque","tapa","tapete","tapia","tapón","taquilla","tarde","tarea","tarifa","tarjeta","tarot","tarro","tarta","tatuaje","tauro","taza","tazón","teatro","techo","tecla","técnica","tejado","tejer","tejido","tela","teléfono","tema","temor","templo","tenaz","tender","tener","tenis","tenso","teoría","terapia","terco","término","ternura","terror","tesis","tesoro","testigo","tetera","texto","tez","tibio","tiburón","tiempo","tienda","tierra","tieso","tigre","tijera","tilde","timbre","tímido","timo","tinta","tío","típico","tipo","tira","tirón","titán","títere","título","tiza","toalla","tobillo","tocar","tocino","todo","toga","toldo","tomar","tono","tonto","topar","tope","toque","tórax","torero","tormenta","torneo","toro","torpedo","torre","torso","tortuga","tos","tosco","toser","tóxico","trabajo","tractor","traer","tráfico","trago","traje","tramo","trance","trato","trauma","trazar","trébol","tregua","treinta","tren","trepar","tres","tribu","trigo","tripa","triste","triunfo","trofeo","trompa","tronco","tropa","trote","trozo","truco","trueno","trufa","tubería","tubo","tuerto","tumba","tumor","túnel","túnica","turbina","turismo","turno","tutor","ubicar","úlcera","umbral","unidad","unir","universo","uno","untar","uña","urbano","urbe","urgente","urna","usar","usuario","útil","utopía","uva","vaca","vacío","vacuna","vagar","vago","vaina","vajilla","vale","válido","valle","valor","válvula","vampiro","vara","variar","varón","vaso","vecino","vector","vehículo","veinte","vejez","vela","velero","veloz","vena","vencer","venda","veneno","vengar","venir","venta","venus","ver","verano","verbo","verde","vereda","verja","verso","verter","vía","viaje","vibrar","vicio","víctima","vida","vídeo","vidrio","viejo","viernes","vigor","vil","villa","vinagre","vino","viñedo","violín","viral","virgo","virtud","visor","víspera","vista","vitamina","viudo","vivaz","vivero","vivir","vivo","volcán","volumen","volver","voraz","votar","voto","voz","vuelo","vulgar","yacer","yate","yegua","yema","yerno","yeso","yodo","yoga","yogur","zafiro","zanja","zapato","zarza","zona","zorro","zumo","zurdo"]')},5428:g=>{"use strict";g.exports=JSON.parse('["가격","가끔","가난","가능","가득","가르침","가뭄","가방","가상","가슴","가운데","가을","가이드","가입","가장","가정","가족","가죽","각오","각자","간격","간부","간섭","간장","간접","간판","갈등","갈비","갈색","갈증","감각","감기","감소","감수성","감자","감정","갑자기","강남","강당","강도","강력히","강변","강북","강사","강수량","강아지","강원도","강의","강제","강조","같이","개구리","개나리","개방","개별","개선","개성","개인","객관적","거실","거액","거울","거짓","거품","걱정","건강","건물","건설","건조","건축","걸음","검사","검토","게시판","게임","겨울","견해","결과","결국","결론","결석","결승","결심","결정","결혼","경계","경고","경기","경력","경복궁","경비","경상도","경영","경우","경쟁","경제","경주","경찰","경치","경향","경험","계곡","계단","계란","계산","계속","계약","계절","계층","계획","고객","고구려","고궁","고급","고등학생","고무신","고민","고양이","고장","고전","고집","고춧가루","고통","고향","곡식","골목","골짜기","골프","공간","공개","공격","공군","공급","공기","공동","공무원","공부","공사","공식","공업","공연","공원","공장","공짜","공책","공통","공포","공항","공휴일","과목","과일","과장","과정","과학","관객","관계","관광","관념","관람","관련","관리","관습","관심","관점","관찰","광경","광고","광장","광주","괴로움","굉장히","교과서","교문","교복","교실","교양","교육","교장","교직","교통","교환","교훈","구경","구름","구멍","구별","구분","구석","구성","구속","구역","구입","구청","구체적","국가","국기","국내","국립","국물","국민","국수","국어","국왕","국적","국제","국회","군대","군사","군인","궁극적","권리","권위","권투","귀국","귀신","규정","규칙","균형","그날","그냥","그늘","그러나","그룹","그릇","그림","그제서야","그토록","극복","극히","근거","근교","근래","근로","근무","근본","근원","근육","근처","글씨","글자","금강산","금고","금년","금메달","금액","금연","금요일","금지","긍정적","기간","기관","기념","기능","기독교","기둥","기록","기름","기법","기본","기분","기쁨","기숙사","기술","기억","기업","기온","기운","기원","기적","기준","기침","기혼","기획","긴급","긴장","길이","김밥","김치","김포공항","깍두기","깜빡","깨달음","깨소금","껍질","꼭대기","꽃잎","나들이","나란히","나머지","나물","나침반","나흘","낙엽","난방","날개","날씨","날짜","남녀","남대문","남매","남산","남자","남편","남학생","낭비","낱말","내년","내용","내일","냄비","냄새","냇물","냉동","냉면","냉방","냉장고","넥타이","넷째","노동","노란색","노력","노인","녹음","녹차","녹화","논리","논문","논쟁","놀이","농구","농담","농민","농부","농업","농장","농촌","높이","눈동자","눈물","눈썹","뉴욕","느낌","늑대","능동적","능력","다방","다양성","다음","다이어트","다행","단계","단골","단독","단맛","단순","단어","단위","단점","단체","단추","단편","단풍","달걀","달러","달력","달리","닭고기","담당","담배","담요","담임","답변","답장","당근","당분간","당연히","당장","대규모","대낮","대단히","대답","대도시","대략","대량","대륙","대문","대부분","대신","대응","대장","대전","대접","대중","대책","대출","대충","대통령","대학","대한민국","대합실","대형","덩어리","데이트","도대체","도덕","도둑","도망","도서관","도심","도움","도입","도자기","도저히","도전","도중","도착","독감","독립","독서","독일","독창적","동화책","뒷모습","뒷산","딸아이","마누라","마늘","마당","마라톤","마련","마무리","마사지","마약","마요네즈","마을","마음","마이크","마중","마지막","마찬가지","마찰","마흔","막걸리","막내","막상","만남","만두","만세","만약","만일","만점","만족","만화","많이","말기","말씀","말투","맘대로","망원경","매년","매달","매력","매번","매스컴","매일","매장","맥주","먹이","먼저","먼지","멀리","메일","며느리","며칠","면담","멸치","명단","명령","명예","명의","명절","명칭","명함","모금","모니터","모델","모든","모범","모습","모양","모임","모조리","모집","모퉁이","목걸이","목록","목사","목소리","목숨","목적","목표","몰래","몸매","몸무게","몸살","몸속","몸짓","몸통","몹시","무관심","무궁화","무더위","무덤","무릎","무슨","무엇","무역","무용","무조건","무지개","무척","문구","문득","문법","문서","문제","문학","문화","물가","물건","물결","물고기","물론","물리학","물음","물질","물체","미국","미디어","미사일","미술","미역","미용실","미움","미인","미팅","미혼","민간","민족","민주","믿음","밀가루","밀리미터","밑바닥","바가지","바구니","바나나","바늘","바닥","바닷가","바람","바이러스","바탕","박물관","박사","박수","반대","반드시","반말","반발","반성","반응","반장","반죽","반지","반찬","받침","발가락","발걸음","발견","발달","발레","발목","발바닥","발생","발음","발자국","발전","발톱","발표","밤하늘","밥그릇","밥맛","밥상","밥솥","방금","방면","방문","방바닥","방법","방송","방식","방안","방울","방지","방학","방해","방향","배경","배꼽","배달","배드민턴","백두산","백색","백성","백인","백제","백화점","버릇","버섯","버튼","번개","번역","번지","번호","벌금","벌레","벌써","범위","범인","범죄","법률","법원","법적","법칙","베이징","벨트","변경","변동","변명","변신","변호사","변화","별도","별명","별일","병실","병아리","병원","보관","보너스","보라색","보람","보름","보상","보안","보자기","보장","보전","보존","보통","보편적","보험","복도","복사","복숭아","복습","볶음","본격적","본래","본부","본사","본성","본인","본질","볼펜","봉사","봉지","봉투","부근","부끄러움","부담","부동산","부문","부분","부산","부상","부엌","부인","부작용","부장","부정","부족","부지런히","부친","부탁","부품","부회장","북부","북한","분노","분량","분리","분명","분석","분야","분위기","분필","분홍색","불고기","불과","불교","불꽃","불만","불법","불빛","불안","불이익","불행","브랜드","비극","비난","비닐","비둘기","비디오","비로소","비만","비명","비밀","비바람","비빔밥","비상","비용","비율","비중","비타민","비판","빌딩","빗물","빗방울","빗줄기","빛깔","빨간색","빨래","빨리","사건","사계절","사나이","사냥","사람","사랑","사립","사모님","사물","사방","사상","사생활","사설","사슴","사실","사업","사용","사월","사장","사전","사진","사촌","사춘기","사탕","사투리","사흘","산길","산부인과","산업","산책","살림","살인","살짝","삼계탕","삼국","삼십","삼월","삼촌","상관","상금","상대","상류","상반기","상상","상식","상업","상인","상자","상점","상처","상추","상태","상표","상품","상황","새벽","색깔","색연필","생각","생명","생물","생방송","생산","생선","생신","생일","생활","서랍","서른","서명","서민","서비스","서양","서울","서적","서점","서쪽","서클","석사","석유","선거","선물","선배","선생","선수","선원","선장","선전","선택","선풍기","설거지","설날","설렁탕","설명","설문","설사","설악산","설치","설탕","섭씨","성공","성당","성명","성별","성인","성장","성적","성질","성함","세금","세미나","세상","세월","세종대왕","세탁","센터","센티미터","셋째","소규모","소극적","소금","소나기","소년","소득","소망","소문","소설","소속","소아과","소용","소원","소음","소중히","소지품","소질","소풍","소형","속담","속도","속옷","손가락","손길","손녀","손님","손등","손목","손뼉","손실","손질","손톱","손해","솔직히","솜씨","송아지","송이","송편","쇠고기","쇼핑","수건","수년","수단","수돗물","수동적","수면","수명","수박","수상","수석","수술","수시로","수업","수염","수영","수입","수준","수집","수출","수컷","수필","수학","수험생","수화기","숙녀","숙소","숙제","순간","순서","순수","순식간","순위","숟가락","술병","술집","숫자","스님","스물","스스로","스승","스웨터","스위치","스케이트","스튜디오","스트레스","스포츠","슬쩍","슬픔","습관","습기","승객","승리","승부","승용차","승진","시각","시간","시골","시금치","시나리오","시댁","시리즈","시멘트","시민","시부모","시선","시설","시스템","시아버지","시어머니","시월","시인","시일","시작","시장","시절","시점","시중","시즌","시집","시청","시합","시험","식구","식기","식당","식량","식료품","식물","식빵","식사","식생활","식초","식탁","식품","신고","신규","신념","신문","신발","신비","신사","신세","신용","신제품","신청","신체","신화","실감","실내","실력","실례","실망","실수","실습","실시","실장","실정","실질적","실천","실체","실컷","실태","실패","실험","실현","심리","심부름","심사","심장","심정","심판","쌍둥이","씨름","씨앗","아가씨","아나운서","아드님","아들","아쉬움","아스팔트","아시아","아울러","아저씨","아줌마","아직","아침","아파트","아프리카","아픔","아홉","아흔","악기","악몽","악수","안개","안경","안과","안내","안녕","안동","안방","안부","안주","알루미늄","알코올","암시","암컷","압력","앞날","앞문","애인","애정","액수","앨범","야간","야단","야옹","약간","약국","약속","약수","약점","약품","약혼녀","양념","양력","양말","양배추","양주","양파","어둠","어려움","어른","어젯밤","어쨌든","어쩌다가","어쩐지","언니","언덕","언론","언어","얼굴","얼른","얼음","얼핏","엄마","업무","업종","업체","엉덩이","엉망","엉터리","엊그제","에너지","에어컨","엔진","여건","여고생","여관","여군","여권","여대생","여덟","여동생","여든","여론","여름","여섯","여성","여왕","여인","여전히","여직원","여학생","여행","역사","역시","역할","연결","연구","연극","연기","연락","연설","연세","연속","연습","연애","연예인","연인","연장","연주","연출","연필","연합","연휴","열기","열매","열쇠","열심히","열정","열차","열흘","염려","엽서","영국","영남","영상","영양","영역","영웅","영원히","영하","영향","영혼","영화","옆구리","옆방","옆집","예감","예금","예방","예산","예상","예선","예술","예습","예식장","예약","예전","예절","예정","예컨대","옛날","오늘","오락","오랫동안","오렌지","오로지","오른발","오븐","오십","오염","오월","오전","오직","오징어","오페라","오피스텔","오히려","옥상","옥수수","온갖","온라인","온몸","온종일","온통","올가을","올림픽","올해","옷차림","와이셔츠","와인","완성","완전","왕비","왕자","왜냐하면","왠지","외갓집","외국","외로움","외삼촌","외출","외침","외할머니","왼발","왼손","왼쪽","요금","요일","요즘","요청","용기","용서","용어","우산","우선","우승","우연히","우정","우체국","우편","운동","운명","운반","운전","운행","울산","울음","움직임","웃어른","웃음","워낙","원고","원래","원서","원숭이","원인","원장","원피스","월급","월드컵","월세","월요일","웨이터","위반","위법","위성","위원","위험","위협","윗사람","유난히","유럽","유명","유물","유산","유적","유치원","유학","유행","유형","육군","육상","육십","육체","은행","음력","음료","음반","음성","음식","음악","음주","의견","의논","의문","의복","의식","의심","의외로","의욕","의원","의학","이것","이곳","이념","이놈","이달","이대로","이동","이렇게","이력서","이론적","이름","이민","이발소","이별","이불","이빨","이상","이성","이슬","이야기","이용","이웃","이월","이윽고","이익","이전","이중","이튿날","이틀","이혼","인간","인격","인공","인구","인근","인기","인도","인류","인물","인생","인쇄","인연","인원","인재","인종","인천","인체","인터넷","인하","인형","일곱","일기","일단","일대","일등","일반","일본","일부","일상","일생","일손","일요일","일월","일정","일종","일주일","일찍","일체","일치","일행","일회용","임금","임무","입대","입력","입맛","입사","입술","입시","입원","입장","입학","자가용","자격","자극","자동","자랑","자부심","자식","자신","자연","자원","자율","자전거","자정","자존심","자판","작가","작년","작성","작업","작용","작은딸","작품","잔디","잔뜩","잔치","잘못","잠깐","잠수함","잠시","잠옷","잠자리","잡지","장관","장군","장기간","장래","장례","장르","장마","장면","장모","장미","장비","장사","장소","장식","장애인","장인","장점","장차","장학금","재능","재빨리","재산","재생","재작년","재정","재채기","재판","재학","재활용","저것","저고리","저곳","저녁","저런","저렇게","저번","저울","저절로","저축","적극","적당히","적성","적용","적응","전개","전공","전기","전달","전라도","전망","전문","전반","전부","전세","전시","전용","전자","전쟁","전주","전철","전체","전통","전혀","전후","절대","절망","절반","절약","절차","점검","점수","점심","점원","점점","점차","접근","접시","접촉","젓가락","정거장","정도","정류장","정리","정말","정면","정문","정반대","정보","정부","정비","정상","정성","정오","정원","정장","정지","정치","정확히","제공","제과점","제대로","제목","제발","제법","제삿날","제안","제일","제작","제주도","제출","제품","제한","조각","조건","조금","조깅","조명","조미료","조상","조선","조용히","조절","조정","조직","존댓말","존재","졸업","졸음","종교","종로","종류","종소리","종업원","종종","종합","좌석","죄인","주관적","주름","주말","주머니","주먹","주문","주민","주방","주변","주식","주인","주일","주장","주전자","주택","준비","줄거리","줄기","줄무늬","중간","중계방송","중국","중년","중단","중독","중반","중부","중세","중소기업","중순","중앙","중요","중학교","즉석","즉시","즐거움","증가","증거","증권","증상","증세","지각","지갑","지경","지극히","지금","지급","지능","지름길","지리산","지방","지붕","지식","지역","지우개","지원","지적","지점","지진","지출","직선","직업","직원","직장","진급","진동","진로","진료","진리","진짜","진찰","진출","진통","진행","질문","질병","질서","짐작","집단","집안","집중","짜증","찌꺼기","차남","차라리","차량","차림","차별","차선","차츰","착각","찬물","찬성","참가","참기름","참새","참석","참여","참외","참조","찻잔","창가","창고","창구","창문","창밖","창작","창조","채널","채점","책가방","책방","책상","책임","챔피언","처벌","처음","천국","천둥","천장","천재","천천히","철도","철저히","철학","첫날","첫째","청년","청바지","청소","청춘","체계","체력","체온","체육","체중","체험","초등학생","초반","초밥","초상화","초순","초여름","초원","초저녁","초점","초청","초콜릿","촛불","총각","총리","총장","촬영","최근","최상","최선","최신","최악","최종","추석","추억","추진","추천","추측","축구","축소","축제","축하","출근","출발","출산","출신","출연","출입","출장","출판","충격","충고","충돌","충분히","충청도","취업","취직","취향","치약","친구","친척","칠십","칠월","칠판","침대","침묵","침실","칫솔","칭찬","카메라","카운터","칼국수","캐릭터","캠퍼스","캠페인","커튼","컨디션","컬러","컴퓨터","코끼리","코미디","콘서트","콜라","콤플렉스","콩나물","쾌감","쿠데타","크림","큰길","큰딸","큰소리","큰아들","큰어머니","큰일","큰절","클래식","클럽","킬로","타입","타자기","탁구","탁자","탄생","태권도","태양","태풍","택시","탤런트","터널","터미널","테니스","테스트","테이블","텔레비전","토론","토마토","토요일","통계","통과","통로","통신","통역","통일","통장","통제","통증","통합","통화","퇴근","퇴원","퇴직금","튀김","트럭","특급","특별","특성","특수","특징","특히","튼튼히","티셔츠","파란색","파일","파출소","판결","판단","판매","판사","팔십","팔월","팝송","패션","팩스","팩시밀리","팬티","퍼센트","페인트","편견","편의","편지","편히","평가","평균","평생","평소","평양","평일","평화","포스터","포인트","포장","포함","표면","표정","표준","표현","품목","품질","풍경","풍속","풍습","프랑스","프린터","플라스틱","피곤","피망","피아노","필름","필수","필요","필자","필통","핑계","하느님","하늘","하드웨어","하룻밤","하반기","하숙집","하순","하여튼","하지만","하천","하품","하필","학과","학교","학급","학기","학년","학력","학번","학부모","학비","학생","학술","학습","학용품","학원","학위","학자","학점","한계","한글","한꺼번에","한낮","한눈","한동안","한때","한라산","한마디","한문","한번","한복","한식","한여름","한쪽","할머니","할아버지","할인","함께","함부로","합격","합리적","항공","항구","항상","항의","해결","해군","해답","해당","해물","해석","해설","해수욕장","해안","핵심","핸드백","햄버거","햇볕","햇살","행동","행복","행사","행운","행위","향기","향상","향수","허락","허용","헬기","현관","현금","현대","현상","현실","현장","현재","현지","혈액","협력","형부","형사","형수","형식","형제","형태","형편","혜택","호기심","호남","호랑이","호박","호텔","호흡","혹시","홀로","홈페이지","홍보","홍수","홍차","화면","화분","화살","화요일","화장","화학","확보","확인","확장","확정","환갑","환경","환영","환율","환자","활기","활동","활발히","활용","활짝","회견","회관","회복","회색","회원","회장","회전","횟수","횡단보도","효율적","후반","후춧가루","훈련","훨씬","휴식","휴일","흉내","흐름","흑백","흑인","흔적","흔히","흥미","흥분","희곡","희망","희생","흰색","힘껏"]')},5436:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(6876), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQzNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsSUFBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtd2FsbGV0L2Rpc3QvaW5kZXguanM/NTg2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNSBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zcmMvd2FsbGV0XCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5436\n\n}')},5467:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MAX_DECIMALS = exports.TOKEN_ID_NUM_BYTES = exports.UNKNOWN_STR = exports.BURN = exports.BURN_STR = exports.SEND = exports.SEND_STR = exports.MINT = exports.MINT_STR = exports.GENESIS = exports.GENESIS_STR = void 0;\nconst str_js_1 = __webpack_require__(2392);\n/** GENESIS tx type: Creates a new token ID */\nexports.GENESIS_STR = 'GENESIS';\nexports.GENESIS = (0, str_js_1.strToBytes)(exports.GENESIS_STR);\n/** MINT tx type: Mints more of a token ID */\nexports.MINT_STR = 'MINT';\nexports.MINT = (0, str_js_1.strToBytes)(exports.MINT_STR);\n/** SEND tx type: Moves existing tokens to different outputs */\nexports.SEND_STR = 'SEND';\nexports.SEND = (0, str_js_1.strToBytes)(exports.SEND_STR);\n/** BURN tx type: Destroys existing tokens */\nexports.BURN_STR = 'BURN';\nexports.BURN = (0, str_js_1.strToBytes)(exports.BURN_STR);\n/**\n * UNKNOWN: Placeholder for unknown token types.\n * Note: These may hold valuable tokens, but which aren't recognized.\n * They should be excluded from UTXO selection.\n **/\nexports.UNKNOWN_STR = 'UNKNOWN';\n/** Number of bytes in a token ID */\nexports.TOKEN_ID_NUM_BYTES = 32;\n/** How many decimals a token can have at most (SLP/ALP) */\nexports.MAX_DECIMALS = 9;\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ2Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyxtQkFBbUIsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLGdCQUFnQixHQUFHLFlBQVksR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsbUJBQW1CO0FBQ3JOLGlCQUFpQixtQkFBTyxDQUFDLElBQWM7QUFDdkM7QUFDQSxtQkFBbUI7QUFDbkIsZUFBZTtBQUNmO0FBQ0EsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWjtBQUNBLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1o7QUFDQSxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L3Rva2VuL2NvbW1vbi5qcz9mY2I2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTUFYX0RFQ0lNQUxTID0gZXhwb3J0cy5UT0tFTl9JRF9OVU1fQllURVMgPSBleHBvcnRzLlVOS05PV05fU1RSID0gZXhwb3J0cy5CVVJOID0gZXhwb3J0cy5CVVJOX1NUUiA9IGV4cG9ydHMuU0VORCA9IGV4cG9ydHMuU0VORF9TVFIgPSBleHBvcnRzLk1JTlQgPSBleHBvcnRzLk1JTlRfU1RSID0gZXhwb3J0cy5HRU5FU0lTID0gZXhwb3J0cy5HRU5FU0lTX1NUUiA9IHZvaWQgMDtcbmNvbnN0IHN0cl9qc18xID0gcmVxdWlyZShcIi4uL2lvL3N0ci5qc1wiKTtcbi8qKiBHRU5FU0lTIHR4IHR5cGU6IENyZWF0ZXMgYSBuZXcgdG9rZW4gSUQgKi9cbmV4cG9ydHMuR0VORVNJU19TVFIgPSAnR0VORVNJUyc7XG5leHBvcnRzLkdFTkVTSVMgPSAoMCwgc3RyX2pzXzEuc3RyVG9CeXRlcykoZXhwb3J0cy5HRU5FU0lTX1NUUik7XG4vKiogTUlOVCB0eCB0eXBlOiBNaW50cyBtb3JlIG9mIGEgdG9rZW4gSUQgKi9cbmV4cG9ydHMuTUlOVF9TVFIgPSAnTUlOVCc7XG5leHBvcnRzLk1JTlQgPSAoMCwgc3RyX2pzXzEuc3RyVG9CeXRlcykoZXhwb3J0cy5NSU5UX1NUUik7XG4vKiogU0VORCB0eCB0eXBlOiBNb3ZlcyBleGlzdGluZyB0b2tlbnMgdG8gZGlmZmVyZW50IG91dHB1dHMgKi9cbmV4cG9ydHMuU0VORF9TVFIgPSAnU0VORCc7XG5leHBvcnRzLlNFTkQgPSAoMCwgc3RyX2pzXzEuc3RyVG9CeXRlcykoZXhwb3J0cy5TRU5EX1NUUik7XG4vKiogQlVSTiB0eCB0eXBlOiBEZXN0cm95cyBleGlzdGluZyB0b2tlbnMgKi9cbmV4cG9ydHMuQlVSTl9TVFIgPSAnQlVSTic7XG5leHBvcnRzLkJVUk4gPSAoMCwgc3RyX2pzXzEuc3RyVG9CeXRlcykoZXhwb3J0cy5CVVJOX1NUUik7XG4vKipcbiAqIFVOS05PV046IFBsYWNlaG9sZGVyIGZvciB1bmtub3duIHRva2VuIHR5cGVzLlxuICogTm90ZTogVGhlc2UgbWF5IGhvbGQgdmFsdWFibGUgdG9rZW5zLCBidXQgd2hpY2ggYXJlbid0IHJlY29nbml6ZWQuXG4gKiBUaGV5IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIFVUWE8gc2VsZWN0aW9uLlxuICoqL1xuZXhwb3J0cy5VTktOT1dOX1NUUiA9ICdVTktOT1dOJztcbi8qKiBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB0b2tlbiBJRCAqL1xuZXhwb3J0cy5UT0tFTl9JRF9OVU1fQllURVMgPSAzMjtcbi8qKiBIb3cgbWFueSBkZWNpbWFscyBhIHRva2VuIGNhbiBoYXZlIGF0IG1vc3QgKFNMUC9BTFApICovXG5leHBvcnRzLk1BWF9ERUNJTUFMUyA9IDk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5467\n\n}")},5576:g=>{"use strict";g.exports=JSON.parse('["abaco","abbaglio","abbinato","abete","abisso","abolire","abrasivo","abrogato","accadere","accenno","accusato","acetone","achille","acido","acqua","acre","acrilico","acrobata","acuto","adagio","addebito","addome","adeguato","aderire","adipe","adottare","adulare","affabile","affetto","affisso","affranto","aforisma","afoso","africano","agave","agente","agevole","aggancio","agire","agitare","agonismo","agricolo","agrumeto","aguzzo","alabarda","alato","albatro","alberato","albo","albume","alce","alcolico","alettone","alfa","algebra","aliante","alibi","alimento","allagato","allegro","allievo","allodola","allusivo","almeno","alogeno","alpaca","alpestre","altalena","alterno","alticcio","altrove","alunno","alveolo","alzare","amalgama","amanita","amarena","ambito","ambrato","ameba","america","ametista","amico","ammasso","ammenda","ammirare","ammonito","amore","ampio","ampliare","amuleto","anacardo","anagrafe","analista","anarchia","anatra","anca","ancella","ancora","andare","andrea","anello","angelo","angolare","angusto","anima","annegare","annidato","anno","annuncio","anonimo","anticipo","anzi","apatico","apertura","apode","apparire","appetito","appoggio","approdo","appunto","aprile","arabica","arachide","aragosta","araldica","arancio","aratura","arazzo","arbitro","archivio","ardito","arenile","argento","argine","arguto","aria","armonia","arnese","arredato","arringa","arrosto","arsenico","arso","artefice","arzillo","asciutto","ascolto","asepsi","asettico","asfalto","asino","asola","aspirato","aspro","assaggio","asse","assoluto","assurdo","asta","astenuto","astice","astratto","atavico","ateismo","atomico","atono","attesa","attivare","attorno","attrito","attuale","ausilio","austria","autista","autonomo","autunno","avanzato","avere","avvenire","avviso","avvolgere","azione","azoto","azzimo","azzurro","babele","baccano","bacino","baco","badessa","badilata","bagnato","baita","balcone","baldo","balena","ballata","balzano","bambino","bandire","baraonda","barbaro","barca","baritono","barlume","barocco","basilico","basso","batosta","battuto","baule","bava","bavosa","becco","beffa","belgio","belva","benda","benevole","benigno","benzina","bere","berlina","beta","bibita","bici","bidone","bifido","biga","bilancia","bimbo","binocolo","biologo","bipede","bipolare","birbante","birra","biscotto","bisesto","bisnonno","bisonte","bisturi","bizzarro","blando","blatta","bollito","bonifico","bordo","bosco","botanico","bottino","bozzolo","braccio","bradipo","brama","branca","bravura","bretella","brevetto","brezza","briglia","brillante","brindare","broccolo","brodo","bronzina","brullo","bruno","bubbone","buca","budino","buffone","buio","bulbo","buono","burlone","burrasca","bussola","busta","cadetto","caduco","calamaro","calcolo","calesse","calibro","calmo","caloria","cambusa","camerata","camicia","cammino","camola","campale","canapa","candela","cane","canino","canotto","cantina","capace","capello","capitolo","capogiro","cappero","capra","capsula","carapace","carcassa","cardo","carisma","carovana","carretto","cartolina","casaccio","cascata","caserma","caso","cassone","castello","casuale","catasta","catena","catrame","cauto","cavillo","cedibile","cedrata","cefalo","celebre","cellulare","cena","cenone","centesimo","ceramica","cercare","certo","cerume","cervello","cesoia","cespo","ceto","chela","chiaro","chicca","chiedere","chimera","china","chirurgo","chitarra","ciao","ciclismo","cifrare","cigno","cilindro","ciottolo","circa","cirrosi","citrico","cittadino","ciuffo","civetta","civile","classico","clinica","cloro","cocco","codardo","codice","coerente","cognome","collare","colmato","colore","colposo","coltivato","colza","coma","cometa","commando","comodo","computer","comune","conciso","condurre","conferma","congelare","coniuge","connesso","conoscere","consumo","continuo","convegno","coperto","copione","coppia","copricapo","corazza","cordata","coricato","cornice","corolla","corpo","corredo","corsia","cortese","cosmico","costante","cottura","covato","cratere","cravatta","creato","credere","cremoso","crescita","creta","criceto","crinale","crisi","critico","croce","cronaca","crostata","cruciale","crusca","cucire","cuculo","cugino","cullato","cupola","curatore","cursore","curvo","cuscino","custode","dado","daino","dalmata","damerino","daniela","dannoso","danzare","datato","davanti","davvero","debutto","decennio","deciso","declino","decollo","decreto","dedicato","definito","deforme","degno","delegare","delfino","delirio","delta","demenza","denotato","dentro","deposito","derapata","derivare","deroga","descritto","deserto","desiderio","desumere","detersivo","devoto","diametro","dicembre","diedro","difeso","diffuso","digerire","digitale","diluvio","dinamico","dinnanzi","dipinto","diploma","dipolo","diradare","dire","dirotto","dirupo","disagio","discreto","disfare","disgelo","disposto","distanza","disumano","dito","divano","divelto","dividere","divorato","doblone","docente","doganale","dogma","dolce","domato","domenica","dominare","dondolo","dono","dormire","dote","dottore","dovuto","dozzina","drago","druido","dubbio","dubitare","ducale","duna","duomo","duplice","duraturo","ebano","eccesso","ecco","eclissi","economia","edera","edicola","edile","editoria","educare","egemonia","egli","egoismo","egregio","elaborato","elargire","elegante","elencato","eletto","elevare","elfico","elica","elmo","elsa","eluso","emanato","emblema","emesso","emiro","emotivo","emozione","empirico","emulo","endemico","enduro","energia","enfasi","enoteca","entrare","enzima","epatite","epilogo","episodio","epocale","eppure","equatore","erario","erba","erboso","erede","eremita","erigere","ermetico","eroe","erosivo","errante","esagono","esame","esanime","esaudire","esca","esempio","esercito","esibito","esigente","esistere","esito","esofago","esortato","esoso","espanso","espresso","essenza","esso","esteso","estimare","estonia","estroso","esultare","etilico","etnico","etrusco","etto","euclideo","europa","evaso","evidenza","evitato","evoluto","evviva","fabbrica","faccenda","fachiro","falco","famiglia","fanale","fanfara","fango","fantasma","fare","farfalla","farinoso","farmaco","fascia","fastoso","fasullo","faticare","fato","favoloso","febbre","fecola","fede","fegato","felpa","feltro","femmina","fendere","fenomeno","fermento","ferro","fertile","fessura","festivo","fetta","feudo","fiaba","fiducia","fifa","figurato","filo","finanza","finestra","finire","fiore","fiscale","fisico","fiume","flacone","flamenco","flebo","flemma","florido","fluente","fluoro","fobico","focaccia","focoso","foderato","foglio","folata","folclore","folgore","fondente","fonetico","fonia","fontana","forbito","forchetta","foresta","formica","fornaio","foro","fortezza","forzare","fosfato","fosso","fracasso","frana","frassino","fratello","freccetta","frenata","fresco","frigo","frollino","fronde","frugale","frutta","fucilata","fucsia","fuggente","fulmine","fulvo","fumante","fumetto","fumoso","fune","funzione","fuoco","furbo","furgone","furore","fuso","futile","gabbiano","gaffe","galateo","gallina","galoppo","gambero","gamma","garanzia","garbo","garofano","garzone","gasdotto","gasolio","gastrico","gatto","gaudio","gazebo","gazzella","geco","gelatina","gelso","gemello","gemmato","gene","genitore","gennaio","genotipo","gergo","ghepardo","ghiaccio","ghisa","giallo","gilda","ginepro","giocare","gioiello","giorno","giove","girato","girone","gittata","giudizio","giurato","giusto","globulo","glutine","gnomo","gobba","golf","gomito","gommone","gonfio","gonna","governo","gracile","grado","grafico","grammo","grande","grattare","gravoso","grazia","greca","gregge","grifone","grigio","grinza","grotta","gruppo","guadagno","guaio","guanto","guardare","gufo","guidare","ibernato","icona","identico","idillio","idolo","idra","idrico","idrogeno","igiene","ignaro","ignorato","ilare","illeso","illogico","illudere","imballo","imbevuto","imbocco","imbuto","immane","immerso","immolato","impacco","impeto","impiego","importo","impronta","inalare","inarcare","inattivo","incanto","incendio","inchino","incisivo","incluso","incontro","incrocio","incubo","indagine","india","indole","inedito","infatti","infilare","inflitto","ingaggio","ingegno","inglese","ingordo","ingrosso","innesco","inodore","inoltrare","inondato","insano","insetto","insieme","insonnia","insulina","intasato","intero","intonaco","intuito","inumidire","invalido","invece","invito","iperbole","ipnotico","ipotesi","ippica","iride","irlanda","ironico","irrigato","irrorare","isolato","isotopo","isterico","istituto","istrice","italia","iterare","labbro","labirinto","lacca","lacerato","lacrima","lacuna","laddove","lago","lampo","lancetta","lanterna","lardoso","larga","laringe","lastra","latenza","latino","lattuga","lavagna","lavoro","legale","leggero","lembo","lentezza","lenza","leone","lepre","lesivo","lessato","lesto","letterale","leva","levigato","libero","lido","lievito","lilla","limatura","limitare","limpido","lineare","lingua","liquido","lira","lirica","lisca","lite","litigio","livrea","locanda","lode","logica","lombare","londra","longevo","loquace","lorenzo","loto","lotteria","luce","lucidato","lumaca","luminoso","lungo","lupo","luppolo","lusinga","lusso","lutto","macabro","macchina","macero","macinato","madama","magico","maglia","magnete","magro","maiolica","malafede","malgrado","malinteso","malsano","malto","malumore","mana","mancia","mandorla","mangiare","manifesto","mannaro","manovra","mansarda","mantide","manubrio","mappa","maratona","marcire","maretta","marmo","marsupio","maschera","massaia","mastino","materasso","matricola","mattone","maturo","mazurca","meandro","meccanico","mecenate","medesimo","meditare","mega","melassa","melis","melodia","meninge","meno","mensola","mercurio","merenda","merlo","meschino","mese","messere","mestolo","metallo","metodo","mettere","miagolare","mica","micelio","michele","microbo","midollo","miele","migliore","milano","milite","mimosa","minerale","mini","minore","mirino","mirtillo","miscela","missiva","misto","misurare","mitezza","mitigare","mitra","mittente","mnemonico","modello","modifica","modulo","mogano","mogio","mole","molosso","monastero","monco","mondina","monetario","monile","monotono","monsone","montato","monviso","mora","mordere","morsicato","mostro","motivato","motosega","motto","movenza","movimento","mozzo","mucca","mucosa","muffa","mughetto","mugnaio","mulatto","mulinello","multiplo","mummia","munto","muovere","murale","musa","muscolo","musica","mutevole","muto","nababbo","nafta","nanometro","narciso","narice","narrato","nascere","nastrare","naturale","nautica","naviglio","nebulosa","necrosi","negativo","negozio","nemmeno","neofita","neretto","nervo","nessuno","nettuno","neutrale","neve","nevrotico","nicchia","ninfa","nitido","nobile","nocivo","nodo","nome","nomina","nordico","normale","norvegese","nostrano","notare","notizia","notturno","novella","nucleo","nulla","numero","nuovo","nutrire","nuvola","nuziale","oasi","obbedire","obbligo","obelisco","oblio","obolo","obsoleto","occasione","occhio","occidente","occorrere","occultare","ocra","oculato","odierno","odorare","offerta","offrire","offuscato","oggetto","oggi","ognuno","olandese","olfatto","oliato","oliva","ologramma","oltre","omaggio","ombelico","ombra","omega","omissione","ondoso","onere","onice","onnivoro","onorevole","onta","operato","opinione","opposto","oracolo","orafo","ordine","orecchino","orefice","orfano","organico","origine","orizzonte","orma","ormeggio","ornativo","orologio","orrendo","orribile","ortensia","ortica","orzata","orzo","osare","oscurare","osmosi","ospedale","ospite","ossa","ossidare","ostacolo","oste","otite","otre","ottagono","ottimo","ottobre","ovale","ovest","ovino","oviparo","ovocito","ovunque","ovviare","ozio","pacchetto","pace","pacifico","padella","padrone","paese","paga","pagina","palazzina","palesare","pallido","palo","palude","pandoro","pannello","paolo","paonazzo","paprica","parabola","parcella","parere","pargolo","pari","parlato","parola","partire","parvenza","parziale","passivo","pasticca","patacca","patologia","pattume","pavone","peccato","pedalare","pedonale","peggio","peloso","penare","pendice","penisola","pennuto","penombra","pensare","pentola","pepe","pepita","perbene","percorso","perdonato","perforare","pergamena","periodo","permesso","perno","perplesso","persuaso","pertugio","pervaso","pesatore","pesista","peso","pestifero","petalo","pettine","petulante","pezzo","piacere","pianta","piattino","piccino","picozza","piega","pietra","piffero","pigiama","pigolio","pigro","pila","pilifero","pillola","pilota","pimpante","pineta","pinna","pinolo","pioggia","piombo","piramide","piretico","pirite","pirolisi","pitone","pizzico","placebo","planare","plasma","platano","plenario","pochezza","poderoso","podismo","poesia","poggiare","polenta","poligono","pollice","polmonite","polpetta","polso","poltrona","polvere","pomice","pomodoro","ponte","popoloso","porfido","poroso","porpora","porre","portata","posa","positivo","possesso","postulato","potassio","potere","pranzo","prassi","pratica","precluso","predica","prefisso","pregiato","prelievo","premere","prenotare","preparato","presenza","pretesto","prevalso","prima","principe","privato","problema","procura","produrre","profumo","progetto","prolunga","promessa","pronome","proposta","proroga","proteso","prova","prudente","prugna","prurito","psiche","pubblico","pudica","pugilato","pugno","pulce","pulito","pulsante","puntare","pupazzo","pupilla","puro","quadro","qualcosa","quasi","querela","quota","raccolto","raddoppio","radicale","radunato","raffica","ragazzo","ragione","ragno","ramarro","ramingo","ramo","randagio","rantolare","rapato","rapina","rappreso","rasatura","raschiato","rasente","rassegna","rastrello","rata","ravveduto","reale","recepire","recinto","recluta","recondito","recupero","reddito","redimere","regalato","registro","regola","regresso","relazione","remare","remoto","renna","replica","reprimere","reputare","resa","residente","responso","restauro","rete","retina","retorica","rettifica","revocato","riassunto","ribadire","ribelle","ribrezzo","ricarica","ricco","ricevere","riciclato","ricordo","ricreduto","ridicolo","ridurre","rifasare","riflesso","riforma","rifugio","rigare","rigettato","righello","rilassato","rilevato","rimanere","rimbalzo","rimedio","rimorchio","rinascita","rincaro","rinforzo","rinnovo","rinomato","rinsavito","rintocco","rinuncia","rinvenire","riparato","ripetuto","ripieno","riportare","ripresa","ripulire","risata","rischio","riserva","risibile","riso","rispetto","ristoro","risultato","risvolto","ritardo","ritegno","ritmico","ritrovo","riunione","riva","riverso","rivincita","rivolto","rizoma","roba","robotico","robusto","roccia","roco","rodaggio","rodere","roditore","rogito","rollio","romantico","rompere","ronzio","rosolare","rospo","rotante","rotondo","rotula","rovescio","rubizzo","rubrica","ruga","rullino","rumine","rumoroso","ruolo","rupe","russare","rustico","sabato","sabbiare","sabotato","sagoma","salasso","saldatura","salgemma","salivare","salmone","salone","saltare","saluto","salvo","sapere","sapido","saporito","saraceno","sarcasmo","sarto","sassoso","satellite","satira","satollo","saturno","savana","savio","saziato","sbadiglio","sbalzo","sbancato","sbarra","sbattere","sbavare","sbendare","sbirciare","sbloccato","sbocciato","sbrinare","sbruffone","sbuffare","scabroso","scadenza","scala","scambiare","scandalo","scapola","scarso","scatenare","scavato","scelto","scenico","scettro","scheda","schiena","sciarpa","scienza","scindere","scippo","sciroppo","scivolo","sclerare","scodella","scolpito","scomparto","sconforto","scoprire","scorta","scossone","scozzese","scriba","scrollare","scrutinio","scuderia","scultore","scuola","scuro","scusare","sdebitare","sdoganare","seccatura","secondo","sedano","seggiola","segnalato","segregato","seguito","selciato","selettivo","sella","selvaggio","semaforo","sembrare","seme","seminato","sempre","senso","sentire","sepolto","sequenza","serata","serbato","sereno","serio","serpente","serraglio","servire","sestina","setola","settimana","sfacelo","sfaldare","sfamato","sfarzoso","sfaticato","sfera","sfida","sfilato","sfinge","sfocato","sfoderare","sfogo","sfoltire","sforzato","sfratto","sfruttato","sfuggito","sfumare","sfuso","sgabello","sgarbato","sgonfiare","sgorbio","sgrassato","sguardo","sibilo","siccome","sierra","sigla","signore","silenzio","sillaba","simbolo","simpatico","simulato","sinfonia","singolo","sinistro","sino","sintesi","sinusoide","sipario","sisma","sistole","situato","slitta","slogatura","sloveno","smarrito","smemorato","smentito","smeraldo","smilzo","smontare","smottato","smussato","snellire","snervato","snodo","sobbalzo","sobrio","soccorso","sociale","sodale","soffitto","sogno","soldato","solenne","solido","sollazzo","solo","solubile","solvente","somatico","somma","sonda","sonetto","sonnifero","sopire","soppeso","sopra","sorgere","sorpasso","sorriso","sorso","sorteggio","sorvolato","sospiro","sosta","sottile","spada","spalla","spargere","spatola","spavento","spazzola","specie","spedire","spegnere","spelatura","speranza","spessore","spettrale","spezzato","spia","spigoloso","spillato","spinoso","spirale","splendido","sportivo","sposo","spranga","sprecare","spronato","spruzzo","spuntino","squillo","sradicare","srotolato","stabile","stacco","staffa","stagnare","stampato","stantio","starnuto","stasera","statuto","stelo","steppa","sterzo","stiletto","stima","stirpe","stivale","stizzoso","stonato","storico","strappo","stregato","stridulo","strozzare","strutto","stuccare","stufo","stupendo","subentro","succoso","sudore","suggerito","sugo","sultano","suonare","superbo","supporto","surgelato","surrogato","sussurro","sutura","svagare","svedese","sveglio","svelare","svenuto","svezia","sviluppo","svista","svizzera","svolta","svuotare","tabacco","tabulato","tacciare","taciturno","tale","talismano","tampone","tannino","tara","tardivo","targato","tariffa","tarpare","tartaruga","tasto","tattico","taverna","tavolata","tazza","teca","tecnico","telefono","temerario","tempo","temuto","tendone","tenero","tensione","tentacolo","teorema","terme","terrazzo","terzetto","tesi","tesserato","testato","tetro","tettoia","tifare","tigella","timbro","tinto","tipico","tipografo","tiraggio","tiro","titanio","titolo","titubante","tizio","tizzone","toccare","tollerare","tolto","tombola","tomo","tonfo","tonsilla","topazio","topologia","toppa","torba","tornare","torrone","tortora","toscano","tossire","tostatura","totano","trabocco","trachea","trafila","tragedia","tralcio","tramonto","transito","trapano","trarre","trasloco","trattato","trave","treccia","tremolio","trespolo","tributo","tricheco","trifoglio","trillo","trincea","trio","tristezza","triturato","trivella","tromba","trono","troppo","trottola","trovare","truccato","tubatura","tuffato","tulipano","tumulto","tunisia","turbare","turchino","tuta","tutela","ubicato","uccello","uccisore","udire","uditivo","uffa","ufficio","uguale","ulisse","ultimato","umano","umile","umorismo","uncinetto","ungere","ungherese","unicorno","unificato","unisono","unitario","unte","uovo","upupa","uragano","urgenza","urlo","usanza","usato","uscito","usignolo","usuraio","utensile","utilizzo","utopia","vacante","vaccinato","vagabondo","vagliato","valanga","valgo","valico","valletta","valoroso","valutare","valvola","vampata","vangare","vanitoso","vano","vantaggio","vanvera","vapore","varano","varcato","variante","vasca","vedetta","vedova","veduto","vegetale","veicolo","velcro","velina","velluto","veloce","venato","vendemmia","vento","verace","verbale","vergogna","verifica","vero","verruca","verticale","vescica","vessillo","vestale","veterano","vetrina","vetusto","viandante","vibrante","vicenda","vichingo","vicinanza","vidimare","vigilia","vigneto","vigore","vile","villano","vimini","vincitore","viola","vipera","virgola","virologo","virulento","viscoso","visione","vispo","vissuto","visura","vita","vitello","vittima","vivanda","vivido","viziare","voce","voga","volatile","volere","volpe","voragine","vulcano","zampogna","zanna","zappato","zattera","zavorra","zefiro","zelante","zelo","zenzero","zerbino","zibetto","zinco","zircone","zitto","zolla","zotico","zucchero","zufolo","zulu","zuppa"]')},5632:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.__setHashes = exports.sha512Hasher = exports.sha256Hasher = exports.sha512 = exports.shaRmd160 = exports.sha256d = exports.sha256 = void 0;\nconst HASHES = {};\nfunction sha256(data) {\n    return HASHES.sha256(data);\n}\nexports.sha256 = sha256;\nfunction sha256d(data) {\n    return HASHES.sha256d(data);\n}\nexports.sha256d = sha256d;\nfunction shaRmd160(data) {\n    return HASHES.shaRmd160(data);\n}\nexports.shaRmd160 = shaRmd160;\nfunction sha512(data) {\n    return HASHES.sha512(data);\n}\nexports.sha512 = sha512;\nfunction sha256Hasher() {\n    return new HASHES.Sha256H();\n}\nexports.sha256Hasher = sha256Hasher;\nfunction sha512Hasher() {\n    return new HASHES.Sha512H();\n}\nexports.sha512Hasher = sha512Hasher;\nfunction __setHashes(hashes) {\n    HASHES.sha256 = hashes.sha256;\n    HASHES.sha256d = hashes.sha256d;\n    HASHES.shaRmd160 = hashes.shaRmd160;\n    HASHES.sha512 = hashes.sha512;\n    HASHES.Sha256H = hashes.Sha256H;\n    HASHES.Sha512H = hashes.Sha512H;\n}\nexports.__setHashes = __setHashes;\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsZUFBZSxHQUFHLGNBQWM7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9oYXNoLmpzPzg2YTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5fX3NldEhhc2hlcyA9IGV4cG9ydHMuc2hhNTEySGFzaGVyID0gZXhwb3J0cy5zaGEyNTZIYXNoZXIgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhUm1kMTYwID0gZXhwb3J0cy5zaGEyNTZkID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBIQVNIRVMgPSB7fTtcbmZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gICAgcmV0dXJuIEhBU0hFUy5zaGEyNTYoZGF0YSk7XG59XG5leHBvcnRzLnNoYTI1NiA9IHNoYTI1NjtcbmZ1bmN0aW9uIHNoYTI1NmQoZGF0YSkge1xuICAgIHJldHVybiBIQVNIRVMuc2hhMjU2ZChkYXRhKTtcbn1cbmV4cG9ydHMuc2hhMjU2ZCA9IHNoYTI1NmQ7XG5mdW5jdGlvbiBzaGFSbWQxNjAoZGF0YSkge1xuICAgIHJldHVybiBIQVNIRVMuc2hhUm1kMTYwKGRhdGEpO1xufVxuZXhwb3J0cy5zaGFSbWQxNjAgPSBzaGFSbWQxNjA7XG5mdW5jdGlvbiBzaGE1MTIoZGF0YSkge1xuICAgIHJldHVybiBIQVNIRVMuc2hhNTEyKGRhdGEpO1xufVxuZXhwb3J0cy5zaGE1MTIgPSBzaGE1MTI7XG5mdW5jdGlvbiBzaGEyNTZIYXNoZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBIQVNIRVMuU2hhMjU2SCgpO1xufVxuZXhwb3J0cy5zaGEyNTZIYXNoZXIgPSBzaGEyNTZIYXNoZXI7XG5mdW5jdGlvbiBzaGE1MTJIYXNoZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBIQVNIRVMuU2hhNTEySCgpO1xufVxuZXhwb3J0cy5zaGE1MTJIYXNoZXIgPSBzaGE1MTJIYXNoZXI7XG5mdW5jdGlvbiBfX3NldEhhc2hlcyhoYXNoZXMpIHtcbiAgICBIQVNIRVMuc2hhMjU2ID0gaGFzaGVzLnNoYTI1NjtcbiAgICBIQVNIRVMuc2hhMjU2ZCA9IGhhc2hlcy5zaGEyNTZkO1xuICAgIEhBU0hFUy5zaGFSbWQxNjAgPSBoYXNoZXMuc2hhUm1kMTYwO1xuICAgIEhBU0hFUy5zaGE1MTIgPSBoYXNoZXMuc2hhNTEyO1xuICAgIEhBU0hFUy5TaGEyNTZIID0gaGFzaGVzLlNoYTI1Nkg7XG4gICAgSEFTSEVTLlNoYTUxMkggPSBoYXNoZXMuU2hhNTEySDtcbn1cbmV4cG9ydHMuX19zZXRIYXNoZXMgPSBfX3NldEhhc2hlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5632\n\n}')},5822:(module,__unused_webpack_exports,__webpack_require__)=>{eval("{const Mode = __webpack_require__(208)\n\nfunction ByteData (data) {\n  this.mode = Mode.BYTE\n  if (typeof (data) === 'string') {\n    this.data = new TextEncoder().encode(data)\n  } else {\n    this.data = new Uint8Array(data)\n  }\n}\n\nByteData.getBitsLength = function getBitsLength (length) {\n  return length * 8\n}\n\nByteData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nByteData.prototype.getBitsLength = function getBitsLength () {\n  return ByteData.getBitsLength(this.data.length)\n}\n\nByteData.prototype.write = function (bitBuffer) {\n  for (let i = 0, l = this.data.length; i < l; i++) {\n    bitBuffer.put(this.data[i], 8)\n  }\n}\n\nmodule.exports = ByteData\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgyMi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsR0FBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2NvcmUvYnl0ZS1kYXRhLmpzPzAxOTYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpXG5cbmZ1bmN0aW9uIEJ5dGVEYXRhIChkYXRhKSB7XG4gIHRoaXMubW9kZSA9IE1vZGUuQllURVxuICBpZiAodHlwZW9mIChkYXRhKSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKVxuICB9XG59XG5cbkJ5dGVEYXRhLmdldEJpdHNMZW5ndGggPSBmdW5jdGlvbiBnZXRCaXRzTGVuZ3RoIChsZW5ndGgpIHtcbiAgcmV0dXJuIGxlbmd0aCAqIDhcbn1cblxuQnl0ZURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoXG59XG5cbkJ5dGVEYXRhLnByb3RvdHlwZS5nZXRCaXRzTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Qml0c0xlbmd0aCAoKSB7XG4gIHJldHVybiBCeXRlRGF0YS5nZXRCaXRzTGVuZ3RoKHRoaXMuZGF0YS5sZW5ndGgpXG59XG5cbkJ5dGVEYXRhLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChiaXRCdWZmZXIpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLmRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYml0QnVmZmVyLnB1dCh0aGlzLmRhdGFbaV0sIDgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCeXRlRGF0YVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5822\n\n}")},5898:g=>{"use strict";g.exports=JSON.parse('["的","一","是","在","不","了","有","和","人","这","中","大","为","上","个","国","我","以","要","他","时","来","用","们","生","到","作","地","于","出","就","分","对","成","会","可","主","发","年","动","同","工","也","能","下","过","子","说","产","种","面","而","方","后","多","定","行","学","法","所","民","得","经","十","三","之","进","着","等","部","度","家","电","力","里","如","水","化","高","自","二","理","起","小","物","现","实","加","量","都","两","体","制","机","当","使","点","从","业","本","去","把","性","好","应","开","它","合","还","因","由","其","些","然","前","外","天","政","四","日","那","社","义","事","平","形","相","全","表","间","样","与","关","各","重","新","线","内","数","正","心","反","你","明","看","原","又","么","利","比","或","但","质","气","第","向","道","命","此","变","条","只","没","结","解","问","意","建","月","公","无","系","军","很","情","者","最","立","代","想","已","通","并","提","直","题","党","程","展","五","果","料","象","员","革","位","入","常","文","总","次","品","式","活","设","及","管","特","件","长","求","老","头","基","资","边","流","路","级","少","图","山","统","接","知","较","将","组","见","计","别","她","手","角","期","根","论","运","农","指","几","九","区","强","放","决","西","被","干","做","必","战","先","回","则","任","取","据","处","队","南","给","色","光","门","即","保","治","北","造","百","规","热","领","七","海","口","东","导","器","压","志","世","金","增","争","济","阶","油","思","术","极","交","受","联","什","认","六","共","权","收","证","改","清","美","再","采","转","更","单","风","切","打","白","教","速","花","带","安","场","身","车","例","真","务","具","万","每","目","至","达","走","积","示","议","声","报","斗","完","类","八","离","华","名","确","才","科","张","信","马","节","话","米","整","空","元","况","今","集","温","传","土","许","步","群","广","石","记","需","段","研","界","拉","林","律","叫","且","究","观","越","织","装","影","算","低","持","音","众","书","布","复","容","儿","须","际","商","非","验","连","断","深","难","近","矿","千","周","委","素","技","备","半","办","青","省","列","习","响","约","支","般","史","感","劳","便","团","往","酸","历","市","克","何","除","消","构","府","称","太","准","精","值","号","率","族","维","划","选","标","写","存","候","毛","亲","快","效","斯","院","查","江","型","眼","王","按","格","养","易","置","派","层","片","始","却","专","状","育","厂","京","识","适","属","圆","包","火","住","调","满","县","局","照","参","红","细","引","听","该","铁","价","严","首","底","液","官","德","随","病","苏","失","尔","死","讲","配","女","黄","推","显","谈","罪","神","艺","呢","席","含","企","望","密","批","营","项","防","举","球","英","氧","势","告","李","台","落","木","帮","轮","破","亚","师","围","注","远","字","材","排","供","河","态","封","另","施","减","树","溶","怎","止","案","言","士","均","武","固","叶","鱼","波","视","仅","费","紧","爱","左","章","早","朝","害","续","轻","服","试","食","充","兵","源","判","护","司","足","某","练","差","致","板","田","降","黑","犯","负","击","范","继","兴","似","余","坚","曲","输","修","故","城","夫","够","送","笔","船","占","右","财","吃","富","春","职","觉","汉","画","功","巴","跟","虽","杂","飞","检","吸","助","升","阳","互","初","创","抗","考","投","坏","策","古","径","换","未","跑","留","钢","曾","端","责","站","简","述","钱","副","尽","帝","射","草","冲","承","独","令","限","阿","宣","环","双","请","超","微","让","控","州","良","轴","找","否","纪","益","依","优","顶","础","载","倒","房","突","坐","粉","敌","略","客","袁","冷","胜","绝","析","块","剂","测","丝","协","诉","念","陈","仍","罗","盐","友","洋","错","苦","夜","刑","移","频","逐","靠","混","母","短","皮","终","聚","汽","村","云","哪","既","距","卫","停","烈","央","察","烧","迅","境","若","印","洲","刻","括","激","孔","搞","甚","室","待","核","校","散","侵","吧","甲","游","久","菜","味","旧","模","湖","货","损","预","阻","毫","普","稳","乙","妈","植","息","扩","银","语","挥","酒","守","拿","序","纸","医","缺","雨","吗","针","刘","啊","急","唱","误","训","愿","审","附","获","茶","鲜","粮","斤","孩","脱","硫","肥","善","龙","演","父","渐","血","欢","械","掌","歌","沙","刚","攻","谓","盾","讨","晚","粒","乱","燃","矛","乎","杀","药","宁","鲁","贵","钟","煤","读","班","伯","香","介","迫","句","丰","培","握","兰","担","弦","蛋","沉","假","穿","执","答","乐","谁","顺","烟","缩","征","脸","喜","松","脚","困","异","免","背","星","福","买","染","井","概","慢","怕","磁","倍","祖","皇","促","静","补","评","翻","肉","践","尼","衣","宽","扬","棉","希","伤","操","垂","秋","宜","氢","套","督","振","架","亮","末","宪","庆","编","牛","触","映","雷","销","诗","座","居","抓","裂","胞","呼","娘","景","威","绿","晶","厚","盟","衡","鸡","孙","延","危","胶","屋","乡","临","陆","顾","掉","呀","灯","岁","措","束","耐","剧","玉","赵","跳","哥","季","课","凯","胡","额","款","绍","卷","齐","伟","蒸","殖","永","宗","苗","川","炉","岩","弱","零","杨","奏","沿","露","杆","探","滑","镇","饭","浓","航","怀","赶","库","夺","伊","灵","税","途","灭","赛","归","召","鼓","播","盘","裁","险","康","唯","录","菌","纯","借","糖","盖","横","符","私","努","堂","域","枪","润","幅","哈","竟","熟","虫","泽","脑","壤","碳","欧","遍","侧","寨","敢","彻","虑","斜","薄","庭","纳","弹","饲","伸","折","麦","湿","暗","荷","瓦","塞","床","筑","恶","户","访","塔","奇","透","梁","刀","旋","迹","卡","氯","遇","份","毒","泥","退","洗","摆","灰","彩","卖","耗","夏","择","忙","铜","献","硬","予","繁","圈","雪","函","亦","抽","篇","阵","阴","丁","尺","追","堆","雄","迎","泛","爸","楼","避","谋","吨","野","猪","旗","累","偏","典","馆","索","秦","脂","潮","爷","豆","忽","托","惊","塑","遗","愈","朱","替","纤","粗","倾","尚","痛","楚","谢","奋","购","磨","君","池","旁","碎","骨","监","捕","弟","暴","割","贯","殊","释","词","亡","壁","顿","宝","午","尘","闻","揭","炮","残","冬","桥","妇","警","综","招","吴","付","浮","遭","徐","您","摇","谷","赞","箱","隔","订","男","吹","园","纷","唐","败","宋","玻","巨","耕","坦","荣","闭","湾","键","凡","驻","锅","救","恩","剥","凝","碱","齿","截","炼","麻","纺","禁","废","盛","版","缓","净","睛","昌","婚","涉","筒","嘴","插","岸","朗","庄","街","藏","姑","贸","腐","奴","啦","惯","乘","伙","恢","匀","纱","扎","辩","耳","彪","臣","亿","璃","抵","脉","秀","萨","俄","网","舞","店","喷","纵","寸","汗","挂","洪","贺","闪","柬","爆","烯","津","稻","墙","软","勇","像","滚","厘","蒙","芳","肯","坡","柱","荡","腿","仪","旅","尾","轧","冰","贡","登","黎","削","钻","勒","逃","障","氨","郭","峰","币","港","伏","轨","亩","毕","擦","莫","刺","浪","秘","援","株","健","售","股","岛","甘","泡","睡","童","铸","汤","阀","休","汇","舍","牧","绕","炸","哲","磷","绩","朋","淡","尖","启","陷","柴","呈","徒","颜","泪","稍","忘","泵","蓝","拖","洞","授","镜","辛","壮","锋","贫","虚","弯","摩","泰","幼","廷","尊","窗","纲","弄","隶","疑","氏","宫","姐","震","瑞","怪","尤","琴","循","描","膜","违","夹","腰","缘","珠","穷","森","枝","竹","沟","催","绳","忆","邦","剩","幸","浆","栏","拥","牙","贮","礼","滤","钠","纹","罢","拍","咱","喊","袖","埃","勤","罚","焦","潜","伍","墨","欲","缝","姓","刊","饱","仿","奖","铝","鬼","丽","跨","默","挖","链","扫","喝","袋","炭","污","幕","诸","弧","励","梅","奶","洁","灾","舟","鉴","苯","讼","抱","毁","懂","寒","智","埔","寄","届","跃","渡","挑","丹","艰","贝","碰","拔","爹","戴","码","梦","芽","熔","赤","渔","哭","敬","颗","奔","铅","仲","虎","稀","妹","乏","珍","申","桌","遵","允","隆","螺","仓","魏","锐","晓","氮","兼","隐","碍","赫","拨","忠","肃","缸","牵","抢","博","巧","壳","兄","杜","讯","诚","碧","祥","柯","页","巡","矩","悲","灌","龄","伦","票","寻","桂","铺","圣","恐","恰","郑","趣","抬","荒","腾","贴","柔","滴","猛","阔","辆","妻","填","撤","储","签","闹","扰","紫","砂","递","戏","吊","陶","伐","喂","疗","瓶","婆","抚","臂","摸","忍","虾","蜡","邻","胸","巩","挤","偶","弃","槽","劲","乳","邓","吉","仁","烂","砖","租","乌","舰","伴","瓜","浅","丙","暂","燥","橡","柳","迷","暖","牌","秧","胆","详","簧","踏","瓷","谱","呆","宾","糊","洛","辉","愤","竞","隙","怒","粘","乃","绪","肩","籍","敏","涂","熙","皆","侦","悬","掘","享","纠","醒","狂","锁","淀","恨","牲","霸","爬","赏","逆","玩","陵","祝","秒","浙","貌","役","彼","悉","鸭","趋","凤","晨","畜","辈","秩","卵","署","梯","炎","滩","棋","驱","筛","峡","冒","啥","寿","译","浸","泉","帽","迟","硅","疆","贷","漏","稿","冠","嫩","胁","芯","牢","叛","蚀","奥","鸣","岭","羊","凭","串","塘","绘","酵","融","盆","锡","庙","筹","冻","辅","摄","袭","筋","拒","僚","旱","钾","鸟","漆","沈","眉","疏","添","棒","穗","硝","韩","逼","扭","侨","凉","挺","碗","栽","炒","杯","患","馏","劝","豪","辽","勃","鸿","旦","吏","拜","狗","埋","辊","掩","饮","搬","骂","辞","勾","扣","估","蒋","绒","雾","丈","朵","姆","拟","宇","辑","陕","雕","偿","蓄","崇","剪","倡","厅","咬","驶","薯","刷","斥","番","赋","奉","佛","浇","漫","曼","扇","钙","桃","扶","仔","返","俗","亏","腔","鞋","棱","覆","框","悄","叔","撞","骗","勘","旺","沸","孤","吐","孟","渠","屈","疾","妙","惜","仰","狠","胀","谐","抛","霉","桑","岗","嘛","衰","盗","渗","脏","赖","涌","甜","曹","阅","肌","哩","厉","烃","纬","毅","昨","伪","症","煮","叹","钉","搭","茎","笼","酷","偷","弓","锥","恒","杰","坑","鼻","翼","纶","叙","狱","逮","罐","络","棚","抑","膨","蔬","寺","骤","穆","冶","枯","册","尸","凸","绅","坯","牺","焰","轰","欣","晋","瘦","御","锭","锦","丧","旬","锻","垄","搜","扑","邀","亭","酯","迈","舒","脆","酶","闲","忧","酚","顽","羽","涨","卸","仗","陪","辟","惩","杭","姚","肚","捉","飘","漂","昆","欺","吾","郎","烷","汁","呵","饰","萧","雅","邮","迁","燕","撒","姻","赴","宴","烦","债","帐","斑","铃","旨","醇","董","饼","雏","姿","拌","傅","腹","妥","揉","贤","拆","歪","葡","胺","丢","浩","徽","昂","垫","挡","览","贪","慰","缴","汪","慌","冯","诺","姜","谊","凶","劣","诬","耀","昏","躺","盈","骑","乔","溪","丛","卢","抹","闷","咨","刮","驾","缆","悟","摘","铒","掷","颇","幻","柄","惠","惨","佳","仇","腊","窝","涤","剑","瞧","堡","泼","葱","罩","霍","捞","胎","苍","滨","俩","捅","湘","砍","霞","邵","萄","疯","淮","遂","熊","粪","烘","宿","档","戈","驳","嫂","裕","徙","箭","捐","肠","撑","晒","辨","殿","莲","摊","搅","酱","屏","疫","哀","蔡","堵","沫","皱","畅","叠","阁","莱","敲","辖","钩","痕","坝","巷","饿","祸","丘","玄","溜","曰","逻","彭","尝","卿","妨","艇","吞","韦","怨","矮","歇"]')},6102:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\n/**\n * @license\n * https://reviews.bitcoinabc.org\n * Copyright (c) 2017-2020 Emilio Almansi\n * Copyright (c) 2023-2024 Bitcoin ABC\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CHARSET = void 0;\nconst validation_1 = __importDefault(__webpack_require__(3377));\nconst { validate } = validation_1.default;\n/**\n * Base32 encoding and decoding.\n *\n * @module base32\n */\n/**\n * Charset containing the 32 symbols used in the base32 encoding.\n * @private\n */\nexports.CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n/**\n * Inverted index mapping each symbol into its index within the charset.\n * @private\n */\nconst CHARSET_INVERSE_INDEX = {\n    q: 0,\n    p: 1,\n    z: 2,\n    r: 3,\n    y: 4,\n    9: 5,\n    x: 6,\n    8: 7,\n    g: 8,\n    f: 9,\n    2: 10,\n    t: 11,\n    v: 12,\n    d: 13,\n    w: 14,\n    0: 15,\n    s: 16,\n    3: 17,\n    j: 18,\n    n: 19,\n    5: 20,\n    4: 21,\n    k: 22,\n    h: 23,\n    c: 24,\n    e: 25,\n    6: 26,\n    m: 27,\n    u: 28,\n    a: 29,\n    7: 30,\n    l: 31,\n};\n/**\n * Encodes the given array of 5-bit integers as a base32-encoded string.\n *\n * @static\n * @param data Array of integers between 0 and 31 inclusive.\n * @throws {ValidationError}\n */\nfunction encode(data) {\n    validate(data instanceof Uint8Array, 'Invalid data: ' + data + '.');\n    let base32 = '';\n    for (let i = 0; i < data.length; ++i) {\n        const value = data[i];\n        validate(0 <= value && value < 32, 'Invalid value: ' + value + '.');\n        base32 += exports.CHARSET[value];\n    }\n    return base32;\n}\n/**\n * Decodes the given base32-encoded string into an array of 5-bit integers.\n *\n * @static\n * @param string\n * @throws {ValidationError}\n */\nfunction decode(string) {\n    validate(typeof string === 'string', 'Invalid base32-encoded string: ' + string + '.');\n    const data = new Uint8Array(string.length);\n    for (let i = 0; i < string.length; ++i) {\n        const value = string[i];\n        validate(value in CHARSET_INVERSE_INDEX, 'Invalid value: ' + value + '.');\n        data[i] = CHARSET_INVERSE_INDEX[value];\n    }\n    return data;\n}\nexports[\"default\"] = {\n    encode: encode,\n    decode: decode,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEwMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YscUNBQXFDLG1CQUFPLENBQUMsSUFBYztBQUMzRCxRQUFRLFdBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2hhZGRyanMvZGlzdC9iYXNlMzIuanM/N2U4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIGh0dHBzOi8vcmV2aWV3cy5iaXRjb2luYWJjLm9yZ1xuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMjAgRW1pbGlvIEFsbWFuc2lcbiAqIENvcHlyaWdodCAoYykgMjAyMy0yMDI0IEJpdGNvaW4gQUJDXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4gKiBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ0hBUlNFVCA9IHZvaWQgMDtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpKTtcbmNvbnN0IHsgdmFsaWRhdGUgfSA9IHZhbGlkYXRpb25fMS5kZWZhdWx0O1xuLyoqXG4gKiBCYXNlMzIgZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICpcbiAqIEBtb2R1bGUgYmFzZTMyXG4gKi9cbi8qKlxuICogQ2hhcnNldCBjb250YWluaW5nIHRoZSAzMiBzeW1ib2xzIHVzZWQgaW4gdGhlIGJhc2UzMiBlbmNvZGluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuQ0hBUlNFVCA9ICdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCc7XG4vKipcbiAqIEludmVydGVkIGluZGV4IG1hcHBpbmcgZWFjaCBzeW1ib2wgaW50byBpdHMgaW5kZXggd2l0aGluIHRoZSBjaGFyc2V0LlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgQ0hBUlNFVF9JTlZFUlNFX0lOREVYID0ge1xuICAgIHE6IDAsXG4gICAgcDogMSxcbiAgICB6OiAyLFxuICAgIHI6IDMsXG4gICAgeTogNCxcbiAgICA5OiA1LFxuICAgIHg6IDYsXG4gICAgODogNyxcbiAgICBnOiA4LFxuICAgIGY6IDksXG4gICAgMjogMTAsXG4gICAgdDogMTEsXG4gICAgdjogMTIsXG4gICAgZDogMTMsXG4gICAgdzogMTQsXG4gICAgMDogMTUsXG4gICAgczogMTYsXG4gICAgMzogMTcsXG4gICAgajogMTgsXG4gICAgbjogMTksXG4gICAgNTogMjAsXG4gICAgNDogMjEsXG4gICAgazogMjIsXG4gICAgaDogMjMsXG4gICAgYzogMjQsXG4gICAgZTogMjUsXG4gICAgNjogMjYsXG4gICAgbTogMjcsXG4gICAgdTogMjgsXG4gICAgYTogMjksXG4gICAgNzogMzAsXG4gICAgbDogMzEsXG59O1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBhcnJheSBvZiA1LWJpdCBpbnRlZ2VycyBhcyBhIGJhc2UzMi1lbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gZGF0YSBBcnJheSBvZiBpbnRlZ2VycyBiZXR3ZWVuIDAgYW5kIDMxIGluY2x1c2l2ZS5cbiAqIEB0aHJvd3Mge1ZhbGlkYXRpb25FcnJvcn1cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICB2YWxpZGF0ZShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSwgJ0ludmFsaWQgZGF0YTogJyArIGRhdGEgKyAnLicpO1xuICAgIGxldCBiYXNlMzIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2ldO1xuICAgICAgICB2YWxpZGF0ZSgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMzIsICdJbnZhbGlkIHZhbHVlOiAnICsgdmFsdWUgKyAnLicpO1xuICAgICAgICBiYXNlMzIgKz0gZXhwb3J0cy5DSEFSU0VUW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2UzMjtcbn1cbi8qKlxuICogRGVjb2RlcyB0aGUgZ2l2ZW4gYmFzZTMyLWVuY29kZWQgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgNS1iaXQgaW50ZWdlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHN0cmluZ1xuICogQHRocm93cyB7VmFsaWRhdGlvbkVycm9yfVxuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nKSB7XG4gICAgdmFsaWRhdGUodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycsICdJbnZhbGlkIGJhc2UzMi1lbmNvZGVkIHN0cmluZzogJyArIHN0cmluZyArICcuJyk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3RyaW5nW2ldO1xuICAgICAgICB2YWxpZGF0ZSh2YWx1ZSBpbiBDSEFSU0VUX0lOVkVSU0VfSU5ERVgsICdJbnZhbGlkIHZhbHVlOiAnICsgdmFsdWUgKyAnLicpO1xuICAgICAgICBkYXRhW2ldID0gQ0hBUlNFVF9JTlZFUlNFX0lOREVYW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6102\n\n}")},6187:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScriptOpIter = exports.Script = void 0;\nconst varsize_js_1 = __webpack_require__(1451);\nconst writerlength_js_1 = __webpack_require__(7408);\nconst writerbytes_js_1 = __webpack_require__(8161);\nconst hex_js_1 = __webpack_require__(2938);\nconst op_js_1 = __webpack_require__(243);\nconst opcode_js_1 = __webpack_require__(2250);\nconst bytes_js_1 = __webpack_require__(1292);\nconst address_1 = __webpack_require__(3085);\n/** A Bitcoin Script locking/unlocking a UTXO */\nclass Script {\n    /** Create a new Script with the given bytecode or empty */\n    constructor(bytecode) {\n        this.bytecode = bytecode ?? new Uint8Array();\n    }\n    /**\n     * Write the script to the writer with the script size as VARINT\n     * prepended.\n     **/\n    writeWithSize(writer) {\n        (0, varsize_js_1.writeVarSize)(this.bytecode.length, writer);\n        writer.putBytes(this.bytecode);\n    }\n    static readWithSize(bytes) {\n        const size = (0, varsize_js_1.readVarSize)(bytes);\n        return new Script(bytes.readBytes(Number(size)));\n    }\n    /** Build a Script from the given Script Ops */\n    static fromOps(ops) {\n        let scriptSize = 0;\n        for (const op of ops) {\n            const writerLength = new writerlength_js_1.WriterLength();\n            (0, op_js_1.writeOp)(op, writerLength);\n            scriptSize += writerLength.length;\n        }\n        const bytecodeWriter = new writerbytes_js_1.WriterBytes(scriptSize);\n        for (const op of ops) {\n            (0, op_js_1.writeOp)(op, bytecodeWriter);\n        }\n        return new Script(bytecodeWriter.data);\n    }\n    static fromAddress(address) {\n        // make Address from address\n        const thisAddress = address_1.Address.fromCashAddress(address);\n        switch (thisAddress.type) {\n            case 'p2pkh': {\n                return Script.p2pkh((0, hex_js_1.fromHex)(thisAddress.hash));\n            }\n            case 'p2sh': {\n                return Script.p2sh((0, hex_js_1.fromHex)(thisAddress.hash));\n            }\n            default: {\n                // Note we should never get here, as Address constructor\n                // only supports p2pkh and p2sh\n                throw new Error(`Unsupported address type: ${thisAddress.type}`);\n            }\n        }\n    }\n    /** Iterate over the Ops of this Script */\n    ops() {\n        return new ScriptOpIter(new bytes_js_1.Bytes(this.bytecode));\n    }\n    /** Create a deep copy of this Script */\n    copy() {\n        return new Script(new Uint8Array(this.bytecode));\n    }\n    /**\n     * Find the n-th OP_CODESEPARATOR (0-based) and cut out the bytecode\n     * following it. Required for signing BIP143 scripts that have an\n     * OP_CODESEPARATOR.\n     *\n     * Throw an error if the n-th OP_CODESEPARATOR doesn't exist.\n     *\n     * Historically this opcode has been seen as obscure and useless, but in\n     * BIP143 sighash-based covenants, basically every covenant benefits from\n     * its usage, by trimming down the sighash preimage size and thus tx size.\n     *\n     * Really long Scripts will have a big BIP143 preimage, which costs precious\n     * bytes (and the preimage might even go over the 520 pushdata limit).\n     * This can be trimmed down to just one single byte by ending the covenant\n     * in `... OP_CODESEPARATOR OP_CHECKSIG`, in which case the BIP143 signature\n     * algo will cut out everything after the OP_CODESEPARATOR, so only the\n     * OP_CHECKSIG remains.\n     * If the covenant bytecode is 520 or so, this would save 519 bytes.\n     */\n    cutOutCodesep(nCodesep) {\n        const ops = this.ops();\n        let op;\n        let nCodesepsFound = 0;\n        while ((op = ops.next()) !== undefined) {\n            if (op == opcode_js_1.OP_CODESEPARATOR) {\n                if (nCodesepsFound == nCodesep) {\n                    return new Script(this.bytecode.slice(ops.bytes.idx));\n                }\n                nCodesepsFound++;\n            }\n        }\n        throw new Error('OP_CODESEPARATOR not found');\n    }\n    /**\n     * Whether the Script is a P2SH Script.\n     * Matches CScript::IsPayToScriptHash in /src/script/script.h.\n     **/\n    isP2sh() {\n        if (this.bytecode.length != 23) {\n            return false;\n        }\n        return (this.bytecode[0] == opcode_js_1.OP_HASH160 &&\n            this.bytecode[1] == 20 &&\n            this.bytecode[22] == opcode_js_1.OP_EQUAL);\n    }\n    /**\n     * Return hex string of this Script's bytecode\n     */\n    toHex() {\n        return (0, hex_js_1.toHex)(this.bytecode);\n    }\n    /** Build a P2SH script for the given script hash */\n    static p2sh(scriptHash) {\n        if (scriptHash.length !== 20) {\n            throw new Error(`scriptHash length must be 20, got ${scriptHash.length}`);\n        }\n        return Script.fromOps([opcode_js_1.OP_HASH160, (0, op_js_1.pushBytesOp)(scriptHash), opcode_js_1.OP_EQUAL]);\n    }\n    /** Build a P2PKH script for the given public key hash */\n    static p2pkh(pkh) {\n        if (pkh.length !== 20) {\n            throw new Error(`pkh length must be 20, got ${pkh.length}`);\n        }\n        return Script.fromOps([\n            opcode_js_1.OP_DUP,\n            opcode_js_1.OP_HASH160,\n            (0, op_js_1.pushBytesOp)(pkh),\n            opcode_js_1.OP_EQUALVERIFY,\n            opcode_js_1.OP_CHECKSIG,\n        ]);\n    }\n    /** Build a scriptSig for spending a P2PKH output */\n    static p2pkhSpend(pk, sig) {\n        return Script.fromOps([(0, op_js_1.pushBytesOp)(sig), (0, op_js_1.pushBytesOp)(pk)]);\n    }\n}\nexports.Script = Script;\n/** Iterator over the Ops of a Script. */\nclass ScriptOpIter {\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Read the next Op and return it, or `undefined` if there are no more Ops.\n     * Throws an error if reading the next op failed.\n     */\n    next() {\n        if (this.bytes.idx >= this.bytes.data.length) {\n            return undefined;\n        }\n        return (0, op_js_1.readOp)(this.bytes);\n    }\n}\nexports.ScriptOpIter = ScriptOpIter;\n//# sourceMappingURL=script.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjE4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxjQUFjO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLElBQWlCO0FBQzlDLDBCQUEwQixtQkFBTyxDQUFDLElBQXNCO0FBQ3hELHlCQUF5QixtQkFBTyxDQUFDLElBQXFCO0FBQ3RELGlCQUFpQixtQkFBTyxDQUFDLElBQWE7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsR0FBUztBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyxJQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLElBQWU7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsSUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGlCQUFpQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9zY3JpcHQuanM/ZjYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNjcmlwdE9wSXRlciA9IGV4cG9ydHMuU2NyaXB0ID0gdm9pZCAwO1xuY29uc3QgdmFyc2l6ZV9qc18xID0gcmVxdWlyZShcIi4vaW8vdmFyc2l6ZS5qc1wiKTtcbmNvbnN0IHdyaXRlcmxlbmd0aF9qc18xID0gcmVxdWlyZShcIi4vaW8vd3JpdGVybGVuZ3RoLmpzXCIpO1xuY29uc3Qgd3JpdGVyYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuL2lvL3dyaXRlcmJ5dGVzLmpzXCIpO1xuY29uc3QgaGV4X2pzXzEgPSByZXF1aXJlKFwiLi9pby9oZXguanNcIik7XG5jb25zdCBvcF9qc18xID0gcmVxdWlyZShcIi4vb3AuanNcIik7XG5jb25zdCBvcGNvZGVfanNfMSA9IHJlcXVpcmUoXCIuL29wY29kZS5qc1wiKTtcbmNvbnN0IGJ5dGVzX2pzXzEgPSByZXF1aXJlKFwiLi9pby9ieXRlcy5qc1wiKTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3MvYWRkcmVzc1wiKTtcbi8qKiBBIEJpdGNvaW4gU2NyaXB0IGxvY2tpbmcvdW5sb2NraW5nIGEgVVRYTyAqL1xuY2xhc3MgU2NyaXB0IHtcbiAgICAvKiogQ3JlYXRlIGEgbmV3IFNjcmlwdCB3aXRoIHRoZSBnaXZlbiBieXRlY29kZSBvciBlbXB0eSAqL1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVjb2RlKSB7XG4gICAgICAgIHRoaXMuYnl0ZWNvZGUgPSBieXRlY29kZSA/PyBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgc2NyaXB0IHRvIHRoZSB3cml0ZXIgd2l0aCB0aGUgc2NyaXB0IHNpemUgYXMgVkFSSU5UXG4gICAgICogcHJlcGVuZGVkLlxuICAgICAqKi9cbiAgICB3cml0ZVdpdGhTaXplKHdyaXRlcikge1xuICAgICAgICAoMCwgdmFyc2l6ZV9qc18xLndyaXRlVmFyU2l6ZSkodGhpcy5ieXRlY29kZS5sZW5ndGgsIHdyaXRlcik7XG4gICAgICAgIHdyaXRlci5wdXRCeXRlcyh0aGlzLmJ5dGVjb2RlKTtcbiAgICB9XG4gICAgc3RhdGljIHJlYWRXaXRoU2l6ZShieXRlcykge1xuICAgICAgICBjb25zdCBzaXplID0gKDAsIHZhcnNpemVfanNfMS5yZWFkVmFyU2l6ZSkoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gbmV3IFNjcmlwdChieXRlcy5yZWFkQnl0ZXMoTnVtYmVyKHNpemUpKSk7XG4gICAgfVxuICAgIC8qKiBCdWlsZCBhIFNjcmlwdCBmcm9tIHRoZSBnaXZlbiBTY3JpcHQgT3BzICovXG4gICAgc3RhdGljIGZyb21PcHMob3BzKSB7XG4gICAgICAgIGxldCBzY3JpcHRTaXplID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRlckxlbmd0aCA9IG5ldyB3cml0ZXJsZW5ndGhfanNfMS5Xcml0ZXJMZW5ndGgoKTtcbiAgICAgICAgICAgICgwLCBvcF9qc18xLndyaXRlT3ApKG9wLCB3cml0ZXJMZW5ndGgpO1xuICAgICAgICAgICAgc2NyaXB0U2l6ZSArPSB3cml0ZXJMZW5ndGgubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVjb2RlV3JpdGVyID0gbmV3IHdyaXRlcmJ5dGVzX2pzXzEuV3JpdGVyQnl0ZXMoc2NyaXB0U2l6ZSk7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgICAoMCwgb3BfanNfMS53cml0ZU9wKShvcCwgYnl0ZWNvZGVXcml0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2NyaXB0KGJ5dGVjb2RlV3JpdGVyLmRhdGEpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICAvLyBtYWtlIEFkZHJlc3MgZnJvbSBhZGRyZXNzXG4gICAgICAgIGNvbnN0IHRoaXNBZGRyZXNzID0gYWRkcmVzc18xLkFkZHJlc3MuZnJvbUNhc2hBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBzd2l0Y2ggKHRoaXNBZGRyZXNzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3AycGtoJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBTY3JpcHQucDJwa2goKDAsIGhleF9qc18xLmZyb21IZXgpKHRoaXNBZGRyZXNzLmhhc2gpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3Ayc2gnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNjcmlwdC5wMnNoKCgwLCBoZXhfanNfMS5mcm9tSGV4KSh0aGlzQWRkcmVzcy5oYXNoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB3ZSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIGFzIEFkZHJlc3MgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHN1cHBvcnRzIHAycGtoIGFuZCBwMnNoXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhZGRyZXNzIHR5cGU6ICR7dGhpc0FkZHJlc3MudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogSXRlcmF0ZSBvdmVyIHRoZSBPcHMgb2YgdGhpcyBTY3JpcHQgKi9cbiAgICBvcHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NyaXB0T3BJdGVyKG5ldyBieXRlc19qc18xLkJ5dGVzKHRoaXMuYnl0ZWNvZGUpKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGlzIFNjcmlwdCAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NyaXB0KG5ldyBVaW50OEFycmF5KHRoaXMuYnl0ZWNvZGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgbi10aCBPUF9DT0RFU0VQQVJBVE9SICgwLWJhc2VkKSBhbmQgY3V0IG91dCB0aGUgYnl0ZWNvZGVcbiAgICAgKiBmb2xsb3dpbmcgaXQuIFJlcXVpcmVkIGZvciBzaWduaW5nIEJJUDE0MyBzY3JpcHRzIHRoYXQgaGF2ZSBhblxuICAgICAqIE9QX0NPREVTRVBBUkFUT1IuXG4gICAgICpcbiAgICAgKiBUaHJvdyBhbiBlcnJvciBpZiB0aGUgbi10aCBPUF9DT0RFU0VQQVJBVE9SIGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBIaXN0b3JpY2FsbHkgdGhpcyBvcGNvZGUgaGFzIGJlZW4gc2VlbiBhcyBvYnNjdXJlIGFuZCB1c2VsZXNzLCBidXQgaW5cbiAgICAgKiBCSVAxNDMgc2lnaGFzaC1iYXNlZCBjb3ZlbmFudHMsIGJhc2ljYWxseSBldmVyeSBjb3ZlbmFudCBiZW5lZml0cyBmcm9tXG4gICAgICogaXRzIHVzYWdlLCBieSB0cmltbWluZyBkb3duIHRoZSBzaWdoYXNoIHByZWltYWdlIHNpemUgYW5kIHRodXMgdHggc2l6ZS5cbiAgICAgKlxuICAgICAqIFJlYWxseSBsb25nIFNjcmlwdHMgd2lsbCBoYXZlIGEgYmlnIEJJUDE0MyBwcmVpbWFnZSwgd2hpY2ggY29zdHMgcHJlY2lvdXNcbiAgICAgKiBieXRlcyAoYW5kIHRoZSBwcmVpbWFnZSBtaWdodCBldmVuIGdvIG92ZXIgdGhlIDUyMCBwdXNoZGF0YSBsaW1pdCkuXG4gICAgICogVGhpcyBjYW4gYmUgdHJpbW1lZCBkb3duIHRvIGp1c3Qgb25lIHNpbmdsZSBieXRlIGJ5IGVuZGluZyB0aGUgY292ZW5hbnRcbiAgICAgKiBpbiBgLi4uIE9QX0NPREVTRVBBUkFUT1IgT1BfQ0hFQ0tTSUdgLCBpbiB3aGljaCBjYXNlIHRoZSBCSVAxNDMgc2lnbmF0dXJlXG4gICAgICogYWxnbyB3aWxsIGN1dCBvdXQgZXZlcnl0aGluZyBhZnRlciB0aGUgT1BfQ09ERVNFUEFSQVRPUiwgc28gb25seSB0aGVcbiAgICAgKiBPUF9DSEVDS1NJRyByZW1haW5zLlxuICAgICAqIElmIHRoZSBjb3ZlbmFudCBieXRlY29kZSBpcyA1MjAgb3Igc28sIHRoaXMgd291bGQgc2F2ZSA1MTkgYnl0ZXMuXG4gICAgICovXG4gICAgY3V0T3V0Q29kZXNlcChuQ29kZXNlcCkge1xuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLm9wcygpO1xuICAgICAgICBsZXQgb3A7XG4gICAgICAgIGxldCBuQ29kZXNlcHNGb3VuZCA9IDA7XG4gICAgICAgIHdoaWxlICgob3AgPSBvcHMubmV4dCgpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3AgPT0gb3Bjb2RlX2pzXzEuT1BfQ09ERVNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIGlmIChuQ29kZXNlcHNGb3VuZCA9PSBuQ29kZXNlcCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNjcmlwdCh0aGlzLmJ5dGVjb2RlLnNsaWNlKG9wcy5ieXRlcy5pZHgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbkNvZGVzZXBzRm91bmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09QX0NPREVTRVBBUkFUT1Igbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIFNjcmlwdCBpcyBhIFAyU0ggU2NyaXB0LlxuICAgICAqIE1hdGNoZXMgQ1NjcmlwdDo6SXNQYXlUb1NjcmlwdEhhc2ggaW4gL3NyYy9zY3JpcHQvc2NyaXB0LmguXG4gICAgICoqL1xuICAgIGlzUDJzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnl0ZWNvZGUubGVuZ3RoICE9IDIzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmJ5dGVjb2RlWzBdID09IG9wY29kZV9qc18xLk9QX0hBU0gxNjAgJiZcbiAgICAgICAgICAgIHRoaXMuYnl0ZWNvZGVbMV0gPT0gMjAgJiZcbiAgICAgICAgICAgIHRoaXMuYnl0ZWNvZGVbMjJdID09IG9wY29kZV9qc18xLk9QX0VRVUFMKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGhleCBzdHJpbmcgb2YgdGhpcyBTY3JpcHQncyBieXRlY29kZVxuICAgICAqL1xuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gKDAsIGhleF9qc18xLnRvSGV4KSh0aGlzLmJ5dGVjb2RlKTtcbiAgICB9XG4gICAgLyoqIEJ1aWxkIGEgUDJTSCBzY3JpcHQgZm9yIHRoZSBnaXZlbiBzY3JpcHQgaGFzaCAqL1xuICAgIHN0YXRpYyBwMnNoKHNjcmlwdEhhc2gpIHtcbiAgICAgICAgaWYgKHNjcmlwdEhhc2gubGVuZ3RoICE9PSAyMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY3JpcHRIYXNoIGxlbmd0aCBtdXN0IGJlIDIwLCBnb3QgJHtzY3JpcHRIYXNoLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2NyaXB0LmZyb21PcHMoW29wY29kZV9qc18xLk9QX0hBU0gxNjAsICgwLCBvcF9qc18xLnB1c2hCeXRlc09wKShzY3JpcHRIYXNoKSwgb3Bjb2RlX2pzXzEuT1BfRVFVQUxdKTtcbiAgICB9XG4gICAgLyoqIEJ1aWxkIGEgUDJQS0ggc2NyaXB0IGZvciB0aGUgZ2l2ZW4gcHVibGljIGtleSBoYXNoICovXG4gICAgc3RhdGljIHAycGtoKHBraCkge1xuICAgICAgICBpZiAocGtoLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGtoIGxlbmd0aCBtdXN0IGJlIDIwLCBnb3QgJHtwa2gubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTY3JpcHQuZnJvbU9wcyhbXG4gICAgICAgICAgICBvcGNvZGVfanNfMS5PUF9EVVAsXG4gICAgICAgICAgICBvcGNvZGVfanNfMS5PUF9IQVNIMTYwLFxuICAgICAgICAgICAgKDAsIG9wX2pzXzEucHVzaEJ5dGVzT3ApKHBraCksXG4gICAgICAgICAgICBvcGNvZGVfanNfMS5PUF9FUVVBTFZFUklGWSxcbiAgICAgICAgICAgIG9wY29kZV9qc18xLk9QX0NIRUNLU0lHLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqIEJ1aWxkIGEgc2NyaXB0U2lnIGZvciBzcGVuZGluZyBhIFAyUEtIIG91dHB1dCAqL1xuICAgIHN0YXRpYyBwMnBraFNwZW5kKHBrLCBzaWcpIHtcbiAgICAgICAgcmV0dXJuIFNjcmlwdC5mcm9tT3BzKFsoMCwgb3BfanNfMS5wdXNoQnl0ZXNPcCkoc2lnKSwgKDAsIG9wX2pzXzEucHVzaEJ5dGVzT3ApKHBrKV0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NyaXB0ID0gU2NyaXB0O1xuLyoqIEl0ZXJhdG9yIG92ZXIgdGhlIE9wcyBvZiBhIFNjcmlwdC4gKi9cbmNsYXNzIFNjcmlwdE9wSXRlciB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBuZXh0IE9wIGFuZCByZXR1cm4gaXQsIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGFyZSBubyBtb3JlIE9wcy5cbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgcmVhZGluZyB0aGUgbmV4dCBvcCBmYWlsZWQuXG4gICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnl0ZXMuaWR4ID49IHRoaXMuYnl0ZXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBvcF9qc18xLnJlYWRPcCkodGhpcy5ieXRlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5TY3JpcHRPcEl0ZXIgPSBTY3JpcHRPcEl0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JpcHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6187\n\n}")},6237:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\nmodule.exports = Reader;\n\nvar util      = __webpack_require__(3610);\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== "undefined"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error("illegal buffer");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error("illegal buffer");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error("invalid varint encoding");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others\' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === "number") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error("invalid wire type " + wireType + " at offset " + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzPzIxMTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlclJlYWRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWFkZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xufVxuXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV90eXBlZF9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfTtcblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZV9hcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfSkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGNyZWF0ZV9hcnJheTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKiBAcmV0dXJucyB7UmVhZGVyfEJ1ZmZlclJlYWRlcn0gQSB7QGxpbmsgQnVmZmVyUmVhZGVyfSBpZiBgYnVmZmVyYCBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGEge0BsaW5rIFJlYWRlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgYnVmZmVyYCBpcyBub3QgYSB2YWxpZCBidWZmZXJcbiAqL1xuUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG5SZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IChmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcbiAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1OyAvLyBvcHRpbWl6ZXIgdHlwZS1oaW50LCB0ZW5kcyB0byBkZW9wdCBvdGhlcndpc2UgKD8hKVxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcbiAgICAgICAgdmFsdWUgPSAoICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3NdICYgMTI3ICAgICAgICkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8ICA3KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAgMTUpIDw8IDI4KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHJlYWRfaW50MzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XG4gICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpIHtcbiAgICAvLyB0ZW5kcyB0byBkZW9wdCB3aXRoIGxvY2FsIHZhcnMgZm9yIG9jdGV0IGV0Yy5cbiAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGxvKVxuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgLy8gMXN0Li40dGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA1dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjgpID4+PiAwO1xuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiAgNCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gMXN0Li4zdGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA0dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAoaGkpXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciN1aW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjc2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIGJvb2xlYW4uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgIT09IDA7XG59O1xuXG5mdW5jdGlvbiByZWFkRml4ZWQzMl9lbmQoYnVmLCBlbmQpIHsgLy8gbm90ZSB0aGF0IHRoaXMgdXNlcyBgZW5kYCwgbm90IGBwb3NgXG4gICAgcmV0dXJuIChidWZbZW5kIC0gNF1cbiAgICAgICAgICB8IGJ1ZltlbmQgLSAzXSA8PCA4XG4gICAgICAgICAgfCBidWZbZW5kIC0gMl0gPDwgMTZcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XG59XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbn07XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhIHNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkRml4ZWQ2NCgvKiB0aGlzOiBSZWFkZXIgKi8pIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xuXG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIHppZy16YWcgZW5jb2RlZCBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI3NmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIGZsb2F0ICgzMiBiaXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gcmVhZF9kb3VibGUoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gcmVhZF9ieXRlcygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSxcbiAgICAgICAgc3RhcnQgID0gdGhpcy5wb3MsXG4gICAgICAgIGVuZCAgICA9IHRoaXMucG9zICsgbGVuZ3RoO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVuZCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcblxuICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpIC8vIHBsYWluIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gc3RhcnQgPT09IGVuZCAvLyBmaXggZm9yIElFIDEwL1dpbjggYW5kIG90aGVycycgc3ViYXJyYXkgcmV0dXJuaW5nIGFycmF5IG9mIHNpemUgMVxuICAgICAgICA/IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKVxuICAgICAgICA6IHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHN0cmluZyBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcyBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBza2lwcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHdpcmUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcblxuICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBcInRvTnVtYmVyXCI7XG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XG5cbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6237\n\n}')},6247:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.__setPkc = exports.PkcAlgo = void 0;\n/** Algorithm instance for public key cryptography */\nclass PkcAlgo {\n    constructor(params) {\n        this.algoOid = params.algoOid;\n        this.params = params.params;\n    }\n    /**\n     * Return a PkcAlgo instance for the given algorithm OID and\n     * elliptic curve params (undefined for RSA).\n     * Throw an exception if the given algo is not supported, otherwise do nothing.\n     */\n    static fromOid(algoOid, params) {\n        try {\n            PKC.algoSupported(algoOid, params);\n        }\n        catch (ex) {\n            throw new Error(ex);\n        }\n        return new PkcAlgo({ algoOid, params });\n    }\n    /**\n     * Verify a signature for the given cryptographic algorithm.\n     * Intended to be used in X509 certificate verification.\n     * Throw an exception if the algorithm is not supported.\n     */\n    verify(sig, msg, pk) {\n        try {\n            PKC.verify(this.algoOid, this.params, sig, msg, pk);\n        }\n        catch (ex) {\n            throw new Error(ex);\n        }\n    }\n}\nexports.PkcAlgo = PkcAlgo;\nconst PKC = {};\nfunction __setPkc(pkc) {\n    PKC.verify = pkc.verify;\n    PKC.algoSupported = pkc.algoSupported;\n}\nexports.__setPkc = __setPkc;\n//# sourceMappingURL=publicKeyCrypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI0Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L3B1YmxpY0tleUNyeXB0by5qcz8yMDAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI1IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX19zZXRQa2MgPSBleHBvcnRzLlBrY0FsZ28gPSB2b2lkIDA7XG4vKiogQWxnb3JpdGhtIGluc3RhbmNlIGZvciBwdWJsaWMga2V5IGNyeXB0b2dyYXBoeSAqL1xuY2xhc3MgUGtjQWxnbyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYWxnb09pZCA9IHBhcmFtcy5hbGdvT2lkO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcy5wYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIFBrY0FsZ28gaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhbGdvcml0aG0gT0lEIGFuZFxuICAgICAqIGVsbGlwdGljIGN1cnZlIHBhcmFtcyAodW5kZWZpbmVkIGZvciBSU0EpLlxuICAgICAqIFRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgZ2l2ZW4gYWxnbyBpcyBub3Qgc3VwcG9ydGVkLCBvdGhlcndpc2UgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU9pZChhbGdvT2lkLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFBLQy5hbGdvU3VwcG9ydGVkKGFsZ29PaWQsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGtjQWxnbyh7IGFsZ29PaWQsIHBhcmFtcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGEgc2lnbmF0dXJlIGZvciB0aGUgZ2l2ZW4gY3J5cHRvZ3JhcGhpYyBhbGdvcml0aG0uXG4gICAgICogSW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBYNTA5IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbi5cbiAgICAgKiBUaHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIGFsZ29yaXRobSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHZlcmlmeShzaWcsIG1zZywgcGspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFBLQy52ZXJpZnkodGhpcy5hbGdvT2lkLCB0aGlzLnBhcmFtcywgc2lnLCBtc2csIHBrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBrY0FsZ28gPSBQa2NBbGdvO1xuY29uc3QgUEtDID0ge307XG5mdW5jdGlvbiBfX3NldFBrYyhwa2MpIHtcbiAgICBQS0MudmVyaWZ5ID0gcGtjLnZlcmlmeTtcbiAgICBQS0MuYWxnb1N1cHBvcnRlZCA9IHBrYy5hbGdvU3VwcG9ydGVkO1xufVxuZXhwb3J0cy5fX3NldFBrYyA9IF9fc2V0UGtjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljS2V5Q3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6247\n\n}')},6314:module=>{"use strict";eval('{\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += "}";\n      }\n      if (item[2]) {\n        content += "}";\n      }\n      if (item[4]) {\n        content += "}";\n      }\n      return content;\n    }).join("");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMxNC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0ZBQXNGLHFCQUFxQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTtcblxuICAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGxpc3Q7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6314\n\n}')},6320:module=>{"use strict";eval("{\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nvar dijkstra = {\n  single_source_shortest_paths: function(graph, s, d) {\n    // Predecessor map for each node that has been encountered.\n    // node ID => predecessor node ID\n    var predecessors = {};\n\n    // Costs of shortest paths from s to all nodes encountered.\n    // node ID => cost\n    var costs = {};\n    costs[s] = 0;\n\n    // Costs of shortest paths from s to all nodes encountered; differs from\n    // `costs` in that it provides easy access to the node that currently has\n    // the known shortest path from s.\n    // XXX: Do we actually need both `costs` and `open`?\n    var open = dijkstra.PriorityQueue.make();\n    open.push(s, 0);\n\n    var closest,\n        u, v,\n        cost_of_s_to_u,\n        adjacent_nodes,\n        cost_of_e,\n        cost_of_s_to_u_plus_cost_of_e,\n        cost_of_s_to_v,\n        first_visit;\n    while (!open.empty()) {\n      // In the nodes remaining in graph that have a known cost from s,\n      // find the node, u, that currently has the shortest path from s.\n      closest = open.pop();\n      u = closest.value;\n      cost_of_s_to_u = closest.cost;\n\n      // Get nodes adjacent to u...\n      adjacent_nodes = graph[u] || {};\n\n      // ...and explore the edges that connect u to those nodes, updating\n      // the cost of the shortest paths to any or all of those nodes as\n      // necessary. v is the node across the current edge from u.\n      for (v in adjacent_nodes) {\n        if (adjacent_nodes.hasOwnProperty(v)) {\n          // Get the cost of the edge running from u to v.\n          cost_of_e = adjacent_nodes[v];\n\n          // Cost of s to u plus the cost of u to v across e--this is *a*\n          // cost from s to v that may or may not be less than the current\n          // known cost to v.\n          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n          // If we haven't visited v yet OR if the current known cost from s to\n          // v is greater than the new cost we just found (cost of s to u plus\n          // cost of u to v across e), update v's cost in the cost list and\n          // update v's predecessor in the predecessor list (it's now u).\n          cost_of_s_to_v = costs[v];\n          first_visit = (typeof costs[v] === 'undefined');\n          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n            open.push(v, cost_of_s_to_u_plus_cost_of_e);\n            predecessors[v] = u;\n          }\n        }\n      }\n    }\n\n    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n      throw new Error(msg);\n    }\n\n    return predecessors;\n  },\n\n  extract_shortest_path_from_predecessor_list: function(predecessors, d) {\n    var nodes = [];\n    var u = d;\n    var predecessor;\n    while (u) {\n      nodes.push(u);\n      predecessor = predecessors[u];\n      u = predecessors[u];\n    }\n    nodes.reverse();\n    return nodes;\n  },\n\n  find_path: function(graph, s, d) {\n    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n    return dijkstra.extract_shortest_path_from_predecessor_list(\n      predecessors, d);\n  },\n\n  /**\n   * A very naive priority queue implementation.\n   */\n  PriorityQueue: {\n    make: function (opts) {\n      var T = dijkstra.PriorityQueue,\n          t = {},\n          key;\n      opts = opts || {};\n      for (key in T) {\n        if (T.hasOwnProperty(key)) {\n          t[key] = T[key];\n        }\n      }\n      t.queue = [];\n      t.sorter = opts.sorter || T.default_sorter;\n      return t;\n    },\n\n    default_sorter: function (a, b) {\n      return a.cost - b.cost;\n    },\n\n    /**\n     * Add a new item to the queue and ensure the highest priority element\n     * is at the front of the queue.\n     */\n    push: function (value, cost) {\n      var item = {value: value, cost: cost};\n      this.queue.push(item);\n      this.queue.sort(this.sorter);\n    },\n\n    /**\n     * Return the highest priority element in the queue.\n     */\n    pop: function () {\n      return this.queue.shift();\n    },\n\n    empty: function () {\n      return this.queue.length === 0;\n    }\n  }\n};\n\n\n// node.js module exports\nif (true) {\n  module.exports = dijkstra;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMyMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9kaWprc3RyYWpzL2RpamtzdHJhLmpzPzEwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDcmVhdGVkIDIwMDgtMDgtMTkuXG4gKlxuICogRGlqa3N0cmEgcGF0aC1maW5kaW5nIGZ1bmN0aW9ucy4gQWRhcHRlZCBmcm9tIHRoZSBEaWprc3RhciBQeXRob24gcHJvamVjdC5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDhcbiAqICAgV3lhdHQgQmFsZHdpbiA8c2VsZkB3eWF0dGJhbGR3aW4uY29tPlxuICogICBBbGwgcmlnaHRzIHJlc2VydmVkXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBkaWprc3RyYSA9IHtcbiAgc2luZ2xlX3NvdXJjZV9zaG9ydGVzdF9wYXRoczogZnVuY3Rpb24oZ3JhcGgsIHMsIGQpIHtcbiAgICAvLyBQcmVkZWNlc3NvciBtYXAgZm9yIGVhY2ggbm9kZSB0aGF0IGhhcyBiZWVuIGVuY291bnRlcmVkLlxuICAgIC8vIG5vZGUgSUQgPT4gcHJlZGVjZXNzb3Igbm9kZSBJRFxuICAgIHZhciBwcmVkZWNlc3NvcnMgPSB7fTtcblxuICAgIC8vIENvc3RzIG9mIHNob3J0ZXN0IHBhdGhzIGZyb20gcyB0byBhbGwgbm9kZXMgZW5jb3VudGVyZWQuXG4gICAgLy8gbm9kZSBJRCA9PiBjb3N0XG4gICAgdmFyIGNvc3RzID0ge307XG4gICAgY29zdHNbc10gPSAwO1xuXG4gICAgLy8gQ29zdHMgb2Ygc2hvcnRlc3QgcGF0aHMgZnJvbSBzIHRvIGFsbCBub2RlcyBlbmNvdW50ZXJlZDsgZGlmZmVycyBmcm9tXG4gICAgLy8gYGNvc3RzYCBpbiB0aGF0IGl0IHByb3ZpZGVzIGVhc3kgYWNjZXNzIHRvIHRoZSBub2RlIHRoYXQgY3VycmVudGx5IGhhc1xuICAgIC8vIHRoZSBrbm93biBzaG9ydGVzdCBwYXRoIGZyb20gcy5cbiAgICAvLyBYWFg6IERvIHdlIGFjdHVhbGx5IG5lZWQgYm90aCBgY29zdHNgIGFuZCBgb3BlbmA/XG4gICAgdmFyIG9wZW4gPSBkaWprc3RyYS5Qcmlvcml0eVF1ZXVlLm1ha2UoKTtcbiAgICBvcGVuLnB1c2gocywgMCk7XG5cbiAgICB2YXIgY2xvc2VzdCxcbiAgICAgICAgdSwgdixcbiAgICAgICAgY29zdF9vZl9zX3RvX3UsXG4gICAgICAgIGFkamFjZW50X25vZGVzLFxuICAgICAgICBjb3N0X29mX2UsXG4gICAgICAgIGNvc3Rfb2Zfc190b191X3BsdXNfY29zdF9vZl9lLFxuICAgICAgICBjb3N0X29mX3NfdG9fdixcbiAgICAgICAgZmlyc3RfdmlzaXQ7XG4gICAgd2hpbGUgKCFvcGVuLmVtcHR5KCkpIHtcbiAgICAgIC8vIEluIHRoZSBub2RlcyByZW1haW5pbmcgaW4gZ3JhcGggdGhhdCBoYXZlIGEga25vd24gY29zdCBmcm9tIHMsXG4gICAgICAvLyBmaW5kIHRoZSBub2RlLCB1LCB0aGF0IGN1cnJlbnRseSBoYXMgdGhlIHNob3J0ZXN0IHBhdGggZnJvbSBzLlxuICAgICAgY2xvc2VzdCA9IG9wZW4ucG9wKCk7XG4gICAgICB1ID0gY2xvc2VzdC52YWx1ZTtcbiAgICAgIGNvc3Rfb2Zfc190b191ID0gY2xvc2VzdC5jb3N0O1xuXG4gICAgICAvLyBHZXQgbm9kZXMgYWRqYWNlbnQgdG8gdS4uLlxuICAgICAgYWRqYWNlbnRfbm9kZXMgPSBncmFwaFt1XSB8fCB7fTtcblxuICAgICAgLy8gLi4uYW5kIGV4cGxvcmUgdGhlIGVkZ2VzIHRoYXQgY29ubmVjdCB1IHRvIHRob3NlIG5vZGVzLCB1cGRhdGluZ1xuICAgICAgLy8gdGhlIGNvc3Qgb2YgdGhlIHNob3J0ZXN0IHBhdGhzIHRvIGFueSBvciBhbGwgb2YgdGhvc2Ugbm9kZXMgYXNcbiAgICAgIC8vIG5lY2Vzc2FyeS4gdiBpcyB0aGUgbm9kZSBhY3Jvc3MgdGhlIGN1cnJlbnQgZWRnZSBmcm9tIHUuXG4gICAgICBmb3IgKHYgaW4gYWRqYWNlbnRfbm9kZXMpIHtcbiAgICAgICAgaWYgKGFkamFjZW50X25vZGVzLmhhc093blByb3BlcnR5KHYpKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBjb3N0IG9mIHRoZSBlZGdlIHJ1bm5pbmcgZnJvbSB1IHRvIHYuXG4gICAgICAgICAgY29zdF9vZl9lID0gYWRqYWNlbnRfbm9kZXNbdl07XG5cbiAgICAgICAgICAvLyBDb3N0IG9mIHMgdG8gdSBwbHVzIHRoZSBjb3N0IG9mIHUgdG8gdiBhY3Jvc3MgZS0tdGhpcyBpcyAqYSpcbiAgICAgICAgICAvLyBjb3N0IGZyb20gcyB0byB2IHRoYXQgbWF5IG9yIG1heSBub3QgYmUgbGVzcyB0aGFuIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8ga25vd24gY29zdCB0byB2LlxuICAgICAgICAgIGNvc3Rfb2Zfc190b191X3BsdXNfY29zdF9vZl9lID0gY29zdF9vZl9zX3RvX3UgKyBjb3N0X29mX2U7XG5cbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHZpc2l0ZWQgdiB5ZXQgT1IgaWYgdGhlIGN1cnJlbnQga25vd24gY29zdCBmcm9tIHMgdG9cbiAgICAgICAgICAvLyB2IGlzIGdyZWF0ZXIgdGhhbiB0aGUgbmV3IGNvc3Qgd2UganVzdCBmb3VuZCAoY29zdCBvZiBzIHRvIHUgcGx1c1xuICAgICAgICAgIC8vIGNvc3Qgb2YgdSB0byB2IGFjcm9zcyBlKSwgdXBkYXRlIHYncyBjb3N0IGluIHRoZSBjb3N0IGxpc3QgYW5kXG4gICAgICAgICAgLy8gdXBkYXRlIHYncyBwcmVkZWNlc3NvciBpbiB0aGUgcHJlZGVjZXNzb3IgbGlzdCAoaXQncyBub3cgdSkuXG4gICAgICAgICAgY29zdF9vZl9zX3RvX3YgPSBjb3N0c1t2XTtcbiAgICAgICAgICBmaXJzdF92aXNpdCA9ICh0eXBlb2YgY29zdHNbdl0gPT09ICd1bmRlZmluZWQnKTtcbiAgICAgICAgICBpZiAoZmlyc3RfdmlzaXQgfHwgY29zdF9vZl9zX3RvX3YgPiBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZSkge1xuICAgICAgICAgICAgY29zdHNbdl0gPSBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZTtcbiAgICAgICAgICAgIG9wZW4ucHVzaCh2LCBjb3N0X29mX3NfdG9fdV9wbHVzX2Nvc3Rfb2ZfZSk7XG4gICAgICAgICAgICBwcmVkZWNlc3NvcnNbdl0gPSB1O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvc3RzW2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIG1zZyA9IFsnQ291bGQgbm90IGZpbmQgYSBwYXRoIGZyb20gJywgcywgJyB0byAnLCBkLCAnLiddLmpvaW4oJycpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWRlY2Vzc29ycztcbiAgfSxcblxuICBleHRyYWN0X3Nob3J0ZXN0X3BhdGhfZnJvbV9wcmVkZWNlc3Nvcl9saXN0OiBmdW5jdGlvbihwcmVkZWNlc3NvcnMsIGQpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgdSA9IGQ7XG4gICAgdmFyIHByZWRlY2Vzc29yO1xuICAgIHdoaWxlICh1KSB7XG4gICAgICBub2Rlcy5wdXNoKHUpO1xuICAgICAgcHJlZGVjZXNzb3IgPSBwcmVkZWNlc3NvcnNbdV07XG4gICAgICB1ID0gcHJlZGVjZXNzb3JzW3VdO1xuICAgIH1cbiAgICBub2Rlcy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9LFxuXG4gIGZpbmRfcGF0aDogZnVuY3Rpb24oZ3JhcGgsIHMsIGQpIHtcbiAgICB2YXIgcHJlZGVjZXNzb3JzID0gZGlqa3N0cmEuc2luZ2xlX3NvdXJjZV9zaG9ydGVzdF9wYXRocyhncmFwaCwgcywgZCk7XG4gICAgcmV0dXJuIGRpamtzdHJhLmV4dHJhY3Rfc2hvcnRlc3RfcGF0aF9mcm9tX3ByZWRlY2Vzc29yX2xpc3QoXG4gICAgICBwcmVkZWNlc3NvcnMsIGQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBIHZlcnkgbmFpdmUgcHJpb3JpdHkgcXVldWUgaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICBQcmlvcml0eVF1ZXVlOiB7XG4gICAgbWFrZTogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgIHZhciBUID0gZGlqa3N0cmEuUHJpb3JpdHlRdWV1ZSxcbiAgICAgICAgICB0ID0ge30sXG4gICAgICAgICAga2V5O1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICBmb3IgKGtleSBpbiBUKSB7XG4gICAgICAgIGlmIChULmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB0W2tleV0gPSBUW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHQucXVldWUgPSBbXTtcbiAgICAgIHQuc29ydGVyID0gb3B0cy5zb3J0ZXIgfHwgVC5kZWZhdWx0X3NvcnRlcjtcbiAgICAgIHJldHVybiB0O1xuICAgIH0sXG5cbiAgICBkZWZhdWx0X3NvcnRlcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmNvc3QgLSBiLmNvc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBpdGVtIHRvIHRoZSBxdWV1ZSBhbmQgZW5zdXJlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGVsZW1lbnRcbiAgICAgKiBpcyBhdCB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlLlxuICAgICAqL1xuICAgIHB1c2g6IGZ1bmN0aW9uICh2YWx1ZSwgY29zdCkge1xuICAgICAgdmFyIGl0ZW0gPSB7dmFsdWU6IHZhbHVlLCBjb3N0OiBjb3N0fTtcbiAgICAgIHRoaXMucXVldWUucHVzaChpdGVtKTtcbiAgICAgIHRoaXMucXVldWUuc29ydCh0aGlzLnNvcnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgaGlnaGVzdCBwcmlvcml0eSBlbGVtZW50IGluIHRoZSBxdWV1ZS5cbiAgICAgKi9cbiAgICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgfSxcblxuICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPT09IDA7XG4gICAgfVxuICB9XG59O1xuXG5cbi8vIG5vZGUuanMgbW9kdWxlIGV4cG9ydHNcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6320\n\n}")},6420:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mnemonicToSeed = exports.mnemonicToEntropy = exports.entropyToMnemonic = void 0;\nconst hash_1 = __webpack_require__(5632);\nconst str_js_1 = __webpack_require__(2392);\nconst pbkdf2_1 = __webpack_require__(1921);\nconst BITS_PER_BYTE = 8;\nconst BITS_PER_WORD = 11;\nconst BITS_PER_CHECKSUM_BIT = 32;\n// Calculate how many bits there are in the mnemonic\nfunction calcNumChecksumBits(numEntropyBytes) {\n    return (numEntropyBytes * BITS_PER_BYTE) / BITS_PER_CHECKSUM_BIT;\n}\n// Normalize according to unicode standard\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\n// Turn the password into a salt for seed generation\nfunction salt(password) {\n    return 'mnemonic' + (password || '');\n}\n/** Derive the mnemonic from entropy */\nfunction entropyToMnemonic(entropy, wordlist) {\n    if (entropy.length < 16 || entropy.length > 32) {\n        throw new TypeError('Entropy must be between 16 and 32 bytes long');\n    }\n    if (entropy.length % 4 !== 0) {\n        throw new TypeError('Entropy length must be divisible by 4');\n    }\n    const checksum = (0, hash_1.sha256)(entropy);\n    const data = new Uint8Array(entropy.length + checksum.length);\n    data.set(entropy, 0);\n    data.set(checksum, entropy.length);\n    let nextBits = 0;\n    let numBits = 0;\n    let numLeftoverBits = entropy.length * BITS_PER_BYTE + calcNumChecksumBits(entropy.length);\n    const words = [];\n    for (const byte of data) {\n        nextBits = (nextBits << BITS_PER_BYTE) | byte;\n        numBits += BITS_PER_BYTE;\n        if (numBits >= BITS_PER_WORD) {\n            const wordIdx = nextBits >> (numBits - BITS_PER_WORD);\n            words.push(wordlist.words[wordIdx]);\n            if (numLeftoverBits <= BITS_PER_WORD) {\n                break;\n            }\n            numBits -= BITS_PER_WORD;\n            numLeftoverBits -= BITS_PER_WORD;\n            nextBits &= 0x7ff >> (BITS_PER_WORD - numBits);\n        }\n    }\n    return words.join(wordlist.separator);\n}\nexports.entropyToMnemonic = entropyToMnemonic;\n/** Recover the entropy from the mnemonic */\nfunction mnemonicToEntropy(phrase, wordlist) {\n    const words = normalize(phrase).split(' ');\n    if (words.length < 12 || words.length > 24) {\n        throw new Error('Number of words in mnemonic phrase must be between 12 and 24');\n    }\n    if (words.length % 3 !== 0) {\n        throw new Error('Number of words in mnemonic phrase must be divisible by 3');\n    }\n    const wordIndices = words.map(word => {\n        const idx = wordlist.indexOf(word);\n        if (idx === -1) {\n            throw new Error('Invalid mnemonic phrase word: ' + word);\n        }\n        return idx;\n    });\n    const numEntropyBytes = (wordIndices.length / 3) * 4;\n    let nextBits = 0;\n    let numBits = 0;\n    let idx = 0;\n    const entropy = new Uint8Array(numEntropyBytes);\n    let checksum = 0;\n    for (const wordIdx of wordIndices) {\n        nextBits = (nextBits << BITS_PER_WORD) | wordIdx;\n        numBits += BITS_PER_WORD;\n        while (numBits >= BITS_PER_BYTE) {\n            const byte = nextBits >> (numBits - BITS_PER_BYTE);\n            if (idx < entropy.length) {\n                entropy[idx] = byte;\n            }\n            else {\n                checksum = (checksum << BITS_PER_BYTE) | byte;\n            }\n            idx++;\n            numBits -= BITS_PER_BYTE;\n            nextBits &= 0xffff >> (16 - numBits);\n        }\n    }\n    if (numBits != 0) {\n        checksum = (checksum << BITS_PER_BYTE) | nextBits;\n    }\n    const entropyHash = (0, hash_1.sha256)(entropy);\n    const numChecksumBits = calcNumChecksumBits(numEntropyBytes);\n    const expectedChecksum = entropyHash[0] >> (BITS_PER_BYTE - numChecksumBits);\n    if (checksum != expectedChecksum) {\n        const expected = expectedChecksum.toString(16);\n        const actual = checksum.toString(16);\n        throw new Error(`Invalid checksum: expected ${expected}, got ${actual}`);\n    }\n    return entropy;\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\n/** Derive the seed bytes from the mnemonic */\nfunction mnemonicToSeed(phrase, password) {\n    return (0, pbkdf2_1.pbkdf2)({\n        hashFactory: hash_1.sha512Hasher,\n        password: (0, str_js_1.strToBytes)(normalize(phrase)),\n        salt: (0, str_js_1.strToBytes)(salt(normalize(password))),\n        blockLength: 128,\n        outputLength: 64,\n        dkLen: 64,\n        iterations: 2048,\n    });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\n//# sourceMappingURL=mnemonic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQyMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDOUUsZUFBZSxtQkFBTyxDQUFDLElBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsSUFBYTtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVMsUUFBUSxPQUFPO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvbW5lbW9uaWMuanM/NzEyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNSBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1uZW1vbmljVG9TZWVkID0gZXhwb3J0cy5tbmVtb25pY1RvRW50cm9weSA9IGV4cG9ydHMuZW50cm9weVRvTW5lbW9uaWMgPSB2b2lkIDA7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuY29uc3Qgc3RyX2pzXzEgPSByZXF1aXJlKFwiLi9pby9zdHIuanNcIik7XG5jb25zdCBwYmtkZjJfMSA9IHJlcXVpcmUoXCIuL3Bia2RmMlwiKTtcbmNvbnN0IEJJVFNfUEVSX0JZVEUgPSA4O1xuY29uc3QgQklUU19QRVJfV09SRCA9IDExO1xuY29uc3QgQklUU19QRVJfQ0hFQ0tTVU1fQklUID0gMzI7XG4vLyBDYWxjdWxhdGUgaG93IG1hbnkgYml0cyB0aGVyZSBhcmUgaW4gdGhlIG1uZW1vbmljXG5mdW5jdGlvbiBjYWxjTnVtQ2hlY2tzdW1CaXRzKG51bUVudHJvcHlCeXRlcykge1xuICAgIHJldHVybiAobnVtRW50cm9weUJ5dGVzICogQklUU19QRVJfQllURSkgLyBCSVRTX1BFUl9DSEVDS1NVTV9CSVQ7XG59XG4vLyBOb3JtYWxpemUgYWNjb3JkaW5nIHRvIHVuaWNvZGUgc3RhbmRhcmRcbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gKHN0ciB8fCAnJykubm9ybWFsaXplKCdORktEJyk7XG59XG4vLyBUdXJuIHRoZSBwYXNzd29yZCBpbnRvIGEgc2FsdCBmb3Igc2VlZCBnZW5lcmF0aW9uXG5mdW5jdGlvbiBzYWx0KHBhc3N3b3JkKSB7XG4gICAgcmV0dXJuICdtbmVtb25pYycgKyAocGFzc3dvcmQgfHwgJycpO1xufVxuLyoqIERlcml2ZSB0aGUgbW5lbW9uaWMgZnJvbSBlbnRyb3B5ICovXG5mdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgIGlmIChlbnRyb3B5Lmxlbmd0aCA8IDE2IHx8IGVudHJvcHkubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW50cm9weSBtdXN0IGJlIGJldHdlZW4gMTYgYW5kIDMyIGJ5dGVzIGxvbmcnKTtcbiAgICB9XG4gICAgaWYgKGVudHJvcHkubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbnRyb3B5IGxlbmd0aCBtdXN0IGJlIGRpdmlzaWJsZSBieSA0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrc3VtID0gKDAsIGhhc2hfMS5zaGEyNTYpKGVudHJvcHkpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShlbnRyb3B5Lmxlbmd0aCArIGNoZWNrc3VtLmxlbmd0aCk7XG4gICAgZGF0YS5zZXQoZW50cm9weSwgMCk7XG4gICAgZGF0YS5zZXQoY2hlY2tzdW0sIGVudHJvcHkubGVuZ3RoKTtcbiAgICBsZXQgbmV4dEJpdHMgPSAwO1xuICAgIGxldCBudW1CaXRzID0gMDtcbiAgICBsZXQgbnVtTGVmdG92ZXJCaXRzID0gZW50cm9weS5sZW5ndGggKiBCSVRTX1BFUl9CWVRFICsgY2FsY051bUNoZWNrc3VtQml0cyhlbnRyb3B5Lmxlbmd0aCk7XG4gICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgZGF0YSkge1xuICAgICAgICBuZXh0Qml0cyA9IChuZXh0Qml0cyA8PCBCSVRTX1BFUl9CWVRFKSB8IGJ5dGU7XG4gICAgICAgIG51bUJpdHMgKz0gQklUU19QRVJfQllURTtcbiAgICAgICAgaWYgKG51bUJpdHMgPj0gQklUU19QRVJfV09SRCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZElkeCA9IG5leHRCaXRzID4+IChudW1CaXRzIC0gQklUU19QRVJfV09SRCk7XG4gICAgICAgICAgICB3b3Jkcy5wdXNoKHdvcmRsaXN0LndvcmRzW3dvcmRJZHhdKTtcbiAgICAgICAgICAgIGlmIChudW1MZWZ0b3ZlckJpdHMgPD0gQklUU19QRVJfV09SRCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtQml0cyAtPSBCSVRTX1BFUl9XT1JEO1xuICAgICAgICAgICAgbnVtTGVmdG92ZXJCaXRzIC09IEJJVFNfUEVSX1dPUkQ7XG4gICAgICAgICAgICBuZXh0Qml0cyAmPSAweDdmZiA+PiAoQklUU19QRVJfV09SRCAtIG51bUJpdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3Jkcy5qb2luKHdvcmRsaXN0LnNlcGFyYXRvcik7XG59XG5leHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gZW50cm9weVRvTW5lbW9uaWM7XG4vKiogUmVjb3ZlciB0aGUgZW50cm9weSBmcm9tIHRoZSBtbmVtb25pYyAqL1xuZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkocGhyYXNlLCB3b3JkbGlzdCkge1xuICAgIGNvbnN0IHdvcmRzID0gbm9ybWFsaXplKHBocmFzZSkuc3BsaXQoJyAnKTtcbiAgICBpZiAod29yZHMubGVuZ3RoIDwgMTIgfHwgd29yZHMubGVuZ3RoID4gMjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2Ygd29yZHMgaW4gbW5lbW9uaWMgcGhyYXNlIG11c3QgYmUgYmV0d2VlbiAxMiBhbmQgMjQnKTtcbiAgICB9XG4gICAgaWYgKHdvcmRzLmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2Ygd29yZHMgaW4gbW5lbW9uaWMgcGhyYXNlIG11c3QgYmUgZGl2aXNpYmxlIGJ5IDMnKTtcbiAgICB9XG4gICAgY29uc3Qgd29yZEluZGljZXMgPSB3b3Jkcy5tYXAod29yZCA9PiB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHdvcmRsaXN0LmluZGV4T2Yod29yZCk7XG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW5lbW9uaWMgcGhyYXNlIHdvcmQ6ICcgKyB3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH0pO1xuICAgIGNvbnN0IG51bUVudHJvcHlCeXRlcyA9ICh3b3JkSW5kaWNlcy5sZW5ndGggLyAzKSAqIDQ7XG4gICAgbGV0IG5leHRCaXRzID0gMDtcbiAgICBsZXQgbnVtQml0cyA9IDA7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgY29uc3QgZW50cm9weSA9IG5ldyBVaW50OEFycmF5KG51bUVudHJvcHlCeXRlcyk7XG4gICAgbGV0IGNoZWNrc3VtID0gMDtcbiAgICBmb3IgKGNvbnN0IHdvcmRJZHggb2Ygd29yZEluZGljZXMpIHtcbiAgICAgICAgbmV4dEJpdHMgPSAobmV4dEJpdHMgPDwgQklUU19QRVJfV09SRCkgfCB3b3JkSWR4O1xuICAgICAgICBudW1CaXRzICs9IEJJVFNfUEVSX1dPUkQ7XG4gICAgICAgIHdoaWxlIChudW1CaXRzID49IEJJVFNfUEVSX0JZVEUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBuZXh0Qml0cyA+PiAobnVtQml0cyAtIEJJVFNfUEVSX0JZVEUpO1xuICAgICAgICAgICAgaWYgKGlkeCA8IGVudHJvcHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZW50cm9weVtpZHhdID0gYnl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtID0gKGNoZWNrc3VtIDw8IEJJVFNfUEVSX0JZVEUpIHwgYnl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCsrO1xuICAgICAgICAgICAgbnVtQml0cyAtPSBCSVRTX1BFUl9CWVRFO1xuICAgICAgICAgICAgbmV4dEJpdHMgJj0gMHhmZmZmID4+ICgxNiAtIG51bUJpdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChudW1CaXRzICE9IDApIHtcbiAgICAgICAgY2hlY2tzdW0gPSAoY2hlY2tzdW0gPDwgQklUU19QRVJfQllURSkgfCBuZXh0Qml0cztcbiAgICB9XG4gICAgY29uc3QgZW50cm9weUhhc2ggPSAoMCwgaGFzaF8xLnNoYTI1NikoZW50cm9weSk7XG4gICAgY29uc3QgbnVtQ2hlY2tzdW1CaXRzID0gY2FsY051bUNoZWNrc3VtQml0cyhudW1FbnRyb3B5Qnl0ZXMpO1xuICAgIGNvbnN0IGV4cGVjdGVkQ2hlY2tzdW0gPSBlbnRyb3B5SGFzaFswXSA+PiAoQklUU19QRVJfQllURSAtIG51bUNoZWNrc3VtQml0cyk7XG4gICAgaWYgKGNoZWNrc3VtICE9IGV4cGVjdGVkQ2hlY2tzdW0pIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBleHBlY3RlZENoZWNrc3VtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY29uc3QgYWN0dWFsID0gY2hlY2tzdW0udG9TdHJpbmcoMTYpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW06IGV4cGVjdGVkICR7ZXhwZWN0ZWR9LCBnb3QgJHthY3R1YWx9YCk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyb3B5O1xufVxuZXhwb3J0cy5tbmVtb25pY1RvRW50cm9weSA9IG1uZW1vbmljVG9FbnRyb3B5O1xuLyoqIERlcml2ZSB0aGUgc2VlZCBieXRlcyBmcm9tIHRoZSBtbmVtb25pYyAqL1xuZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQocGhyYXNlLCBwYXNzd29yZCkge1xuICAgIHJldHVybiAoMCwgcGJrZGYyXzEucGJrZGYyKSh7XG4gICAgICAgIGhhc2hGYWN0b3J5OiBoYXNoXzEuc2hhNTEySGFzaGVyLFxuICAgICAgICBwYXNzd29yZDogKDAsIHN0cl9qc18xLnN0clRvQnl0ZXMpKG5vcm1hbGl6ZShwaHJhc2UpKSxcbiAgICAgICAgc2FsdDogKDAsIHN0cl9qc18xLnN0clRvQnl0ZXMpKHNhbHQobm9ybWFsaXplKHBhc3N3b3JkKSkpLFxuICAgICAgICBibG9ja0xlbmd0aDogMTI4LFxuICAgICAgICBvdXRwdXRMZW5ndGg6IDY0LFxuICAgICAgICBka0xlbjogNjQsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDIwNDgsXG4gICAgfSk7XG59XG5leHBvcnRzLm1uZW1vbmljVG9TZWVkID0gbW5lbW9uaWNUb1NlZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tbmVtb25pYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6420\n\n}")},6421:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{/**\n * Alignment pattern are fixed reference pattern in defined positions\n * in a matrix symbology, which enables the decode software to re-synchronise\n * the coordinate mapping of the image modules in the event of moderate amounts\n * of distortion of the image.\n *\n * Alignment patterns are present only in QR Code symbols of version 2 or larger\n * and their number depends on the symbol version.\n */\n\nconst getSymbolSize = (__webpack_require__(6886).getSymbolSize)\n\n/**\n * Calculate the row/column coordinates of the center module of each alignment pattern\n * for the specified QR Code version.\n *\n * The alignment patterns are positioned symmetrically on either side of the diagonal\n * running from the top left corner of the symbol to the bottom right corner.\n *\n * Since positions are simmetrical only half of the coordinates are returned.\n * Each item of the array will represent in turn the x and y coordinate.\n * @see {@link getPositions}\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinate\n */\nexports.getRowColCoords = function getRowColCoords (version) {\n  if (version === 1) return []\n\n  const posCount = Math.floor(version / 7) + 2\n  const size = getSymbolSize(version)\n  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2\n  const positions = [size - 7] // Last coord is always (size - 7)\n\n  for (let i = 1; i < posCount - 1; i++) {\n    positions[i] = positions[i - 1] - intervals\n  }\n\n  positions.push(6) // First coord is always 6\n\n  return positions.reverse()\n}\n\n/**\n * Returns an array containing the positions of each alignment pattern.\n * Each array's element represent the center point of the pattern as (x, y) coordinates\n *\n * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n * and filtering out the items that overlaps with finder pattern\n *\n * @example\n * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n * The alignment patterns, therefore, are to be centered on (row, column)\n * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n * and are not therefore used for alignment patterns.\n *\n * let pos = getPositions(7)\n * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const coords = []\n  const pos = exports.getRowColCoords(version)\n  const posLength = pos.length\n\n  for (let i = 0; i < posLength; i++) {\n    for (let j = 0; j < posLength; j++) {\n      // Skip if position is occupied by finder patterns\n      if ((i === 0 && j === 0) || // top-left\n          (i === 0 && j === posLength - 1) || // bottom-left\n          (i === posLength - 1 && j === 0)) { // top-right\n        continue\n      }\n\n      coords.push([pos[i], pos[j]])\n    }\n  }\n\n  return coords\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQyMS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHlDQUFnQzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakMsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvY29yZS9hbGlnbm1lbnQtcGF0dGVybi5qcz9kNmMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQWxpZ25tZW50IHBhdHRlcm4gYXJlIGZpeGVkIHJlZmVyZW5jZSBwYXR0ZXJuIGluIGRlZmluZWQgcG9zaXRpb25zXG4gKiBpbiBhIG1hdHJpeCBzeW1ib2xvZ3ksIHdoaWNoIGVuYWJsZXMgdGhlIGRlY29kZSBzb2Z0d2FyZSB0byByZS1zeW5jaHJvbmlzZVxuICogdGhlIGNvb3JkaW5hdGUgbWFwcGluZyBvZiB0aGUgaW1hZ2UgbW9kdWxlcyBpbiB0aGUgZXZlbnQgb2YgbW9kZXJhdGUgYW1vdW50c1xuICogb2YgZGlzdG9ydGlvbiBvZiB0aGUgaW1hZ2UuXG4gKlxuICogQWxpZ25tZW50IHBhdHRlcm5zIGFyZSBwcmVzZW50IG9ubHkgaW4gUVIgQ29kZSBzeW1ib2xzIG9mIHZlcnNpb24gMiBvciBsYXJnZXJcbiAqIGFuZCB0aGVpciBudW1iZXIgZGVwZW5kcyBvbiB0aGUgc3ltYm9sIHZlcnNpb24uXG4gKi9cblxuY29uc3QgZ2V0U3ltYm9sU2l6ZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5nZXRTeW1ib2xTaXplXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSByb3cvY29sdW1uIGNvb3JkaW5hdGVzIG9mIHRoZSBjZW50ZXIgbW9kdWxlIG9mIGVhY2ggYWxpZ25tZW50IHBhdHRlcm5cbiAqIGZvciB0aGUgc3BlY2lmaWVkIFFSIENvZGUgdmVyc2lvbi5cbiAqXG4gKiBUaGUgYWxpZ25tZW50IHBhdHRlcm5zIGFyZSBwb3NpdGlvbmVkIHN5bW1ldHJpY2FsbHkgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGRpYWdvbmFsXG4gKiBydW5uaW5nIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc3ltYm9sIHRvIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICpcbiAqIFNpbmNlIHBvc2l0aW9ucyBhcmUgc2ltbWV0cmljYWwgb25seSBoYWxmIG9mIHRoZSBjb29yZGluYXRlcyBhcmUgcmV0dXJuZWQuXG4gKiBFYWNoIGl0ZW0gb2YgdGhlIGFycmF5IHdpbGwgcmVwcmVzZW50IGluIHR1cm4gdGhlIHggYW5kIHkgY29vcmRpbmF0ZS5cbiAqIEBzZWUge0BsaW5rIGdldFBvc2l0aW9uc31cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2YgY29vcmRpbmF0ZVxuICovXG5leHBvcnRzLmdldFJvd0NvbENvb3JkcyA9IGZ1bmN0aW9uIGdldFJvd0NvbENvb3JkcyAodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMSkgcmV0dXJuIFtdXG5cbiAgY29uc3QgcG9zQ291bnQgPSBNYXRoLmZsb29yKHZlcnNpb24gLyA3KSArIDJcbiAgY29uc3Qgc2l6ZSA9IGdldFN5bWJvbFNpemUodmVyc2lvbilcbiAgY29uc3QgaW50ZXJ2YWxzID0gc2l6ZSA9PT0gMTQ1ID8gMjYgOiBNYXRoLmNlaWwoKHNpemUgLSAxMykgLyAoMiAqIHBvc0NvdW50IC0gMikpICogMlxuICBjb25zdCBwb3NpdGlvbnMgPSBbc2l6ZSAtIDddIC8vIExhc3QgY29vcmQgaXMgYWx3YXlzIChzaXplIC0gNylcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvc0NvdW50IC0gMTsgaSsrKSB7XG4gICAgcG9zaXRpb25zW2ldID0gcG9zaXRpb25zW2kgLSAxXSAtIGludGVydmFsc1xuICB9XG5cbiAgcG9zaXRpb25zLnB1c2goNikgLy8gRmlyc3QgY29vcmQgaXMgYWx3YXlzIDZcblxuICByZXR1cm4gcG9zaXRpb25zLnJldmVyc2UoKVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgcG9zaXRpb25zIG9mIGVhY2ggYWxpZ25tZW50IHBhdHRlcm4uXG4gKiBFYWNoIGFycmF5J3MgZWxlbWVudCByZXByZXNlbnQgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgcGF0dGVybiBhcyAoeCwgeSkgY29vcmRpbmF0ZXNcbiAqXG4gKiBDb29yZGluYXRlcyBhcmUgY2FsY3VsYXRlZCBleHBhbmRpbmcgdGhlIHJvdy9jb2x1bW4gY29vcmRpbmF0ZXMgcmV0dXJuZWQgYnkge0BsaW5rIGdldFJvd0NvbENvb3Jkc31cbiAqIGFuZCBmaWx0ZXJpbmcgb3V0IHRoZSBpdGVtcyB0aGF0IG92ZXJsYXBzIHdpdGggZmluZGVyIHBhdHRlcm5cbiAqXG4gKiBAZXhhbXBsZVxuICogRm9yIGEgVmVyc2lvbiA3IHN5bWJvbCB7QGxpbmsgZ2V0Um93Q29sQ29vcmRzfSByZXR1cm5zIHZhbHVlcyA2LCAyMiBhbmQgMzguXG4gKiBUaGUgYWxpZ25tZW50IHBhdHRlcm5zLCB0aGVyZWZvcmUsIGFyZSB0byBiZSBjZW50ZXJlZCBvbiAocm93LCBjb2x1bW4pXG4gKiBwb3NpdGlvbnMgKDYsMjIpLCAoMjIsNiksICgyMiwyMiksICgyMiwzOCksICgzOCwyMiksICgzOCwzOCkuXG4gKiBOb3RlIHRoYXQgdGhlIGNvb3JkaW5hdGVzICg2LDYpLCAoNiwzOCksICgzOCw2KSBhcmUgb2NjdXBpZWQgYnkgZmluZGVyIHBhdHRlcm5zXG4gKiBhbmQgYXJlIG5vdCB0aGVyZWZvcmUgdXNlZCBmb3IgYWxpZ25tZW50IHBhdHRlcm5zLlxuICpcbiAqIGxldCBwb3MgPSBnZXRQb3NpdGlvbnMoNylcbiAqIC8vIFtbNiwyMl0sIFsyMiw2XSwgWzIyLDIyXSwgWzIyLDM4XSwgWzM4LDIyXSwgWzM4LDM4XV1cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2YgY29vcmRpbmF0ZXNcbiAqL1xuZXhwb3J0cy5nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiBnZXRQb3NpdGlvbnMgKHZlcnNpb24pIHtcbiAgY29uc3QgY29vcmRzID0gW11cbiAgY29uc3QgcG9zID0gZXhwb3J0cy5nZXRSb3dDb2xDb29yZHModmVyc2lvbilcbiAgY29uc3QgcG9zTGVuZ3RoID0gcG9zLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zTGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvc0xlbmd0aDsgaisrKSB7XG4gICAgICAvLyBTa2lwIGlmIHBvc2l0aW9uIGlzIG9jY3VwaWVkIGJ5IGZpbmRlciBwYXR0ZXJuc1xuICAgICAgaWYgKChpID09PSAwICYmIGogPT09IDApIHx8IC8vIHRvcC1sZWZ0XG4gICAgICAgICAgKGkgPT09IDAgJiYgaiA9PT0gcG9zTGVuZ3RoIC0gMSkgfHwgLy8gYm90dG9tLWxlZnRcbiAgICAgICAgICAoaSA9PT0gcG9zTGVuZ3RoIC0gMSAmJiBqID09PSAwKSkgeyAvLyB0b3AtcmlnaHRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29vcmRzLnB1c2goW3Bvc1tpXSwgcG9zW2pdXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29vcmRzXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6421\n\n}")},6425:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{/* provided dependency */ var Buffer = __webpack_require__(8287)[\"Buffer\"];\n/*! Axios v1.12.2 Copyright (c) 2025 Matt Zabriskie and contributors */\n\n\nfunction bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\nconst {iterator, toStringTag} = Symbol;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n};\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction$1 = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);\n};\n\n/**\n * Determine if a value is an empty object (safely handles Buffers)\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an empty object, otherwise false\n */\nconst isEmptyObject = (val) => {\n  // Early return for non-objects or Buffers to prevent RangeError\n  if (!isObject(val) || isBuffer(val)) {\n    return false;\n  }\n\n  try {\n    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;\n  } catch (e) {\n    // Fallback for any other objects that might cause RangeError with Object.keys()\n    return false;\n  }\n};\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction$1(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction$1(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction$1(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n};\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Buffer check\n    if (isBuffer(obj)) {\n      return;\n    }\n\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  if (isBuffer(obj)){\n    return null;\n  }\n\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : __webpack_require__.g)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless, skipUndefined} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else if (!skipUndefined || !isUndefined(val)) {\n      result[targetKey] = val;\n    }\n  };\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction$1(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n};\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n};\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n};\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n};\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[iterator];\n\n  const _iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = _iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n};\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n};\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction$1(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction$1(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n};\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  };\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n};\n\nconst noop = () => {};\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n};\n\n\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      //Buffer check\n      if (isBuffer(source)) {\n        return source;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  };\n\n  return visit(obj, 0);\n};\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction$1(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\n// *********************\n\n\nconst isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);\n\n\nvar utils$1 = {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isEmptyObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction: isFunction$1,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap,\n  isIterable\n};\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  if (response) {\n    this.response = response;\n    this.status = response.status ? response.status : null;\n  }\n}\n\nutils$1.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils$1.toJSONObject(this.config),\n      code: this.code,\n      status: this.status\n    };\n  }\n});\n\nconst prototype$1 = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype$1, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype$1);\n\n  utils$1.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  const msg = error && error.message ? error.message : 'Error';\n\n  // Prefer explicit code; otherwise copy the low-level error's code (e.g. ECONNREFUSED)\n  const errCode = code == null && error ? error.code : code;\n  AxiosError.call(axiosError, msg, errCode, config, request, response);\n\n  // Chain the original error on the standard field; non-enumerable to avoid JSON noise\n  if (error && axiosError.cause == null) {\n    Object.defineProperty(axiosError, 'cause', { value: error, configurable: true });\n  }\n\n  axiosError.name = (error && error.name) || 'Error';\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\n// eslint-disable-next-line strict\nvar httpAdapter = null;\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils$1.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils$1.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils$1.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);\n\n  if (!utils$1.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils$1.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (utils$1.isBoolean(value)) {\n      return value.toString();\n    }\n\n    if (!useBlob && utils$1.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils$1.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils$1.isArray(value) && isFlatArray(value)) ||\n        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils$1.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils$1.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils$1.forEach(value, function each(el, key) {\n      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode$1(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode$1);\n  } : encode$1;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */\nfunction buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  if (utils$1.isFunction(options)) {\n    options = {\n      serialize: options\n    };\n  } \n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils$1.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils$1.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nvar InterceptorManager$1 = InterceptorManager;\n\nvar transitionalDefaults = {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n\nvar URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;\n\nvar FormData$1 = typeof FormData !== 'undefined' ? FormData : null;\n\nvar Blob$1 = typeof Blob !== 'undefined' ? Blob : null;\n\nvar platform$1 = {\n  isBrowser: true,\n  classes: {\n    URLSearchParams: URLSearchParams$1,\n    FormData: FormData$1,\n    Blob: Blob$1\n  },\n  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']\n};\n\nconst hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst _navigator = typeof navigator === 'object' && navigator || undefined;\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = hasBrowserEnv &&\n  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\nvar utils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  hasBrowserEnv: hasBrowserEnv,\n  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,\n  hasStandardBrowserEnv: hasStandardBrowserEnv,\n  navigator: _navigator,\n  origin: origin\n});\n\nvar platform = {\n  ...utils,\n  ...platform$1\n};\n\nfunction toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), {\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils$1.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    },\n    ...options\n  });\n}\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils$1.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils$1.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils$1.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils$1.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils$1.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils$1.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils$1.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils$1.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http', 'fetch'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils$1.isObject(data);\n\n    if (isObjectPayload && utils$1.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils$1.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils$1.isArrayBuffer(data) ||\n      utils$1.isBuffer(data) ||\n      utils$1.isStream(data) ||\n      utils$1.isFile(data) ||\n      utils$1.isBlob(data) ||\n      utils$1.isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (utils$1.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils$1.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data, this.parseReviver);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\nvar defaults$1 = defaults;\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils$1.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nvar parseHeaders = rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils$1.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils$1.isString(value)) return;\n\n  if (utils$1.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils$1.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils$1.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils$1.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite);\n    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {\n      let obj = {}, dest, key;\n      for (const entry of header) {\n        if (!utils$1.isArray(entry)) {\n          throw TypeError('Object iterator must return a key-value pair');\n        }\n\n        obj[key = entry[0]] = (dest = obj[key]) ?\n          (utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];\n      }\n\n      setHeaders(obj, valueOrRewrite);\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils$1.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils$1.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils$1.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils$1.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils$1.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils$1.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils$1.forEach(this, (value, header) => {\n      const key = utils$1.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils$1.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  getSetCookie() {\n    return this.get(\"set-cookie\") || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils$1.freezeMethods(AxiosHeaders);\n\nvar AxiosHeaders$1 = AxiosHeaders;\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nfunction transformData(fns, response) {\n  const config = this || defaults$1;\n  const context = response || config;\n  const headers = AxiosHeaders$1.from(context.headers);\n  let data = context.data;\n\n  utils$1.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils$1.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nfunction settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n\nfunction parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\n/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  let threshold = 1000 / freq;\n  let lastArgs;\n  let timer;\n\n  const invoke = (args, now = Date.now()) => {\n    timestamp = now;\n    lastArgs = null;\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    fn(...args);\n  };\n\n  const throttled = (...args) => {\n    const now = Date.now();\n    const passed = now - timestamp;\n    if ( passed >= threshold) {\n      invoke(args, now);\n    } else {\n      lastArgs = args;\n      if (!timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          invoke(lastArgs);\n        }, threshold - passed);\n      }\n    }\n  };\n\n  const flush = () => lastArgs && invoke(lastArgs);\n\n  return [throttled, flush];\n}\n\nconst progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return throttle(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null,\n      [isDownloadStream ? 'download' : 'upload']: true\n    };\n\n    listener(data);\n  }, freq);\n};\n\nconst progressEventDecorator = (total, throttled) => {\n  const lengthComputable = total != null;\n\n  return [(loaded) => throttled[0]({\n    lengthComputable,\n    total,\n    loaded\n  }), throttled[1]];\n};\n\nconst asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));\n\nvar isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {\n  url = new URL(url, platform.origin);\n\n  return (\n    origin.protocol === url.protocol &&\n    origin.host === url.host &&\n    (isMSIE || origin.port === url.port)\n  );\n})(\n  new URL(platform.origin),\n  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)\n) : () => true;\n\nvar cookies = platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure) {\n      const cookie = [name + '=' + encodeURIComponent(value)];\n\n      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());\n\n      utils$1.isString(path) && cookie.push('path=' + path);\n\n      utils$1.isString(domain) && cookie.push('domain=' + domain);\n\n      secure === true && cookie.push('secure');\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      const match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return (match ? decodeURIComponent(match[3]) : null);\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  };\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nfunction isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nfunction combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nfunction buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {\n  let isRelativeUrl = !isAbsoluteURL(requestedURL);\n  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nfunction mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {\n      return utils$1.merge.call({caseless}, target, source);\n    } else if (utils$1.isPlainObject(source)) {\n      return utils$1.merge({}, source);\n    } else if (utils$1.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop , caseless) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(a, b, prop , caseless);\n    } else if (!utils$1.isUndefined(a)) {\n      return getMergedValue(undefined, a, prop , caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils$1.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils$1.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)\n  };\n\n  utils$1.forEach(Object.keys({...config1, ...config2}), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n\nvar resolveConfig = (config) => {\n  const newConfig = mergeConfig({}, config);\n\n  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;\n\n  newConfig.headers = headers = AxiosHeaders$1.from(headers);\n\n  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set('Authorization', 'Basic ' +\n      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))\n    );\n  }\n\n  if (utils$1.isFormData(data)) {\n    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // browser handles it\n    } else if (utils$1.isFunction(data.getHeaders)) {\n      // Node.js FormData (like form-data package)\n      const formHeaders = data.getHeaders();\n      // Only set safe headers to avoid overwriting security headers\n      const allowedHeaders = ['content-type', 'content-length'];\n      Object.entries(formHeaders).forEach(([key, val]) => {\n        if (allowedHeaders.includes(key.toLowerCase())) {\n          headers.set(key, val);\n        }\n      });\n    }\n  }  \n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we're in a web worker, or react-native.\n\n  if (platform.hasStandardBrowserEnv) {\n    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n};\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nvar xhrAdapter = isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener('abort', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders$1.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n  request.onerror = function handleError(event) {\n       // Browsers deliver a ProgressEvent in XHR onerror\n       // (message may be empty; when present, surface it)\n       // See https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/error_event\n       const msg = event && event.message ? event.message : 'Network Error';\n       const err = new AxiosError(msg, AxiosError.ERR_NETWORK, config, request);\n       // attach the underlying event for consumers who want details\n       err.event = event || null;\n       reject(err);\n       request = null;\n    };\n    \n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils$1.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));\n      request.addEventListener('progress', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));\n\n      request.upload.addEventListener('progress', uploadThrottled);\n\n      request.upload.addEventListener('loadend', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n};\n\nconst composeSignals = (signals, timeout) => {\n  const {length} = (signals = signals ? signals.filter(Boolean) : []);\n\n  if (timeout || length) {\n    let controller = new AbortController();\n\n    let aborted;\n\n    const onabort = function (reason) {\n      if (!aborted) {\n        aborted = true;\n        unsubscribe();\n        const err = reason instanceof Error ? reason : this.reason;\n        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));\n      }\n    };\n\n    let timer = timeout && setTimeout(() => {\n      timer = null;\n      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));\n    }, timeout);\n\n    const unsubscribe = () => {\n      if (signals) {\n        timer && clearTimeout(timer);\n        timer = null;\n        signals.forEach(signal => {\n          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);\n        });\n        signals = null;\n      }\n    };\n\n    signals.forEach((signal) => signal.addEventListener('abort', onabort));\n\n    const {signal} = controller;\n\n    signal.unsubscribe = () => utils$1.asap(unsubscribe);\n\n    return signal;\n  }\n};\n\nvar composeSignals$1 = composeSignals;\n\nconst streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n};\n\nconst readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n};\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n};\n\nconst trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  };\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n};\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst {isFunction} = utils$1;\n\nconst globalFetchAPI = (({Request, Response}) => ({\n  Request, Response\n}))(utils$1.global);\n\nconst {\n  ReadableStream: ReadableStream$1, TextEncoder\n} = utils$1.global;\n\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n};\n\nconst factory = (env) => {\n  env = utils$1.merge.call({\n    skipUndefined: true\n  }, globalFetchAPI, env);\n\n  const {fetch: envFetch, Request, Response} = env;\n  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';\n  const isRequestSupported = isFunction(Request);\n  const isResponseSupported = isFunction(Response);\n\n  if (!isFetchSupported) {\n    return false;\n  }\n\n  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);\n\n  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n      ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n      async (str) => new Uint8Array(await new Request(str).arrayBuffer())\n  );\n\n  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {\n    let duplexAccessed = false;\n\n    const hasContentType = new Request(platform.origin, {\n      body: new ReadableStream$1(),\n      method: 'POST',\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      },\n    }).headers.has('Content-Type');\n\n    return duplexAccessed && !hasContentType;\n  });\n\n  const supportsResponseStream = isResponseSupported && isReadableStreamSupported &&\n    test(() => utils$1.isReadableStream(new Response('').body));\n\n  const resolvers = {\n    stream: supportsResponseStream && ((res) => res.body)\n  };\n\n  isFetchSupported && ((() => {\n    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n      !resolvers[type] && (resolvers[type] = (res, config) => {\n        let method = res && res[type];\n\n        if (method) {\n          return method.call(res);\n        }\n\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      });\n    });\n  })());\n\n  const getBodyLength = async (body) => {\n    if (body == null) {\n      return 0;\n    }\n\n    if (utils$1.isBlob(body)) {\n      return body.size;\n    }\n\n    if (utils$1.isSpecCompliantForm(body)) {\n      const _request = new Request(platform.origin, {\n        method: 'POST',\n        body,\n      });\n      return (await _request.arrayBuffer()).byteLength;\n    }\n\n    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {\n      return body.byteLength;\n    }\n\n    if (utils$1.isURLSearchParams(body)) {\n      body = body + '';\n    }\n\n    if (utils$1.isString(body)) {\n      return (await encodeText(body)).byteLength;\n    }\n  };\n\n  const resolveBodyLength = async (headers, body) => {\n    const length = utils$1.toFiniteNumber(headers.getContentLength());\n\n    return length == null ? getBodyLength(body) : length;\n  };\n\n  return async (config) => {\n    let {\n      url,\n      method,\n      data,\n      signal,\n      cancelToken,\n      timeout,\n      onDownloadProgress,\n      onUploadProgress,\n      responseType,\n      headers,\n      withCredentials = 'same-origin',\n      fetchOptions\n    } = resolveConfig(config);\n\n    let _fetch = envFetch || fetch;\n\n    responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n    let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n    let request = null;\n\n    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n    });\n\n    let requestContentLength;\n\n    try {\n      if (\n        onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n        (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n      ) {\n        let _request = new Request(url, {\n          method: 'POST',\n          body: data,\n          duplex: \"half\"\n        });\n\n        let contentTypeHeader;\n\n        if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n          headers.setContentType(contentTypeHeader);\n        }\n\n        if (_request.body) {\n          const [onProgress, flush] = progressEventDecorator(\n            requestContentLength,\n            progressEventReducer(asyncDecorator(onUploadProgress))\n          );\n\n          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n        }\n      }\n\n      if (!utils$1.isString(withCredentials)) {\n        withCredentials = withCredentials ? 'include' : 'omit';\n      }\n\n      // Cloudflare Workers throws when credentials are defined\n      // see https://github.com/cloudflare/workerd/issues/902\n      const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n\n      const resolvedOptions = {\n        ...fetchOptions,\n        signal: composedSignal,\n        method: method.toUpperCase(),\n        headers: headers.normalize().toJSON(),\n        body: data,\n        duplex: \"half\",\n        credentials: isCredentialsSupported ? withCredentials : undefined\n      };\n\n      request = isRequestSupported && new Request(url, resolvedOptions);\n\n      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));\n\n      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n      if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n        const options = {};\n\n        ['status', 'statusText', 'headers'].forEach(prop => {\n          options[prop] = response[prop];\n        });\n\n        const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));\n\n        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n          responseContentLength,\n          progressEventReducer(asyncDecorator(onDownloadProgress), true)\n        ) || [];\n\n        response = new Response(\n          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n            flush && flush();\n            unsubscribe && unsubscribe();\n          }),\n          options\n        );\n      }\n\n      responseType = responseType || 'text';\n\n      let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);\n\n      !isStreamResponse && unsubscribe && unsubscribe();\n\n      return await new Promise((resolve, reject) => {\n        settle(resolve, reject, {\n          data: responseData,\n          headers: AxiosHeaders$1.from(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          config,\n          request\n        });\n      })\n    } catch (err) {\n      unsubscribe && unsubscribe();\n\n      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n        throw Object.assign(\n          new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n          {\n            cause: err.cause || err\n          }\n        )\n      }\n\n      throw AxiosError.from(err, err && err.code, config, request);\n    }\n  }\n};\n\nconst seedCache = new Map();\n\nconst getFetch = (config) => {\n  let env = config ? config.env : {};\n  const {fetch, Request, Response} = env;\n  const seeds = [\n    Request, Response, fetch\n  ];\n\n  let len = seeds.length, i = len,\n    seed, target, map = seedCache;\n\n  while (i--) {\n    seed = seeds[i];\n    target = map.get(seed);\n\n    target === undefined && map.set(seed, target = (i ? new Map() : factory(env)));\n\n    map = target;\n  }\n\n  return target;\n};\n\ngetFetch();\n\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: {\n    get: getFetch,\n  }\n};\n\nutils$1.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {value});\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {value});\n  }\n});\n\nconst renderReason = (reason) => `- ${reason}`;\n\nconst isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;\n\nvar adapters = {\n  getAdapter: (adapters, config) => {\n    adapters = utils$1.isArray(adapters) ? adapters : [adapters];\n\n    const {length} = adapters;\n    let nameOrAdapter;\n    let adapter;\n\n    const rejectedReasons = {};\n\n    for (let i = 0; i < length; i++) {\n      nameOrAdapter = adapters[i];\n      let id;\n\n      adapter = nameOrAdapter;\n\n      if (!isResolvedHandle(nameOrAdapter)) {\n        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n        if (adapter === undefined) {\n          throw new AxiosError(`Unknown adapter '${id}'`);\n        }\n      }\n\n      if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {\n        break;\n      }\n\n      rejectedReasons[id || '#' + i] = adapter;\n    }\n\n    if (!adapter) {\n\n      const reasons = Object.entries(rejectedReasons)\n        .map(([id, state]) => `adapter ${id} ` +\n          (state === false ? 'is not supported by the environment' : 'is not available in the build')\n        );\n\n      let s = length ?\n        (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n        'as no adapter specified';\n\n      throw new AxiosError(\n        `There is no suitable adapter to dispatch the request ` + s,\n        'ERR_NOT_SUPPORT'\n      );\n    }\n\n    return adapter;\n  },\n  adapters: knownAdapters\n};\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nfunction dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders$1.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter, config);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders$1.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n\nconst VERSION = \"1.12.2\";\n\nconst validators$1 = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators$1[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators$1.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\nvalidators$1.spelling = function spelling(correctSpelling) {\n  return (value, opt) => {\n    // eslint-disable-next-line no-console\n    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n    return true;\n  }\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nvar validator = {\n  assertOptions,\n  validators: validators$1\n};\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig || {};\n    this.interceptors = {\n      request: new InterceptorManager$1(),\n      response: new InterceptorManager$1()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack;\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils$1.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        };\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    // Set config.allowAbsoluteUrls\n    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {\n      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;\n    } else {\n      config.allowAbsoluteUrls = true;\n    }\n\n    validator.assertOptions(config, {\n      baseUrl: validators.spelling('baseURL'),\n      withXsrfToken: validators.spelling('withXSRFToken')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils$1.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils$1.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift(...requestInterceptorChain);\n      chain.push(...responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nvar Axios$1 = Axios;\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  toAbortSignal() {\n    const controller = new AbortController();\n\n    const abort = (err) => {\n      controller.abort(err);\n    };\n\n    this.subscribe(abort);\n\n    controller.signal.unsubscribe = () => this.unsubscribe(abort);\n\n    return controller.signal;\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nvar CancelToken$1 = CancelToken;\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nfunction spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nfunction isAxiosError(payload) {\n  return utils$1.isObject(payload) && (payload.isAxiosError === true);\n}\n\nconst HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nvar HttpStatusCode$1 = HttpStatusCode;\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios$1(defaultConfig);\n  const instance = bind(Axios$1.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils$1.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults$1);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios$1;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken$1;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders$1;\n\naxios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = HttpStatusCode$1;\n\naxios.default = axios;\n\nmodule.exports = axios;\n//# sourceMappingURL=axios.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FB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T0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsS0FBSztBQUNwRCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdELGlCQUFpQjs7QUFFekU7QUFDQSwyQ0FBMkMsaUJBQWlCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9heGlvcy9kaXN0L2Jyb3dzZXIvYXhpb3MuY2pzP2JhZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEF4aW9zIHYxLjEyLjIgQ29weXJpZ2h0IChjKSAyMDI1IE1hdHQgWmFicmlza2llIGFuZCBjb250cmlidXRvcnMgKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxuY29uc3Qge3RvU3RyaW5nfSA9IE9iamVjdC5wcm90b3R5cGU7XG5jb25zdCB7Z2V0UHJvdG90eXBlT2Z9ID0gT2JqZWN0O1xuY29uc3Qge2l0ZXJhdG9yLCB0b1N0cmluZ1RhZ30gPSBTeW1ib2w7XG5cbmNvbnN0IGtpbmRPZiA9IChjYWNoZSA9PiB0aGluZyA9PiB7XG4gICAgY29uc3Qgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XG4gICAgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBzdHIuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xufSkoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmNvbnN0IGtpbmRPZlRlc3QgPSAodHlwZSkgPT4ge1xuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKHRoaW5nKSA9PiBraW5kT2YodGhpbmcpID09PSB0eXBlXG59O1xuXG5jb25zdCB0eXBlT2ZUZXN0ID0gdHlwZSA9PiB0aGluZyA9PiB0eXBlb2YgdGhpbmcgPT09IHR5cGU7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVPZlRlc3QoJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIGlzRnVuY3Rpb24kMSh2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmluZyA9IHR5cGVPZlRlc3QoJ3N0cmluZycpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb24kMSA9IHR5cGVPZlRlc3QoJ2Z1bmN0aW9uJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNOdW1iZXIgPSB0eXBlT2ZUZXN0KCdudW1iZXInKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNPYmplY3QgPSAodGhpbmcpID0+IHRoaW5nICE9PSBudWxsICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCb29sZWFuXG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCb29sZWFuLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCb29sZWFuID0gdGhpbmcgPT4gdGhpbmcgPT09IHRydWUgfHwgdGhpbmcgPT09IGZhbHNlO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB7XG4gIGlmIChraW5kT2YodmFsKSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZih2YWwpO1xuICByZXR1cm4gKHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmICEodG9TdHJpbmdUYWcgaW4gdmFsKSAmJiAhKGl0ZXJhdG9yIGluIHZhbCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIGVtcHR5IG9iamVjdCAoc2FmZWx5IGhhbmRsZXMgQnVmZmVycylcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIGVtcHR5IG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRW1wdHlPYmplY3QgPSAodmFsKSA9PiB7XG4gIC8vIEVhcmx5IHJldHVybiBmb3Igbm9uLW9iamVjdHMgb3IgQnVmZmVycyB0byBwcmV2ZW50IFJhbmdlRXJyb3JcbiAgaWYgKCFpc09iamVjdCh2YWwpIHx8IGlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEZhbGxiYWNrIGZvciBhbnkgb3RoZXIgb2JqZWN0cyB0aGF0IG1pZ2h0IGNhdXNlIFJhbmdlRXJyb3Igd2l0aCBPYmplY3Qua2V5cygpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlID0ga2luZE9mVGVzdCgnRmlsZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNCbG9iID0ga2luZE9mVGVzdCgnQmxvYicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZUxpc3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHZhbCkgPT4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uJDEodmFsLnBpcGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Zvcm1EYXRhID0gKHRoaW5nKSA9PiB7XG4gIGxldCBraW5kO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHwgKFxuICAgICAgaXNGdW5jdGlvbiQxKHRoaW5nLmFwcGVuZCkgJiYgKFxuICAgICAgICAoa2luZCA9IGtpbmRPZih0aGluZykpID09PSAnZm9ybWRhdGEnIHx8XG4gICAgICAgIC8vIGRldGVjdCBmb3JtLWRhdGEgaW5zdGFuY2VcbiAgICAgICAgKGtpbmQgPT09ICdvYmplY3QnICYmIGlzRnVuY3Rpb24kMSh0aGluZy50b1N0cmluZykgJiYgdGhpbmcudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgRm9ybURhdGFdJylcbiAgICAgIClcbiAgICApXG4gIClcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1VSTFNlYXJjaFBhcmFtcyA9IGtpbmRPZlRlc3QoJ1VSTFNlYXJjaFBhcmFtcycpO1xuXG5jb25zdCBbaXNSZWFkYWJsZVN0cmVhbSwgaXNSZXF1ZXN0LCBpc1Jlc3BvbnNlLCBpc0hlYWRlcnNdID0gWydSZWFkYWJsZVN0cmVhbScsICdSZXF1ZXN0JywgJ1Jlc3BvbnNlJywgJ0hlYWRlcnMnXS5tYXAoa2luZE9mVGVzdCk7XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmNvbnN0IHRyaW0gPSAoc3RyKSA9PiBzdHIudHJpbSA/XG4gIHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXMgPSBmYWxzZV1cbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbiwge2FsbE93bktleXMgPSBmYWxzZX0gPSB7fSkge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAoaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gQnVmZmVyIGNoZWNrXG4gICAgaWYgKGlzQnVmZmVyKG9iaikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBjb25zdCBrZXlzID0gYWxsT3duS2V5cyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikgOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrZXk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqLCBrZXkpIHtcbiAgaWYgKGlzQnVmZmVyKG9iaikpe1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgX2tleTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBfa2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5ID09PSBfa2V5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHJldHVybiBfa2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgX2dsb2JhbCA9ICgoKSA9PiB7XG4gIC8qZXNsaW50IG5vLXVuZGVmOjAqL1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBnbG9iYWxUaGlzO1xuICByZXR1cm4gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxufSkoKTtcblxuY29uc3QgaXNDb250ZXh0RGVmaW5lZCA9IChjb250ZXh0KSA9PiAhaXNVbmRlZmluZWQoY29udGV4dCkgJiYgY29udGV4dCAhPT0gX2dsb2JhbDtcblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKlxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICBjb25zdCB7Y2FzZWxlc3MsIHNraXBVbmRlZmluZWR9ID0gaXNDb250ZXh0RGVmaW5lZCh0aGlzKSAmJiB0aGlzIHx8IHt9O1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgYXNzaWduVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSBjYXNlbGVzcyAmJiBmaW5kS2V5KHJlc3VsdCwga2V5KSB8fCBrZXk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W3RhcmdldEtleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSBtZXJnZShyZXN1bHRbdGFyZ2V0S2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2UgaWYgKCFza2lwVW5kZWZpbmVkIHx8ICFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICByZXN1bHRbdGFyZ2V0S2V5XSA9IHZhbDtcbiAgICB9XG4gIH07XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldICYmIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXNdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmNvbnN0IGV4dGVuZCA9IChhLCBiLCB0aGlzQXJnLCB7YWxsT3duS2V5c309IHt9KSA9PiB7XG4gIGZvckVhY2goYiwgKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKHRoaXNBcmcgJiYgaXNGdW5jdGlvbiQxKHZhbCkpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSwge2FsbE93bktleXN9KTtcbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5jb25zdCBzdHJpcEJPTSA9IChjb250ZW50KSA9PiB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufTtcblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3BzXVxuICogQHBhcmFtIHtvYmplY3R9IFtkZXNjcmlwdG9yc11cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgaW5oZXJpdHMgPSAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IsIHByb3BzLCBkZXNjcmlwdG9ycykgPT4ge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCBkZXNjcmlwdG9ycyk7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0b3IsICdzdXBlcicsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgfSk7XG4gIHByb3BzICYmIE9iamVjdC5hc3NpZ24oY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgb2JqZWN0IHdpdGggZGVlcCBwcm90b3R5cGUgY2hhaW4gdG8gYSBmbGF0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZU9iaiBzb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gW2Rlc3RPYmpdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEJvb2xlYW59IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvcEZpbHRlcl1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5jb25zdCB0b0ZsYXRPYmplY3QgPSAoc291cmNlT2JqLCBkZXN0T2JqLCBmaWx0ZXIsIHByb3BGaWx0ZXIpID0+IHtcbiAgbGV0IHByb3BzO1xuICBsZXQgaTtcbiAgbGV0IHByb3A7XG4gIGNvbnN0IG1lcmdlZCA9IHt9O1xuXG4gIGRlc3RPYmogPSBkZXN0T2JqIHx8IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgaWYgKHNvdXJjZU9iaiA9PSBudWxsKSByZXR1cm4gZGVzdE9iajtcblxuICBkbyB7XG4gICAgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VPYmopO1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmICgoIXByb3BGaWx0ZXIgfHwgcHJvcEZpbHRlcihwcm9wLCBzb3VyY2VPYmosIGRlc3RPYmopKSAmJiAhbWVyZ2VkW3Byb3BdKSB7XG4gICAgICAgIGRlc3RPYmpbcHJvcF0gPSBzb3VyY2VPYmpbcHJvcF07XG4gICAgICAgIG1lcmdlZFtwcm9wXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZU9iaiA9IGZpbHRlciAhPT0gZmFsc2UgJiYgZ2V0UHJvdG90eXBlT2Yoc291cmNlT2JqKTtcbiAgfSB3aGlsZSAoc291cmNlT2JqICYmICghZmlsdGVyIHx8IGZpbHRlcihzb3VyY2VPYmosIGRlc3RPYmopKSAmJiBzb3VyY2VPYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHJldHVybiBkZXN0T2JqO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBjaGFyYWN0ZXJzIG9mIGEgc3BlY2lmaWVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT4ge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgbmV3IGFycmF5IGZyb20gYXJyYXkgbGlrZSBvYmplY3Qgb3IgbnVsbCBpZiBmYWlsZWRcbiAqXG4gKiBAcGFyYW0geyp9IFt0aGluZ11cbiAqXG4gKiBAcmV0dXJucyB7P0FycmF5fVxuICovXG5jb25zdCB0b0FycmF5ID0gKHRoaW5nKSA9PiB7XG4gIGlmICghdGhpbmcpIHJldHVybiBudWxsO1xuICBpZiAoaXNBcnJheSh0aGluZykpIHJldHVybiB0aGluZztcbiAgbGV0IGkgPSB0aGluZy5sZW5ndGg7XG4gIGlmICghaXNOdW1iZXIoaSkpIHJldHVybiBudWxsO1xuICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgYXJyW2ldID0gdGhpbmdbaV07XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogQ2hlY2tpbmcgaWYgdGhlIFVpbnQ4QXJyYXkgZXhpc3RzIGFuZCBpZiBpdCBkb2VzLCBpdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gKiB0aGluZyBwYXNzZWQgaW4gaXMgYW4gaW5zdGFuY2Ugb2YgVWludDhBcnJheVxuICpcbiAqIEBwYXJhbSB7VHlwZWRBcnJheX1cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5jb25zdCBpc1R5cGVkQXJyYXkgPSAoVHlwZWRBcnJheSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiB0aGluZyA9PiB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXkgJiYgdGhpbmcgaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xuICB9O1xufSkodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIGdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkpKTtcblxuLyoqXG4gKiBGb3IgZWFjaCBlbnRyeSBpbiB0aGUgb2JqZWN0LCBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBrZXkgYW5kIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0PGFueSwgYW55Pn0gb2JqIC0gVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGVudHJ5LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBmb3JFYWNoRW50cnkgPSAob2JqLCBmbikgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBvYmogJiYgb2JqW2l0ZXJhdG9yXTtcblxuICBjb25zdCBfaXRlcmF0b3IgPSBnZW5lcmF0b3IuY2FsbChvYmopO1xuXG4gIGxldCByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBfaXRlcmF0b3IubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBjb25zdCBwYWlyID0gcmVzdWx0LnZhbHVlO1xuICAgIGZuLmNhbGwob2JqLCBwYWlyWzBdLCBwYWlyWzFdKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJdCB0YWtlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdFeHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBzZWFyY2guXG4gKlxuICogQHJldHVybnMge0FycmF5PGJvb2xlYW4+fVxuICovXG5jb25zdCBtYXRjaEFsbCA9IChyZWdFeHAsIHN0cikgPT4ge1xuICBsZXQgbWF0Y2hlcztcbiAgY29uc3QgYXJyID0gW107XG5cbiAgd2hpbGUgKChtYXRjaGVzID0gcmVnRXhwLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBhcnIucHVzaChtYXRjaGVzKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59O1xuXG4vKiBDaGVja2luZyBpZiB0aGUga2luZE9mVGVzdCBmdW5jdGlvbiByZXR1cm5zIHRydWUgd2hlbiBwYXNzZWQgYW4gSFRNTEZvcm1FbGVtZW50LiAqL1xuY29uc3QgaXNIVE1MRm9ybSA9IGtpbmRPZlRlc3QoJ0hUTUxGb3JtRWxlbWVudCcpO1xuXG5jb25zdCB0b0NhbWVsQ2FzZSA9IHN0ciA9PiB7XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9cXHNdKFthLXpcXGRdKShcXHcqKS9nLFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG0sIHAxLCBwMikge1xuICAgICAgcmV0dXJuIHAxLnRvVXBwZXJDYXNlKCkgKyBwMjtcbiAgICB9XG4gICk7XG59O1xuXG4vKiBDcmVhdGluZyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBjaGVjayBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9ICgoe2hhc093blByb3BlcnR5fSkgPT4gKG9iaiwgcHJvcCkgPT4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKShPYmplY3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3RcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzUmVnRXhwID0ga2luZE9mVGVzdCgnUmVnRXhwJyk7XG5cbmNvbnN0IHJlZHVjZURlc2NyaXB0b3JzID0gKG9iaiwgcmVkdWNlcikgPT4ge1xuICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaik7XG4gIGNvbnN0IHJlZHVjZWREZXNjcmlwdG9ycyA9IHt9O1xuXG4gIGZvckVhY2goZGVzY3JpcHRvcnMsIChkZXNjcmlwdG9yLCBuYW1lKSA9PiB7XG4gICAgbGV0IHJldDtcbiAgICBpZiAoKHJldCA9IHJlZHVjZXIoZGVzY3JpcHRvciwgbmFtZSwgb2JqKSkgIT09IGZhbHNlKSB7XG4gICAgICByZWR1Y2VkRGVzY3JpcHRvcnNbbmFtZV0gPSByZXQgfHwgZGVzY3JpcHRvcjtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iaiwgcmVkdWNlZERlc2NyaXB0b3JzKTtcbn07XG5cbi8qKlxuICogTWFrZXMgYWxsIG1ldGhvZHMgcmVhZC1vbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuY29uc3QgZnJlZXplTWV0aG9kcyA9IChvYmopID0+IHtcbiAgcmVkdWNlRGVzY3JpcHRvcnMob2JqLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIC8vIHNraXAgcmVzdHJpY3RlZCBwcm9wcyBpbiBzdHJpY3QgbW9kZVxuICAgIGlmIChpc0Z1bmN0aW9uJDEob2JqKSAmJiBbJ2FyZ3VtZW50cycsICdjYWxsZXInLCAnY2FsbGVlJ10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IG9ialtuYW1lXTtcblxuICAgIGlmICghaXNGdW5jdGlvbiQxKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoJ3dyaXRhYmxlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFkZXNjcmlwdG9yLnNldCkge1xuICAgICAgZGVzY3JpcHRvci5zZXQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IEVycm9yKCdDYW4gbm90IHJld3JpdGUgcmVhZC1vbmx5IG1ldGhvZCBcXCcnICsgbmFtZSArICdcXCcnKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IHRvT2JqZWN0U2V0ID0gKGFycmF5T3JTdHJpbmcsIGRlbGltaXRlcikgPT4ge1xuICBjb25zdCBvYmogPSB7fTtcblxuICBjb25zdCBkZWZpbmUgPSAoYXJyKSA9PiB7XG4gICAgYXJyLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgb2JqW3ZhbHVlXSA9IHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgaXNBcnJheShhcnJheU9yU3RyaW5nKSA/IGRlZmluZShhcnJheU9yU3RyaW5nKSA6IGRlZmluZShTdHJpbmcoYXJyYXlPclN0cmluZykuc3BsaXQoZGVsaW1pdGVyKSk7XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuY29uc3QgdG9GaW5pdGVOdW1iZXIgPSAodmFsdWUsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUgPSArdmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59O1xuXG5cblxuLyoqXG4gKiBJZiB0aGUgdGhpbmcgaXMgYSBGb3JtRGF0YSBvYmplY3QsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdGhpbmcgLSBUaGUgdGhpbmcgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3BlY0NvbXBsaWFudEZvcm0odGhpbmcpIHtcbiAgcmV0dXJuICEhKHRoaW5nICYmIGlzRnVuY3Rpb24kMSh0aGluZy5hcHBlbmQpICYmIHRoaW5nW3RvU3RyaW5nVGFnXSA9PT0gJ0Zvcm1EYXRhJyAmJiB0aGluZ1tpdGVyYXRvcl0pO1xufVxuXG5jb25zdCB0b0pTT05PYmplY3QgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEFycmF5KDEwKTtcblxuICBjb25zdCB2aXNpdCA9IChzb3VyY2UsIGkpID0+IHtcblxuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihzb3VyY2UpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvL0J1ZmZlciBjaGVja1xuICAgICAgaWYgKGlzQnVmZmVyKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgaWYoISgndG9KU09OJyBpbiBzb3VyY2UpKSB7XG4gICAgICAgIHN0YWNrW2ldID0gc291cmNlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpc0FycmF5KHNvdXJjZSkgPyBbXSA6IHt9O1xuXG4gICAgICAgIGZvckVhY2goc291cmNlLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlZHVjZWRWYWx1ZSA9IHZpc2l0KHZhbHVlLCBpICsgMSk7XG4gICAgICAgICAgIWlzVW5kZWZpbmVkKHJlZHVjZWRWYWx1ZSkgJiYgKHRhcmdldFtrZXldID0gcmVkdWNlZFZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhY2tbaV0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlO1xuICB9O1xuXG4gIHJldHVybiB2aXNpdChvYmosIDApO1xufTtcblxuY29uc3QgaXNBc3luY0ZuID0ga2luZE9mVGVzdCgnQXN5bmNGdW5jdGlvbicpO1xuXG5jb25zdCBpc1RoZW5hYmxlID0gKHRoaW5nKSA9PlxuICB0aGluZyAmJiAoaXNPYmplY3QodGhpbmcpIHx8IGlzRnVuY3Rpb24kMSh0aGluZykpICYmIGlzRnVuY3Rpb24kMSh0aGluZy50aGVuKSAmJiBpc0Z1bmN0aW9uJDEodGhpbmcuY2F0Y2gpO1xuXG4vLyBvcmlnaW5hbCBjb2RlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vRGlnaXRhbEJyYWluSlMvQXhpb3NQcm9taXNlL2Jsb2IvMTZkZWFiMTM3MTBlYzA5Nzc5OTIyMTMxZjNmYTU5NTQzMjBmODNhYi9saWIvdXRpbHMuanMjTDExLUwzNFxuXG5jb25zdCBfc2V0SW1tZWRpYXRlID0gKChzZXRJbW1lZGlhdGVTdXBwb3J0ZWQsIHBvc3RNZXNzYWdlU3VwcG9ydGVkKSA9PiB7XG4gIGlmIChzZXRJbW1lZGlhdGVTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gc2V0SW1tZWRpYXRlO1xuICB9XG5cbiAgcmV0dXJuIHBvc3RNZXNzYWdlU3VwcG9ydGVkID8gKCh0b2tlbiwgY2FsbGJhY2tzKSA9PiB7XG4gICAgX2dsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoe3NvdXJjZSwgZGF0YX0pID0+IHtcbiAgICAgIGlmIChzb3VyY2UgPT09IF9nbG9iYWwgJiYgZGF0YSA9PT0gdG9rZW4pIHtcbiAgICAgICAgY2FsbGJhY2tzLmxlbmd0aCAmJiBjYWxsYmFja3Muc2hpZnQoKSgpO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcblxuICAgIHJldHVybiAoY2IpID0+IHtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgIF9nbG9iYWwucG9zdE1lc3NhZ2UodG9rZW4sIFwiKlwiKTtcbiAgICB9XG4gIH0pKGBheGlvc0Ake01hdGgucmFuZG9tKCl9YCwgW10pIDogKGNiKSA9PiBzZXRUaW1lb3V0KGNiKTtcbn0pKFxuICB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nLFxuICBpc0Z1bmN0aW9uJDEoX2dsb2JhbC5wb3N0TWVzc2FnZSlcbik7XG5cbmNvbnN0IGFzYXAgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgIT09ICd1bmRlZmluZWQnID9cbiAgcXVldWVNaWNyb3Rhc2suYmluZChfZ2xvYmFsKSA6ICggdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MubmV4dFRpY2sgfHwgX3NldEltbWVkaWF0ZSk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKlxuXG5cbmNvbnN0IGlzSXRlcmFibGUgPSAodGhpbmcpID0+IHRoaW5nICE9IG51bGwgJiYgaXNGdW5jdGlvbiQxKHRoaW5nW2l0ZXJhdG9yXSk7XG5cblxudmFyIHV0aWxzJDEgPSB7XG4gIGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmcsXG4gIGlzTnVtYmVyLFxuICBpc0Jvb2xlYW4sXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc0VtcHR5T2JqZWN0LFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1JlcXVlc3QsXG4gIGlzUmVzcG9uc2UsXG4gIGlzSGVhZGVycyxcbiAgaXNVbmRlZmluZWQsXG4gIGlzRGF0ZSxcbiAgaXNGaWxlLFxuICBpc0Jsb2IsXG4gIGlzUmVnRXhwLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uJDEsXG4gIGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0LFxuICBmb3JFYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICB0cmltLFxuICBzdHJpcEJPTSxcbiAgaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdCxcbiAga2luZE9mLFxuICBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aCxcbiAgdG9BcnJheSxcbiAgZm9yRWFjaEVudHJ5LFxuICBtYXRjaEFsbCxcbiAgaXNIVE1MRm9ybSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGhhc093blByb3A6IGhhc093blByb3BlcnR5LCAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9ycyxcbiAgZnJlZXplTWV0aG9kcyxcbiAgdG9PYmplY3RTZXQsXG4gIHRvQ2FtZWxDYXNlLFxuICBub29wLFxuICB0b0Zpbml0ZU51bWJlcixcbiAgZmluZEtleSxcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBpc0NvbnRleHREZWZpbmVkLFxuICBpc1NwZWNDb21wbGlhbnRGb3JtLFxuICB0b0pTT05PYmplY3QsXG4gIGlzQXN5bmNGbixcbiAgaXNUaGVuYWJsZSxcbiAgc2V0SW1tZWRpYXRlOiBfc2V0SW1tZWRpYXRlLFxuICBhc2FwLFxuICBpc0l0ZXJhYmxlXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQXhpb3NFcnJvcihtZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIEVycm9yLmNhbGwodGhpcyk7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gIH1cblxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLm5hbWUgPSAnQXhpb3NFcnJvcic7XG4gIGNvZGUgJiYgKHRoaXMuY29kZSA9IGNvZGUpO1xuICBjb25maWcgJiYgKHRoaXMuY29uZmlnID0gY29uZmlnKTtcbiAgcmVxdWVzdCAmJiAodGhpcy5yZXF1ZXN0ID0gcmVxdWVzdCk7XG4gIGlmIChyZXNwb25zZSkge1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cyA/IHJlc3BvbnNlLnN0YXR1cyA6IG51bGw7XG4gIH1cbn1cblxudXRpbHMkMS5pbmhlcml0cyhBeGlvc0Vycm9yLCBFcnJvciwge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB1dGlscyQxLnRvSlNPTk9iamVjdCh0aGlzLmNvbmZpZyksXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzXG4gICAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IHByb3RvdHlwZSQxID0gQXhpb3NFcnJvci5wcm90b3R5cGU7XG5jb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xuXG5bXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXG4gICdFUlJfQkFEX09QVElPTicsXG4gICdFQ09OTkFCT1JURUQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VSUl9ORVRXT1JLJyxcbiAgJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnLFxuICAnRVJSX0RFUFJFQ0FURUQnLFxuICAnRVJSX0JBRF9SRVNQT05TRScsXG4gICdFUlJfQkFEX1JFUVVFU1QnLFxuICAnRVJSX0NBTkNFTEVEJyxcbiAgJ0VSUl9OT1RfU1VQUE9SVCcsXG4gICdFUlJfSU5WQUxJRF9VUkwnXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXS5mb3JFYWNoKGNvZGUgPT4ge1xuICBkZXNjcmlwdG9yc1tjb2RlXSA9IHt2YWx1ZTogY29kZX07XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQXhpb3NFcnJvciwgZGVzY3JpcHRvcnMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSQxLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XG4gIGNvbnN0IGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSQxKTtcblxuICB1dGlscyQxLnRvRmxhdE9iamVjdChlcnJvciwgYXhpb3NFcnJvciwgZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogIT09IEVycm9yLnByb3RvdHlwZTtcbiAgfSwgcHJvcCA9PiB7XG4gICAgcmV0dXJuIHByb3AgIT09ICdpc0F4aW9zRXJyb3InO1xuICB9KTtcblxuICBjb25zdCBtc2cgPSBlcnJvciAmJiBlcnJvci5tZXNzYWdlID8gZXJyb3IubWVzc2FnZSA6ICdFcnJvcic7XG5cbiAgLy8gUHJlZmVyIGV4cGxpY2l0IGNvZGU7IG90aGVyd2lzZSBjb3B5IHRoZSBsb3ctbGV2ZWwgZXJyb3IncyBjb2RlIChlLmcuIEVDT05OUkVGVVNFRClcbiAgY29uc3QgZXJyQ29kZSA9IGNvZGUgPT0gbnVsbCAmJiBlcnJvciA/IGVycm9yLmNvZGUgOiBjb2RlO1xuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgbXNnLCBlcnJDb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICAvLyBDaGFpbiB0aGUgb3JpZ2luYWwgZXJyb3Igb24gdGhlIHN0YW5kYXJkIGZpZWxkOyBub24tZW51bWVyYWJsZSB0byBhdm9pZCBKU09OIG5vaXNlXG4gIGlmIChlcnJvciAmJiBheGlvc0Vycm9yLmNhdXNlID09IG51bGwpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXhpb3NFcnJvciwgJ2NhdXNlJywgeyB2YWx1ZTogZXJyb3IsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIGF4aW9zRXJyb3IubmFtZSA9IChlcnJvciAmJiBlcnJvci5uYW1lKSB8fCAnRXJyb3InO1xuXG4gIGN1c3RvbVByb3BzICYmIE9iamVjdC5hc3NpZ24oYXhpb3NFcnJvciwgY3VzdG9tUHJvcHMpO1xuXG4gIHJldHVybiBheGlvc0Vycm9yO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0cmljdFxudmFyIGh0dHBBZGFwdGVyID0gbnVsbDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiB0aGluZyBpcyBhIGFycmF5IG9yIGpzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGhpbmcgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIHZpc2l0ZWQuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmlzaXRhYmxlKHRoaW5nKSB7XG4gIHJldHVybiB1dGlscyQxLmlzUGxhaW5PYmplY3QodGhpbmcpIHx8IHV0aWxzJDEuaXNBcnJheSh0aGluZyk7XG59XG5cbi8qKlxuICogSXQgcmVtb3ZlcyB0aGUgYnJhY2tldHMgZnJvbSB0aGUgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmFtZXRlci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUga2V5IHdpdGhvdXQgdGhlIGJyYWNrZXRzLlxuICovXG5mdW5jdGlvbiByZW1vdmVCcmFja2V0cyhrZXkpIHtcbiAgcmV0dXJuIHV0aWxzJDEuZW5kc1dpdGgoa2V5LCAnW10nKSA/IGtleS5zbGljZSgwLCAtMikgOiBrZXk7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBwYXRoLCBhIGtleSwgYW5kIGEgYm9vbGVhbiwgYW5kIHJldHVybnMgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBUaGUga2V5IG9mIHRoZSBjdXJyZW50IG9iamVjdCBiZWluZyBpdGVyYXRlZCBvdmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvdHMgLSBJZiB0cnVlLCB0aGUga2V5IHdpbGwgYmUgcmVuZGVyZWQgd2l0aCBkb3RzIGluc3RlYWQgb2YgYnJhY2tldHMuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHBhdGggdG8gdGhlIGN1cnJlbnQga2V5LlxuICovXG5mdW5jdGlvbiByZW5kZXJLZXkocGF0aCwga2V5LCBkb3RzKSB7XG4gIGlmICghcGF0aCkgcmV0dXJuIGtleTtcbiAgcmV0dXJuIHBhdGguY29uY2F0KGtleSkubWFwKGZ1bmN0aW9uIGVhY2godG9rZW4sIGkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB0b2tlbiA9IHJlbW92ZUJyYWNrZXRzKHRva2VuKTtcbiAgICByZXR1cm4gIWRvdHMgJiYgaSA/ICdbJyArIHRva2VuICsgJ10nIDogdG9rZW47XG4gIH0pLmpvaW4oZG90cyA/ICcuJyA6ICcnKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgYXJyYXkgaXMgYW4gYXJyYXkgYW5kIG5vbmUgb2YgaXRzIGVsZW1lbnRzIGFyZSB2aXNpdGFibGUsIHRoZW4gaXQncyBhIGZsYXQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnIgLSBUaGUgYXJyYXkgdG8gY2hlY2tcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGbGF0QXJyYXkoYXJyKSB7XG4gIHJldHVybiB1dGlscyQxLmlzQXJyYXkoYXJyKSAmJiAhYXJyLnNvbWUoaXNWaXNpdGFibGUpO1xufVxuXG5jb25zdCBwcmVkaWNhdGVzID0gdXRpbHMkMS50b0ZsYXRPYmplY3QodXRpbHMkMSwge30sIG51bGwsIGZ1bmN0aW9uIGZpbHRlcihwcm9wKSB7XG4gIHJldHVybiAvXmlzW0EtWl0vLnRlc3QocHJvcCk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgZGF0YSBvYmplY3QgdG8gRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0gez9PYmplY3R9IFtmb3JtRGF0YV1cbiAqIEBwYXJhbSB7P09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52aXNpdG9yXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXRhVG9rZW5zID0gdHJ1ZV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG90cyA9IGZhbHNlXVxuICogQHBhcmFtIHs/Qm9vbGVhbn0gW29wdGlvbnMuaW5kZXhlcyA9IGZhbHNlXVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiovXG5cbi8qKlxuICogSXQgY29udmVydHMgYW4gb2JqZWN0IGludG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gY29udmVydCB0byBmb3JtIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybURhdGEgLSBUaGUgRm9ybURhdGEgb2JqZWN0IHRvIGFwcGVuZCB0by5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHRvRm9ybURhdGEob2JqLCBmb3JtRGF0YSwgb3B0aW9ucykge1xuICBpZiAoIXV0aWxzJDEuaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IChGb3JtRGF0YSkoKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgb3B0aW9ucyA9IHV0aWxzJDEudG9GbGF0T2JqZWN0KG9wdGlvbnMsIHtcbiAgICBtZXRhVG9rZW5zOiB0cnVlLFxuICAgIGRvdHM6IGZhbHNlLFxuICAgIGluZGV4ZXM6IGZhbHNlXG4gIH0sIGZhbHNlLCBmdW5jdGlvbiBkZWZpbmVkKG9wdGlvbiwgc291cmNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgcmV0dXJuICF1dGlscyQxLmlzVW5kZWZpbmVkKHNvdXJjZVtvcHRpb25dKTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0YVRva2VucyA9IG9wdGlvbnMubWV0YVRva2VucztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XG4gIGNvbnN0IGRvdHMgPSBvcHRpb25zLmRvdHM7XG4gIGNvbnN0IGluZGV4ZXMgPSBvcHRpb25zLmluZGV4ZXM7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xuICBjb25zdCB1c2VCbG9iID0gX0Jsb2IgJiYgdXRpbHMkMS5pc1NwZWNDb21wbGlhbnRGb3JtKGZvcm1EYXRhKTtcblxuICBpZiAoIXV0aWxzJDEuaXNGdW5jdGlvbih2aXNpdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Zpc2l0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnJztcblxuICAgIGlmICh1dGlscyQxLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh1dGlscyQxLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghdXNlQmxvYiAmJiB1dGlscyQxLmlzQmxvYih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhIEJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIGlmICh1dGlscyQxLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzJDEuaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHVzZUJsb2IgJiYgdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgPyBuZXcgQmxvYihbdmFsdWVdKSA6IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCB2aXNpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5XG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nfE51bWJlcj59IHBhdGhcbiAgICogQHRoaXMge0Zvcm1EYXRhfVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgdG8gdmlzaXQgdGhlIGVhY2ggcHJvcCBvZiB0aGUgdmFsdWUgcmVjdXJzaXZlbHlcbiAgICovXG4gIGZ1bmN0aW9uIGRlZmF1bHRWaXNpdG9yKHZhbHVlLCBrZXksIHBhdGgpIHtcbiAgICBsZXQgYXJyID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgJiYgIXBhdGggJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHV0aWxzJDEuZW5kc1dpdGgoa2V5LCAne30nKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gbWV0YVRva2VucyA/IGtleSA6IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICh1dGlscyQxLmlzQXJyYXkodmFsdWUpICYmIGlzRmxhdEFycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgKCh1dGlscyQxLmlzRmlsZUxpc3QodmFsdWUpIHx8IHV0aWxzJDEuZW5kc1dpdGgoa2V5LCAnW10nKSkgJiYgKGFyciA9IHV0aWxzJDEudG9BcnJheSh2YWx1ZSkpXG4gICAgICAgICkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IHJlbW92ZUJyYWNrZXRzKGtleSk7XG5cbiAgICAgICAgYXJyLmZvckVhY2goZnVuY3Rpb24gZWFjaChlbCwgaW5kZXgpIHtcbiAgICAgICAgICAhKHV0aWxzJDEuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIGluZGV4ZXMgPT09IHRydWUgPyByZW5kZXJLZXkoW2tleV0sIGluZGV4LCBkb3RzKSA6IChpbmRleGVzID09PSBudWxsID8ga2V5IDoga2V5ICsgJ1tdJyksXG4gICAgICAgICAgICBjb252ZXJ0VmFsdWUoZWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNWaXNpdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3JtRGF0YS5hcHBlbmQocmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cyksIGNvbnZlcnRWYWx1ZSh2YWx1ZSkpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBjb25zdCBleHBvc2VkSGVscGVycyA9IE9iamVjdC5hc3NpZ24ocHJlZGljYXRlcywge1xuICAgIGRlZmF1bHRWaXNpdG9yLFxuICAgIGNvbnZlcnRWYWx1ZSxcbiAgICBpc1Zpc2l0YWJsZVxuICB9KTtcblxuICBmdW5jdGlvbiBidWlsZCh2YWx1ZSwgcGF0aCkge1xuICAgIGlmICh1dGlscyQxLmlzVW5kZWZpbmVkKHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCBpbiAnICsgcGF0aC5qb2luKCcuJykpO1xuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsdWUpO1xuXG4gICAgdXRpbHMkMS5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiBlYWNoKGVsLCBrZXkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9ICEodXRpbHMkMS5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIHZpc2l0b3IuY2FsbChcbiAgICAgICAgZm9ybURhdGEsIGVsLCB1dGlscyQxLmlzU3RyaW5nKGtleSkgPyBrZXkudHJpbSgpIDoga2V5LCBwYXRoLCBleHBvc2VkSGVscGVyc1xuICAgICAgKTtcblxuICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICBidWlsZChlbCwgcGF0aCA/IHBhdGguY29uY2F0KGtleSkgOiBba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICghdXRpbHMkMS5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgYnVpbGQob2JqKTtcblxuICByZXR1cm4gZm9ybURhdGE7XG59XG5cbi8qKlxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXG4gKiB0aGVpciBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUkMShzdHIpIHtcbiAgY29uc3QgY2hhck1hcCA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgIFwiJ1wiOiAnJTI3JyxcbiAgICAnKCc6ICclMjgnLFxuICAgICcpJzogJyUyOScsXG4gICAgJ34nOiAnJTdFJyxcbiAgICAnJTIwJzogJysnLFxuICAgICclMDAnOiAnXFx4MDAnXG4gIH07XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKX5dfCUyMHwlMDAvZywgZnVuY3Rpb24gcmVwbGFjZXIobWF0Y2gpIHtcbiAgICByZXR1cm4gY2hhck1hcFttYXRjaF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGFyYW1zIG9iamVjdCBhbmQgY29udmVydHMgaXQgdG8gYSBGb3JtRGF0YSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIGJlIGNvbnZlcnRlZCB0byBhIEZvcm1EYXRhIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gdGhlIEF4aW9zIGNvbnN0cnVjdG9yLlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgdGhpcy5fcGFpcnMgPSBbXTtcblxuICBwYXJhbXMgJiYgdG9Gb3JtRGF0YShwYXJhbXMsIHRoaXMsIG9wdGlvbnMpO1xufVxuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc1VSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5fcGFpcnMucHVzaChbbmFtZSwgdmFsdWVdKTtcbn07XG5cbnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGVuY29kZXIpIHtcbiAgY29uc3QgX2VuY29kZSA9IGVuY29kZXIgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBlbmNvZGVyLmNhbGwodGhpcywgdmFsdWUsIGVuY29kZSQxKTtcbiAgfSA6IGVuY29kZSQxO1xuXG4gIHJldHVybiB0aGlzLl9wYWlycy5tYXAoZnVuY3Rpb24gZWFjaChwYWlyKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xuICB9LCAnJykuam9pbignJicpO1xufTtcblxuLyoqXG4gKiBJdCByZXBsYWNlcyBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjaGFyYWN0ZXJzIGA6YCwgYCRgLCBgLGAsIGArYCwgYFtgLCBhbmQgYF1gIHdpdGggdGhlaXJcbiAqIFVSSSBlbmNvZGVkIGNvdW50ZXJwYXJ0c1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWwgVGhlIHZhbHVlIHRvIGJlIGVuY29kZWQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHBhcmFtIHs/KG9iamVjdHxGdW5jdGlvbil9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5mdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgb3B0aW9ucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIFxuICBjb25zdCBfZW5jb2RlID0gb3B0aW9ucyAmJiBvcHRpb25zLmVuY29kZSB8fCBlbmNvZGU7XG5cbiAgaWYgKHV0aWxzJDEuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzZXJpYWxpemU6IG9wdGlvbnNcbiAgICB9O1xuICB9IFxuXG4gIGNvbnN0IHNlcmlhbGl6ZUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLnNlcmlhbGl6ZTtcblxuICBsZXQgc2VyaWFsaXplZFBhcmFtcztcblxuICBpZiAoc2VyaWFsaXplRm4pIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gc2VyaWFsaXplRm4ocGFyYW1zLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gdXRpbHMkMS5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpID9cbiAgICAgIHBhcmFtcy50b1N0cmluZygpIDpcbiAgICAgIG5ldyBBeGlvc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMsIG9wdGlvbnMpLnRvU3RyaW5nKF9lbmNvZGUpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICBjb25zdCBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoXCIjXCIpO1xuXG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59XG5cbmNsYXNzIEludGVyY2VwdG9yTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgZnVsZmlsbGVkLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBzeW5jaHJvbm91czogb3B0aW9ucyA/IG9wdGlvbnMuc3luY2hyb25vdXMgOiBmYWxzZSxcbiAgICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBpbnRlcmNlcHRvciB3YXMgcmVtb3ZlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICovXG4gIGVqZWN0KGlkKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBpbnRlcmNlcHRvcnMgZnJvbSB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICAgKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmb3JFYWNoKGZuKSB7XG4gICAgdXRpbHMkMS5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgIGZuKGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbnZhciBJbnRlcmNlcHRvck1hbmFnZXIkMSA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0ge1xuICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gIGNsYXJpZnlUaW1lb3V0RXJyb3I6IGZhbHNlXG59O1xuXG52YXIgVVJMU2VhcmNoUGFyYW1zJDEgPSB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IFVSTFNlYXJjaFBhcmFtcyA6IEF4aW9zVVJMU2VhcmNoUGFyYW1zO1xuXG52YXIgRm9ybURhdGEkMSA9IHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBGb3JtRGF0YSA6IG51bGw7XG5cbnZhciBCbG9iJDEgPSB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbDtcblxudmFyIHBsYXRmb3JtJDEgPSB7XG4gIGlzQnJvd3NlcjogdHJ1ZSxcbiAgY2xhc3Nlczoge1xuICAgIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zJDEsXG4gICAgRm9ybURhdGE6IEZvcm1EYXRhJDEsXG4gICAgQmxvYjogQmxvYiQxXG4gIH0sXG4gIHByb3RvY29sczogWydodHRwJywgJ2h0dHBzJywgJ2ZpbGUnLCAnYmxvYicsICd1cmwnLCAnZGF0YSddXG59O1xuXG5jb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuY29uc3QgX25hdmlnYXRvciA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvciB8fCB1bmRlZmluZWQ7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJFbnYgPSBoYXNCcm93c2VyRW52ICYmXG4gICghX25hdmlnYXRvciB8fCBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YoX25hdmlnYXRvci5wcm9kdWN0KSA8IDApO1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciB3ZWJXb3JrZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBBbHRob3VnaCB0aGUgYGlzU3RhbmRhcmRCcm93c2VyRW52YCBtZXRob2QgaW5kaWNhdGVzIHRoYXRcbiAqIGBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlcmAsIHRoZSBXZWJXb3JrZXIgd2lsbCBzdGlsbCBiZVxuICogZmlsdGVyZWQgb3V0IGR1ZSB0byBpdHMganVkZ21lbnQgc3RhbmRhcmRcbiAqIGB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnYC5cbiAqIFRoaXMgbGVhZHMgdG8gYSBwcm9ibGVtIHdoZW4gYXhpb3MgcG9zdCBgRm9ybURhdGFgIGluIHdlYldvcmtlclxuICovXG5jb25zdCBoYXNTdGFuZGFyZEJyb3dzZXJXZWJXb3JrZXJFbnYgPSAoKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiZcbiAgICB0eXBlb2Ygc2VsZi5pbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nXG4gICk7XG59KSgpO1xuXG5jb25zdCBvcmlnaW4gPSBoYXNCcm93c2VyRW52ICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICdodHRwOi8vbG9jYWxob3N0JztcblxudmFyIHV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGhhc0Jyb3dzZXJFbnY6IGhhc0Jyb3dzZXJFbnYsXG4gIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudjogaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnY6IGhhc1N0YW5kYXJkQnJvd3NlckVudixcbiAgbmF2aWdhdG9yOiBfbmF2aWdhdG9yLFxuICBvcmlnaW46IG9yaWdpblxufSk7XG5cbnZhciBwbGF0Zm9ybSA9IHtcbiAgLi4udXRpbHMsXG4gIC4uLnBsYXRmb3JtJDFcbn07XG5cbmZ1bmN0aW9uIHRvVVJMRW5jb2RlZEZvcm0oZGF0YSwgb3B0aW9ucykge1xuICByZXR1cm4gdG9Gb3JtRGF0YShkYXRhLCBuZXcgcGxhdGZvcm0uY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwge1xuICAgIHZpc2l0b3I6IGZ1bmN0aW9uKHZhbHVlLCBrZXksIHBhdGgsIGhlbHBlcnMpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5pc05vZGUgJiYgdXRpbHMkMS5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoa2V5LCB2YWx1ZS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWxwZXJzLmRlZmF1bHRWaXNpdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nIGxpa2UgYGZvb1t4XVt5XVt6XWAgYW5kIHJldHVybnMgYW4gYXJyYXkgbGlrZSBgWydmb28nLCAneCcsICd5JywgJ3onXVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmdzLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BQYXRoKG5hbWUpIHtcbiAgLy8gZm9vW3hdW3ldW3pdXG4gIC8vIGZvby54LnkuelxuICAvLyBmb28teC15LXpcbiAgLy8gZm9vIHggeSB6XG4gIHJldHVybiB1dGlscyQxLm1hdGNoQWxsKC9cXHcrfFxcWyhcXHcqKV0vZywgbmFtZSkubWFwKG1hdGNoID0+IHtcbiAgICByZXR1cm4gbWF0Y2hbMF0gPT09ICdbXScgPyAnJyA6IG1hdGNoWzFdIHx8IG1hdGNoWzBdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFycmF5IHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjb252ZXJ0IHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFuZCB2YWx1ZXMgYXMgdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVRvT2JqZWN0KGFycikge1xuICBjb25zdCBvYmogPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFycik7XG4gIGxldCBpO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGtleTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBvYmpba2V5XSA9IGFycltrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBGb3JtRGF0YSBvYmplY3QgYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSBUaGUgRm9ybURhdGEgb2JqZWN0IHRvIGNvbnZlcnQgdG8gSlNPTi5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgYW55PiB8IG51bGx9IFRoZSBjb252ZXJ0ZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBmb3JtRGF0YVRvSlNPTihmb3JtRGF0YSkge1xuICBmdW5jdGlvbiBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldCwgaW5kZXgpIHtcbiAgICBsZXQgbmFtZSA9IHBhdGhbaW5kZXgrK107XG5cbiAgICBpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHJldHVybiB0cnVlO1xuXG4gICAgY29uc3QgaXNOdW1lcmljS2V5ID0gTnVtYmVyLmlzRmluaXRlKCtuYW1lKTtcbiAgICBjb25zdCBpc0xhc3QgPSBpbmRleCA+PSBwYXRoLmxlbmd0aDtcbiAgICBuYW1lID0gIW5hbWUgJiYgdXRpbHMkMS5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQubGVuZ3RoIDogbmFtZTtcblxuICAgIGlmIChpc0xhc3QpIHtcbiAgICAgIGlmICh1dGlscyQxLmhhc093blByb3AodGFyZ2V0LCBuYW1lKSkge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSBbdGFyZ2V0W25hbWVdLCB2YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRbbmFtZV0gfHwgIXV0aWxzJDEuaXNPYmplY3QodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gW107XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXRbbmFtZV0sIGluZGV4KTtcblxuICAgIGlmIChyZXN1bHQgJiYgdXRpbHMkMS5pc0FycmF5KHRhcmdldFtuYW1lXSkpIHtcbiAgICAgIHRhcmdldFtuYW1lXSA9IGFycmF5VG9PYmplY3QodGFyZ2V0W25hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgfVxuXG4gIGlmICh1dGlscyQxLmlzRm9ybURhdGEoZm9ybURhdGEpICYmIHV0aWxzJDEuaXNGdW5jdGlvbihmb3JtRGF0YS5lbnRyaWVzKSkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgdXRpbHMkMS5mb3JFYWNoRW50cnkoZm9ybURhdGEsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgYnVpbGRQYXRoKHBhcnNlUHJvcFBhdGgobmFtZSksIHZhbHVlLCBvYmosIDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgc3RyaW5nLCB0cmllcyB0byBwYXJzZSBpdCwgYW5kIGlmIGl0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uXG4gKiBvZiB0aGUgaW5wdXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXJzZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgdGhlIHJhd1ZhbHVlLlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMkMS5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMkMS50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDogdHJhbnNpdGlvbmFsRGVmYXVsdHMsXG5cbiAgYWRhcHRlcjogWyd4aHInLCAnaHR0cCcsICdmZXRjaCddLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0Q29udGVudFR5cGUoKSB8fCAnJztcbiAgICBjb25zdCBoYXNKU09OQ29udGVudFR5cGUgPSBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMTtcbiAgICBjb25zdCBpc09iamVjdFBheWxvYWQgPSB1dGlscyQxLmlzT2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCAmJiB1dGlscyQxLmlzSFRNTEZvcm0oZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRm9ybURhdGEoZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGb3JtRGF0YSA9IHV0aWxzJDEuaXNGb3JtRGF0YShkYXRhKTtcblxuICAgIGlmIChpc0Zvcm1EYXRhKSB7XG4gICAgICByZXR1cm4gaGFzSlNPTkNvbnRlbnRUeXBlID8gSlNPTi5zdHJpbmdpZnkoZm9ybURhdGFUb0pTT04oZGF0YSkpIDogZGF0YTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMkMS5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscyQxLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscyQxLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscyQxLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMkMS5pc0Jsb2IoZGF0YSkgfHxcbiAgICAgIHV0aWxzJDEuaXNSZWFkYWJsZVN0cmVhbShkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscyQxLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscyQxLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkKSB7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCB0aGlzLmZvcm1TZXJpYWxpemVyKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscyQxLmlzRmlsZUxpc3QoZGF0YSkpIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ211bHRpcGFydC9mb3JtLWRhdGEnKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IF9Gb3JtRGF0YSA9IHRoaXMuZW52ICYmIHRoaXMuZW52LkZvcm1EYXRhO1xuXG4gICAgICAgIHJldHVybiB0b0Zvcm1EYXRhKFxuICAgICAgICAgIGlzRmlsZUxpc3QgPyB7J2ZpbGVzW10nOiBkYXRhfSA6IGRhdGEsXG4gICAgICAgICAgX0Zvcm1EYXRhICYmIG5ldyBfRm9ybURhdGEoKSxcbiAgICAgICAgICB0aGlzLmZvcm1TZXJpYWxpemVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0UGF5bG9hZCB8fCBoYXNKU09OQ29udGVudFR5cGUgKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi9qc29uJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWwgfHwgZGVmYXVsdHMudHJhbnNpdGlvbmFsO1xuICAgIGNvbnN0IGZvcmNlZEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5mb3JjZWRKU09OUGFyc2luZztcbiAgICBjb25zdCBKU09OUmVxdWVzdGVkID0gdGhpcy5yZXNwb25zZVR5cGUgPT09ICdqc29uJztcblxuICAgIGlmICh1dGlscyQxLmlzUmVzcG9uc2UoZGF0YSkgfHwgdXRpbHMkMS5pc1JlYWRhYmxlU3RyZWFtKGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSAmJiB1dGlscyQxLmlzU3RyaW5nKGRhdGEpICYmICgoZm9yY2VkSlNPTlBhcnNpbmcgJiYgIXRoaXMucmVzcG9uc2VUeXBlKSB8fCBKU09OUmVxdWVzdGVkKSkge1xuICAgICAgY29uc3Qgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgICAgY29uc3Qgc3RyaWN0SlNPTlBhcnNpbmcgPSAhc2lsZW50SlNPTlBhcnNpbmcgJiYgSlNPTlJlcXVlc3RlZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSwgdGhpcy5wYXJzZVJldml2ZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHBsYXRmb3JtLmNsYXNzZXMuRm9ybURhdGEsXG4gICAgQmxvYjogcGxhdGZvcm0uY2xhc3Nlcy5CbG9iXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicsXG4gICAgICAnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkXG4gICAgfVxuICB9XG59O1xuXG51dGlscyQxLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgKG1ldGhvZCkgPT4ge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG52YXIgZGVmYXVsdHMkMSA9IGRlZmF1bHRzO1xuXG4vLyBSYXdBeGlvc0hlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG5jb25zdCBpZ25vcmVEdXBsaWNhdGVPZiA9IHV0aWxzJDEudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xudmFyIHBhcnNlSGVhZGVycyA9IHJhd0hlYWRlcnMgPT4ge1xuICBjb25zdCBwYXJzZWQgPSB7fTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcbiAgbGV0IGk7XG5cbiAgcmF3SGVhZGVycyAmJiByYXdIZWFkZXJzLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IGxpbmUuc3Vic3RyaW5nKGkgKyAxKS50cmltKCk7XG5cbiAgICBpZiAoIWtleSB8fCAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2Zba2V5XSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSkge1xuICAgICAgICBwYXJzZWRba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IFt2YWxdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbmNvbnN0ICRpbnRlcm5hbHMgPSBTeW1ib2woJ2ludGVybmFscycpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXIoaGVhZGVyKSB7XG4gIHJldHVybiBoZWFkZXIgJiYgU3RyaW5nKGhlYWRlcikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB1dGlscyQxLmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXHMsOz1dKylcXHMqKD86PVxccyooW14sO10rKSk/L2c7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xuICAgIHRva2Vuc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gKHN0cikgPT4gL15bLV9hLXpBLVowLTleYHx+LCEjJCUmJyorLl0rJC8udGVzdChzdHIudHJpbSgpKTtcblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMkMS5pc0Z1bmN0aW9uKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLmNhbGwodGhpcywgdmFsdWUsIGhlYWRlcik7XG4gIH1cblxuICBpZiAoaXNIZWFkZXJOYW1lRmlsdGVyKSB7XG4gICAgdmFsdWUgPSBoZWFkZXI7XG4gIH1cblxuICBpZiAoIXV0aWxzJDEuaXNTdHJpbmcodmFsdWUpKSByZXR1cm47XG5cbiAgaWYgKHV0aWxzJDEuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzJDEuaXNSZWdFeHAoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXIudGVzdCh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0SGVhZGVyKGhlYWRlcikge1xuICByZXR1cm4gaGVhZGVyLnRyaW0oKVxuICAgIC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbYS16XFxkXSkoXFx3KikvZywgKHcsIGNoYXIsIHN0cikgPT4ge1xuICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKSArIHN0cjtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBY2Nlc3NvcnMob2JqLCBoZWFkZXIpIHtcbiAgY29uc3QgYWNjZXNzb3JOYW1lID0gdXRpbHMkMS50b0NhbWVsQ2FzZSgnICcgKyBoZWFkZXIpO1xuXG4gIFsnZ2V0JywgJ3NldCcsICdoYXMnXS5mb3JFYWNoKG1ldGhvZE5hbWUgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG1ldGhvZE5hbWUgKyBhY2Nlc3Nvck5hbWUsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIHJldHVybiB0aGlzW21ldGhvZE5hbWVdLmNhbGwodGhpcywgaGVhZGVyLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbmNsYXNzIEF4aW9zSGVhZGVycyB7XG4gIGNvbnN0cnVjdG9yKGhlYWRlcnMpIHtcbiAgICBoZWFkZXJzICYmIHRoaXMuc2V0KGhlYWRlcnMpO1xuICB9XG5cbiAgc2V0KGhlYWRlciwgdmFsdWVPclJld3JpdGUsIHJld3JpdGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWxIZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZWFkZXIgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXkgPSB1dGlscyQxLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscyQxLmZvckVhY2goaGVhZGVycywgKF92YWx1ZSwgX2hlYWRlcikgPT4gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpKTtcblxuICAgIGlmICh1dGlscyQxLmlzUGxhaW5PYmplY3QoaGVhZGVyKSB8fCBoZWFkZXIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICBzZXRIZWFkZXJzKGhlYWRlciwgdmFsdWVPclJld3JpdGUpO1xuICAgIH0gZWxzZSBpZih1dGlscyQxLmlzU3RyaW5nKGhlYWRlcikgJiYgKGhlYWRlciA9IGhlYWRlci50cmltKCkpICYmICFpc1ZhbGlkSGVhZGVyTmFtZShoZWFkZXIpKSB7XG4gICAgICBzZXRIZWFkZXJzKHBhcnNlSGVhZGVycyhoZWFkZXIpLCB2YWx1ZU9yUmV3cml0ZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscyQxLmlzT2JqZWN0KGhlYWRlcikgJiYgdXRpbHMkMS5pc0l0ZXJhYmxlKGhlYWRlcikpIHtcbiAgICAgIGxldCBvYmogPSB7fSwgZGVzdCwga2V5O1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBoZWFkZXIpIHtcbiAgICAgICAgaWYgKCF1dGlscyQxLmlzQXJyYXkoZW50cnkpKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdPYmplY3QgaXRlcmF0b3IgbXVzdCByZXR1cm4gYSBrZXktdmFsdWUgcGFpcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqW2tleSA9IGVudHJ5WzBdXSA9IChkZXN0ID0gb2JqW2tleV0pID9cbiAgICAgICAgICAodXRpbHMkMS5pc0FycmF5KGRlc3QpID8gWy4uLmRlc3QsIGVudHJ5WzFdXSA6IFtkZXN0LCBlbnRyeVsxXV0pIDogZW50cnlbMV07XG4gICAgICB9XG5cbiAgICAgIHNldEhlYWRlcnMob2JqLCB2YWx1ZU9yUmV3cml0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlciAhPSBudWxsICYmIHNldEhlYWRlcih2YWx1ZU9yUmV3cml0ZSwgaGVhZGVyLCByZXdyaXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChoZWFkZXIsIHBhcnNlcikge1xuICAgIGhlYWRlciA9IG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMkMS5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5zKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscyQxLmlzRnVuY3Rpb24ocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscyQxLmlzUmVnRXhwKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmV4ZWModmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyc2VyIG11c3QgYmUgYm9vbGVhbnxyZWdleHB8ZnVuY3Rpb24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYXMoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscyQxLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgcmV0dXJuICEhKGtleSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlcikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZWxldGUoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XG4gICAgICBfaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoX2hlYWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSB1dGlscyQxLmZpbmRLZXkoc2VsZiwgX2hlYWRlcik7XG5cbiAgICAgICAgaWYgKGtleSAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZShzZWxmLCBzZWxmW2tleV0sIGtleSwgbWF0Y2hlcikpKSB7XG4gICAgICAgICAgZGVsZXRlIHNlbGZba2V5XTtcblxuICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzJDEuaXNBcnJheShoZWFkZXIpKSB7XG4gICAgICBoZWFkZXIuZm9yRWFjaChkZWxldGVIZWFkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVIZWFkZXIoaGVhZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIGNsZWFyKG1hdGNoZXIpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gICAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUodGhpcywgdGhpc1trZXldLCBrZXksIG1hdGNoZXIsIHRydWUpKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgbm9ybWFsaXplKGZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcblxuICAgIHV0aWxzJDEuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMkMS5maW5kS2V5KGhlYWRlcnMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgc2VsZltrZXldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBmb3JtYXQgPyBmb3JtYXRIZWFkZXIoaGVhZGVyKSA6IFN0cmluZyhoZWFkZXIpLnRyaW0oKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IGhlYWRlcikge1xuICAgICAgICBkZWxldGUgc2VsZltoZWFkZXJdO1xuICAgICAgfVxuXG4gICAgICBzZWxmW25vcm1hbGl6ZWRdID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWRdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uY2F0KC4uLnRhcmdldHMpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb25jYXQodGhpcywgLi4udGFyZ2V0cyk7XG4gIH1cblxuICB0b0pTT04oYXNTdHJpbmdzKSB7XG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHV0aWxzJDEuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UgJiYgKG9ialtoZWFkZXJdID0gYXNTdHJpbmdzICYmIHV0aWxzJDEuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSkubWFwKChbaGVhZGVyLCB2YWx1ZV0pID0+IGhlYWRlciArICc6ICcgKyB2YWx1ZSkuam9pbignXFxuJyk7XG4gIH1cblxuICBnZXRTZXRDb29raWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KFwic2V0LWNvb2tpZVwiKSB8fCBbXTtcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ0F4aW9zSGVhZGVycyc7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0aGluZykge1xuICAgIHJldHVybiB0aGluZyBpbnN0YW5jZW9mIHRoaXMgPyB0aGluZyA6IG5ldyB0aGlzKHRoaW5nKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25jYXQoZmlyc3QsIC4uLnRhcmdldHMpIHtcbiAgICBjb25zdCBjb21wdXRlZCA9IG5ldyB0aGlzKGZpcnN0KTtcblxuICAgIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiBjb21wdXRlZC5zZXQodGFyZ2V0KSk7XG5cbiAgICByZXR1cm4gY29tcHV0ZWQ7XG4gIH1cblxuICBzdGF0aWMgYWNjZXNzb3IoaGVhZGVyKSB7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gdGhpc1skaW50ZXJuYWxzXSA9ICh0aGlzWyRpbnRlcm5hbHNdID0ge1xuICAgICAgYWNjZXNzb3JzOiB7fVxuICAgIH0pO1xuXG4gICAgY29uc3QgYWNjZXNzb3JzID0gaW50ZXJuYWxzLmFjY2Vzc29ycztcbiAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGRlZmluZUFjY2Vzc29yKF9oZWFkZXIpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghYWNjZXNzb3JzW2xIZWFkZXJdKSB7XG4gICAgICAgIGJ1aWxkQWNjZXNzb3JzKHByb3RvdHlwZSwgX2hlYWRlcik7XG4gICAgICAgIGFjY2Vzc29yc1tsSGVhZGVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHMkMS5pc0FycmF5KGhlYWRlcikgPyBoZWFkZXIuZm9yRWFjaChkZWZpbmVBY2Nlc3NvcikgOiBkZWZpbmVBY2Nlc3NvcihoZWFkZXIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuQXhpb3NIZWFkZXJzLmFjY2Vzc29yKFsnQ29udGVudC1UeXBlJywgJ0NvbnRlbnQtTGVuZ3RoJywgJ0FjY2VwdCcsICdBY2NlcHQtRW5jb2RpbmcnLCAnVXNlci1BZ2VudCcsICdBdXRob3JpemF0aW9uJ10pO1xuXG4vLyByZXNlcnZlZCBuYW1lcyBob3RmaXhcbnV0aWxzJDEucmVkdWNlRGVzY3JpcHRvcnMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSwgKHt2YWx1ZX0sIGtleSkgPT4ge1xuICBsZXQgbWFwcGVkID0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7IC8vIG1hcCBgc2V0YCA9PiBgU2V0YFxuICByZXR1cm4ge1xuICAgIGdldDogKCkgPT4gdmFsdWUsXG4gICAgc2V0KGhlYWRlclZhbHVlKSB7XG4gICAgICB0aGlzW21hcHBlZF0gPSBoZWFkZXJWYWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG51dGlscyQxLmZyZWV6ZU1ldGhvZHMoQXhpb3NIZWFkZXJzKTtcblxudmFyIEF4aW9zSGVhZGVycyQxID0gQXhpb3NIZWFkZXJzO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcGFyYW0gez9PYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZm5zLCByZXNwb25zZSkge1xuICBjb25zdCBjb25maWcgPSB0aGlzIHx8IGRlZmF1bHRzJDE7XG4gIGNvbnN0IGNvbnRleHQgPSByZXNwb25zZSB8fCBjb25maWc7XG4gIGNvbnN0IGhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzJDEuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbmZpZywgZGF0YSwgaGVhZGVycy5ub3JtYWxpemUoKSwgcmVzcG9uc2UgPyByZXNwb25zZS5zdGF0dXMgOiB1bmRlZmluZWQpO1xuICB9KTtcblxuICBoZWFkZXJzLm5vcm1hbGl6ZSgpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59XG5cbi8qKlxuICogQSBgQ2FuY2VsZWRFcnJvcmAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdD19IHJlcXVlc3QgVGhlIHJlcXVlc3QuXG4gKlxuICogQHJldHVybnMge0NhbmNlbGVkRXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5mdW5jdGlvbiBDYW5jZWxlZEVycm9yKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCwgY29uZmlnLCByZXF1ZXN0KTtcbiAgdGhpcy5uYW1lID0gJ0NhbmNlbGVkRXJyb3InO1xufVxuXG51dGlscyQxLmluaGVyaXRzKENhbmNlbGVkRXJyb3IsIEF4aW9zRXJyb3IsIHtcbiAgX19DQU5DRUxfXzogdHJ1ZVxufSk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIHJlc3BvbnNlLlxuICovXG5mdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICBjb25zdCB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRhdGEgbWF4UmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtzYW1wbGVzQ291bnQ9IDEwXVxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW49IDEwMDBdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHNwZWVkb21ldGVyKHNhbXBsZXNDb3VudCwgbWluKSB7XG4gIHNhbXBsZXNDb3VudCA9IHNhbXBsZXNDb3VudCB8fCAxMDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgY29uc3QgdGltZXN0YW1wcyA9IG5ldyBBcnJheShzYW1wbGVzQ291bnQpO1xuICBsZXQgaGVhZCA9IDA7XG4gIGxldCB0YWlsID0gMDtcbiAgbGV0IGZpcnN0U2FtcGxlVFM7XG5cbiAgbWluID0gbWluICE9PSB1bmRlZmluZWQgPyBtaW4gOiAxMDAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiBwdXNoKGNodW5rTGVuZ3RoKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHN0YXJ0ZWRBdCA9IHRpbWVzdGFtcHNbdGFpbF07XG5cbiAgICBpZiAoIWZpcnN0U2FtcGxlVFMpIHtcbiAgICAgIGZpcnN0U2FtcGxlVFMgPSBub3c7XG4gICAgfVxuXG4gICAgYnl0ZXNbaGVhZF0gPSBjaHVua0xlbmd0aDtcbiAgICB0aW1lc3RhbXBzW2hlYWRdID0gbm93O1xuXG4gICAgbGV0IGkgPSB0YWlsO1xuICAgIGxldCBieXRlc0NvdW50ID0gMDtcblxuICAgIHdoaWxlIChpICE9PSBoZWFkKSB7XG4gICAgICBieXRlc0NvdW50ICs9IGJ5dGVzW2krK107XG4gICAgICBpID0gaSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBoZWFkID0gKGhlYWQgKyAxKSAlIHNhbXBsZXNDb3VudDtcblxuICAgIGlmIChoZWFkID09PSB0YWlsKSB7XG4gICAgICB0YWlsID0gKHRhaWwgKyAxKSAlIHNhbXBsZXNDb3VudDtcbiAgICB9XG5cbiAgICBpZiAobm93IC0gZmlyc3RTYW1wbGVUUyA8IG1pbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhc3NlZCA9IHN0YXJ0ZWRBdCAmJiBub3cgLSBzdGFydGVkQXQ7XG5cbiAgICByZXR1cm4gcGFzc2VkID8gTWF0aC5yb3VuZChieXRlc0NvdW50ICogMTAwMCAvIHBhc3NlZCkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbi8qKlxuICogVGhyb3R0bGUgZGVjb3JhdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtOdW1iZXJ9IGZyZXFcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgZnJlcSkge1xuICBsZXQgdGltZXN0YW1wID0gMDtcbiAgbGV0IHRocmVzaG9sZCA9IDEwMDAgLyBmcmVxO1xuICBsZXQgbGFzdEFyZ3M7XG4gIGxldCB0aW1lcjtcblxuICBjb25zdCBpbnZva2UgPSAoYXJncywgbm93ID0gRGF0ZS5ub3coKSkgPT4ge1xuICAgIHRpbWVzdGFtcCA9IG5vdztcbiAgICBsYXN0QXJncyA9IG51bGw7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgICBmbiguLi5hcmdzKTtcbiAgfTtcblxuICBjb25zdCB0aHJvdHRsZWQgPSAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcGFzc2VkID0gbm93IC0gdGltZXN0YW1wO1xuICAgIGlmICggcGFzc2VkID49IHRocmVzaG9sZCkge1xuICAgICAgaW52b2tlKGFyZ3MsIG5vdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgaW52b2tlKGxhc3RBcmdzKTtcbiAgICAgICAgfSwgdGhyZXNob2xkIC0gcGFzc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZmx1c2ggPSAoKSA9PiBsYXN0QXJncyAmJiBpbnZva2UobGFzdEFyZ3MpO1xuXG4gIHJldHVybiBbdGhyb3R0bGVkLCBmbHVzaF07XG59XG5cbmNvbnN0IHByb2dyZXNzRXZlbnRSZWR1Y2VyID0gKGxpc3RlbmVyLCBpc0Rvd25sb2FkU3RyZWFtLCBmcmVxID0gMykgPT4ge1xuICBsZXQgYnl0ZXNOb3RpZmllZCA9IDA7XG4gIGNvbnN0IF9zcGVlZG9tZXRlciA9IHNwZWVkb21ldGVyKDUwLCAyNTApO1xuXG4gIHJldHVybiB0aHJvdHRsZShlID0+IHtcbiAgICBjb25zdCBsb2FkZWQgPSBlLmxvYWRlZDtcbiAgICBjb25zdCB0b3RhbCA9IGUubGVuZ3RoQ29tcHV0YWJsZSA/IGUudG90YWwgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvZ3Jlc3NCeXRlcyA9IGxvYWRlZCAtIGJ5dGVzTm90aWZpZWQ7XG4gICAgY29uc3QgcmF0ZSA9IF9zcGVlZG9tZXRlcihwcm9ncmVzc0J5dGVzKTtcbiAgICBjb25zdCBpblJhbmdlID0gbG9hZGVkIDw9IHRvdGFsO1xuXG4gICAgYnl0ZXNOb3RpZmllZCA9IGxvYWRlZDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBsb2FkZWQsXG4gICAgICB0b3RhbCxcbiAgICAgIHByb2dyZXNzOiB0b3RhbCA/IChsb2FkZWQgLyB0b3RhbCkgOiB1bmRlZmluZWQsXG4gICAgICBieXRlczogcHJvZ3Jlc3NCeXRlcyxcbiAgICAgIHJhdGU6IHJhdGUgPyByYXRlIDogdW5kZWZpbmVkLFxuICAgICAgZXN0aW1hdGVkOiByYXRlICYmIHRvdGFsICYmIGluUmFuZ2UgPyAodG90YWwgLSBsb2FkZWQpIC8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogdG90YWwgIT0gbnVsbCxcbiAgICAgIFtpc0Rvd25sb2FkU3RyZWFtID8gJ2Rvd25sb2FkJyA6ICd1cGxvYWQnXTogdHJ1ZVxuICAgIH07XG5cbiAgICBsaXN0ZW5lcihkYXRhKTtcbiAgfSwgZnJlcSk7XG59O1xuXG5jb25zdCBwcm9ncmVzc0V2ZW50RGVjb3JhdG9yID0gKHRvdGFsLCB0aHJvdHRsZWQpID0+IHtcbiAgY29uc3QgbGVuZ3RoQ29tcHV0YWJsZSA9IHRvdGFsICE9IG51bGw7XG5cbiAgcmV0dXJuIFsobG9hZGVkKSA9PiB0aHJvdHRsZWRbMF0oe1xuICAgIGxlbmd0aENvbXB1dGFibGUsXG4gICAgdG90YWwsXG4gICAgbG9hZGVkXG4gIH0pLCB0aHJvdHRsZWRbMV1dO1xufTtcblxuY29uc3QgYXN5bmNEZWNvcmF0b3IgPSAoZm4pID0+ICguLi5hcmdzKSA9PiB1dGlscyQxLmFzYXAoKCkgPT4gZm4oLi4uYXJncykpO1xuXG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID8gKChvcmlnaW4sIGlzTVNJRSkgPT4gKHVybCkgPT4ge1xuICB1cmwgPSBuZXcgVVJMKHVybCwgcGxhdGZvcm0ub3JpZ2luKTtcblxuICByZXR1cm4gKFxuICAgIG9yaWdpbi5wcm90b2NvbCA9PT0gdXJsLnByb3RvY29sICYmXG4gICAgb3JpZ2luLmhvc3QgPT09IHVybC5ob3N0ICYmXG4gICAgKGlzTVNJRSB8fCBvcmlnaW4ucG9ydCA9PT0gdXJsLnBvcnQpXG4gICk7XG59KShcbiAgbmV3IFVSTChwbGF0Zm9ybS5vcmlnaW4pLFxuICBwbGF0Zm9ybS5uYXZpZ2F0b3IgJiYgLyhtc2llfHRyaWRlbnQpL2kudGVzdChwbGF0Zm9ybS5uYXZpZ2F0b3IudXNlckFnZW50KVxuKSA6ICgpID0+IHRydWU7XG5cbnZhciBjb29raWVzID0gcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyRW52ID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAge1xuICAgIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgY29uc3QgY29va2llID0gW25hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpXTtcblxuICAgICAgdXRpbHMkMS5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cbiAgICAgIHV0aWxzJDEuaXNTdHJpbmcocGF0aCkgJiYgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuXG4gICAgICB1dGlscyQxLmlzU3RyaW5nKGRvbWFpbikgJiYgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcblxuICAgICAgc2VjdXJlID09PSB0cnVlICYmIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcblxuICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgfSxcblxuICAgIHJlYWQobmFtZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlKG5hbWUpIHtcbiAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgfVxuICB9XG5cbiAgOlxuXG4gIC8vIE5vbi1zdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAge1xuICAgIHdyaXRlKCkge30sXG4gICAgcmVhZCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlKCkge31cbiAgfTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGQrXFwtLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5mdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvP1xcLyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIGJhc2VVUkwgd2l0aCB0aGUgcmVxdWVzdGVkVVJMLFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxuICogSWYgdGhlIHJlcXVlc3RVUkwgaXMgYWJzb2x1dGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgcmVxdWVzdGVkVVJMIHVudG91Y2hlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0ZWRVUkwgQWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMIHRvIGNvbWJpbmVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMLCBhbGxvd0Fic29sdXRlVXJscykge1xuICBsZXQgaXNSZWxhdGl2ZVVybCA9ICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCk7XG4gIGlmIChiYXNlVVJMICYmIChpc1JlbGF0aXZlVXJsIHx8IGFsbG93QWJzb2x1dGVVcmxzID09IGZhbHNlKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMkMSA/IHsgLi4udGhpbmcgfSA6IHRoaW5nO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICBjb25zdCBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSwgcHJvcCwgY2FzZWxlc3MpIHtcbiAgICBpZiAodXRpbHMkMS5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMkMS5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscyQxLm1lcmdlLmNhbGwoe2Nhc2VsZXNzfSwgdGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMkMS5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscyQxLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMkMS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKGEsIGIsIHByb3AgLCBjYXNlbGVzcykge1xuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGEsIGIsIHByb3AgLCBjYXNlbGVzcyk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChhKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYSwgcHJvcCAsIGNhc2VsZXNzKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscyQxLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscyQxLmlzVW5kZWZpbmVkKGIpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBiKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscyQxLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEaXJlY3RLZXlzKGEsIGIsIHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoYSwgYik7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1lcmdlTWFwID0ge1xuICAgIHVybDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBtZXRob2Q6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgZGF0YTogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBiYXNlVVJMOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcGFyYW1zU2VyaWFsaXplcjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXRNZXNzYWdlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHdpdGhDcmVkZW50aWFsczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoWFNSRlRva2VuOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGFkYXB0ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VUeXBlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZDb29raWVOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZIZWFkZXJOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGRlY29tcHJlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Q29udGVudExlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhCb2R5TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGJlZm9yZVJlZGlyZWN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zcG9ydDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cHNBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBjYW5jZWxUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBzb2NrZXRQYXRoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdmFsaWRhdGVTdGF0dXM6IG1lcmdlRGlyZWN0S2V5cyxcbiAgICBoZWFkZXJzOiAoYSwgYiAsIHByb3ApID0+IG1lcmdlRGVlcFByb3BlcnRpZXMoaGVhZGVyc1RvT2JqZWN0KGEpLCBoZWFkZXJzVG9PYmplY3QoYikscHJvcCwgdHJ1ZSlcbiAgfTtcblxuICB1dGlscyQxLmZvckVhY2goT2JqZWN0LmtleXMoey4uLmNvbmZpZzEsIC4uLmNvbmZpZzJ9KSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcbiAgICBjb25zdCBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgY29uc3QgY29uZmlnVmFsdWUgPSBtZXJnZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdLCBwcm9wKTtcbiAgICAodXRpbHMkMS5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxudmFyIHJlc29sdmVDb25maWcgPSAoY29uZmlnKSA9PiB7XG4gIGNvbnN0IG5ld0NvbmZpZyA9IG1lcmdlQ29uZmlnKHt9LCBjb25maWcpO1xuXG4gIGxldCB7IGRhdGEsIHdpdGhYU1JGVG9rZW4sIHhzcmZIZWFkZXJOYW1lLCB4c3JmQ29va2llTmFtZSwgaGVhZGVycywgYXV0aCB9ID0gbmV3Q29uZmlnO1xuXG4gIG5ld0NvbmZpZy5oZWFkZXJzID0gaGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmZyb20oaGVhZGVycyk7XG5cbiAgbmV3Q29uZmlnLnVybCA9IGJ1aWxkVVJMKGJ1aWxkRnVsbFBhdGgobmV3Q29uZmlnLmJhc2VVUkwsIG5ld0NvbmZpZy51cmwsIG5ld0NvbmZpZy5hbGxvd0Fic29sdXRlVXJscyksIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcblxuICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gIGlmIChhdXRoKSB7XG4gICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArXG4gICAgICBidG9hKChhdXRoLnVzZXJuYW1lIHx8ICcnKSArICc6JyArIChhdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgucGFzc3dvcmQpKSA6ICcnKSlcbiAgICApO1xuICB9XG5cbiAgaWYgKHV0aWxzJDEuaXNGb3JtRGF0YShkYXRhKSkge1xuICAgIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKHVuZGVmaW5lZCk7IC8vIGJyb3dzZXIgaGFuZGxlcyBpdFxuICAgIH0gZWxzZSBpZiAodXRpbHMkMS5pc0Z1bmN0aW9uKGRhdGEuZ2V0SGVhZGVycykpIHtcbiAgICAgIC8vIE5vZGUuanMgRm9ybURhdGEgKGxpa2UgZm9ybS1kYXRhIHBhY2thZ2UpXG4gICAgICBjb25zdCBmb3JtSGVhZGVycyA9IGRhdGEuZ2V0SGVhZGVycygpO1xuICAgICAgLy8gT25seSBzZXQgc2FmZSBoZWFkZXJzIHRvIGF2b2lkIG92ZXJ3cml0aW5nIHNlY3VyaXR5IGhlYWRlcnNcbiAgICAgIGNvbnN0IGFsbG93ZWRIZWFkZXJzID0gWydjb250ZW50LXR5cGUnLCAnY29udGVudC1sZW5ndGgnXTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGZvcm1IZWFkZXJzKS5mb3JFYWNoKChba2V5LCB2YWxdKSA9PiB7XG4gICAgICAgIGlmIChhbGxvd2VkSGVhZGVycy5pbmNsdWRlcyhrZXkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICBoZWFkZXJzLnNldChrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSAgXG5cbiAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuXG4gIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYpIHtcbiAgICB3aXRoWFNSRlRva2VuICYmIHV0aWxzJDEuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4obmV3Q29uZmlnKSk7XG5cbiAgICBpZiAod2l0aFhTUkZUb2tlbiB8fCAod2l0aFhTUkZUb2tlbiAhPT0gZmFsc2UgJiYgaXNVUkxTYW1lT3JpZ2luKG5ld0NvbmZpZy51cmwpKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICBjb25zdCB4c3JmVmFsdWUgPSB4c3JmSGVhZGVyTmFtZSAmJiB4c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoeHNyZkNvb2tpZU5hbWUpO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KHhzcmZIZWFkZXJOYW1lLCB4c3JmVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdDb25maWc7XG59O1xuXG5jb25zdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgeGhyQWRhcHRlciA9IGlzWEhSQWRhcHRlclN1cHBvcnRlZCAmJiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgY29uc3QgX2NvbmZpZyA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcbiAgICBsZXQgcmVxdWVzdERhdGEgPSBfY29uZmlnLmRhdGE7XG4gICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKF9jb25maWcuaGVhZGVycykubm9ybWFsaXplKCk7XG4gICAgbGV0IHtyZXNwb25zZVR5cGUsIG9uVXBsb2FkUHJvZ3Jlc3MsIG9uRG93bmxvYWRQcm9ncmVzc30gPSBfY29uZmlnO1xuICAgIGxldCBvbkNhbmNlbGVkO1xuICAgIGxldCB1cGxvYWRUaHJvdHRsZWQsIGRvd25sb2FkVGhyb3R0bGVkO1xuICAgIGxldCBmbHVzaFVwbG9hZCwgZmx1c2hEb3dubG9hZDtcblxuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBmbHVzaFVwbG9hZCAmJiBmbHVzaFVwbG9hZCgpOyAvLyBmbHVzaCBldmVudHNcbiAgICAgIGZsdXNoRG93bmxvYWQgJiYgZmx1c2hEb3dubG9hZCgpOyAvLyBmbHVzaCBldmVudHNcblxuICAgICAgX2NvbmZpZy5jYW5jZWxUb2tlbiAmJiBfY29uZmlnLmNhbmNlbFRva2VuLnVuc3Vic2NyaWJlKG9uQ2FuY2VsZWQpO1xuXG4gICAgICBfY29uZmlnLnNpZ25hbCAmJiBfY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgIH1cblxuICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICByZXF1ZXN0Lm9wZW4oX2NvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgX2NvbmZpZy51cmwsIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBfY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmZyb20oXG4gICAgICAgICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgJiYgcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELCBjb25maWcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXZlbnQpIHtcbiAgICAgICAvLyBCcm93c2VycyBkZWxpdmVyIGEgUHJvZ3Jlc3NFdmVudCBpbiBYSFIgb25lcnJvclxuICAgICAgIC8vIChtZXNzYWdlIG1heSBiZSBlbXB0eTsgd2hlbiBwcmVzZW50LCBzdXJmYWNlIGl0KVxuICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvZXJyb3JfZXZlbnRcbiAgICAgICBjb25zdCBtc2cgPSBldmVudCAmJiBldmVudC5tZXNzYWdlID8gZXZlbnQubWVzc2FnZSA6ICdOZXR3b3JrIEVycm9yJztcbiAgICAgICBjb25zdCBlcnIgPSBuZXcgQXhpb3NFcnJvcihtc2csIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgICAgLy8gYXR0YWNoIHRoZSB1bmRlcmx5aW5nIGV2ZW50IGZvciBjb25zdW1lcnMgd2hvIHdhbnQgZGV0YWlsc1xuICAgICAgIGVyci5ldmVudCA9IGV2ZW50IHx8IG51bGw7XG4gICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcbiAgICBcbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIGxldCB0aW1lb3V0RXJyb3JNZXNzYWdlID0gX2NvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIF9jb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcgOiAndGltZW91dCBleGNlZWRlZCc7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uYWwgPSBfY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcbiAgICAgIGlmIChfY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IF9jb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgdHJhbnNpdGlvbmFsLmNsYXJpZnlUaW1lb3V0RXJyb3IgPyBBeGlvc0Vycm9yLkVUSU1FRE9VVCA6IEF4aW9zRXJyb3IuRUNPTk5BQk9SVEVELFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzJDEuZm9yRWFjaChyZXF1ZXN0SGVhZGVycy50b0pTT04oKSwgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMkMS5pc1VuZGVmaW5lZChfY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFfY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBfY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKG9uRG93bmxvYWRQcm9ncmVzcykge1xuICAgICAgKFtkb3dubG9hZFRocm90dGxlZCwgZmx1c2hEb3dubG9hZF0gPSBwcm9ncmVzc0V2ZW50UmVkdWNlcihvbkRvd25sb2FkUHJvZ3Jlc3MsIHRydWUpKTtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBkb3dubG9hZFRocm90dGxlZCk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAob25VcGxvYWRQcm9ncmVzcyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgKFt1cGxvYWRUaHJvdHRsZWQsIGZsdXNoVXBsb2FkXSA9IHByb2dyZXNzRXZlbnRSZWR1Y2VyKG9uVXBsb2FkUHJvZ3Jlc3MpKTtcblxuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB1cGxvYWRUaHJvdHRsZWQpO1xuXG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZmx1c2hVcGxvYWQpO1xuICAgIH1cblxuICAgIGlmIChfY29uZmlnLmNhbmNlbFRva2VuIHx8IF9jb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgX2NvbmZpZy5jYW5jZWxUb2tlbiAmJiBfY29uZmlnLmNhbmNlbFRva2VuLnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIGlmIChfY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBfY29uZmlnLnNpZ25hbC5hYm9ydGVkID8gb25DYW5jZWxlZCgpIDogX2NvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2woX2NvbmZpZy51cmwpO1xuXG4gICAgaWYgKHByb3RvY29sICYmIHBsYXRmb3JtLnByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sICsgJzonLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhIHx8IG51bGwpO1xuICB9KTtcbn07XG5cbmNvbnN0IGNvbXBvc2VTaWduYWxzID0gKHNpZ25hbHMsIHRpbWVvdXQpID0+IHtcbiAgY29uc3Qge2xlbmd0aH0gPSAoc2lnbmFscyA9IHNpZ25hbHMgPyBzaWduYWxzLmZpbHRlcihCb29sZWFuKSA6IFtdKTtcblxuICBpZiAodGltZW91dCB8fCBsZW5ndGgpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICAgIGxldCBhYm9ydGVkO1xuXG4gICAgY29uc3Qgb25hYm9ydCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmICghYWJvcnRlZCkge1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgY29uc3QgZXJyID0gcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24gOiB0aGlzLnJlYXNvbjtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydChlcnIgaW5zdGFuY2VvZiBBeGlvc0Vycm9yID8gZXJyIDogbmV3IENhbmNlbGVkRXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IGVycikpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsZXQgdGltZXIgPSB0aW1lb3V0ICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgb25hYm9ydChuZXcgQXhpb3NFcnJvcihgdGltZW91dCAke3RpbWVvdXR9IG9mIG1zIGV4Y2VlZGVkYCwgQXhpb3NFcnJvci5FVElNRURPVVQpKTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgaWYgKHNpZ25hbHMpIHtcbiAgICAgICAgdGltZXIgJiYgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICBzaWduYWxzLmZvckVhY2goc2lnbmFsID0+IHtcbiAgICAgICAgICBzaWduYWwudW5zdWJzY3JpYmUgPyBzaWduYWwudW5zdWJzY3JpYmUob25hYm9ydCkgOiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbmFib3J0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZ25hbHMgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzaWduYWxzLmZvckVhY2goKHNpZ25hbCkgPT4gc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25hYm9ydCkpO1xuXG4gICAgY29uc3Qge3NpZ25hbH0gPSBjb250cm9sbGVyO1xuXG4gICAgc2lnbmFsLnVuc3Vic2NyaWJlID0gKCkgPT4gdXRpbHMkMS5hc2FwKHVuc3Vic2NyaWJlKTtcblxuICAgIHJldHVybiBzaWduYWw7XG4gIH1cbn07XG5cbnZhciBjb21wb3NlU2lnbmFscyQxID0gY29tcG9zZVNpZ25hbHM7XG5cbmNvbnN0IHN0cmVhbUNodW5rID0gZnVuY3Rpb24qIChjaHVuaywgY2h1bmtTaXplKSB7XG4gIGxldCBsZW4gPSBjaHVuay5ieXRlTGVuZ3RoO1xuXG4gIGlmICghY2h1bmtTaXplIHx8IGxlbiA8IGNodW5rU2l6ZSkge1xuICAgIHlpZWxkIGNodW5rO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBwb3MgPSAwO1xuICBsZXQgZW5kO1xuXG4gIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICBlbmQgPSBwb3MgKyBjaHVua1NpemU7XG4gICAgeWllbGQgY2h1bmsuc2xpY2UocG9zLCBlbmQpO1xuICAgIHBvcyA9IGVuZDtcbiAgfVxufTtcblxuY29uc3QgcmVhZEJ5dGVzID0gYXN5bmMgZnVuY3Rpb24qIChpdGVyYWJsZSwgY2h1bmtTaXplKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZFN0cmVhbShpdGVyYWJsZSkpIHtcbiAgICB5aWVsZCogc3RyZWFtQ2h1bmsoY2h1bmssIGNodW5rU2l6ZSk7XG4gIH1cbn07XG5cbmNvbnN0IHJlYWRTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiogKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgIHlpZWxkKiBzdHJlYW07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtkb25lLCB2YWx1ZX0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuICB9XG59O1xuXG5jb25zdCB0cmFja1N0cmVhbSA9IChzdHJlYW0sIGNodW5rU2l6ZSwgb25Qcm9ncmVzcywgb25GaW5pc2gpID0+IHtcbiAgY29uc3QgaXRlcmF0b3IgPSByZWFkQnl0ZXMoc3RyZWFtLCBjaHVua1NpemUpO1xuXG4gIGxldCBieXRlcyA9IDA7XG4gIGxldCBkb25lO1xuICBsZXQgX29uRmluaXNoID0gKGUpID0+IHtcbiAgICBpZiAoIWRvbmUpIHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgb25GaW5pc2ggJiYgb25GaW5pc2goZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgX29uRmluaXNoKCk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgIGxldCBsb2FkZWRCeXRlcyA9IGJ5dGVzICs9IGxlbjtcbiAgICAgICAgICBvblByb2dyZXNzKGxvYWRlZEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfb25GaW5pc2goZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKHJlYXNvbikge1xuICAgICAgX29uRmluaXNoKHJlYXNvbik7XG4gICAgICByZXR1cm4gaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgfVxuICB9LCB7XG4gICAgaGlnaFdhdGVyTWFyazogMlxuICB9KVxufTtcblxuY29uc3QgREVGQVVMVF9DSFVOS19TSVpFID0gNjQgKiAxMDI0O1xuXG5jb25zdCB7aXNGdW5jdGlvbn0gPSB1dGlscyQxO1xuXG5jb25zdCBnbG9iYWxGZXRjaEFQSSA9ICgoe1JlcXVlc3QsIFJlc3BvbnNlfSkgPT4gKHtcbiAgUmVxdWVzdCwgUmVzcG9uc2Vcbn0pKSh1dGlscyQxLmdsb2JhbCk7XG5cbmNvbnN0IHtcbiAgUmVhZGFibGVTdHJlYW06IFJlYWRhYmxlU3RyZWFtJDEsIFRleHRFbmNvZGVyXG59ID0gdXRpbHMkMS5nbG9iYWw7XG5cblxuY29uc3QgdGVzdCA9IChmbiwgLi4uYXJncykgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiAhIWZuKC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbmNvbnN0IGZhY3RvcnkgPSAoZW52KSA9PiB7XG4gIGVudiA9IHV0aWxzJDEubWVyZ2UuY2FsbCh7XG4gICAgc2tpcFVuZGVmaW5lZDogdHJ1ZVxuICB9LCBnbG9iYWxGZXRjaEFQSSwgZW52KTtcblxuICBjb25zdCB7ZmV0Y2g6IGVudkZldGNoLCBSZXF1ZXN0LCBSZXNwb25zZX0gPSBlbnY7XG4gIGNvbnN0IGlzRmV0Y2hTdXBwb3J0ZWQgPSBlbnZGZXRjaCA/IGlzRnVuY3Rpb24oZW52RmV0Y2gpIDogdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBpc1JlcXVlc3RTdXBwb3J0ZWQgPSBpc0Z1bmN0aW9uKFJlcXVlc3QpO1xuICBjb25zdCBpc1Jlc3BvbnNlU3VwcG9ydGVkID0gaXNGdW5jdGlvbihSZXNwb25zZSk7XG5cbiAgaWYgKCFpc0ZldGNoU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgaXNGdW5jdGlvbihSZWFkYWJsZVN0cmVhbSQxKTtcblxuICBjb25zdCBlbmNvZGVUZXh0ID0gaXNGZXRjaFN1cHBvcnRlZCAmJiAodHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID9cbiAgICAgICgoZW5jb2RlcikgPT4gKHN0cikgPT4gZW5jb2Rlci5lbmNvZGUoc3RyKSkobmV3IFRleHRFbmNvZGVyKCkpIDpcbiAgICAgIGFzeW5jIChzdHIpID0+IG5ldyBVaW50OEFycmF5KGF3YWl0IG5ldyBSZXF1ZXN0KHN0cikuYXJyYXlCdWZmZXIoKSlcbiAgKTtcblxuICBjb25zdCBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gPSBpc1JlcXVlc3RTdXBwb3J0ZWQgJiYgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCAmJiB0ZXN0KCgpID0+IHtcbiAgICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGhhc0NvbnRlbnRUeXBlID0gbmV3IFJlcXVlc3QocGxhdGZvcm0ub3JpZ2luLCB7XG4gICAgICBib2R5OiBuZXcgUmVhZGFibGVTdHJlYW0kMSgpLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBnZXQgZHVwbGV4KCkge1xuICAgICAgICBkdXBsZXhBY2Nlc3NlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiAnaGFsZic7XG4gICAgICB9LFxuICAgIH0pLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKTtcblxuICAgIHJldHVybiBkdXBsZXhBY2Nlc3NlZCAmJiAhaGFzQ29udGVudFR5cGU7XG4gIH0pO1xuXG4gIGNvbnN0IHN1cHBvcnRzUmVzcG9uc2VTdHJlYW0gPSBpc1Jlc3BvbnNlU3VwcG9ydGVkICYmIGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgJiZcbiAgICB0ZXN0KCgpID0+IHV0aWxzJDEuaXNSZWFkYWJsZVN0cmVhbShuZXcgUmVzcG9uc2UoJycpLmJvZHkpKTtcblxuICBjb25zdCByZXNvbHZlcnMgPSB7XG4gICAgc3RyZWFtOiBzdXBwb3J0c1Jlc3BvbnNlU3RyZWFtICYmICgocmVzKSA9PiByZXMuYm9keSlcbiAgfTtcblxuICBpc0ZldGNoU3VwcG9ydGVkICYmICgoKCkgPT4ge1xuICAgIFsndGV4dCcsICdhcnJheUJ1ZmZlcicsICdibG9iJywgJ2Zvcm1EYXRhJywgJ3N0cmVhbSddLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAhcmVzb2x2ZXJzW3R5cGVdICYmIChyZXNvbHZlcnNbdHlwZV0gPSAocmVzLCBjb25maWcpID0+IHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IHJlcyAmJiByZXNbdHlwZV07XG5cbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoYFJlc3BvbnNlIHR5cGUgJyR7dHlwZX0nIGlzIG5vdCBzdXBwb3J0ZWRgLCBBeGlvc0Vycm9yLkVSUl9OT1RfU1VQUE9SVCwgY29uZmlnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSgpKTtcblxuICBjb25zdCBnZXRCb2R5TGVuZ3RoID0gYXN5bmMgKGJvZHkpID0+IHtcbiAgICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMkMS5pc0Jsb2IoYm9keSkpIHtcbiAgICAgIHJldHVybiBib2R5LnNpemU7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzJDEuaXNTcGVjQ29tcGxpYW50Rm9ybShib2R5KSkge1xuICAgICAgY29uc3QgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdChwbGF0Zm9ybS5vcmlnaW4sIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoYXdhaXQgX3JlcXVlc3QuYXJyYXlCdWZmZXIoKSkuYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMkMS5pc0FycmF5QnVmZmVyVmlldyhib2R5KSB8fCB1dGlscyQxLmlzQXJyYXlCdWZmZXIoYm9keSkpIHtcbiAgICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzJDEuaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkpIHtcbiAgICAgIGJvZHkgPSBib2R5ICsgJyc7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzJDEuaXNTdHJpbmcoYm9keSkpIHtcbiAgICAgIHJldHVybiAoYXdhaXQgZW5jb2RlVGV4dChib2R5KSkuYnl0ZUxlbmd0aDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVzb2x2ZUJvZHlMZW5ndGggPSBhc3luYyAoaGVhZGVycywgYm9keSkgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IHV0aWxzJDEudG9GaW5pdGVOdW1iZXIoaGVhZGVycy5nZXRDb250ZW50TGVuZ3RoKCkpO1xuXG4gICAgcmV0dXJuIGxlbmd0aCA9PSBudWxsID8gZ2V0Qm9keUxlbmd0aChib2R5KSA6IGxlbmd0aDtcbiAgfTtcblxuICByZXR1cm4gYXN5bmMgKGNvbmZpZykgPT4ge1xuICAgIGxldCB7XG4gICAgICB1cmwsXG4gICAgICBtZXRob2QsXG4gICAgICBkYXRhLFxuICAgICAgc2lnbmFsLFxuICAgICAgY2FuY2VsVG9rZW4sXG4gICAgICB0aW1lb3V0LFxuICAgICAgb25Eb3dubG9hZFByb2dyZXNzLFxuICAgICAgb25VcGxvYWRQcm9ncmVzcyxcbiAgICAgIHJlc3BvbnNlVHlwZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB3aXRoQ3JlZGVudGlhbHMgPSAnc2FtZS1vcmlnaW4nLFxuICAgICAgZmV0Y2hPcHRpb25zXG4gICAgfSA9IHJlc29sdmVDb25maWcoY29uZmlnKTtcblxuICAgIGxldCBfZmV0Y2ggPSBlbnZGZXRjaCB8fCBmZXRjaDtcblxuICAgIHJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZSA/IChyZXNwb25zZVR5cGUgKyAnJykudG9Mb3dlckNhc2UoKSA6ICd0ZXh0JztcblxuICAgIGxldCBjb21wb3NlZFNpZ25hbCA9IGNvbXBvc2VTaWduYWxzJDEoW3NpZ25hbCwgY2FuY2VsVG9rZW4gJiYgY2FuY2VsVG9rZW4udG9BYm9ydFNpZ25hbCgpXSwgdGltZW91dCk7XG5cbiAgICBsZXQgcmVxdWVzdCA9IG51bGw7XG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNvbXBvc2VkU2lnbmFsICYmIGNvbXBvc2VkU2lnbmFsLnVuc3Vic2NyaWJlICYmICgoKSA9PiB7XG4gICAgICBjb21wb3NlZFNpZ25hbC51bnN1YnNjcmliZSgpO1xuICAgIH0pO1xuXG4gICAgbGV0IHJlcXVlc3RDb250ZW50TGVuZ3RoO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChcbiAgICAgICAgb25VcGxvYWRQcm9ncmVzcyAmJiBzdXBwb3J0c1JlcXVlc3RTdHJlYW0gJiYgbWV0aG9kICE9PSAnZ2V0JyAmJiBtZXRob2QgIT09ICdoZWFkJyAmJlxuICAgICAgICAocmVxdWVzdENvbnRlbnRMZW5ndGggPSBhd2FpdCByZXNvbHZlQm9keUxlbmd0aChoZWFkZXJzLCBkYXRhKSkgIT09IDBcbiAgICAgICkge1xuICAgICAgICBsZXQgX3JlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICAgIGR1cGxleDogXCJoYWxmXCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlSGVhZGVyO1xuXG4gICAgICAgIGlmICh1dGlscyQxLmlzRm9ybURhdGEoZGF0YSkgJiYgKGNvbnRlbnRUeXBlSGVhZGVyID0gX3JlcXVlc3QuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSkge1xuICAgICAgICAgIGhlYWRlcnMuc2V0Q29udGVudFR5cGUoY29udGVudFR5cGVIZWFkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9yZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgICBjb25zdCBbb25Qcm9ncmVzcywgZmx1c2hdID0gcHJvZ3Jlc3NFdmVudERlY29yYXRvcihcbiAgICAgICAgICAgIHJlcXVlc3RDb250ZW50TGVuZ3RoLFxuICAgICAgICAgICAgcHJvZ3Jlc3NFdmVudFJlZHVjZXIoYXN5bmNEZWNvcmF0b3Iob25VcGxvYWRQcm9ncmVzcykpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGRhdGEgPSB0cmFja1N0cmVhbShfcmVxdWVzdC5ib2R5LCBERUZBVUxUX0NIVU5LX1NJWkUsIG9uUHJvZ3Jlc3MsIGZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXV0aWxzJDEuaXNTdHJpbmcod2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgICB3aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnb21pdCc7XG4gICAgICB9XG5cbiAgICAgIC8vIENsb3VkZmxhcmUgV29ya2VycyB0aHJvd3Mgd2hlbiBjcmVkZW50aWFscyBhcmUgZGVmaW5lZFxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGZsYXJlL3dvcmtlcmQvaXNzdWVzLzkwMlxuICAgICAgY29uc3QgaXNDcmVkZW50aWFsc1N1cHBvcnRlZCA9IGlzUmVxdWVzdFN1cHBvcnRlZCAmJiBcImNyZWRlbnRpYWxzXCIgaW4gUmVxdWVzdC5wcm90b3R5cGU7XG5cbiAgICAgIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4uZmV0Y2hPcHRpb25zLFxuICAgICAgICBzaWduYWw6IGNvbXBvc2VkU2lnbmFsLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLm5vcm1hbGl6ZSgpLnRvSlNPTigpLFxuICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgICAgICBjcmVkZW50aWFsczogaXNDcmVkZW50aWFsc1N1cHBvcnRlZCA/IHdpdGhDcmVkZW50aWFscyA6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgcmVxdWVzdCA9IGlzUmVxdWVzdFN1cHBvcnRlZCAmJiBuZXcgUmVxdWVzdCh1cmwsIHJlc29sdmVkT3B0aW9ucyk7XG5cbiAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IChpc1JlcXVlc3RTdXBwb3J0ZWQgPyBfZmV0Y2gocmVxdWVzdCwgZmV0Y2hPcHRpb25zKSA6IF9mZXRjaCh1cmwsIHJlc29sdmVkT3B0aW9ucykpO1xuXG4gICAgICBjb25zdCBpc1N0cmVhbVJlc3BvbnNlID0gc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAocmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJyB8fCByZXNwb25zZVR5cGUgPT09ICdyZXNwb25zZScpO1xuXG4gICAgICBpZiAoc3VwcG9ydHNSZXNwb25zZVN0cmVhbSAmJiAob25Eb3dubG9hZFByb2dyZXNzIHx8IChpc1N0cmVhbVJlc3BvbnNlICYmIHVuc3Vic2NyaWJlKSkpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgIFsnc3RhdHVzJywgJ3N0YXR1c1RleHQnLCAnaGVhZGVycyddLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgb3B0aW9uc1twcm9wXSA9IHJlc3BvbnNlW3Byb3BdO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRMZW5ndGggPSB1dGlscyQxLnRvRmluaXRlTnVtYmVyKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LWxlbmd0aCcpKTtcblxuICAgICAgICBjb25zdCBbb25Qcm9ncmVzcywgZmx1c2hdID0gb25Eb3dubG9hZFByb2dyZXNzICYmIHByb2dyZXNzRXZlbnREZWNvcmF0b3IoXG4gICAgICAgICAgcmVzcG9uc2VDb250ZW50TGVuZ3RoLFxuICAgICAgICAgIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGFzeW5jRGVjb3JhdG9yKG9uRG93bmxvYWRQcm9ncmVzcyksIHRydWUpXG4gICAgICAgICkgfHwgW107XG5cbiAgICAgICAgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoXG4gICAgICAgICAgdHJhY2tTdHJlYW0ocmVzcG9uc2UuYm9keSwgREVGQVVMVF9DSFVOS19TSVpFLCBvblByb2dyZXNzLCAoKSA9PiB7XG4gICAgICAgICAgICBmbHVzaCAmJiBmbHVzaCgpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgJiYgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZSB8fCAndGV4dCc7XG5cbiAgICAgIGxldCByZXNwb25zZURhdGEgPSBhd2FpdCByZXNvbHZlcnNbdXRpbHMkMS5maW5kS2V5KHJlc29sdmVycywgcmVzcG9uc2VUeXBlKSB8fCAndGV4dCddKHJlc3BvbnNlLCBjb25maWcpO1xuXG4gICAgICAhaXNTdHJlYW1SZXNwb25zZSAmJiB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB7XG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAgIGhlYWRlcnM6IEF4aW9zSGVhZGVycyQxLmZyb20ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1bnN1YnNjcmliZSAmJiB1bnN1YnNjcmliZSgpO1xuXG4gICAgICBpZiAoZXJyICYmIGVyci5uYW1lID09PSAnVHlwZUVycm9yJyAmJiAvTG9hZCBmYWlsZWR8ZmV0Y2gvaS50ZXN0KGVyci5tZXNzYWdlKSkge1xuICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjYXVzZTogZXJyLmNhdXNlIHx8IGVyclxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZXJyLCBlcnIgJiYgZXJyLmNvZGUsIGNvbmZpZywgcmVxdWVzdCk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBzZWVkQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGdldEZldGNoID0gKGNvbmZpZykgPT4ge1xuICBsZXQgZW52ID0gY29uZmlnID8gY29uZmlnLmVudiA6IHt9O1xuICBjb25zdCB7ZmV0Y2gsIFJlcXVlc3QsIFJlc3BvbnNlfSA9IGVudjtcbiAgY29uc3Qgc2VlZHMgPSBbXG4gICAgUmVxdWVzdCwgUmVzcG9uc2UsIGZldGNoXG4gIF07XG5cbiAgbGV0IGxlbiA9IHNlZWRzLmxlbmd0aCwgaSA9IGxlbixcbiAgICBzZWVkLCB0YXJnZXQsIG1hcCA9IHNlZWRDYWNoZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgc2VlZCA9IHNlZWRzW2ldO1xuICAgIHRhcmdldCA9IG1hcC5nZXQoc2VlZCk7XG5cbiAgICB0YXJnZXQgPT09IHVuZGVmaW5lZCAmJiBtYXAuc2V0KHNlZWQsIHRhcmdldCA9IChpID8gbmV3IE1hcCgpIDogZmFjdG9yeShlbnYpKSk7XG5cbiAgICBtYXAgPSB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuZ2V0RmV0Y2goKTtcblxuY29uc3Qga25vd25BZGFwdGVycyA9IHtcbiAgaHR0cDogaHR0cEFkYXB0ZXIsXG4gIHhocjogeGhyQWRhcHRlcixcbiAgZmV0Y2g6IHtcbiAgICBnZXQ6IGdldEZldGNoLFxuICB9XG59O1xuXG51dGlscyQxLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHt2YWx1ZX0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdhZGFwdGVyTmFtZScsIHt2YWx1ZX0pO1xuICB9XG59KTtcblxuY29uc3QgcmVuZGVyUmVhc29uID0gKHJlYXNvbikgPT4gYC0gJHtyZWFzb259YDtcblxuY29uc3QgaXNSZXNvbHZlZEhhbmRsZSA9IChhZGFwdGVyKSA9PiB1dGlscyQxLmlzRnVuY3Rpb24oYWRhcHRlcikgfHwgYWRhcHRlciA9PT0gbnVsbCB8fCBhZGFwdGVyID09PSBmYWxzZTtcblxudmFyIGFkYXB0ZXJzID0ge1xuICBnZXRBZGFwdGVyOiAoYWRhcHRlcnMsIGNvbmZpZykgPT4ge1xuICAgIGFkYXB0ZXJzID0gdXRpbHMkMS5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBjb25zdCByZWplY3RlZFJlYXNvbnMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcbiAgICAgIGxldCBpZDtcblxuICAgICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICAgIGlmICghaXNSZXNvbHZlZEhhbmRsZShuYW1lT3JBZGFwdGVyKSkge1xuICAgICAgICBhZGFwdGVyID0ga25vd25BZGFwdGVyc1soaWQgPSBTdHJpbmcobmFtZU9yQWRhcHRlcikpLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWRhcHRlciAmJiAodXRpbHMkMS5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IChhZGFwdGVyID0gYWRhcHRlci5nZXQoY29uZmlnKSkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZWplY3RlZFJlYXNvbnNbaWQgfHwgJyMnICsgaV0gPSBhZGFwdGVyO1xuICAgIH1cblxuICAgIGlmICghYWRhcHRlcikge1xuXG4gICAgICBjb25zdCByZWFzb25zID0gT2JqZWN0LmVudHJpZXMocmVqZWN0ZWRSZWFzb25zKVxuICAgICAgICAubWFwKChbaWQsIHN0YXRlXSkgPT4gYGFkYXB0ZXIgJHtpZH0gYCArXG4gICAgICAgICAgKHN0YXRlID09PSBmYWxzZSA/ICdpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudCcgOiAnaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnVpbGQnKVxuICAgICAgICApO1xuXG4gICAgICBsZXQgcyA9IGxlbmd0aCA/XG4gICAgICAgIChyZWFzb25zLmxlbmd0aCA+IDEgPyAnc2luY2UgOlxcbicgKyByZWFzb25zLm1hcChyZW5kZXJSZWFzb24pLmpvaW4oJ1xcbicpIDogJyAnICsgcmVuZGVyUmVhc29uKHJlYXNvbnNbMF0pKSA6XG4gICAgICAgICdhcyBubyBhZGFwdGVyIHNwZWNpZmllZCc7XG5cbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICBgVGhlcmUgaXMgbm8gc3VpdGFibGUgYWRhcHRlciB0byBkaXNwYXRjaCB0aGUgcmVxdWVzdCBgICsgcyxcbiAgICAgICAgJ0VSUl9OT1RfU1VQUE9SVCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkYXB0ZXI7XG4gIH0sXG4gIGFkYXB0ZXJzOiBrbm93bkFkYXB0ZXJzXG59O1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5zaWduYWwgJiYgY29uZmlnLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzJDEuZnJvbShjb25maWcuaGVhZGVycyk7XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICBjb25maWcsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICBpZiAoWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLmluZGV4T2YoY29uZmlnLm1ldGhvZCkgIT09IC0xKSB7XG4gICAgY29uZmlnLmhlYWRlcnMuc2V0Q29udGVudFR5cGUoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IGFkYXB0ZXIgPSBhZGFwdGVycy5nZXRBZGFwdGVyKGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzJDEuYWRhcHRlciwgY29uZmlnKTtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgIHJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMkMS5mcm9tKHJlc3BvbnNlLmhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZVxuICAgICAgICApO1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyA9IEF4aW9zSGVhZGVycyQxLmZyb20ocmVhc29uLnJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn1cblxuY29uc3QgVkVSU0lPTiA9IFwiMS4xMi4yXCI7XG5cbmNvbnN0IHZhbGlkYXRvcnMkMSA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goKHR5cGUsIGkpID0+IHtcbiAgdmFsaWRhdG9ycyQxW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxuY29uc3QgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMkMS50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbiB0cmFuc2l0aW9uYWwodmFsaWRhdG9yLCB2ZXJzaW9uLCBtZXNzYWdlKSB7XG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XG4gICAgcmV0dXJuICdbQXhpb3MgdicgKyBWRVJTSU9OICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiAodmFsdWUsIG9wdCwgb3B0cykgPT4ge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG52YWxpZGF0b3JzJDEuc3BlbGxpbmcgPSBmdW5jdGlvbiBzcGVsbGluZyhjb3JyZWN0U3BlbGxpbmcpIHtcbiAgcmV0dXJuICh2YWx1ZSwgb3B0KSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oYCR7b3B0fSBpcyBsaWtlbHkgYSBtaXNzcGVsbGluZyBvZiAke2NvcnJlY3RTcGVsbGluZ31gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnLCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgY29uc3Qgb3B0ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ1Vua25vd24gb3B0aW9uICcgKyBvcHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT04pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsaWRhdG9yID0ge1xuICBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzJDFcbn07XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuY2xhc3MgQXhpb3Mge1xuICBjb25zdHJ1Y3RvcihpbnN0YW5jZUNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIkMSgpLFxuICAgICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIkMSgpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWdPclVybCBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gICAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgZHVtbXkgPSB7fTtcblxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGR1bW15KSA6IChkdW1teSA9IG5ldyBFcnJvcigpKTtcblxuICAgICAgICAvLyBzbGljZSBvZmYgdGhlIEVycm9yOiAuLi4gbGluZVxuICAgICAgICBjb25zdCBzdGFjayA9IGR1bW15LnN0YWNrID8gZHVtbXkuc3RhY2sucmVwbGFjZSgvXi4rXFxuLywgJycpIDogJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIGVyci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgLy8gbWF0Y2ggd2l0aG91dCB0aGUgMiB0b3Agc3RhY2sgbGluZXNcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrICYmICFTdHJpbmcoZXJyLnN0YWNrKS5lbmRzV2l0aChzdGFjay5yZXBsYWNlKC9eLitcXG4uK1xcbi8sICcnKSkpIHtcbiAgICAgICAgICAgIGVyci5zdGFjayArPSAnXFxuJyArIHN0YWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB0aGUgY2FzZSB3aGVyZSBcInN0YWNrXCIgaXMgYW4gdW4td3JpdGFibGUgcHJvcGVydHlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgX3JlcXVlc3QoY29uZmlnT3JVcmwsIGNvbmZpZykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgICBpZiAodHlwZW9mIGNvbmZpZ09yVXJsID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgY29uZmlnLnVybCA9IGNvbmZpZ09yVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gICAgY29uc3Qge3RyYW5zaXRpb25hbCwgcGFyYW1zU2VyaWFsaXplciwgaGVhZGVyc30gPSBjb25maWc7XG5cbiAgICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbilcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zU2VyaWFsaXplciAhPSBudWxsKSB7XG4gICAgICBpZiAodXRpbHMkMS5pc0Z1bmN0aW9uKHBhcmFtc1NlcmlhbGl6ZXIpKSB7XG4gICAgICAgIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyID0ge1xuICAgICAgICAgIHNlcmlhbGl6ZTogcGFyYW1zU2VyaWFsaXplclxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMocGFyYW1zU2VyaWFsaXplciwge1xuICAgICAgICAgIGVuY29kZTogdmFsaWRhdG9ycy5mdW5jdGlvbixcbiAgICAgICAgICBzZXJpYWxpemU6IHZhbGlkYXRvcnMuZnVuY3Rpb25cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGNvbmZpZy5hbGxvd0Fic29sdXRlVXJsc1xuICAgIGlmIChjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMgIT09IHVuZGVmaW5lZCkgOyBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLmFsbG93QWJzb2x1dGVVcmxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRoaXMuZGVmYXVsdHMuYWxsb3dBYnNvbHV0ZVVybHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZy5hbGxvd0Fic29sdXRlVXJscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnMoY29uZmlnLCB7XG4gICAgICBiYXNlVXJsOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCdiYXNlVVJMJyksXG4gICAgICB3aXRoWHNyZlRva2VuOiB2YWxpZGF0b3JzLnNwZWxsaW5nKCd3aXRoWFNSRlRva2VuJylcbiAgICB9LCB0cnVlKTtcblxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXG4gICAgY29uZmlnLm1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IHRoaXMuZGVmYXVsdHMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgbGV0IGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscyQxLm1lcmdlKFxuICAgICAgaGVhZGVycy5jb21tb24sXG4gICAgICBoZWFkZXJzW2NvbmZpZy5tZXRob2RdXG4gICAgKTtcblxuICAgIGhlYWRlcnMgJiYgdXRpbHMkMS5mb3JFYWNoKFxuICAgICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgICAobWV0aG9kKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW21ldGhvZF07XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzJDEuY29uY2F0KGNvbnRleHRIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbjtcblxuICAgIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QuYmluZCh0aGlzKSwgdW5kZWZpbmVkXTtcbiAgICAgIGNoYWluLnVuc2hpZnQoLi4ucmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgY2hhaW4ucHVzaCguLi5yZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuICAgICAgbGVuID0gY2hhaW4ubGVuZ3RoO1xuXG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW5baSsrXSwgY2hhaW5baSsrXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cblxuICAgIGxlbiA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aDtcblxuICAgIGxldCBuZXdDb25maWcgPSBjb25maWc7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgY29uc3Qgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgY29uc3Qgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluW2krK107XG4gICAgICB0cnkge1xuICAgICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgb25SZWplY3RlZC5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QuY2FsbCh0aGlzLCBuZXdDb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGkgPSAwO1xuICAgIGxlbiA9IHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW5baSsrXSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgZ2V0VXJpKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gICAgY29uc3QgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsLCBjb25maWcuYWxsb3dBYnNvbHV0ZVVybHMpO1xuICAgIHJldHVybiBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpO1xuICB9XG59XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMkMS5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzJDEuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaXNGb3JtID8ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSA6IHt9LFxuICAgICAgICB1cmwsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pKTtcbiAgICB9O1xuICB9XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBnZW5lcmF0ZUhUVFBNZXRob2QoKTtcblxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kICsgJ0Zvcm0nXSA9IGdlbmVyYXRlSFRUUE1ldGhvZCh0cnVlKTtcbn0pO1xuXG52YXIgQXhpb3MkMSA9IEF4aW9zO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxUb2tlbn1cbiAqL1xuY2xhc3MgQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbihjYW5jZWwgPT4ge1xuICAgICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAgIGxldCBpID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbiA9IG9uZnVsZmlsbGVkID0+IHtcbiAgICAgIGxldCBfcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHRvQWJvcnRTaWduYWwoKSB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcblxuICAgIGNvbnN0IGFib3J0ID0gKGVycikgPT4ge1xuICAgICAgY29udHJvbGxlci5hYm9ydChlcnIpO1xuICAgIH07XG5cbiAgICB0aGlzLnN1YnNjcmliZShhYm9ydCk7XG5cbiAgICBjb250cm9sbGVyLnNpZ25hbC51bnN1YnNjcmliZSA9ICgpID0+IHRoaXMudW5zdWJzY3JpYmUoYWJvcnQpO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAgICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAgICovXG4gIHN0YXRpYyBzb3VyY2UoKSB7XG4gICAgbGV0IGNhbmNlbDtcbiAgICBjb25zdCB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgICBjYW5jZWwgPSBjO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbixcbiAgICAgIGNhbmNlbFxuICAgIH07XG4gIH1cbn1cblxudmFyIENhbmNlbFRva2VuJDEgPSBDYW5jZWxUb2tlbjtcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiB1dGlscyQxLmlzT2JqZWN0KHBheWxvYWQpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59XG5cbmNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG52YXIgSHR0cFN0YXR1c0NvZGUkMSA9IEh0dHBTdGF0dXNDb2RlO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgQXhpb3MkMShkZWZhdWx0Q29uZmlnKTtcbiAgY29uc3QgaW5zdGFuY2UgPSBiaW5kKEF4aW9zJDEucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzJDEuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcyQxLnByb3RvdHlwZSwgY29udGV4dCwge2FsbE93bktleXM6IHRydWV9KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMkMS5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQsIG51bGwsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICBpbnN0YW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxuY29uc3QgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyQxKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zJDE7XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsZWRFcnJvciA9IENhbmNlbGVkRXJyb3I7XG5heGlvcy5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuJDE7XG5heGlvcy5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuYXhpb3MuVkVSU0lPTiA9IFZFUlNJT047XG5heGlvcy50b0Zvcm1EYXRhID0gdG9Gb3JtRGF0YTtcblxuLy8gRXhwb3NlIEF4aW9zRXJyb3IgY2xhc3NcbmF4aW9zLkF4aW9zRXJyb3IgPSBBeGlvc0Vycm9yO1xuXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuYXhpb3MuQ2FuY2VsID0gYXhpb3MuQ2FuY2VsZWRFcnJvcjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcblxuYXhpb3Muc3ByZWFkID0gc3ByZWFkO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSBpc0F4aW9zRXJyb3I7XG5cbi8vIEV4cG9zZSBtZXJnZUNvbmZpZ1xuYXhpb3MubWVyZ2VDb25maWcgPSBtZXJnZUNvbmZpZztcblxuYXhpb3MuQXhpb3NIZWFkZXJzID0gQXhpb3NIZWFkZXJzJDE7XG5cbmF4aW9zLmZvcm1Ub0pTT04gPSB0aGluZyA9PiBmb3JtRGF0YVRvSlNPTih1dGlscyQxLmlzSFRNTEZvcm0odGhpbmcpID8gbmV3IEZvcm1EYXRhKHRoaW5nKSA6IHRoaW5nKTtcblxuYXhpb3MuZ2V0QWRhcHRlciA9IGFkYXB0ZXJzLmdldEFkYXB0ZXI7XG5cbmF4aW9zLkh0dHBTdGF0dXNDb2RlID0gSHR0cFN0YXR1c0NvZGUkMTtcblxuYXhpb3MuZGVmYXVsdCA9IGF4aW9zO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXhpb3MuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6425\n\n}")},6450:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.verifyPluginSubscription = exports.verifyTxid = exports.verifyTokenId = exports.verifyLokadId = exports.isValidWsSubscription = void 0;\nconst VALID_HEX_REGEX = new RegExp(/^[a-f0-9]+$/);\nconst VALID_LOKADID_REGEX = new RegExp(/^[a-f0-9]{8}$/);\nconst VALID_TXID_REGEX = new RegExp(/^[a-f0-9]{64}$/);\nconst isValidWsSubscription = (subscription) => {\n    const { scriptType, payload } = subscription;\n    // Test for odd length\n    if (payload.length % 2 !== 0) {\n        return `Odd hex length: ${payload}`;\n    }\n    // Test for valid hex\n    if (!VALID_HEX_REGEX.test(payload)) {\n        return `Invalid hex: "${payload}". Payload must be lowercase hex string.`;\n    }\n    // 20 bytes\n    const SUPPORTED_HASH_BYTES_P2PKH_P2SH = 20;\n    const SUPPORTED_HASH_BYTES_P2PK = [33, 65];\n    const payloadBytes = payload.length / 2;\n    switch (scriptType) {\n        case \'p2pkh\':\n        case \'p2sh\': {\n            // Test for length\n            if (payloadBytes !== SUPPORTED_HASH_BYTES_P2PKH_P2SH) {\n                return `Invalid length, expected 20 bytes but got ${payloadBytes} bytes`;\n            }\n            return true;\n        }\n        case \'p2pk\': {\n            if (!SUPPORTED_HASH_BYTES_P2PK.includes(payloadBytes)) {\n                return `Invalid length, expected one of [33, 65] but got ${payloadBytes} bytes`;\n            }\n            return true;\n        }\n        case \'other\': {\n            // Only tests here are for odd length and valid hex, already performed\n            return true;\n        }\n        default:\n            // Unsupported type\n            return `Invalid scriptType: ${scriptType}`;\n    }\n};\nexports.isValidWsSubscription = isValidWsSubscription;\nconst verifyLokadId = (lokadId) => {\n    if (!VALID_LOKADID_REGEX.test(lokadId)) {\n        throw new Error(`Invalid lokadId: "${lokadId}". lokadId must be 4 bytes (8 chars) of lowercase hex.`);\n    }\n};\nexports.verifyLokadId = verifyLokadId;\nconst verifyTokenId = (tokenId) => {\n    if (!VALID_TXID_REGEX.test(tokenId)) {\n        throw new Error(`Invalid tokenId: "${tokenId}". tokenId must be 64 characters of lowercase hex.`);\n    }\n};\nexports.verifyTokenId = verifyTokenId;\nconst verifyTxid = (txid) => {\n    if (!VALID_TXID_REGEX.test(txid)) {\n        throw new Error(`Invalid txid: "${txid}". txid must be 64 characters of lowercase hex.`);\n    }\n};\nexports.verifyTxid = verifyTxid;\n// Tested in test/integration/plugins.ts\nconst verifyPluginSubscription = (pluginSubscription) => {\n    const { pluginName, group } = pluginSubscription;\n    if (typeof pluginName === \'undefined\') {\n        throw new Error(`pluginName must be a string`);\n    }\n    if (typeof group === \'undefined\') {\n        throw new Error(`group must be a string`);\n    }\n    // Test for odd length\n    if (group.length % 2 !== 0) {\n        throw new Error(`group must have even length (complete bytes): "${group}"`);\n    }\n    // Test for valid hex\n    if (!VALID_HEX_REGEX.test(group)) {\n        throw new Error(`group must be a valid lowercase hex string: "${group}"`);\n    }\n};\nexports.verifyPluginSubscription = verifyPluginSubscription;\n//# sourceMappingURL=validation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ1MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyw2QkFBNkI7QUFDckk7QUFDQSxrREFBa0QsRUFBRTtBQUNwRCwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxjQUFjO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsY0FBYztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE1BQU07QUFDaEY7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE1BQU07QUFDOUU7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvY2hyb25pay1jbGllbnQvZGlzdC9zcmMvdmFsaWRhdGlvbi5qcz9iNzQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5UGx1Z2luU3Vic2NyaXB0aW9uID0gZXhwb3J0cy52ZXJpZnlUeGlkID0gZXhwb3J0cy52ZXJpZnlUb2tlbklkID0gZXhwb3J0cy52ZXJpZnlMb2thZElkID0gZXhwb3J0cy5pc1ZhbGlkV3NTdWJzY3JpcHRpb24gPSB2b2lkIDA7XG5jb25zdCBWQUxJRF9IRVhfUkVHRVggPSBuZXcgUmVnRXhwKC9eW2EtZjAtOV0rJC8pO1xuY29uc3QgVkFMSURfTE9LQURJRF9SRUdFWCA9IG5ldyBSZWdFeHAoL15bYS1mMC05XXs4fSQvKTtcbmNvbnN0IFZBTElEX1RYSURfUkVHRVggPSBuZXcgUmVnRXhwKC9eW2EtZjAtOV17NjR9JC8pO1xuY29uc3QgaXNWYWxpZFdzU3Vic2NyaXB0aW9uID0gKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgIGNvbnN0IHsgc2NyaXB0VHlwZSwgcGF5bG9hZCB9ID0gc3Vic2NyaXB0aW9uO1xuICAgIC8vIFRlc3QgZm9yIG9kZCBsZW5ndGhcbiAgICBpZiAocGF5bG9hZC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBgT2RkIGhleCBsZW5ndGg6ICR7cGF5bG9hZH1gO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciB2YWxpZCBoZXhcbiAgICBpZiAoIVZBTElEX0hFWF9SRUdFWC50ZXN0KHBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybiBgSW52YWxpZCBoZXg6IFwiJHtwYXlsb2FkfVwiLiBQYXlsb2FkIG11c3QgYmUgbG93ZXJjYXNlIGhleCBzdHJpbmcuYDtcbiAgICB9XG4gICAgLy8gMjAgYnl0ZXNcbiAgICBjb25zdCBTVVBQT1JURURfSEFTSF9CWVRFU19QMlBLSF9QMlNIID0gMjA7XG4gICAgY29uc3QgU1VQUE9SVEVEX0hBU0hfQllURVNfUDJQSyA9IFszMywgNjVdO1xuICAgIGNvbnN0IHBheWxvYWRCeXRlcyA9IHBheWxvYWQubGVuZ3RoIC8gMjtcbiAgICBzd2l0Y2ggKHNjcmlwdFR5cGUpIHtcbiAgICAgICAgY2FzZSAncDJwa2gnOlxuICAgICAgICBjYXNlICdwMnNoJzoge1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgbGVuZ3RoXG4gICAgICAgICAgICBpZiAocGF5bG9hZEJ5dGVzICE9PSBTVVBQT1JURURfSEFTSF9CWVRFU19QMlBLSF9QMlNIKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIGxlbmd0aCwgZXhwZWN0ZWQgMjAgYnl0ZXMgYnV0IGdvdCAke3BheWxvYWRCeXRlc30gYnl0ZXNgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncDJwayc6IHtcbiAgICAgICAgICAgIGlmICghU1VQUE9SVEVEX0hBU0hfQllURVNfUDJQSy5pbmNsdWRlcyhwYXlsb2FkQnl0ZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIGxlbmd0aCwgZXhwZWN0ZWQgb25lIG9mIFszMywgNjVdIGJ1dCBnb3QgJHtwYXlsb2FkQnl0ZXN9IGJ5dGVzYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ290aGVyJzoge1xuICAgICAgICAgICAgLy8gT25seSB0ZXN0cyBoZXJlIGFyZSBmb3Igb2RkIGxlbmd0aCBhbmQgdmFsaWQgaGV4LCBhbHJlYWR5IHBlcmZvcm1lZFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFVuc3VwcG9ydGVkIHR5cGVcbiAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBzY3JpcHRUeXBlOiAke3NjcmlwdFR5cGV9YDtcbiAgICB9XG59O1xuZXhwb3J0cy5pc1ZhbGlkV3NTdWJzY3JpcHRpb24gPSBpc1ZhbGlkV3NTdWJzY3JpcHRpb247XG5jb25zdCB2ZXJpZnlMb2thZElkID0gKGxva2FkSWQpID0+IHtcbiAgICBpZiAoIVZBTElEX0xPS0FESURfUkVHRVgudGVzdChsb2thZElkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbG9rYWRJZDogXCIke2xva2FkSWR9XCIuIGxva2FkSWQgbXVzdCBiZSA0IGJ5dGVzICg4IGNoYXJzKSBvZiBsb3dlcmNhc2UgaGV4LmApO1xuICAgIH1cbn07XG5leHBvcnRzLnZlcmlmeUxva2FkSWQgPSB2ZXJpZnlMb2thZElkO1xuY29uc3QgdmVyaWZ5VG9rZW5JZCA9ICh0b2tlbklkKSA9PiB7XG4gICAgaWYgKCFWQUxJRF9UWElEX1JFR0VYLnRlc3QodG9rZW5JZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRva2VuSWQ6IFwiJHt0b2tlbklkfVwiLiB0b2tlbklkIG11c3QgYmUgNjQgY2hhcmFjdGVycyBvZiBsb3dlcmNhc2UgaGV4LmApO1xuICAgIH1cbn07XG5leHBvcnRzLnZlcmlmeVRva2VuSWQgPSB2ZXJpZnlUb2tlbklkO1xuY29uc3QgdmVyaWZ5VHhpZCA9ICh0eGlkKSA9PiB7XG4gICAgaWYgKCFWQUxJRF9UWElEX1JFR0VYLnRlc3QodHhpZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHR4aWQ6IFwiJHt0eGlkfVwiLiB0eGlkIG11c3QgYmUgNjQgY2hhcmFjdGVycyBvZiBsb3dlcmNhc2UgaGV4LmApO1xuICAgIH1cbn07XG5leHBvcnRzLnZlcmlmeVR4aWQgPSB2ZXJpZnlUeGlkO1xuLy8gVGVzdGVkIGluIHRlc3QvaW50ZWdyYXRpb24vcGx1Z2lucy50c1xuY29uc3QgdmVyaWZ5UGx1Z2luU3Vic2NyaXB0aW9uID0gKHBsdWdpblN1YnNjcmlwdGlvbikgPT4ge1xuICAgIGNvbnN0IHsgcGx1Z2luTmFtZSwgZ3JvdXAgfSA9IHBsdWdpblN1YnNjcmlwdGlvbjtcbiAgICBpZiAodHlwZW9mIHBsdWdpbk5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGx1Z2luTmFtZSBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ3JvdXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JvdXAgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAgIH1cbiAgICAvLyBUZXN0IGZvciBvZGQgbGVuZ3RoXG4gICAgaWYgKGdyb3VwLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBncm91cCBtdXN0IGhhdmUgZXZlbiBsZW5ndGggKGNvbXBsZXRlIGJ5dGVzKTogXCIke2dyb3VwfVwiYCk7XG4gICAgfVxuICAgIC8vIFRlc3QgZm9yIHZhbGlkIGhleFxuICAgIGlmICghVkFMSURfSEVYX1JFR0VYLnRlc3QoZ3JvdXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZ3JvdXAgbXVzdCBiZSBhIHZhbGlkIGxvd2VyY2FzZSBoZXggc3RyaW5nOiBcIiR7Z3JvdXB9XCJgKTtcbiAgICB9XG59O1xuZXhwb3J0cy52ZXJpZnlQbHVnaW5TdWJzY3JpcHRpb24gPSB2ZXJpZnlQbHVnaW5TdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6450\n\n}')},6519:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.alpBurn = exports.alpSend = exports.alpMint = exports.alpGenesis = exports.ALP_POLICY_MAX_OUTPUTS = exports.ALP_TOKEN_TYPE_STANDARD = exports.ALP_MAX_SIZE = exports.ALP_STANDARD = exports.ALP_LOKAD_ID = exports.ALP_LOKAD_ID_STR = void 0;\nconst hex_js_1 = __webpack_require__(2938);\nconst str_js_1 = __webpack_require__(2392);\nconst writerbytes_js_1 = __webpack_require__(8161);\nconst writerlength_js_1 = __webpack_require__(7408);\nconst common_js_1 = __webpack_require__(5467);\n/** LOKAD ID for ALP as string */\nexports.ALP_LOKAD_ID_STR = 'SLP2';\n/** LOKAD ID for ALP */\nexports.ALP_LOKAD_ID = (0, str_js_1.strToBytes)(exports.ALP_LOKAD_ID_STR);\n/** ALP standard token type number */\nexports.ALP_STANDARD = 0;\n/** ALP limits lengths/sizes to this number, e.g. the number of outputs */\nexports.ALP_MAX_SIZE = 127;\nexports.ALP_TOKEN_TYPE_STANDARD = {\n    protocol: 'ALP',\n    type: 'ALP_TOKEN_TYPE_STANDARD',\n    number: exports.ALP_STANDARD,\n};\n/**\n * Although ALP_MAX_SIZE is 127, in practice we can only\n * handle 29 ALP outputs in a single OP_RETURN given the curent\n * 223-byte OP_RETURN size limit, and even this assumes\n * we are only working with 1 ALP token.\n *\n * For example an ALP tx that sends multiple tokens cannot support\n * 29 token outputs as the instructions will require more than 223\n * bytes in the OP_RETURN.\n *\n * So, this is an upper bound on ALP outputs per current mempool\n * acceptance rules\n */\nexports.ALP_POLICY_MAX_OUTPUTS = 29;\n/** Build an ALP GENESIS pushdata section, creating a new ALP token */\nfunction alpGenesis(tokenType, genesisInfo, mintData) {\n    const writeSection = (writer) => {\n        writer.putBytes(exports.ALP_LOKAD_ID);\n        writer.putU8(tokenType);\n        putVarBytes(common_js_1.GENESIS, writer);\n        putVarBytes((0, str_js_1.strToBytes)(genesisInfo.tokenTicker ?? ''), writer);\n        putVarBytes((0, str_js_1.strToBytes)(genesisInfo.tokenName ?? ''), writer);\n        putVarBytes((0, str_js_1.strToBytes)(genesisInfo.url ?? ''), writer);\n        putVarBytes((0, hex_js_1.fromHex)(genesisInfo.data ?? ''), writer);\n        putVarBytes((0, hex_js_1.fromHex)(genesisInfo.authPubkey ?? ''), writer);\n        writer.putU8(genesisInfo.decimals ?? 0);\n        putMintData(mintData, writer);\n    };\n    const writerLength = new writerlength_js_1.WriterLength();\n    writeSection(writerLength);\n    const writerBytes = new writerbytes_js_1.WriterBytes(writerLength.length);\n    writeSection(writerBytes);\n    return writerBytes.data;\n}\nexports.alpGenesis = alpGenesis;\n/**\n * Build an ALP MINT pushdata section, creating new ALP tokens and mint batons\n * of the given token ID.\n **/\nfunction alpMint(tokenId, tokenType, mintData) {\n    const tokenIdBytes = (0, hex_js_1.fromHexRev)(tokenId);\n    const writeSection = (writer) => {\n        writer.putBytes(exports.ALP_LOKAD_ID);\n        writer.putU8(tokenType);\n        putVarBytes(common_js_1.MINT, writer);\n        writer.putBytes(tokenIdBytes);\n        putMintData(mintData, writer);\n    };\n    const writerLength = new writerlength_js_1.WriterLength();\n    writeSection(writerLength);\n    const writerBytes = new writerbytes_js_1.WriterBytes(writerLength.length);\n    writeSection(writerBytes);\n    return writerBytes.data;\n}\nexports.alpMint = alpMint;\n/**\n * Build an ALP SEND pushdata section, moving ALP tokens to different outputs\n **/\nfunction alpSend(tokenId, tokenType, sendAtomsArray) {\n    const tokenIdBytes = (0, hex_js_1.fromHexRev)(tokenId);\n    const writeSection = (writer) => {\n        writer.putBytes(exports.ALP_LOKAD_ID);\n        writer.putU8(tokenType);\n        writer.putU8(common_js_1.SEND.length);\n        writer.putBytes(common_js_1.SEND);\n        writer.putBytes(tokenIdBytes);\n        writer.putU8(sendAtomsArray.length);\n        for (const atoms of sendAtomsArray) {\n            putAlpAtoms(atoms, writer);\n        }\n    };\n    const writerLength = new writerlength_js_1.WriterLength();\n    writeSection(writerLength);\n    const writerBytes = new writerbytes_js_1.WriterBytes(writerLength.length);\n    writeSection(writerBytes);\n    return writerBytes.data;\n}\nexports.alpSend = alpSend;\n/** Build an ALP BURN pushdata section, intentionally burning ALP tokens. */\nfunction alpBurn(tokenId, tokenType, burnAtoms) {\n    const tokenIdBytes = (0, hex_js_1.fromHexRev)(tokenId);\n    const writeSection = (writer) => {\n        writer.putBytes(exports.ALP_LOKAD_ID);\n        writer.putU8(tokenType);\n        writer.putU8(common_js_1.BURN.length);\n        writer.putBytes(common_js_1.BURN);\n        writer.putBytes(tokenIdBytes);\n        putAlpAtoms(burnAtoms, writer);\n    };\n    const writerLength = new writerlength_js_1.WriterLength();\n    writeSection(writerLength);\n    const writerBytes = new writerbytes_js_1.WriterBytes(writerLength.length);\n    writeSection(writerBytes);\n    return writerBytes.data;\n}\nexports.alpBurn = alpBurn;\nfunction putMintData(mintData, writer) {\n    writer.putU8(mintData.atomsArray.length);\n    for (const atoms of mintData.atomsArray) {\n        putAlpAtoms(atoms, writer);\n    }\n    writer.putU8(mintData.numBatons);\n}\nfunction putAlpAtoms(atoms, writer) {\n    const atomsN = BigInt(atoms);\n    writer.putU32(atomsN & 0xffffffffn);\n    writer.putU16(atomsN >> 32n);\n}\nfunction putVarBytes(bytes, writer) {\n    if (bytes.length > 127) {\n        throw new Error('Length of bytes must be between 0 and 127');\n    }\n    writer.putU8(bytes.length);\n    writer.putBytes(bytes);\n}\n//# sourceMappingURL=alp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUxOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsZUFBZSxHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyw4QkFBOEIsR0FBRywrQkFBK0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDM08saUJBQWlCLG1CQUFPLENBQUMsSUFBYztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFjO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLElBQXNCO0FBQ3ZELDBCQUEwQixtQkFBTyxDQUFDLElBQXVCO0FBQ3pELG9CQUFvQixtQkFBTyxDQUFDLElBQWE7QUFDekM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L3Rva2VuL2FscC5qcz8xZTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWxwQnVybiA9IGV4cG9ydHMuYWxwU2VuZCA9IGV4cG9ydHMuYWxwTWludCA9IGV4cG9ydHMuYWxwR2VuZXNpcyA9IGV4cG9ydHMuQUxQX1BPTElDWV9NQVhfT1VUUFVUUyA9IGV4cG9ydHMuQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkQgPSBleHBvcnRzLkFMUF9NQVhfU0laRSA9IGV4cG9ydHMuQUxQX1NUQU5EQVJEID0gZXhwb3J0cy5BTFBfTE9LQURfSUQgPSBleHBvcnRzLkFMUF9MT0tBRF9JRF9TVFIgPSB2b2lkIDA7XG5jb25zdCBoZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9pby9oZXguanNcIik7XG5jb25zdCBzdHJfanNfMSA9IHJlcXVpcmUoXCIuLi9pby9zdHIuanNcIik7XG5jb25zdCB3cml0ZXJieXRlc19qc18xID0gcmVxdWlyZShcIi4uL2lvL3dyaXRlcmJ5dGVzLmpzXCIpO1xuY29uc3Qgd3JpdGVybGVuZ3RoX2pzXzEgPSByZXF1aXJlKFwiLi4vaW8vd3JpdGVybGVuZ3RoLmpzXCIpO1xuY29uc3QgY29tbW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG4vKiogTE9LQUQgSUQgZm9yIEFMUCBhcyBzdHJpbmcgKi9cbmV4cG9ydHMuQUxQX0xPS0FEX0lEX1NUUiA9ICdTTFAyJztcbi8qKiBMT0tBRCBJRCBmb3IgQUxQICovXG5leHBvcnRzLkFMUF9MT0tBRF9JRCA9ICgwLCBzdHJfanNfMS5zdHJUb0J5dGVzKShleHBvcnRzLkFMUF9MT0tBRF9JRF9TVFIpO1xuLyoqIEFMUCBzdGFuZGFyZCB0b2tlbiB0eXBlIG51bWJlciAqL1xuZXhwb3J0cy5BTFBfU1RBTkRBUkQgPSAwO1xuLyoqIEFMUCBsaW1pdHMgbGVuZ3Rocy9zaXplcyB0byB0aGlzIG51bWJlciwgZS5nLiB0aGUgbnVtYmVyIG9mIG91dHB1dHMgKi9cbmV4cG9ydHMuQUxQX01BWF9TSVpFID0gMTI3O1xuZXhwb3J0cy5BTFBfVE9LRU5fVFlQRV9TVEFOREFSRCA9IHtcbiAgICBwcm90b2NvbDogJ0FMUCcsXG4gICAgdHlwZTogJ0FMUF9UT0tFTl9UWVBFX1NUQU5EQVJEJyxcbiAgICBudW1iZXI6IGV4cG9ydHMuQUxQX1NUQU5EQVJELFxufTtcbi8qKlxuICogQWx0aG91Z2ggQUxQX01BWF9TSVpFIGlzIDEyNywgaW4gcHJhY3RpY2Ugd2UgY2FuIG9ubHlcbiAqIGhhbmRsZSAyOSBBTFAgb3V0cHV0cyBpbiBhIHNpbmdsZSBPUF9SRVRVUk4gZ2l2ZW4gdGhlIGN1cmVudFxuICogMjIzLWJ5dGUgT1BfUkVUVVJOIHNpemUgbGltaXQsIGFuZCBldmVuIHRoaXMgYXNzdW1lc1xuICogd2UgYXJlIG9ubHkgd29ya2luZyB3aXRoIDEgQUxQIHRva2VuLlxuICpcbiAqIEZvciBleGFtcGxlIGFuIEFMUCB0eCB0aGF0IHNlbmRzIG11bHRpcGxlIHRva2VucyBjYW5ub3Qgc3VwcG9ydFxuICogMjkgdG9rZW4gb3V0cHV0cyBhcyB0aGUgaW5zdHJ1Y3Rpb25zIHdpbGwgcmVxdWlyZSBtb3JlIHRoYW4gMjIzXG4gKiBieXRlcyBpbiB0aGUgT1BfUkVUVVJOLlxuICpcbiAqIFNvLCB0aGlzIGlzIGFuIHVwcGVyIGJvdW5kIG9uIEFMUCBvdXRwdXRzIHBlciBjdXJyZW50IG1lbXBvb2xcbiAqIGFjY2VwdGFuY2UgcnVsZXNcbiAqL1xuZXhwb3J0cy5BTFBfUE9MSUNZX01BWF9PVVRQVVRTID0gMjk7XG4vKiogQnVpbGQgYW4gQUxQIEdFTkVTSVMgcHVzaGRhdGEgc2VjdGlvbiwgY3JlYXRpbmcgYSBuZXcgQUxQIHRva2VuICovXG5mdW5jdGlvbiBhbHBHZW5lc2lzKHRva2VuVHlwZSwgZ2VuZXNpc0luZm8sIG1pbnREYXRhKSB7XG4gICAgY29uc3Qgd3JpdGVTZWN0aW9uID0gKHdyaXRlcikgPT4ge1xuICAgICAgICB3cml0ZXIucHV0Qnl0ZXMoZXhwb3J0cy5BTFBfTE9LQURfSUQpO1xuICAgICAgICB3cml0ZXIucHV0VTgodG9rZW5UeXBlKTtcbiAgICAgICAgcHV0VmFyQnl0ZXMoY29tbW9uX2pzXzEuR0VORVNJUywgd3JpdGVyKTtcbiAgICAgICAgcHV0VmFyQnl0ZXMoKDAsIHN0cl9qc18xLnN0clRvQnl0ZXMpKGdlbmVzaXNJbmZvLnRva2VuVGlja2VyID8/ICcnKSwgd3JpdGVyKTtcbiAgICAgICAgcHV0VmFyQnl0ZXMoKDAsIHN0cl9qc18xLnN0clRvQnl0ZXMpKGdlbmVzaXNJbmZvLnRva2VuTmFtZSA/PyAnJyksIHdyaXRlcik7XG4gICAgICAgIHB1dFZhckJ5dGVzKCgwLCBzdHJfanNfMS5zdHJUb0J5dGVzKShnZW5lc2lzSW5mby51cmwgPz8gJycpLCB3cml0ZXIpO1xuICAgICAgICBwdXRWYXJCeXRlcygoMCwgaGV4X2pzXzEuZnJvbUhleCkoZ2VuZXNpc0luZm8uZGF0YSA/PyAnJyksIHdyaXRlcik7XG4gICAgICAgIHB1dFZhckJ5dGVzKCgwLCBoZXhfanNfMS5mcm9tSGV4KShnZW5lc2lzSW5mby5hdXRoUHVia2V5ID8/ICcnKSwgd3JpdGVyKTtcbiAgICAgICAgd3JpdGVyLnB1dFU4KGdlbmVzaXNJbmZvLmRlY2ltYWxzID8/IDApO1xuICAgICAgICBwdXRNaW50RGF0YShtaW50RGF0YSwgd3JpdGVyKTtcbiAgICB9O1xuICAgIGNvbnN0IHdyaXRlckxlbmd0aCA9IG5ldyB3cml0ZXJsZW5ndGhfanNfMS5Xcml0ZXJMZW5ndGgoKTtcbiAgICB3cml0ZVNlY3Rpb24od3JpdGVyTGVuZ3RoKTtcbiAgICBjb25zdCB3cml0ZXJCeXRlcyA9IG5ldyB3cml0ZXJieXRlc19qc18xLldyaXRlckJ5dGVzKHdyaXRlckxlbmd0aC5sZW5ndGgpO1xuICAgIHdyaXRlU2VjdGlvbih3cml0ZXJCeXRlcyk7XG4gICAgcmV0dXJuIHdyaXRlckJ5dGVzLmRhdGE7XG59XG5leHBvcnRzLmFscEdlbmVzaXMgPSBhbHBHZW5lc2lzO1xuLyoqXG4gKiBCdWlsZCBhbiBBTFAgTUlOVCBwdXNoZGF0YSBzZWN0aW9uLCBjcmVhdGluZyBuZXcgQUxQIHRva2VucyBhbmQgbWludCBiYXRvbnNcbiAqIG9mIHRoZSBnaXZlbiB0b2tlbiBJRC5cbiAqKi9cbmZ1bmN0aW9uIGFscE1pbnQodG9rZW5JZCwgdG9rZW5UeXBlLCBtaW50RGF0YSkge1xuICAgIGNvbnN0IHRva2VuSWRCeXRlcyA9ICgwLCBoZXhfanNfMS5mcm9tSGV4UmV2KSh0b2tlbklkKTtcbiAgICBjb25zdCB3cml0ZVNlY3Rpb24gPSAod3JpdGVyKSA9PiB7XG4gICAgICAgIHdyaXRlci5wdXRCeXRlcyhleHBvcnRzLkFMUF9MT0tBRF9JRCk7XG4gICAgICAgIHdyaXRlci5wdXRVOCh0b2tlblR5cGUpO1xuICAgICAgICBwdXRWYXJCeXRlcyhjb21tb25fanNfMS5NSU5ULCB3cml0ZXIpO1xuICAgICAgICB3cml0ZXIucHV0Qnl0ZXModG9rZW5JZEJ5dGVzKTtcbiAgICAgICAgcHV0TWludERhdGEobWludERhdGEsIHdyaXRlcik7XG4gICAgfTtcbiAgICBjb25zdCB3cml0ZXJMZW5ndGggPSBuZXcgd3JpdGVybGVuZ3RoX2pzXzEuV3JpdGVyTGVuZ3RoKCk7XG4gICAgd3JpdGVTZWN0aW9uKHdyaXRlckxlbmd0aCk7XG4gICAgY29uc3Qgd3JpdGVyQnl0ZXMgPSBuZXcgd3JpdGVyYnl0ZXNfanNfMS5Xcml0ZXJCeXRlcyh3cml0ZXJMZW5ndGgubGVuZ3RoKTtcbiAgICB3cml0ZVNlY3Rpb24od3JpdGVyQnl0ZXMpO1xuICAgIHJldHVybiB3cml0ZXJCeXRlcy5kYXRhO1xufVxuZXhwb3J0cy5hbHBNaW50ID0gYWxwTWludDtcbi8qKlxuICogQnVpbGQgYW4gQUxQIFNFTkQgcHVzaGRhdGEgc2VjdGlvbiwgbW92aW5nIEFMUCB0b2tlbnMgdG8gZGlmZmVyZW50IG91dHB1dHNcbiAqKi9cbmZ1bmN0aW9uIGFscFNlbmQodG9rZW5JZCwgdG9rZW5UeXBlLCBzZW5kQXRvbXNBcnJheSkge1xuICAgIGNvbnN0IHRva2VuSWRCeXRlcyA9ICgwLCBoZXhfanNfMS5mcm9tSGV4UmV2KSh0b2tlbklkKTtcbiAgICBjb25zdCB3cml0ZVNlY3Rpb24gPSAod3JpdGVyKSA9PiB7XG4gICAgICAgIHdyaXRlci5wdXRCeXRlcyhleHBvcnRzLkFMUF9MT0tBRF9JRCk7XG4gICAgICAgIHdyaXRlci5wdXRVOCh0b2tlblR5cGUpO1xuICAgICAgICB3cml0ZXIucHV0VTgoY29tbW9uX2pzXzEuU0VORC5sZW5ndGgpO1xuICAgICAgICB3cml0ZXIucHV0Qnl0ZXMoY29tbW9uX2pzXzEuU0VORCk7XG4gICAgICAgIHdyaXRlci5wdXRCeXRlcyh0b2tlbklkQnl0ZXMpO1xuICAgICAgICB3cml0ZXIucHV0VTgoc2VuZEF0b21zQXJyYXkubGVuZ3RoKTtcbiAgICAgICAgZm9yIChjb25zdCBhdG9tcyBvZiBzZW5kQXRvbXNBcnJheSkge1xuICAgICAgICAgICAgcHV0QWxwQXRvbXMoYXRvbXMsIHdyaXRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdyaXRlckxlbmd0aCA9IG5ldyB3cml0ZXJsZW5ndGhfanNfMS5Xcml0ZXJMZW5ndGgoKTtcbiAgICB3cml0ZVNlY3Rpb24od3JpdGVyTGVuZ3RoKTtcbiAgICBjb25zdCB3cml0ZXJCeXRlcyA9IG5ldyB3cml0ZXJieXRlc19qc18xLldyaXRlckJ5dGVzKHdyaXRlckxlbmd0aC5sZW5ndGgpO1xuICAgIHdyaXRlU2VjdGlvbih3cml0ZXJCeXRlcyk7XG4gICAgcmV0dXJuIHdyaXRlckJ5dGVzLmRhdGE7XG59XG5leHBvcnRzLmFscFNlbmQgPSBhbHBTZW5kO1xuLyoqIEJ1aWxkIGFuIEFMUCBCVVJOIHB1c2hkYXRhIHNlY3Rpb24sIGludGVudGlvbmFsbHkgYnVybmluZyBBTFAgdG9rZW5zLiAqL1xuZnVuY3Rpb24gYWxwQnVybih0b2tlbklkLCB0b2tlblR5cGUsIGJ1cm5BdG9tcykge1xuICAgIGNvbnN0IHRva2VuSWRCeXRlcyA9ICgwLCBoZXhfanNfMS5mcm9tSGV4UmV2KSh0b2tlbklkKTtcbiAgICBjb25zdCB3cml0ZVNlY3Rpb24gPSAod3JpdGVyKSA9PiB7XG4gICAgICAgIHdyaXRlci5wdXRCeXRlcyhleHBvcnRzLkFMUF9MT0tBRF9JRCk7XG4gICAgICAgIHdyaXRlci5wdXRVOCh0b2tlblR5cGUpO1xuICAgICAgICB3cml0ZXIucHV0VTgoY29tbW9uX2pzXzEuQlVSTi5sZW5ndGgpO1xuICAgICAgICB3cml0ZXIucHV0Qnl0ZXMoY29tbW9uX2pzXzEuQlVSTik7XG4gICAgICAgIHdyaXRlci5wdXRCeXRlcyh0b2tlbklkQnl0ZXMpO1xuICAgICAgICBwdXRBbHBBdG9tcyhidXJuQXRvbXMsIHdyaXRlcik7XG4gICAgfTtcbiAgICBjb25zdCB3cml0ZXJMZW5ndGggPSBuZXcgd3JpdGVybGVuZ3RoX2pzXzEuV3JpdGVyTGVuZ3RoKCk7XG4gICAgd3JpdGVTZWN0aW9uKHdyaXRlckxlbmd0aCk7XG4gICAgY29uc3Qgd3JpdGVyQnl0ZXMgPSBuZXcgd3JpdGVyYnl0ZXNfanNfMS5Xcml0ZXJCeXRlcyh3cml0ZXJMZW5ndGgubGVuZ3RoKTtcbiAgICB3cml0ZVNlY3Rpb24od3JpdGVyQnl0ZXMpO1xuICAgIHJldHVybiB3cml0ZXJCeXRlcy5kYXRhO1xufVxuZXhwb3J0cy5hbHBCdXJuID0gYWxwQnVybjtcbmZ1bmN0aW9uIHB1dE1pbnREYXRhKG1pbnREYXRhLCB3cml0ZXIpIHtcbiAgICB3cml0ZXIucHV0VTgobWludERhdGEuYXRvbXNBcnJheS5sZW5ndGgpO1xuICAgIGZvciAoY29uc3QgYXRvbXMgb2YgbWludERhdGEuYXRvbXNBcnJheSkge1xuICAgICAgICBwdXRBbHBBdG9tcyhhdG9tcywgd3JpdGVyKTtcbiAgICB9XG4gICAgd3JpdGVyLnB1dFU4KG1pbnREYXRhLm51bUJhdG9ucyk7XG59XG5mdW5jdGlvbiBwdXRBbHBBdG9tcyhhdG9tcywgd3JpdGVyKSB7XG4gICAgY29uc3QgYXRvbXNOID0gQmlnSW50KGF0b21zKTtcbiAgICB3cml0ZXIucHV0VTMyKGF0b21zTiAmIDB4ZmZmZmZmZmZuKTtcbiAgICB3cml0ZXIucHV0VTE2KGF0b21zTiA+PiAzMm4pO1xufVxuZnVuY3Rpb24gcHV0VmFyQnl0ZXMoYnl0ZXMsIHdyaXRlcikge1xuICAgIGlmIChieXRlcy5sZW5ndGggPiAxMjcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggb2YgYnl0ZXMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEyNycpO1xuICAgIH1cbiAgICB3cml0ZXIucHV0VTgoYnl0ZXMubGVuZ3RoKTtcbiAgICB3cml0ZXIucHV0Qnl0ZXMoYnl0ZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6519\n\n}")},6595:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\n// Copyright (c) 2017-2018 Emilio Almansi\n// Copyright (c) 2017 Pieter Wuille\n// Copyright (c) 2024 Bitcoin ABC\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = default_1;\nconst validation_1 = __importDefault(__webpack_require__(3377));\nconst { validate } = validation_1.default;\n/**\n * Converts an array of integers made up of 'from' bits into an\n * array of integers made up of 'to' bits. The output array is\n * zero-padded if necessary, unless strict mode is true.\n * Throws a {@link ValidationError} if input is invalid.\n * Original by Pieter Wuille: https://github.com/sipa/bech32.\n *\n * @param data Array of integers made up of 'from' bits.\n * @param from Length in bits of elements in the input array.\n * @param to Length in bits of elements in the output array.\n * @param strictMode Require the conversion to be completed without padding.\n */\nfunction default_1(data, from, to, strictMode = false) {\n    const length = strictMode\n        ? Math.floor((data.length * from) / to)\n        : Math.ceil((data.length * from) / to);\n    const mask = (1 << to) - 1;\n    const result = new Uint8Array(length);\n    let index = 0;\n    let accumulator = 0;\n    let bits = 0;\n    for (let i = 0; i < data.length; ++i) {\n        const value = data[i];\n        validate(0 <= value && value >> from === 0, 'Invalid value: ' + value + '.');\n        accumulator = (accumulator << from) | value;\n        bits += from;\n        while (bits >= to) {\n            bits -= to;\n            result[index] = (accumulator >> bits) & mask;\n            ++index;\n        }\n    }\n    if (!strictMode) {\n        if (bits > 0) {\n            result[index] = (accumulator << (to - bits)) & mask;\n            ++index;\n        }\n    }\n    else {\n        validate(bits < from && ((accumulator << (to - bits)) & mask) === 0, 'Input cannot be converted to ' +\n            to +\n            ' bits without padding, but strict mode was used.');\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU5NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2YscUNBQXFDLG1CQUFPLENBQUMsSUFBYztBQUMzRCxRQUFRLFdBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2hhZGRyanMvZGlzdC9jb252ZXJ0Qml0cy5qcz84NjMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggRW1pbGlvIEFsbWFuc2lcbi8vIENvcHlyaWdodCAoYykgMjAxNyBQaWV0ZXIgV3VpbGxlXG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgQml0Y29pbiBBQkNcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIikpO1xuY29uc3QgeyB2YWxpZGF0ZSB9ID0gdmFsaWRhdGlvbl8xLmRlZmF1bHQ7XG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGludGVnZXJzIG1hZGUgdXAgb2YgJ2Zyb20nIGJpdHMgaW50byBhblxuICogYXJyYXkgb2YgaW50ZWdlcnMgbWFkZSB1cCBvZiAndG8nIGJpdHMuIFRoZSBvdXRwdXQgYXJyYXkgaXNcbiAqIHplcm8tcGFkZGVkIGlmIG5lY2Vzc2FyeSwgdW5sZXNzIHN0cmljdCBtb2RlIGlzIHRydWUuXG4gKiBUaHJvd3MgYSB7QGxpbmsgVmFsaWRhdGlvbkVycm9yfSBpZiBpbnB1dCBpcyBpbnZhbGlkLlxuICogT3JpZ2luYWwgYnkgUGlldGVyIFd1aWxsZTogaHR0cHM6Ly9naXRodWIuY29tL3NpcGEvYmVjaDMyLlxuICpcbiAqIEBwYXJhbSBkYXRhIEFycmF5IG9mIGludGVnZXJzIG1hZGUgdXAgb2YgJ2Zyb20nIGJpdHMuXG4gKiBAcGFyYW0gZnJvbSBMZW5ndGggaW4gYml0cyBvZiBlbGVtZW50cyBpbiB0aGUgaW5wdXQgYXJyYXkuXG4gKiBAcGFyYW0gdG8gTGVuZ3RoIGluIGJpdHMgb2YgZWxlbWVudHMgaW4gdGhlIG91dHB1dCBhcnJheS5cbiAqIEBwYXJhbSBzdHJpY3RNb2RlIFJlcXVpcmUgdGhlIGNvbnZlcnNpb24gdG8gYmUgY29tcGxldGVkIHdpdGhvdXQgcGFkZGluZy5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdF8xKGRhdGEsIGZyb20sIHRvLCBzdHJpY3RNb2RlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW5ndGggPSBzdHJpY3RNb2RlXG4gICAgICAgID8gTWF0aC5mbG9vcigoZGF0YS5sZW5ndGggKiBmcm9tKSAvIHRvKVxuICAgICAgICA6IE1hdGguY2VpbCgoZGF0YS5sZW5ndGggKiBmcm9tKSAvIHRvKTtcbiAgICBjb25zdCBtYXNrID0gKDEgPDwgdG8pIC0gMTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGFjY3VtdWxhdG9yID0gMDtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtpXTtcbiAgICAgICAgdmFsaWRhdGUoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA+PiBmcm9tID09PSAwLCAnSW52YWxpZCB2YWx1ZTogJyArIHZhbHVlICsgJy4nKTtcbiAgICAgICAgYWNjdW11bGF0b3IgPSAoYWNjdW11bGF0b3IgPDwgZnJvbSkgfCB2YWx1ZTtcbiAgICAgICAgYml0cyArPSBmcm9tO1xuICAgICAgICB3aGlsZSAoYml0cyA+PSB0bykge1xuICAgICAgICAgICAgYml0cyAtPSB0bztcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSAoYWNjdW11bGF0b3IgPj4gYml0cykgJiBtYXNrO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0cmljdE1vZGUpIHtcbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gKGFjY3VtdWxhdG9yIDw8ICh0byAtIGJpdHMpKSAmIG1hc2s7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZShiaXRzIDwgZnJvbSAmJiAoKGFjY3VtdWxhdG9yIDw8ICh0byAtIGJpdHMpKSAmIG1hc2spID09PSAwLCAnSW5wdXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byAnICtcbiAgICAgICAgICAgIHRvICtcbiAgICAgICAgICAgICcgYml0cyB3aXRob3V0IHBhZGRpbmcsIGJ1dCBzdHJpY3QgbW9kZSB3YXMgdXNlZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6595\n\n}")},6756:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const Utils = __webpack_require__(2726)\n\nfunction getColorAttrib (color, attrib) {\n  const alpha = color.a / 255\n  const str = attrib + '=\"' + color.hex + '\"'\n\n  return alpha < 1\n    ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"'\n    : str\n}\n\nfunction svgCmd (cmd, x, y) {\n  let str = cmd + x\n  if (typeof y !== 'undefined') str += ' ' + y\n\n  return str\n}\n\nfunction qrToPath (data, size, margin) {\n  let path = ''\n  let moveBy = 0\n  let newRow = false\n  let lineLength = 0\n\n  for (let i = 0; i < data.length; i++) {\n    const col = Math.floor(i % size)\n    const row = Math.floor(i / size)\n\n    if (!col && !newRow) newRow = true\n\n    if (data[i]) {\n      lineLength++\n\n      if (!(i > 0 && col > 0 && data[i - 1])) {\n        path += newRow\n          ? svgCmd('M', col + margin, 0.5 + row + margin)\n          : svgCmd('m', moveBy, 0)\n\n        moveBy = 0\n        newRow = false\n      }\n\n      if (!(col + 1 < size && data[i + 1])) {\n        path += svgCmd('h', lineLength)\n        lineLength = 0\n      }\n    } else {\n      moveBy++\n    }\n  }\n\n  return path\n}\n\nexports.render = function render (qrData, options, cb) {\n  const opts = Utils.getOptions(options)\n  const size = qrData.modules.size\n  const data = qrData.modules.data\n  const qrcodesize = size + opts.margin * 2\n\n  const bg = !opts.color.light.a\n    ? ''\n    : '<path ' + getColorAttrib(opts.color.light, 'fill') +\n      ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>'\n\n  const path =\n    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +\n    ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>'\n\n  const viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"'\n\n  const width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" '\n\n  const svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n'\n\n  if (typeof cb === 'function') {\n    cb(null, svgTag)\n  }\n\n  return svgTag\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvcmVuZGVyZXIvc3ZnLXRhZy5qcz80MDA2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmZ1bmN0aW9uIGdldENvbG9yQXR0cmliIChjb2xvciwgYXR0cmliKSB7XG4gIGNvbnN0IGFscGhhID0gY29sb3IuYSAvIDI1NVxuICBjb25zdCBzdHIgPSBhdHRyaWIgKyAnPVwiJyArIGNvbG9yLmhleCArICdcIidcblxuICByZXR1cm4gYWxwaGEgPCAxXG4gICAgPyBzdHIgKyAnICcgKyBhdHRyaWIgKyAnLW9wYWNpdHk9XCInICsgYWxwaGEudG9GaXhlZCgyKS5zbGljZSgxKSArICdcIidcbiAgICA6IHN0clxufVxuXG5mdW5jdGlvbiBzdmdDbWQgKGNtZCwgeCwgeSkge1xuICBsZXQgc3RyID0gY21kICsgeFxuICBpZiAodHlwZW9mIHkgIT09ICd1bmRlZmluZWQnKSBzdHIgKz0gJyAnICsgeVxuXG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gcXJUb1BhdGggKGRhdGEsIHNpemUsIG1hcmdpbikge1xuICBsZXQgcGF0aCA9ICcnXG4gIGxldCBtb3ZlQnkgPSAwXG4gIGxldCBuZXdSb3cgPSBmYWxzZVxuICBsZXQgbGluZUxlbmd0aCA9IDBcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2wgPSBNYXRoLmZsb29yKGkgJSBzaXplKVxuICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoaSAvIHNpemUpXG5cbiAgICBpZiAoIWNvbCAmJiAhbmV3Um93KSBuZXdSb3cgPSB0cnVlXG5cbiAgICBpZiAoZGF0YVtpXSkge1xuICAgICAgbGluZUxlbmd0aCsrXG5cbiAgICAgIGlmICghKGkgPiAwICYmIGNvbCA+IDAgJiYgZGF0YVtpIC0gMV0pKSB7XG4gICAgICAgIHBhdGggKz0gbmV3Um93XG4gICAgICAgICAgPyBzdmdDbWQoJ00nLCBjb2wgKyBtYXJnaW4sIDAuNSArIHJvdyArIG1hcmdpbilcbiAgICAgICAgICA6IHN2Z0NtZCgnbScsIG1vdmVCeSwgMClcblxuICAgICAgICBtb3ZlQnkgPSAwXG4gICAgICAgIG5ld1JvdyA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICghKGNvbCArIDEgPCBzaXplICYmIGRhdGFbaSArIDFdKSkge1xuICAgICAgICBwYXRoICs9IHN2Z0NtZCgnaCcsIGxpbmVMZW5ndGgpXG4gICAgICAgIGxpbmVMZW5ndGggPSAwXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVCeSsrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhcbn1cblxuZXhwb3J0cy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHFyRGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgY29uc3Qgb3B0cyA9IFV0aWxzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgY29uc3Qgc2l6ZSA9IHFyRGF0YS5tb2R1bGVzLnNpemVcbiAgY29uc3QgZGF0YSA9IHFyRGF0YS5tb2R1bGVzLmRhdGFcbiAgY29uc3QgcXJjb2Rlc2l6ZSA9IHNpemUgKyBvcHRzLm1hcmdpbiAqIDJcblxuICBjb25zdCBiZyA9ICFvcHRzLmNvbG9yLmxpZ2h0LmFcbiAgICA/ICcnXG4gICAgOiAnPHBhdGggJyArIGdldENvbG9yQXR0cmliKG9wdHMuY29sb3IubGlnaHQsICdmaWxsJykgK1xuICAgICAgJyBkPVwiTTAgMGgnICsgcXJjb2Rlc2l6ZSArICd2JyArIHFyY29kZXNpemUgKyAnSDB6XCIvPidcblxuICBjb25zdCBwYXRoID1cbiAgICAnPHBhdGggJyArIGdldENvbG9yQXR0cmliKG9wdHMuY29sb3IuZGFyaywgJ3N0cm9rZScpICtcbiAgICAnIGQ9XCInICsgcXJUb1BhdGgoZGF0YSwgc2l6ZSwgb3B0cy5tYXJnaW4pICsgJ1wiLz4nXG5cbiAgY29uc3Qgdmlld0JveCA9ICd2aWV3Qm94PVwiJyArICcwIDAgJyArIHFyY29kZXNpemUgKyAnICcgKyBxcmNvZGVzaXplICsgJ1wiJ1xuXG4gIGNvbnN0IHdpZHRoID0gIW9wdHMud2lkdGggPyAnJyA6ICd3aWR0aD1cIicgKyBvcHRzLndpZHRoICsgJ1wiIGhlaWdodD1cIicgKyBvcHRzLndpZHRoICsgJ1wiICdcblxuICBjb25zdCBzdmdUYWcgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArIHdpZHRoICsgdmlld0JveCArICcgc2hhcGUtcmVuZGVyaW5nPVwiY3Jpc3BFZGdlc1wiPicgKyBiZyArIHBhdGggKyAnPC9zdmc+XFxuJ1xuXG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYihudWxsLCBzdmdUYWcpXG4gIH1cblxuICByZXR1cm4gc3ZnVGFnXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6756\n\n}")},6810:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.payment = void 0;\n__exportStar(__webpack_require__(2260), exports);\n__exportStar(__webpack_require__(3799), exports);\n__exportStar(__webpack_require__(5632), exports);\n__exportStar(__webpack_require__(243), exports);\n__exportStar(__webpack_require__(2250), exports);\n__exportStar(__webpack_require__(6187), exports);\n__exportStar(__webpack_require__(9176), exports);\n__exportStar(__webpack_require__(6420), exports);\n__exportStar(__webpack_require__(1509), exports);\n__exportStar(__webpack_require__(3085), exports);\n__exportStar(__webpack_require__(1659), exports);\n__exportStar(__webpack_require__(932), exports);\n__exportStar(__webpack_require__(9825), exports);\n__exportStar(__webpack_require__(7151), exports);\n__exportStar(__webpack_require__(1292), exports);\n__exportStar(__webpack_require__(2938), exports);\n__exportStar(__webpack_require__(8710), exports);\n__exportStar(__webpack_require__(2392), exports);\n__exportStar(__webpack_require__(1451), exports);\n__exportStar(__webpack_require__(8112), exports);\n__exportStar(__webpack_require__(8161), exports);\n__exportStar(__webpack_require__(7408), exports);\n__exportStar(__webpack_require__(6519), exports);\n__exportStar(__webpack_require__(8950), exports);\n__exportStar(__webpack_require__(5467), exports);\n__exportStar(__webpack_require__(4004), exports);\n__exportStar(__webpack_require__(8737), exports);\n__exportStar(__webpack_require__(4964), exports);\nexports.payment = __importStar(__webpack_require__(5019));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjgxMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxJQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxJQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxJQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxHQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxJQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxJQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxJQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxJQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxJQUFlO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxJQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsSUFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLEdBQVM7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLElBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxJQUFpQjtBQUN0QyxhQUFhLG1CQUFPLENBQUMsSUFBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsSUFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsSUFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsSUFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsSUFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLElBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxJQUFxQjtBQUMxQyxhQUFhLG1CQUFPLENBQUMsSUFBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLElBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxJQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsSUFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLElBQWlCO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxJQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMsSUFBc0I7QUFDM0MsZUFBZSxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFXO0FBQ2xEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9pbmRleC5qcz83OGQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGF5bWVudCA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25zdHMuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VjYy5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaC5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3AuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wY29kZS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NyaXB0LmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZXNzYWdlcy5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW5lbW9uaWMuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hkd2FsbGV0LmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGRyZXNzL2FkZHJlc3MuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ0hhc2hUeXBlLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eC5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHhCdWlsZGVyLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91bnNpZ25lZFR4LmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pby9ieXRlcy5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW8vaGV4LmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pby9pbnQuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2lvL3N0ci5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW8vdmFyc2l6ZS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW8vd3JpdGVyLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pby93cml0ZXJieXRlcy5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW8vd3JpdGVybGVuZ3RoLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90b2tlbi9hbHAuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Rva2VuL2FscC5wYXJzZS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdG9rZW4vY29tbW9uLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90b2tlbi9lbXBwLmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90b2tlbi9zbHAuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Rva2VuL3NscC5wYXJzZS5qc1wiKSwgZXhwb3J0cyk7XG5leHBvcnRzLnBheW1lbnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcGF5bWVudFwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6810\n\n}')},6876:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.finalizeOutputs = exports.paymentOutputsToTxOutputs = exports.getTokenType = exports.selectUtxos = exports.SatsSelectionStrategy = exports.getActionTotals = exports.validateTokenActions = exports.getNftChildGenesisInput = exports.getTokenUtxosWithExactAtoms = exports.Wallet = void 0;\nconst ecash_lib_1 = __webpack_require__(8816);\n/**\n * Wallet\n *\n * Implements a one-address eCash (XEC) wallet\n * Useful for running a simple hot wallet\n */\nclass Wallet {\n    constructor(sk, chronik) {\n        this.sk = sk;\n        this.chronik = chronik;\n        this.ecc = new ecash_lib_1.Ecc();\n        // Calculate values derived from the sk\n        this.pk = this.ecc.derivePubkey(sk);\n        this.pkh = (0, ecash_lib_1.shaRmd160)(this.pk);\n        this.script = ecash_lib_1.Script.p2pkh(this.pkh);\n        this.address = ecash_lib_1.Address.p2pkh(this.pkh).toString();\n        // Constructors cannot be async, so we must sync() to get utxos and tipHeight\n        this.tipHeight = 0;\n        this.utxos = [];\n    }\n    /**\n     * Update Wallet\n     * - Set utxos to latest from chronik\n     * - Set tipHeight to latest from chronik\n     *\n     * NB the reason we update tipHeight with sync() is\n     * to determine which (if any) coinbase utxos\n     * are spendable when we build txs\n     */\n    async sync() {\n        // Update the utxo set\n        const utxos = (await this.chronik.address(this.address).utxos()).utxos;\n        // Get tipHeight of last sync()\n        const tipHeight = (await this.chronik.blockchainInfo()).tipHeight;\n        // Only set chronik-dependent fields if we got no errors\n        this.utxos = utxos;\n        this.tipHeight = tipHeight;\n    }\n    /**\n     * Return all spendable UTXOs only containing sats and no tokens\n     *\n     * - Any spendable coinbase UTXO without tokens\n     * - Any non-coinbase UTXO without tokens\n     */\n    spendableSatsOnlyUtxos() {\n        return this.utxos\n            .filter(utxo => typeof utxo.token === 'undefined' &&\n            utxo.isCoinbase === false)\n            .concat(this._spendableCoinbaseUtxos().filter(utxo => typeof utxo.token === 'undefined'));\n    }\n    /**\n     * Return all spendable utxos\n     */\n    spendableUtxos() {\n        return this.utxos\n            .filter(utxo => utxo.isCoinbase === false)\n            .concat(this._spendableCoinbaseUtxos());\n    }\n    /**\n     * Return all spendable coinbase utxos\n     * i.e. coinbase utxos with COINBASE_MATURITY confirmations\n     */\n    _spendableCoinbaseUtxos() {\n        return this.utxos.filter(utxo => utxo.isCoinbase === true &&\n            this.tipHeight - utxo.blockHeight >= ecash_lib_1.COINBASE_MATURITY);\n    }\n    /** Create class that supports action-fulfilling methods  */\n    action(\n    /**\n     * User-specified instructions for desired on-chain action(s)\n     *\n     * Note that an Action may take more than 1 tx to fulfill\n     */\n    action, \n    /**\n     * Strategy for selecting satoshis in UTXO selection\n     * @default SatsSelectionStrategy.REQUIRE_SATS\n     */\n    satsStrategy = SatsSelectionStrategy.REQUIRE_SATS) {\n        return WalletAction.fromAction(this, action, satsStrategy);\n    }\n    /**\n     * Convert a ScriptUtxo into a TxBuilderInput\n     */\n    p2pkhUtxoToBuilderInput(utxo, sighash = ecash_lib_1.ALL_BIP143) {\n        // Sign and prep utxos for ecash-lib inputs\n        return {\n            input: {\n                prevOut: {\n                    txid: utxo.outpoint.txid,\n                    outIdx: utxo.outpoint.outIdx,\n                },\n                signData: {\n                    sats: utxo.sats,\n                    outputScript: this.script,\n                },\n            },\n            signatory: (0, ecash_lib_1.P2PKHSignatory)(this.sk, this.pk, sighash),\n        };\n    }\n    /**\n     * static constructor for sk as Uint8Array\n     */\n    static fromSk(sk, chronik) {\n        return new Wallet(sk, chronik);\n    }\n    /**\n     * static constructor from mnemonic\n     *\n     * NB ecash-lib mnemonicToSeed does not validate for bip39 mnemonics\n     * Any string will be walletized\n     */\n    static fromMnemonic(mnemonic, chronik) {\n        const seed = (0, ecash_lib_1.mnemonicToSeed)(mnemonic);\n        const master = ecash_lib_1.HdNode.fromSeed(seed);\n        // ecash-wallet Wallets are token aware, so we use the token-aware derivation path\n        const xecMaster = master.derivePath(ecash_lib_1.XEC_TOKEN_AWARE_DERIVATION_PATH);\n        const sk = xecMaster.seckey();\n        return Wallet.fromSk(sk, chronik);\n    }\n}\nexports.Wallet = Wallet;\n/**\n * Return total quantity of satoshis held\n * by arbitrary array of utxos\n */\nWallet.sumUtxosSats = (utxos) => {\n    return utxos\n        .map(utxo => utxo.sats)\n        .reduce((prev, curr) => prev + curr, 0n);\n};\n/**\n * eCash tx(s) that fulfill(s) an Action\n */\nclass WalletAction {\n    constructor(wallet, action, selectUtxosResult, actionTotal) {\n        /**\n         * We need to build and sign a tx to confirm\n         * we have sufficient inputs\n         */\n        this._getBuiltTx = (inputs, outputs, feePerKb, dustSats) => {\n            // Can you cover the tx without fuelUtxos?\n            try {\n                const txBuilder = new ecash_lib_1.TxBuilder({\n                    inputs,\n                    // ecash-wallet always adds a leftover output\n                    outputs: [...outputs, this._wallet.script],\n                });\n                const thisTx = txBuilder.sign({\n                    feePerKb,\n                    dustSats,\n                });\n                const txSize = thisTx.serSize();\n                const txFee = (0, ecash_lib_1.calcTxFee)(txSize, feePerKb);\n                const inputSats = inputs\n                    .map(input => input.input.signData.sats)\n                    .reduce((a, b) => a + b, 0n);\n                // Do your inputs cover outputSum + txFee?\n                if (inputSats >= this.actionTotal.sats + txFee) {\n                    // mightTheseUtxosWork --\x3e now we have confirmed they will work\n                    return {\n                        success: true,\n                        builtTx: new BuiltTx(this._wallet, thisTx, feePerKb),\n                    };\n                }\n            }\n            catch {\n                // Error is expected if we do not have enough utxos\n                // So do nothing\n                return { success: false };\n            }\n            return { success: false };\n        };\n        this._wallet = wallet;\n        this.action = action;\n        this.selectUtxosResult = selectUtxosResult;\n        this.actionTotal = actionTotal;\n    }\n    static fromAction(wallet, action, satsStrategy = SatsSelectionStrategy.REQUIRE_SATS) {\n        const selectUtxosResult = (0, exports.selectUtxos)(action, wallet.spendableUtxos(), satsStrategy);\n        // NB actionTotal is an intermediate value calculated in selectUtxos\n        // Since it is dependent on action and spendable utxos, we do not want it\n        // to be a standalone param for selectUtxos\n        // We need it here to get sat totals for tx building\n        const actionTotal = (0, exports.getActionTotals)(action);\n        // Create a new WalletAction with the same wallet and action\n        return new WalletAction(wallet, action, selectUtxosResult, actionTotal);\n    }\n    /**\n     * Build (but do not broadcast) an eCash tx to handle the\n     * action specified by the constructor\n     *\n     * NB that, for now, we will throw an error if we cannot handle\n     * all instructions in a single tx\n     */\n    build(sighash = ecash_lib_1.ALL_BIP143) {\n        if (this.selectUtxosResult.success === false ||\n            typeof this.selectUtxosResult.utxos === 'undefined' ||\n            this.selectUtxosResult.missingSats > 0n) {\n            // Use the errors field if available, otherwise construct a generic error\n            if (this.selectUtxosResult.errors &&\n                this.selectUtxosResult.errors.length > 0) {\n                throw new Error(this.selectUtxosResult.errors.join('; '));\n            }\n            // The build() method only works for the REQUIRE_SATS strategy\n            // TODO add another method to handle missingSats selectUtxos\n            throw new Error(`Insufficient sats to complete tx. Need ${this.selectUtxosResult.missingSats} additional satoshis to complete this Action.`);\n        }\n        const selectedUtxos = this.selectUtxosResult.utxos;\n        const dustSats = this.action.dustSats || ecash_lib_1.DEFAULT_DUST_SATS;\n        const feePerKb = this.action.feePerKb || ecash_lib_1.DEFAULT_FEE_SATS_PER_KB;\n        /**\n         * Validate outputs AND add token-required generated outputs\n         * i.e. token change or burn-adjusted token change\n         */\n        const outputs = (0, exports.finalizeOutputs)(this.action, selectedUtxos, this._wallet.script, dustSats);\n        // Determine the exact utxos we need for this tx by building and signing the tx\n        let inputSats = Wallet.sumUtxosSats(selectedUtxos);\n        const outputSats = this.actionTotal.sats;\n        let needsAnotherUtxo = false;\n        let txFee;\n        const finalizedInputs = selectedUtxos.map(utxo => this._wallet.p2pkhUtxoToBuilderInput(utxo, sighash));\n        // Can you cover the tx without fuelUtxos?\n        const builtTxResult = this._getBuiltTx(finalizedInputs, outputs, feePerKb, dustSats);\n        if (builtTxResult.success) {\n            return builtTxResult.builtTx;\n        }\n        else {\n            needsAnotherUtxo = true;\n        }\n        // If we get here, we need more utxos\n        // Fuel utxos are spendableSatsUtxos that are not already included in selectedUtxos\n        const fuelUtxos = this._wallet\n            .spendableSatsOnlyUtxos()\n            .filter(spendableSatsOnlyUtxo => !selectedUtxos.some(selectedUtxo => selectedUtxo.outpoint.txid ===\n            spendableSatsOnlyUtxo.outpoint.txid &&\n            selectedUtxo.outpoint.outIdx ===\n                spendableSatsOnlyUtxo.outpoint.outIdx));\n        for (const utxo of fuelUtxos) {\n            // If our inputs cover our outputs, we might have enough\n            // But we don't really know since we must calculate the fee\n            let mightTheseUtxosWork = inputSats >= outputSats;\n            if (!mightTheseUtxosWork || needsAnotherUtxo) {\n                // If we know these utxos are insufficient to cover the tx, add a utxo\n                inputSats += utxo.sats;\n                finalizedInputs.push(this._wallet.p2pkhUtxoToBuilderInput(utxo, sighash));\n            }\n            // Update mightTheseUtxosWork as now we have another input\n            mightTheseUtxosWork = inputSats > outputSats;\n            if (mightTheseUtxosWork) {\n                const builtTxResult = this._getBuiltTx(finalizedInputs, outputs, feePerKb, dustSats);\n                if (builtTxResult.success) {\n                    return builtTxResult.builtTx;\n                }\n                else {\n                    needsAnotherUtxo = true;\n                }\n            }\n        }\n        // If we run out of availableUtxos without returning inputs, we can't afford this tx\n        throw new Error(`Insufficient satoshis in available utxos (${inputSats}) to cover outputs of this tx (${outputSats}) + fee${typeof txFee !== 'undefined' ? ` (${txFee})` : ``}`);\n    }\n    /**\n     * Build a postage transaction that is structurally valid but financially insufficient\n     * This is used for postage scenarios where fuel inputs will be added later\n     */\n    buildPostage(sighash = ecash_lib_1.ALL_ANYONECANPAY_BIP143) {\n        if (this.selectUtxosResult.success === false ||\n            typeof this.selectUtxosResult.utxos === 'undefined') {\n            // Use the errors field if available, otherwise construct a generic error\n            if (this.selectUtxosResult.errors &&\n                this.selectUtxosResult.errors.length > 0) {\n                throw new Error(this.selectUtxosResult.errors.join('; '));\n            }\n            throw new Error(`Unable to select required UTXOs for this Action.`);\n        }\n        const selectedUtxos = this.selectUtxosResult.utxos;\n        const dustSats = this.action.dustSats || ecash_lib_1.DEFAULT_DUST_SATS;\n        const feePerKb = this.action.feePerKb || ecash_lib_1.DEFAULT_FEE_SATS_PER_KB;\n        /**\n         * Validate outputs AND add token-required generated outputs\n         * i.e. token change or burn-adjusted token change\n         */\n        const outputs = (0, exports.finalizeOutputs)(this.action, selectedUtxos, this._wallet.script, dustSats);\n        // Create inputs with the specified sighash\n        const finalizedInputs = selectedUtxos.map(utxo => this._wallet.p2pkhUtxoToBuilderInput(utxo, sighash));\n        // Create a PostageTx (structurally valid but financially insufficient)\n        return new PostageTx(this._wallet, finalizedInputs, outputs, feePerKb, dustSats, this.actionTotal);\n    }\n}\nclass BuiltTx {\n    constructor(wallet, tx, feePerKb) {\n        this._wallet = wallet;\n        this.tx = tx;\n        this.feePerKb = feePerKb;\n    }\n    size() {\n        return this.tx.serSize();\n    }\n    fee() {\n        return (0, ecash_lib_1.calcTxFee)(this.size(), this.feePerKb);\n    }\n    async broadcast() {\n        // NB we get the same result here if we do not use toHex\n        // We use toHex because it simplifies creating and storing\n        // mocks for mock-chronik-client in tests\n        return await this._wallet.chronik.broadcastTx((0, ecash_lib_1.toHex)(this.tx.ser()));\n    }\n}\n/**\n * PostageTx represents a transaction that is structurally valid but financially insufficient\n * It can be used for postage scenarios where fuel inputs need to be added later\n */\nclass PostageTx {\n    constructor(wallet, inputs, outputs, feePerKb, dustSats, actionTotal) {\n        this._wallet = wallet;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.feePerKb = feePerKb;\n        this.dustSats = dustSats;\n        this.actionTotal = actionTotal;\n    }\n    /**\n     * Add fuel inputs and create a broadcastable transaction\n     * Uses the same fee calculation approach as build() method\n     */\n    addFuelAndSign(fuelWallet, sighash = ecash_lib_1.ALL_BIP143) {\n        const fuelUtxos = fuelWallet.spendableSatsOnlyUtxos();\n        if (fuelUtxos.length === 0) {\n            throw new Error('No XEC UTXOs available in fuel wallet');\n        }\n        // Start with postage inputs (token UTXOs with insufficient sats)\n        const allInputs = [...this.inputs];\n        let inputSats = allInputs.reduce((sum, input) => sum + input.input.signData.sats, 0n);\n        const baseOutputs = [...this.outputs];\n        const outputSats = baseOutputs.reduce((sum, output) => {\n            if ('sats' in output) {\n                return sum + output.sats;\n            }\n            else {\n                return sum;\n            }\n        }, 0n);\n        // Add a leftover output (change) as just the Script, not {script, sats}\n        const outputsWithChange = [\n            ...baseOutputs,\n            fuelWallet.script, // This signals TxBuilder to calculate change and fee\n        ];\n        // Try to build with just postage inputs first\n        try {\n            const txBuilder = new ecash_lib_1.TxBuilder({\n                inputs: allInputs,\n                outputs: outputsWithChange,\n            });\n            const signedTx = txBuilder.sign({\n                feePerKb: this.feePerKb,\n                dustSats: this.dustSats,\n            });\n            return new BuiltTx(fuelWallet, signedTx, this.feePerKb);\n        }\n        catch {\n            // Expected - postage inputs are insufficient\n        }\n        // If we get here, we need fuel UTXOs\n        // Add fuel UTXOs one by one and try to build after each addition\n        for (const fuelUtxo of fuelUtxos) {\n            inputSats += fuelUtxo.sats;\n            allInputs.push(fuelWallet.p2pkhUtxoToBuilderInput(fuelUtxo, sighash));\n            // Try to build with current inputs\n            try {\n                const txBuilder = new ecash_lib_1.TxBuilder({\n                    inputs: allInputs,\n                    outputs: outputsWithChange,\n                });\n                const signedTx = txBuilder.sign({\n                    feePerKb: this.feePerKb,\n                    dustSats: this.dustSats,\n                });\n                return new BuiltTx(fuelWallet, signedTx, this.feePerKb);\n            }\n            catch {\n                // Continue to next fuel UTXO\n            }\n        }\n        // If we run out of fuel UTXOs without success, we can't afford this tx\n        throw new Error(`Insufficient fuel: cannot cover outputs (${outputSats}) + fee with available fuel UTXOs (${inputSats} total sats)`);\n    }\n}\n/**\n * Finds a combination of UTXOs for a given tokenId whose atoms exactly sum to burnAtoms.\n * Returns the matching UTXOs or throws an error if no exact match is found.\n *\n * @param availableUtxos - Array of UTXOs to search through\n * @param tokenId - The token ID to match\n * @param burnAtoms - The exact amount of atoms to burn\n * @returns Array of UTXOs whose atoms sum exactly to burnAtoms\n */\nconst getTokenUtxosWithExactAtoms = (availableUtxos, tokenId, burnAtoms) => {\n    if (burnAtoms <= 0n) {\n        throw new Error(`burnAtoms of ${burnAtoms} specified for ${tokenId}. burnAtoms must be greater than 0n.`);\n    }\n    // Filter UTXOs for the given tokenId and valid token data\n    const relevantUtxos = availableUtxos.filter(utxo => utxo.token?.tokenId === tokenId &&\n        utxo.token.atoms > 0n &&\n        !utxo.token.isMintBaton);\n    if (relevantUtxos.length === 0) {\n        throw new Error(`Cannot burn ${tokenId} as no UTXOs are available.`);\n    }\n    // Calculate total atoms available\n    const totalAtoms = relevantUtxos.reduce((sum, utxo) => sum + utxo.token.atoms, 0n);\n    if (totalAtoms < burnAtoms) {\n        throw new Error(`burnAtoms of ${burnAtoms} specified for ${tokenId}, but only ${totalAtoms} are available.`);\n    }\n    if (totalAtoms === burnAtoms) {\n        // If total equals burnAtoms, return all relevant UTXOs\n        return relevantUtxos;\n    }\n    // Use dynamic programming to find the exact sum and track UTXOs\n    const dp = new Map();\n    dp.set(0n, []);\n    for (const utxo of relevantUtxos) {\n        const atoms = utxo.token.atoms;\n        const newEntries = [];\n        for (const [currentSum, utxos] of dp) {\n            const newSum = currentSum + atoms;\n            if (newSum <= burnAtoms) {\n                newEntries.push([newSum, [...utxos, utxo]]);\n            }\n        }\n        for (const [newSum, utxos] of newEntries) {\n            if (newSum === burnAtoms) {\n                // Found exact match\n                return utxos;\n            }\n            dp.set(newSum, utxos);\n        }\n    }\n    throw new Error(`Unable to find UTXOs for ${tokenId} with exactly ${burnAtoms} atoms. Create a UTXO with ${burnAtoms} atoms to burn without a SEND action.`);\n};\nexports.getTokenUtxosWithExactAtoms = getTokenUtxosWithExactAtoms;\n/**\n * We need a qty-1 input of this tokenId at index 0 of inputs to mint an NFT\n * - Try to get this\n * - If we can't get this, get the biggest qty utxo\n * - If we don't have anything, return undefined\n */\nconst getNftChildGenesisInput = (tokenId, slpUtxos) => {\n    // Note that we do not use .filter() as we do in most \"getInput\" functions for SLP,\n    // because in this case we only want exactly 1 utxo\n    for (const utxo of slpUtxos) {\n        if (utxo.token?.tokenId === tokenId &&\n            utxo.token?.isMintBaton === false &&\n            utxo.token?.atoms === 1n) {\n            return utxo;\n        }\n    }\n    // If we can't find exactly 1 input, look for the input with the highest qty\n    let highestQtyUtxo = undefined;\n    let highestQty = 0n;\n    for (const utxo of slpUtxos) {\n        if (utxo.token?.tokenId === tokenId &&\n            utxo.token?.isMintBaton === false &&\n            utxo.token?.atoms > highestQty) {\n            highestQtyUtxo = utxo;\n            highestQty = utxo.token.atoms;\n        }\n    }\n    // Return the highest qty utxo if found\n    return highestQtyUtxo;\n};\nexports.getNftChildGenesisInput = getNftChildGenesisInput;\n/**\n * Validate only user-specified token actions\n * For v0 of ecash-wallet, we only support single-tx actions, which\n * means some combinations of actions are always invalid, or\n * unsupported by the lib\n *\n * Full validation of tokenActions is complex and depends on available utxos\n * and user-specified outputs. In this function, we do all the validation\n * we can without knowing anything about token type, utxos, or outputs\n *\n * - No duplicate actions\n * - Only 0 or 1 GenesisAction and must be first\n * - No MINT and SEND for the same tokenId\n */\nconst validateTokenActions = (tokenActions) => {\n    const mintTokenIds = [];\n    const sendTokenIds = [];\n    const burnTokenIds = [];\n    for (let i = 0; i < tokenActions.length; i++) {\n        const tokenAction = tokenActions[i];\n        switch (tokenAction.type) {\n            case 'GENESIS': {\n                if (i !== 0) {\n                    // This also handles the validation condition of \"no more than one genesis action\"\n                    throw new Error(`GenesisAction must be at index 0 of tokenActions. Found GenesisAction at index ${i}.`);\n                }\n                if (tokenAction.tokenType.type === 'SLP_TOKEN_TYPE_NFT1_CHILD') {\n                    if (typeof tokenAction.groupTokenId === 'undefined') {\n                        throw new Error(`SLP_TOKEN_TYPE_NFT1_CHILD genesis txs must specify a groupTokenId.`);\n                    }\n                }\n                else {\n                    if (typeof tokenAction.groupTokenId !== 'undefined') {\n                        throw new Error(`${tokenAction.tokenType.type} genesis txs must not specify a groupTokenId.`);\n                    }\n                }\n                break;\n            }\n            case 'SEND': {\n                const { tokenId } = tokenAction;\n                if (sendTokenIds.includes(tokenId)) {\n                    throw new Error(`Duplicate SEND action for tokenId ${tokenId}`);\n                }\n                if (mintTokenIds.includes(tokenId)) {\n                    throw new Error(`ecash-wallet does not support minting and sending the same token in the same Action. tokenActions MINT and SEND ${tokenId}.`);\n                }\n                sendTokenIds.push(tokenId);\n                break;\n            }\n            case 'MINT': {\n                const { tokenId, tokenType } = tokenAction;\n                if (tokenType.type === 'SLP_TOKEN_TYPE_MINT_VAULT') {\n                    throw new Error(`ecash-wallet does not currently support minting SLP_TOKEN_TYPE_MINT_VAULT tokens.`);\n                }\n                if (mintTokenIds.includes(tokenId)) {\n                    throw new Error(`Duplicate MINT action for tokenId ${tokenId}`);\n                }\n                if (sendTokenIds.includes(tokenId)) {\n                    throw new Error(`ecash-wallet does not support minting and sending the same token in the same Action. tokenActions MINT and SEND ${tokenId}.`);\n                }\n                mintTokenIds.push(tokenId);\n                break;\n            }\n            case 'BURN': {\n                const { tokenId } = tokenAction;\n                if (burnTokenIds.includes(tokenId)) {\n                    throw new Error(`Duplicate BURN action for tokenId ${tokenId}`);\n                }\n                burnTokenIds.push(tokenId);\n                break;\n            }\n            case 'DATA': {\n                // DataAction validation is handled in finalizeOutputs\n                // No specific validation needed here\n                // We do not validate data actions here because we would need to know token type\n                break;\n            }\n            default: {\n                throw new Error(`Unknown token action at index ${i} of tokenActions`);\n            }\n        }\n    }\n};\nexports.validateTokenActions = validateTokenActions;\n/**\n * Parse actions to determine the total quantity of satoshis\n * and token atoms (of each token) required to fulfill the Action\n */\nconst getActionTotals = (action) => {\n    const { outputs } = action;\n    const tokenActions = action.tokenActions ?? [];\n    // Iterate over tokenActions to figure out which outputs are associated with which actions\n    const sendActionTokenIds = new Set();\n    const burnActionTokenIds = new Set();\n    const burnWithChangeTokenIds = new Set();\n    const burnAllTokenIds = new Set();\n    const mintActionTokenIds = new Set();\n    let groupTokenId = undefined;\n    const burnAtomsMap = new Map();\n    for (const action of tokenActions) {\n        switch (action.type) {\n            case 'SEND': {\n                sendActionTokenIds.add(action.tokenId);\n                break;\n            }\n            case 'BURN': {\n                burnActionTokenIds.add(action.tokenId);\n                burnAtomsMap.set(action.tokenId, action.burnAtoms);\n                break;\n            }\n            case 'MINT': {\n                mintActionTokenIds.add(action.tokenId);\n                break;\n            }\n            case 'GENESIS': {\n                // GENESIS txs only require specific inputs if they are for SLP_TOKEN_TYPE_NFT1_CHILD\n                if (action.tokenType.type === 'SLP_TOKEN_TYPE_NFT1_CHILD') {\n                    // NB we already validate that a genesis action for SLP_TOKEN_TYPE_NFT1_CHILD has a groupTokenId\n                    // in validateTokenActions\n                    groupTokenId = action.groupTokenId;\n                }\n            }\n        }\n    }\n    // Group burn action tokenIds into two sets with different input requirements\n    burnActionTokenIds.forEach(tokenId => {\n        if (sendActionTokenIds.has(tokenId)) {\n            burnWithChangeTokenIds.add(tokenId);\n        }\n        else {\n            burnAllTokenIds.add(tokenId);\n        }\n    });\n    const dustSats = action.dustSats ?? ecash_lib_1.DEFAULT_DUST_SATS;\n    // NB we do not require any token inputs for genesisAction\n    // Initialize map to store token requirements\n    const requiredTokenInputsMap = new Map();\n    // Get all outputs that require input atoms\n    const tokenSendOutputs = outputs.filter((output) => 'tokenId' in output &&\n        typeof output.tokenId !== 'undefined' &&\n        (sendActionTokenIds.has(output.tokenId) ||\n            burnActionTokenIds.has(output.tokenId)));\n    // Process token send outputs\n    for (const tokenSendOutput of tokenSendOutputs) {\n        const { tokenId, atoms } = tokenSendOutput;\n        const requiredTokenInputs = requiredTokenInputsMap.get(tokenId);\n        if (typeof requiredTokenInputs === 'undefined') {\n            // Initialize\n            requiredTokenInputsMap.set(tokenId, {\n                atoms,\n                atomsMustBeExact: false,\n                needsMintBaton: false,\n            });\n        }\n        else {\n            // Increment atoms\n            requiredTokenInputs.atoms += atoms;\n        }\n    }\n    // Process burn with change actions\n    // We only need utxos with atoms >= burnAtoms for these tokenIds\n    burnWithChangeTokenIds.forEach(tokenId => {\n        const burnAtoms = burnAtomsMap.get(tokenId);\n        const requiredTokenInputs = requiredTokenInputsMap.get(tokenId);\n        if (typeof requiredTokenInputs === 'undefined') {\n            // Initialize\n            requiredTokenInputsMap.set(tokenId, {\n                atoms: burnAtoms,\n                // We are only looking at the tokens that burn with change\n                atomsMustBeExact: false,\n                needsMintBaton: false,\n            });\n        }\n        else {\n            // Increment atoms\n            // We only get here if the user is SENDing and BURNing the same tokenId\n            // NB we do need MORE atoms in inputs to burn, as the user-specified outputs are NOT burned\n            // So we need inputs to cover the specified outputs AND the burn\n            requiredTokenInputs.atoms += burnAtoms;\n        }\n    });\n    // Process burnAll actions\n    // We must find utxos with atoms that exactly match burnAtoms for these tokenIds\n    burnAllTokenIds.forEach(tokenId => {\n        const burnAtoms = burnAtomsMap.get(tokenId);\n        // No increment here, we need exact atoms and\n        // we will not have any atom requirements for these tokenIds from SEND outputs\n        requiredTokenInputsMap.set(tokenId, {\n            atoms: burnAtoms,\n            atomsMustBeExact: true,\n            needsMintBaton: false,\n        });\n    });\n    // Process mint actions\n    mintActionTokenIds.forEach(tokenId => {\n        const requiredTokenInputs = requiredTokenInputsMap.get(tokenId);\n        if (typeof requiredTokenInputs === 'undefined') {\n            requiredTokenInputsMap.set(tokenId, {\n                atoms: 0n,\n                atomsMustBeExact: false,\n                needsMintBaton: true,\n            });\n        }\n        else {\n            // If we have already defined this, i.e. if we are also BURNing this tokenId\n            // in this tx, then do not modify atoms. Make sure we add mintBaton though.\n            requiredTokenInputs.needsMintBaton = true;\n        }\n    });\n    // We need to know sats for all outputs in the tx\n    let requiredSats = 0n;\n    for (const output of outputs) {\n        if ('bytecode' in output) {\n            // If this output is a Script output\n            // We do not sum this as an output, as its value must be\n            // calculated dynamically by the txBuilder.sign method\n            continue;\n        }\n        requiredSats += output.sats ?? dustSats;\n    }\n    const actionTotal = { sats: requiredSats };\n    if (requiredTokenInputsMap.size > 0) {\n        actionTotal.tokens = requiredTokenInputsMap;\n    }\n    if (typeof groupTokenId !== 'undefined') {\n        actionTotal.groupTokenId = groupTokenId;\n    }\n    return actionTotal;\n};\nexports.getActionTotals = getActionTotals;\n/**\n * Strategy for selecting satoshis in UTXO selection\n */\nvar SatsSelectionStrategy;\n(function (SatsSelectionStrategy) {\n    /** Must select enough sats to cover outputs + fee, otherwise error (default behavior) */\n    SatsSelectionStrategy[\"REQUIRE_SATS\"] = \"REQUIRE_SATS\";\n    /** Try to cover sats, otherwise return UTXOs which cover less than asked for */\n    SatsSelectionStrategy[\"ATTEMPT_SATS\"] = \"ATTEMPT_SATS\";\n    /** Don't add sats, even if they're available (for postage-paid-in-full scenarios) */\n    SatsSelectionStrategy[\"NO_SATS\"] = \"NO_SATS\";\n})(SatsSelectionStrategy || (exports.SatsSelectionStrategy = SatsSelectionStrategy = {}));\n/**\n * Select utxos to fulfill the requirements of an Action\n *\n * Notes about minting SLP_TOKEN_TYPE_NFT1_CHILD tokens\n *\n * These tokens, aka \"NFTs\", are minted by burning exactly 1 SLP_TOKEN_TYPE_NFT1_GROUP token\n * However, a user may not have these quantity-1 SLP_TOKEN_TYPE_NFT1_GROUP tokens available\n * We return a unique error msg for the case of \"user has no qty-1 SLP_TOKEN_TYPE_NFT1_GROUP tokens\"\n * vs \"user has only qty-more-than-1 SLP_TOKEN_TYPE_NFT1_GROUP tokens\"\n *\n * ref https://github.com/simpleledger/slp-specifications/blob/master/slp-nft-1.md\n * NB we actually \"could\" mint NFT by burning an SLP_TOKEN_TYPE_NFT1_GROUP with qty > 1.\n * However we cannot have \"change\" for the SLP_TOKEN_TYPE_NFT1_GROUP in this tx, because\n * SLP only supports one action, and the mint action must be for token type SLP_TOKEN_TYPE_NFT1_CHILD\n * So, the best practice is to perform fan-out txs\n *\n * ecash-wallet could handle this with chained txs, either before MINT or after the genesis of the\n * SLP_TOKEN_TYPE_NFT1_GROUP token. For now, the user must perform fan-out txs manually.\n *\n * NB the following are not currently supported:\n * - Minting of SLP_TOKEN_TYPE_MINT_VAULT tokens\n */\nconst selectUtxos = (action, \n/**\n * All spendable utxos available to the wallet\n * - Token utxos\n * - Non-token utxos\n * - Coinbase utxos with at least COINBASE_MATURITY confirmations\n */\nspendableUtxos, \n/**\n * Strategy for selecting satoshis\n * @default SatsSelectionStrategy.REQUIRE_SATS\n */\nsatsStrategy = SatsSelectionStrategy.REQUIRE_SATS) => {\n    const { sats, tokens, groupTokenId } = (0, exports.getActionTotals)(action);\n    let tokenIdsWithRequiredUtxos = [];\n    // Burn all tokenIds require special handling as we must collect\n    // utxos where the atoms exactly sum to burnAtoms\n    const burnAllTokenIds = [];\n    if (typeof tokens !== 'undefined') {\n        tokenIdsWithRequiredUtxos = Array.from(tokens.keys());\n        for (const tokenId of tokenIdsWithRequiredUtxos) {\n            const requiredTokenInputs = tokens.get(tokenId);\n            if (requiredTokenInputs.atomsMustBeExact) {\n                // If this tokenId requires an exact burn\n                // We will need to collect utxos that exactly sum to burnAtoms\n                burnAllTokenIds.push(tokenId);\n            }\n        }\n    }\n    // We need exactly 1 qty-1 input of this tokenId at index 0 of inputs to mint an NFT\n    // If we have it, use it, and we can make this mint in 1 tx\n    // If we have an input with qty > 1, we need to chain a fan-out tx; return appropriate error msg\n    // If we have no inputs, return appropriate error msg\n    let nftMintInput = undefined;\n    let needsNftMintInput = false;\n    let needsNftFanout = false;\n    if (typeof groupTokenId !== 'undefined') {\n        nftMintInput = (0, exports.getNftChildGenesisInput)(groupTokenId, spendableUtxos);\n        if (typeof nftMintInput === 'undefined') {\n            // We do not have the inputs we need\n            // So that we can still use the existing tokens and sats logic of this function\n            // below, add this as a missing token\n            needsNftMintInput = true;\n        }\n        else if (nftMintInput.token?.atoms && nftMintInput.token.atoms > 1n) {\n            // We have it but not the right qty\n            needsNftFanout = true;\n        }\n    }\n    // NB for a non-token tx, we only use non-token utxos\n    // As this function is extended, we will need to count the sats\n    // in token utxos\n    const selectedUtxos = [];\n    let selectedUtxosSats = 0n;\n    // Add NFT mint input if we have one\n    if (typeof groupTokenId !== 'undefined' &&\n        typeof nftMintInput !== 'undefined' &&\n        !needsNftFanout) {\n        // We only add if it is a qty-1 input\n        // Technically, a higher qty input would \"work\" per spec\n        // But we enforce using only qty-1 inputs\n        // TODO we could perhaps auto-fan-and-mint using this library\n        selectedUtxos.push(nftMintInput);\n        selectedUtxosSats += nftMintInput.sats;\n    }\n    // Handle burnAll tokenIds first\n    for (const burnAllTokenId of burnAllTokenIds) {\n        const utxosThisBurnAllTokenId = (0, exports.getTokenUtxosWithExactAtoms)(spendableUtxos, burnAllTokenId, tokens.get(burnAllTokenId).atoms);\n        for (const utxo of utxosThisBurnAllTokenId) {\n            selectedUtxos.push(utxo);\n            selectedUtxosSats += utxo.sats;\n        }\n        // We have now added utxos to cover the required atoms for this tokenId\n        if (typeof tokens !== 'undefined') {\n            // If we have tokens to handle\n            // (we always will if we are here, ts assertion issue)\n            const requiredTokenInputs = tokens.get(burnAllTokenId);\n            if (!requiredTokenInputs.needsMintBaton) {\n                // If we do not need a mint baton\n                // Then we no longer need utxos for this token\n                tokenIdsWithRequiredUtxos = tokenIdsWithRequiredUtxos.filter(tokenId => tokenId !== burnAllTokenId);\n            }\n            else {\n                // Otherwise we've only dealt with the atoms\n                requiredTokenInputs.atoms = 0n;\n            }\n        }\n    }\n    // If this tx is ONLY a burn all tx, we may have enough already\n    if (typeof groupTokenId === 'undefined') {\n        // Make sure this is not an NFT mint tx\n        if ((selectedUtxosSats >= sats ||\n            satsStrategy === SatsSelectionStrategy.NO_SATS) &&\n            tokenIdsWithRequiredUtxos.length === 0) {\n            // If selectedUtxos fulfill the requirements of this Action, return them\n            return {\n                success: true,\n                utxos: selectedUtxos,\n                // Only expected to be > 0n if satsStrategy is NO_SATS\n                missingSats: selectedUtxosSats >= sats ? 0n : sats - selectedUtxosSats,\n            };\n        }\n    }\n    for (const utxo of spendableUtxos) {\n        if ('token' in utxo && typeof utxo.token !== 'undefined') {\n            // If this is a token utxo\n            if (tokenIdsWithRequiredUtxos.includes(utxo.token.tokenId)) {\n                // If we have remaining requirements for a utxo with this tokenId\n                // to complete this user-specified Action\n                const requiredTokenInputsThisToken = tokens.get(utxo.token.tokenId);\n                if (utxo.token.isMintBaton &&\n                    requiredTokenInputsThisToken.needsMintBaton) {\n                    // If this is a mint baton and we need a mint baton, add this utxo to selectedUtxos\n                    selectedUtxos.push(utxo);\n                    selectedUtxosSats += utxo.sats;\n                    // Now we no longer need a mint baton\n                    requiredTokenInputsThisToken.needsMintBaton = false;\n                    if (requiredTokenInputsThisToken.atoms === 0n &&\n                        !requiredTokenInputsThisToken.needsMintBaton) {\n                        // If we no longer require any utxos for this tokenId,\n                        // remove it from tokenIdsWithRequiredUtxos\n                        tokenIdsWithRequiredUtxos =\n                            tokenIdsWithRequiredUtxos.filter(tokenId => tokenId !== utxo.token.tokenId);\n                    }\n                    // Return utxos if we have enough\n                    if ((selectedUtxosSats >= sats ||\n                        satsStrategy === SatsSelectionStrategy.NO_SATS) &&\n                        tokenIdsWithRequiredUtxos.length === 0) {\n                        return {\n                            success: true,\n                            utxos: selectedUtxos,\n                            // Only expected to be > 0n if satsStrategy is NO_SATS\n                            missingSats: selectedUtxosSats >= sats\n                                ? 0n\n                                : sats - selectedUtxosSats,\n                        };\n                    }\n                }\n                else if (!utxo.token.isMintBaton &&\n                    requiredTokenInputsThisToken.atoms > 0n) {\n                    // If this is a token utxo and we need atoms, add this utxo to selectedUtxos\n                    selectedUtxos.push(utxo);\n                    selectedUtxosSats += utxo.sats;\n                    // We now require fewer atoms of this tokenId. Update.\n                    const requiredAtomsRemainingThisToken = (requiredTokenInputsThisToken.atoms -=\n                        utxo.token.atoms);\n                    // Update required atoms remaining for this token\n                    requiredTokenInputsThisToken.atoms =\n                        requiredAtomsRemainingThisToken > 0n\n                            ? requiredAtomsRemainingThisToken\n                            : 0n;\n                    if (requiredTokenInputsThisToken.atoms === 0n &&\n                        !requiredTokenInputsThisToken.needsMintBaton) {\n                        // If we no longer require utxos for this tokenId,\n                        // remove tokenId from tokenIdsWithRequiredUtxos\n                        tokenIdsWithRequiredUtxos =\n                            tokenIdsWithRequiredUtxos.filter(tokenId => tokenId !== utxo.token.tokenId);\n                    }\n                    if ((selectedUtxosSats >= sats ||\n                        satsStrategy === SatsSelectionStrategy.NO_SATS) &&\n                        tokenIdsWithRequiredUtxos.length === 0) {\n                        // If selectedUtxos fulfill the requirements of this Action, return them\n                        return {\n                            success: true,\n                            utxos: selectedUtxos,\n                            // Only expected to be > 0n if satsStrategy is NO_SATS\n                            missingSats: selectedUtxosSats >= sats\n                                ? 0n\n                                : sats - selectedUtxosSats,\n                        };\n                    }\n                }\n            }\n            // Done processing token utxo, go the next utxo\n            // NB we DO NOT add any tokenUtxo to selectedUtxos unless there is\n            // a token-related need for it specified in the Action\n            continue;\n        }\n        if (satsStrategy === SatsSelectionStrategy.NO_SATS) {\n            // We do not need any fuel utxos if we are gasless\n            continue;\n        }\n        // For ATTEMPT_SATS and REQUIRE_SATS, we collect sats utxos\n        // ATTEMPT_SATS will return what we have even if incomplete\n        // REQUIRE_SATS will only return if we have enough\n        // If we have not returned selectedUtxos yet, we still need more sats\n        // So, add this utxo\n        selectedUtxos.push(utxo);\n        selectedUtxosSats += utxo.sats;\n        if (selectedUtxosSats >= sats &&\n            tokenIdsWithRequiredUtxos.length === 0 &&\n            !needsNftMintInput &&\n            !needsNftFanout) {\n            return {\n                success: true,\n                utxos: selectedUtxos,\n                // Always 0 here, determined by condition of this if block\n                missingSats: 0n,\n            };\n        }\n    }\n    // If we get here, we do not have sufficient utxos\n    const errors = [];\n    if (tokenIdsWithRequiredUtxos.length > 0) {\n        // Add human-readable error msg for missing token utxos\n        tokens?.forEach(requiredTokenInfo => {\n            requiredTokenInfo.error = `${requiredTokenInfo.needsMintBaton\n                ? `Missing mint baton`\n                : `Missing ${requiredTokenInfo.atoms} atom${requiredTokenInfo.atoms !== 1n ? 's' : ''}`}`;\n        });\n        const tokenErrorMsg = [];\n        // Sort by tokenId to ensure consistent order\n        const sortedTokenIds = Array.from(tokens.keys()).sort();\n        sortedTokenIds.forEach(tokenId => {\n            const requiredTokenInfo = tokens.get(tokenId);\n            tokenErrorMsg.push(` ${tokenId} => ${requiredTokenInfo.error}`);\n        });\n        errors.push(`Missing required token utxos:${tokenErrorMsg.join(',')}`);\n        // Missing tokens always cause failure, regardless of strategy\n        return {\n            success: false,\n            missingTokens: tokens,\n            missingSats: selectedUtxosSats >= sats ? 0n : sats - selectedUtxosSats,\n            errors,\n        };\n    }\n    if (needsNftMintInput || needsNftFanout) {\n        // Special case where user wants to mint an NFT but lacks any inputs\n        const missingTokensCustom = new Map();\n        missingTokensCustom.set(groupTokenId, {\n            atoms: 1n,\n            needsMintBaton: false,\n        });\n        return {\n            success: false,\n            missingTokens: missingTokensCustom,\n            missingSats: selectedUtxosSats >= sats ? 0n : sats - selectedUtxosSats,\n            errors: needsNftMintInput\n                ? [\n                    `Missing SLP_TOKEN_TYPE_NFT1_GROUP input for groupTokenId ${groupTokenId}`,\n                ]\n                : [\n                    `Missing qty-1 SLP_TOKEN_TYPE_NFT1_GROUP input for groupTokenId ${groupTokenId}. You must split your qty-${nftMintInput?.token?.atoms} input into qty-1 inputs.`,\n                ],\n        };\n    }\n    const missingSats = selectedUtxosSats >= sats ? 0n : sats - selectedUtxosSats;\n    if (missingSats > 0n) {\n        errors.push(`Insufficient sats to complete tx. Need ${missingSats} additional satoshis to complete this Action.`);\n    }\n    if (satsStrategy === SatsSelectionStrategy.REQUIRE_SATS) {\n        return {\n            success: false,\n            missingSats,\n            errors,\n        };\n    }\n    // For ATTEMPT_SATS and NO_SATS strategies, return what we have even if incomplete\n    // Do not include errors field for missing sats if returning success\n    return {\n        success: true,\n        utxos: selectedUtxos,\n        missingSats,\n        // NB we do not have errors for missingSats with these strategies\n    };\n};\nexports.selectUtxos = selectUtxos;\n/**\n * ecash-wallet only supports one token type per action (for now)\n * - We could support multiple ALP types in one tx, if and when we have multiple ALP types\n * - We could support multiple types in multiple txs. Support for multiple txs is planned.\n * Parse tokenActions for tokenType\n *\n * TODO (own diff) will need special handling (i.e. multiple token types) for minting of SLP NFT1\n *\n * Returns TokenType of the token associated with this action, if action is valid\n * Throws if action specifies more than one TokenType in a single tx\n * Returns undefined for non-token tx\n */\nconst getTokenType = (action) => {\n    let tokenType;\n    const { tokenActions } = action;\n    if (typeof tokenActions == 'undefined' || tokenActions.length === 0) {\n        // If no tokenActions are specified\n        return tokenType;\n    }\n    const genesisAction = action.tokenActions?.find(action => action.type === 'GENESIS');\n    if (typeof genesisAction !== 'undefined') {\n        // We have specified token actions\n        // Genesis txs must specify a token type in the token action\n        // Parse for this\n        tokenType = genesisAction.tokenType;\n    }\n    // Confirm no other token types are specified\n    for (const action of tokenActions) {\n        if ('tokenType' in action && typeof action.tokenType !== 'undefined') {\n            // If this is a token action (i.e. NOT a data action)\n            if (typeof tokenType === 'undefined') {\n                // If we have not yet defined tokenType, define it\n                tokenType = action.tokenType;\n            }\n            else {\n                // If we have defined tokenType, verify we do not have multiple tokenTypes\n                if (tokenType.type !== action.tokenType.type) {\n                    throw new Error(`Action must include only one token type. Found (at least) two: ${tokenType.type} and ${action.tokenType.type}.`);\n                }\n            }\n        }\n        // NB we do not expect to find tokenType in a data action\n    }\n    return tokenType;\n};\nexports.getTokenType = getTokenType;\n// Convert user-specified ecash-wallet Output[] to TxOutput[], so we can build\n// and sign the tx that fulfills this Action\nconst paymentOutputsToTxOutputs = (outputs, dustSats) => {\n    const txBuilderOutputs = [];\n    for (const output of outputs) {\n        txBuilderOutputs.push({\n            sats: output.sats ?? dustSats,\n            script: output.script,\n        });\n    }\n    return txBuilderOutputs;\n};\nexports.paymentOutputsToTxOutputs = paymentOutputsToTxOutputs;\n/**\n * finalizeOutputs\n *\n * Accept user-specified outputs and prepare them for network broadcast\n * - Parse and validate token inputs and outputs according to relevant token spec\n * - Add token change outputs to fulfill user SEND and/or BURN instructions\n * - Build OP_RETURN to fulfill intended user action per token spec\n * - Validate outputs for token and non-token actions\n * - Convert user-specified ecash-wallet PaymentOutput[] into TxBuilderOutput[] ready for signing/broadcast\n *\n * SLP_TOKEN_TYPE_FUNGIBLE\n * - May only have 1 mint quantity and it must be at outIdx 1\n * - May only have 1 mint baton and it must be at outIdx >= 2 and <= 0xff (255)\n * - All send outputs must be at 1<=outIdx<=19\n *\n * SLP_TOKEN_TYPE_NFT1_GROUP is the same spec rules as SLP_TOKEN_TYPE_FUNGIBLE except different type byte\n * Will have some distinctions added when we support SLP_TOKEN_TYPE_NFT1_CHILD\n *\n * SLP spec rules prevent exceeding 223 bytes in the OP_RETURN. So, even if this\n * limit increase in future, SLP txs will be the same.\n *\n * ALP_TOKEN_TYPE_STANDARD\n * MINT or GENESIS\n * - May have n mint quantities\n * - May have n mint batons, but must be consecutive and have higher index than qty outputs\n * - With current 223-byte OP_RETURN limit, no indices higher than 29\n * SEND\n * - All send outputs must be at 1<=outIdx<=29\n * - We cannot have SEND and MINT for the same tokenId\n * - We cannot have more than one genesis\n *\n * Assumptions\n * - Only one token type per tx\n * - We do not support SLP intentional burns\n * - We do not support ALP combined MINT / BURN txs\n *\n * Returns: The action outputs. The script field of each output will be set if\n * the address was specified.\n */\nconst finalizeOutputs = (action, requiredUtxos, changeScript, dustSats = ecash_lib_1.DEFAULT_DUST_SATS) => {\n    // Make a deep copy of outputs to avoid mutating the action object\n    const outputs = action.outputs.map(output => ({ ...output }));\n    const tokenActions = action.tokenActions;\n    if (outputs.length === 0) {\n        throw new Error(`No outputs specified. All actions must have outputs.`);\n    }\n    // Convert any address fields to script fields before processing\n    for (let i = 0; i < outputs.length; i++) {\n        const output = outputs[i];\n        if ('address' in output && output.address) {\n            // Convert from address variant to script variant of the union type\n            const { address, ...restOfOutput } = output;\n            outputs[i] = {\n                ...restOfOutput,\n                script: ecash_lib_1.Script.fromAddress(address),\n            };\n        }\n    }\n    // We do not support manually-specified leftover outputs\n    // ecash-wallet automatically includes a leftover output\n    // We may add support for manually specifying NO leftover, but probably not\n    const leftoverOutputArr = outputs.filter(output => 'bytecode' in output);\n    if (leftoverOutputArr.length > 0) {\n        throw new Error(`ecash-wallet automatically includes a leftover output. Do not specify a leftover output in the outputs array.`);\n    }\n    const tokenType = (0, exports.getTokenType)(action);\n    const isTokenTx = typeof tokenType !== 'undefined';\n    // Check for data actions\n    const dataActions = tokenActions?.filter(action => action.type === 'DATA');\n    if (dataActions && dataActions.length > 0) {\n        // Data actions are only supported for ALP_TOKEN_TYPE_STANDARD token actions\n        // Users who want straight-up EMPP in a tx or straight-up OP_RETURN do not include\n        // DataAction in tokenActions, but instead specify their OP_RETURN output\n        if (tokenType?.type !== 'ALP_TOKEN_TYPE_STANDARD') {\n            throw new Error(`Data actions are only supported for ALP_TOKEN_TYPE_STANDARD token actions.`);\n        }\n    }\n    // We can have only 1 OP_RETURN output\n    // A non-token tx must specify OP_RETURN output manually\n    // A token tx must specify a blank OP_RETURN output at index 0\n    const maxOpReturnOutputs = isTokenTx ? 0 : 1;\n    // Validate OP_RETURN (we can have only 1 that does not burn sats)\n    const opReturnArr = outputs.filter(output => 'script' in output &&\n        typeof output.script !== 'undefined' &&\n        output.script.bytecode[0] === ecash_lib_1.OP_RETURN);\n    if (opReturnArr.length > maxOpReturnOutputs) {\n        const opReturnErrMsg = isTokenTx\n            ? `A token tx cannot specify any manual OP_RETURN outputs. Token txs can only include a blank OP_RETURN output (i.e. { sats: 0n} at index 0.`\n            : `ecash-wallet only supports 1 OP_RETURN per tx. ${opReturnArr.length} OP_RETURN outputs specified.`;\n        throw new Error(opReturnErrMsg);\n    }\n    else if (opReturnArr.length === 1) {\n        const opReturnSats = opReturnArr[0].sats;\n        // If we have exactly 1 OP_RETURN, validate we do not burn sats\n        if (opReturnSats !== 0n) {\n            throw new Error(`Tx burns ${opReturnSats} satoshis in OP_RETURN output. ecash-wallet does not support burning XEC in the OP_RETURN.`);\n        }\n    }\n    if (typeof tokenType === 'undefined') {\n        // If this is a non-token tx, i.e. there are no token inputs or outputs\n        // Make sure we DO NOT have a blank OP_RETURN output\n        const blankOpReturnOutput = outputs.filter(output => Object.keys(output).length === 1 &&\n            'sats' in output &&\n            output.sats === 0n);\n        if (blankOpReturnOutput.length > 0) {\n            throw new Error(`A blank OP_RETURN output (i.e. {sats: 0n}) is not allowed in a non-token tx.`);\n        }\n        // For this case, validation is finished\n        return (0, exports.paymentOutputsToTxOutputs)(outputs, dustSats);\n    }\n    // Everything below is for token txs\n    if (typeof tokenActions === 'undefined' || tokenActions.length === 0) {\n        // If we have implied token action by outputs but not token actions are specified\n        throw new Error(`Specified outputs imply token actions, but no tokenActions specified.`);\n    }\n    // Validate actions\n    (0, exports.validateTokenActions)(tokenActions);\n    if (tokenType.protocol === 'SLP') {\n        // SLP tokens may have only one token action\n        // We have a kind of exception for minting SLP NFTs, where we must consume / burn a Parent token to mint a child\n        // But ecash-wallet treats this as one action, since it is a unique case\n        if (tokenActions.length > 1) {\n            // And we have more than 1 tokenAction specified\n            throw new Error(`${tokenType.type} token txs may only have a single token action. ${tokenActions.length} tokenActions specified.`);\n        }\n    }\n    // NB we have already validated that, if GenesisAction exists, it is at index 0\n    const genesisAction = tokenActions.find(action => action.type === 'GENESIS');\n    const genesisActionOutputs = outputs.filter((o) => 'tokenId' in o &&\n        o.tokenId === ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER);\n    if (genesisActionOutputs.length > 0 &&\n        typeof genesisAction === 'undefined') {\n        throw new Error(`Genesis outputs specified without GenesisAction. Must include GenesisAction or remove genesis outputs.`);\n    }\n    /**\n     * ALP\n     * - We can have multiple mint actions (but each must be for a different tokenId)\n     * SLP\n     * - We can have ONLY ONE mint action\n     */\n    const mintActionTokenIds = new Set(tokenActions\n        .filter(action => action.type === 'MINT')\n        .map(action => action.tokenId));\n    const invalidMintBatonOutputs = outputs.filter((output) => 'isMintBaton' in output &&\n        output.isMintBaton &&\n        'atoms' in output &&\n        output.atoms !== 0n);\n    if (invalidMintBatonOutputs.length > 0) {\n        throw new Error(`Mint baton outputs must have 0 atoms. Found ${invalidMintBatonOutputs.length} mint baton output${invalidMintBatonOutputs.length == 1 ? '' : 's'} with non-zero atoms.`);\n    }\n    /**\n     * ALP\n     * - We can have multiple burn actions (but each must be for a different tokenId)\n     * SLP\n     * - We can have ONLY ONE burn action\n     *\n     * Note that it is possible to have a burn action specified with no specified outputs associated\n     * with this tokenId.\n     *\n     * For ALP, can also specify a SEND action with a BURN action, and no outputs, and finalizeOutputs\n     * will automatically size a change output to allow intentional burn of user-specified burnAtoms.\n     *\n     * This would be expected behavior for an intentional ALP or SLP burn of 100% of token inputs.\n     */\n    const burnActionTokenIds = new Set(tokenActions\n        .filter(action => action.type === 'BURN')\n        .map(action => action.tokenId));\n    // We identify SEND outputs from user specified SEND action\n    const sendActionTokenIds = new Set(tokenActions\n        .filter(action => action.type === 'SEND')\n        .map(action => action.tokenId));\n    /**\n     * Get all tokenIds associated with this Action from the Outputs\n     */\n    const tokenIdsThisAction = new Set(outputs\n        .filter(o => 'tokenId' in o &&\n        typeof o.tokenId !== 'undefined' &&\n        o.tokenId !== ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER)\n        .map(o => o.tokenId));\n    // Make sure we do not have any output-specified tokenIds that are not\n    // associated with any action\n    for (const tokenIdThisAction of tokenIdsThisAction) {\n        if (!sendActionTokenIds.has(tokenIdThisAction) &&\n            !burnActionTokenIds.has(tokenIdThisAction) &&\n            !mintActionTokenIds.has(tokenIdThisAction)) {\n            throw new Error(`Output-specified tokenId ${tokenIdThisAction} is not associated with any action. Please ensure that the tokenActions match the outputs specified in the action.`);\n        }\n    }\n    // Since this is a token Action, validate we have a blank OP_RETURN template output at outIdx 0\n    const indexZeroOutput = outputs[0];\n    const indexZeroOutputKeys = Object.keys(indexZeroOutput);\n    const hasIndexZeroOpReturnBlank = indexZeroOutputKeys.length === 1 && indexZeroOutputKeys[0] === 'sats';\n    if (!hasIndexZeroOpReturnBlank) {\n        throw new Error(`Token action requires a built OP_RETURN at index 0 of outputs, i.e. { sats: 0n }.`);\n    }\n    /**\n     * If this is a SEND or BURN tx, we (may) need to generate and add change outputs\n     *\n     * We need to calculate them to validate them, so we might as well do that here\n     *\n     * Because Action is an object and a param in this function, changes we make to the outputs array\n     * in Action will persist when this function is called in the class\n     */\n    /**\n     * If a token is\n     * - Sent AND burned\n     *   - We may need to calculate a change output that fulfills burnAtoms from BurnAction\n     * - Sent only\n     *   - We may need to calculate a change output based on available inputs that prevents\n     *     a token burn\n     *\n     * We may need to generate an output to fulfill the user-specified action\n     *\n     * If a token is\n     *\n     * - Burned only\n     * - Minted and burned\n     *\n     * Then we can only burn quantities that exactly match atoms of this token in the inputs\n     * We will not generate any outputs\n     */\n    // Get all tokenIds that are SENT and BURNED\n    const sendAndBurnActionTokenIds = new Set();\n    sendActionTokenIds.forEach(tokenId => {\n        if (burnActionTokenIds.has(tokenId)) {\n            sendAndBurnActionTokenIds.add(tokenId);\n        }\n    });\n    if (sendActionTokenIds.size > 0 || sendAndBurnActionTokenIds.size > 0) {\n        /**\n         * See if we need a token change output (or outputs, possibly, if ALP)\n         *\n         * Note that requiredUtxos is a generated value, so we do not expect\n         * the validation errors checked here\n         *\n         * It is expected to have >= atoms needed for any SEND or BURN action\n         */\n        // Possible user specifies a burn for a tokenId with no specified SEND outputs\n        // We need to iterate over all tokenIds that are SENT or BURNed\n        const sendOrSendAndBurnTokens = new Set([\n            ...sendActionTokenIds,\n            ...sendAndBurnActionTokenIds,\n        ]);\n        sendOrSendAndBurnTokens.forEach(tokenId => {\n            const availableUtxosThisToken = requiredUtxos.filter(utxo => 'token' in utxo && utxo.token?.tokenId === tokenId);\n            const inputAtomsThisToken = availableUtxosThisToken\n                .map(utxo => utxo.token.atoms)\n                .reduce((prev, curr) => prev + curr, 0n);\n            const outputsThisToken = outputs.filter(output => 'tokenId' in output && output.tokenId === tokenId);\n            const outputAtomsThisToken = outputsThisToken\n                .map(output => output.atoms)\n                .reduce((prev, curr) => prev + curr, 0n);\n            if (inputAtomsThisToken < outputAtomsThisToken) {\n                // Not expected to happen in ecash-wallet, as we only call finalizeOutputs with\n                // calculated requiredUtxos\n                throw new Error(`Insufficient atoms of ${tokenId} in inputs (${inputAtomsThisToken}) to cover atoms specified in outputs ${outputAtomsThisToken}`);\n            }\n            if (inputAtomsThisToken >= outputAtomsThisToken) {\n                // We may need a change output. Check for intentionalBurns\n                let intentionalBurnAtomsThisToken = 0n;\n                if (sendAndBurnActionTokenIds.has(tokenId)) {\n                    // We have burn atoms for this token\n                    intentionalBurnAtomsThisToken = tokenActions.find(burnAction => burnAction.tokenId ===\n                        tokenId && 'burnAtoms' in burnAction).burnAtoms;\n                }\n                if (outputAtomsThisToken >\n                    inputAtomsThisToken - intentionalBurnAtomsThisToken) {\n                    // If the user has specified \"too many\" output atoms of a token he wishes to burn\n                    // NB we do not expect this to happen in ecash-wallet usage as the inputs will be\n                    // calculated to support the burnAction\n                    throw new Error(`Cannot process burn action for ${tokenId}: output atoms exceed input atoms less burn atoms.`);\n                }\n                const adjustedOutputAtomsThisToken = outputAtomsThisToken - intentionalBurnAtomsThisToken;\n                if (inputAtomsThisToken > adjustedOutputAtomsThisToken) {\n                    // We need a change output\n                    const changeAtoms = inputAtomsThisToken -\n                        outputAtomsThisToken -\n                        intentionalBurnAtomsThisToken;\n                    // NB adding a change output can make the tx invalid based on the outIdx of\n                    // the change output.\n                    // The change output will be added at the end of the outputs array\n                    // This approach preserves the outIdx of the user-specified outputs\n                    // We could attempt to do something like, only add token change outputs\n                    // at a valid outIdx, if available ... but this would get confusing\n                    // very fast, we do not want to change the outIdx of user-specified outputs\n                    // Just throw a specific error msg\n                    const changeOutputIdx = outputs.length;\n                    // Apply SLP or ALP max output rules\n                    const changeOutputIdxMax = tokenType.protocol === 'SLP'\n                        ? ecash_lib_1.SLP_MAX_SEND_OUTPUTS\n                        : ecash_lib_1.ALP_POLICY_MAX_OUTPUTS;\n                    if (changeOutputIdx > changeOutputIdxMax) {\n                        throw new Error(`Tx needs a token change output to avoid burning atoms of ${tokenId}, but the token change output would be at outIdx ${changeOutputIdx} which is greater than the maximum allowed outIdx of ${changeOutputIdxMax} for ${tokenType.type}.`);\n                    }\n                    // We add a token change output\n                    outputs.push({\n                        sats: dustSats,\n                        tokenId: tokenId,\n                        atoms: changeAtoms,\n                        isMintBaton: false,\n                        script: changeScript,\n                    });\n                }\n            }\n        });\n    }\n    /**\n     * Initialize a map to store lastAtomsOutIdx\n     * tokenId => lastAtomsOutIdx\n     *\n     * For SLP, can only ever have one tokenId\n     * For ALP, can have many\n     */\n    // tokenId => lastAtomsOutIdx\n    const lastAtomsOutIdxMap = new Map();\n    // tokenId => numBatons\n    // Only needed for ALP_TOKEN_TYPE_STANDARD\n    const numBatonsMap = new Map();\n    switch (tokenType.type) {\n        case 'SLP_TOKEN_TYPE_MINT_VAULT': {\n            /**\n             * Validate for tokenId(s) and actions\n             * - SLP SLP_TOKEN_TYPE_MINT_VAULT can have ONLY genesis or\n             *   ONLY send or ONLY mint, ONLY with a single tokenId\n             *\n             * NB ecash-wallet does not currently support MINT for SLP_TOKEN_TYPE_MINT_VAULT tokens\n             * This is handled in validateTokenActions\n             */\n            if (tokenIdsThisAction.size > 1) {\n                throw new Error(`An SLP SLP_TOKEN_TYPE_MINT_VAULT Action may only be associated with a single tokenId. Found ${tokenIdsThisAction.size}.`);\n            }\n            if (typeof genesisAction !== 'undefined' &&\n                tokenIdsThisAction.size !== 0) {\n                // If we have a genesis action and any other associated tokenIds\n                // NB this covers the case of attempting to combine GENESIS and BURN\n                throw new Error(`An SLP SLP_TOKEN_TYPE_MINT_VAULT Action with a specified genesisAction may not have any other associated token actions.`);\n            }\n            /**\n             * For an SLP SLP_TOKEN_TYPE_FUNGIBLE Action,\n             * if we have any send outputs, then we cannot have any other token outputs\n             * and we may ONLY have a burn action\n             */\n            if (sendActionTokenIds.size > 0 && mintActionTokenIds.size > 0) {\n                throw new Error(`An SLP SLP_TOKEN_TYPE_MINT_VAULT Action with SEND outputs may not have any MINT outputs.`);\n            }\n            /**\n             * Now that we have validated everything we can validate at the Action and\n             * Output level, iterate over outputs to validate for spec-related requirements\n             * related to output ordering and indices\n             *\n             * Spec\n             * https://github.com/badger-cash/slp-specifications/blob/master/slp-token-type-2.md\n             *\n             * - Mint qty must be at outIdx 1 for GENESIS txs (can be at 1 and more for MINT txs)\n             * - Mint txs are only valid if their blockheight is > genesis tx blockheight\n             * - No mint batons\n             */\n            for (let i = 0; i < outputs.length; i += 1) {\n                const output = outputs[i];\n                if ('tokenId' in output) {\n                    if (output.isMintBaton === true) {\n                        throw new Error(`An SLP SLP_TOKEN_TYPE_MINT_VAULT Action may not have any mint batons.`);\n                    }\n                    // If this is a token output\n                    if (i > ecash_lib_1.SLP_MAX_SEND_OUTPUTS) {\n                        /**\n                         * For an SLP SLP_TOKEN_TYPE_MINT_VAULT action, we cannot have\n                         * more than SLP_MAX_SEND_OUTPUTS (19) total token outputs\n                         *\n                         * We will support Actions with more than 19 outputs when we support\n                         * chained txs, but even in this case there are additional rules (i.e.\n                         * we would only support chained txs of sends, not mint or genesis)\n                         *\n                         * If the outIdx is higher than SLP_MAX_SEND_OUTPUTS, throw\n                         * NB we need to validate not just for max outputs, but also for max outIdx, this approach does both\n                         */\n                        throw new Error(`An SLP SLP_TOKEN_TYPE_MINT_VAULT Action may not have more than ${ecash_lib_1.SLP_MAX_SEND_OUTPUTS} token outputs, and no outputs may be at outIdx > ${ecash_lib_1.SLP_MAX_SEND_OUTPUTS}. Found output at outIdx ${i}.`);\n                    }\n                    if (sendActionTokenIds.has(output.tokenId)) {\n                        // If this is a token send output, update lastAtomsOutIdx map\n                        lastAtomsOutIdxMap.set(output.tokenId, i);\n                    }\n                }\n                if (i === 1) {\n                    // If we are at outIdx of 1\n                    if (typeof genesisAction !== 'undefined') {\n                        // If we have a genesis action specified\n                        if (!('tokenId' in output) ||\n                            output.tokenId !==\n                                ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER) {\n                            // Throw if output at outIdx 1 is NOT a genesis-related mint quantity output\n                            throw new Error(`Genesis action for SLP_TOKEN_TYPE_MINT_VAULT token specified, but no mint quantity output found at outIdx 1. This is a spec requirement for SLP SLP_TOKEN_TYPE_MINT_VAULT tokens.`);\n                        }\n                        // else continue to the next output, no further validation required\n                        continue;\n                    }\n                }\n                if (typeof genesisAction !== 'undefined' &&\n                    'tokenId' in output &&\n                    output.tokenId === ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER) {\n                    // Genesis tx cannot have any mint qty output other than the one at outIdx 1\n                    throw new Error(`An SLP SLP_TOKEN_TYPE_MINT_VAULT GENESIS tx may have only one mint qty output and it must be at outIdx 1. Found another mint qty output at outIdx ${i}.`);\n                }\n            }\n            break;\n        }\n        // Intentional fall through as SLP_TOKEN_TYPE_NFT1_GROUP tokens have same spec as SLP_TOKEN_TYPE_FUNGIBLE tokens\n        // Intentional fall through as SLP_TOKEN_TYPE_NFT1_CHILD tokens have same spec as SLP_TOKEN_TYPE_FUNGIBLE tokens\n        // There is a unique case where we burn exactly 1 SLP_TOKEN_TYPE_NFT1_GROUP, but that is handled in the inputs, needed for selecting utxos, only for minting a SLP_TOKEN_TYPE_NFT1_CHILD\n        // It is not technically a BURN action\n        case 'SLP_TOKEN_TYPE_NFT1_GROUP':\n        case 'SLP_TOKEN_TYPE_NFT1_CHILD':\n        case 'SLP_TOKEN_TYPE_FUNGIBLE': {\n            /**\n             * Valid\n             * - no token actions and no token outputs\n             * - no token actions and send outputs of a single tokenId ONLY\n             * - no token actions and burn outputs ONLY\n             * - MINT action only and no send outputs\n             * - GENESIS action only and no send outputs\n             */\n            // Flags to validate we DO NOT have more than one mint baton\n            let hasExtendedMintingMintBaton = false;\n            /**\n             * Validate for tokenId(s) and actions\n             * - SLP SLP_TOKEN_TYPE_FUNGIBLE can have ONLY genesis or\n             *   ONLY send or ONLY mint, ONLY with a single tokenId\n             */\n            if (tokenIdsThisAction.size > 1) {\n                throw new Error(`An SLP ${tokenType.type} Action may only be associated with a single tokenId. Found ${tokenIdsThisAction.size}.`);\n            }\n            if (typeof genesisAction !== 'undefined' &&\n                tokenIdsThisAction.size !== 0) {\n                // If we have a genesis action and any other associated tokenIds\n                // NB this covers the case of attempting to combine GENESIS and BURN\n                throw new Error(`An SLP ${tokenType.type} Action with a specified genesisAction may not have any other associated token actions.`);\n            }\n            /**\n             * For an SLP SLP_TOKEN_TYPE_FUNGIBLE Action,\n             * if we have any send outputs, then we cannot have any other token outputs\n             * and we may ONLY have a burn action\n             */\n            if (sendActionTokenIds.size > 0 && mintActionTokenIds.size > 0) {\n                throw new Error(`An SLP ${tokenType.type} Action with SEND outputs may not have any MINT outputs.`);\n            }\n            /**\n             * Now that we have validated everything we can validate at the Action and\n             * Output level, iterate over outputs to validate for spec-related requirements\n             * related to output ordering and indices\n             *\n             * For SLP SLP_TOKEN_TYPE_FUNGIBLE, mint qty and mint baton output validation is\n             * simplified by strict spec requirements\n             * - Mint qty must be at outIdx 1\n             * - Can only have 1 mint baton, must be at outIdx 2-255\n             */\n            for (let i = 0; i < outputs.length; i += 1) {\n                const output = outputs[i];\n                if ('tokenId' in output) {\n                    // If this is a token output\n                    if (i > ecash_lib_1.SLP_MAX_SEND_OUTPUTS) {\n                        /**\n                         * For an SLP SLP_TOKEN_TYPE_FUNGIBLE action, we cannot have\n                         * more than SLP_MAX_SEND_OUTPUTS (19) total token outputs\n                         *\n                         * We will support Actions with more than 19 outputs when we support\n                         * chained txs, but even in this case there are additional rules (i.e.\n                         * we would only support chained txs of sends, not mint or genesis)\n                         *\n                         * If the outIdx is higher than SLP_MAX_SEND_OUTPUTS, throw\n                         * NB we need to validate not just for max outputs, but also for max outIdx, this approach does both\n                         */\n                        throw new Error(`An SLP ${tokenType.type} Action may not have more than ${ecash_lib_1.SLP_MAX_SEND_OUTPUTS} token outputs, and no outputs may be at outIdx > ${ecash_lib_1.SLP_MAX_SEND_OUTPUTS}. Found output at outIdx ${i}.`);\n                    }\n                    if (sendActionTokenIds.has(output.tokenId)) {\n                        // If this is a token send output, update lastAtomsOutIdx map\n                        lastAtomsOutIdxMap.set(output.tokenId, i);\n                    }\n                }\n                if (i === 1) {\n                    // If we are at outIdx of 1\n                    if (typeof genesisAction !== 'undefined') {\n                        // If we have a genesis action specified\n                        if (!('tokenId' in output) ||\n                            output.tokenId !==\n                                ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER ||\n                            output.isMintBaton === true) {\n                            // Throw if output at outIdx 1 is NOT a genesis-related mint quantity output\n                            throw new Error(`Genesis action for ${tokenType.type} token specified, but no mint quantity output found at outIdx 1. This is a spec requirement for SLP ${tokenType.type} tokens.`);\n                        }\n                        // else continue to the next output, no further validation required\n                        continue;\n                    }\n                    else if (mintActionTokenIds.size > 0) {\n                        // If we have a non-genesis mint action implied by outputs\n                        if (!('tokenId' in output) ||\n                            !mintActionTokenIds.has(output.tokenId) ||\n                            output.isMintBaton === true) {\n                            // If the output at outIdx 1 for an SLP_TOKEN_TYPE_FUNGIBLE tx with a mint qty specified\n                            // is NOT a mint quantity output, throw\n                            // This is a spec requirement for SLP SLP_TOKEN_TYPE_FUNGIBLE tokens\n                            throw new Error(`Mint action for ${tokenType.type} token specified, but no mint quantity output found at outIdx 1. This is a spec requirement for SLP ${tokenType.type} tokens.`);\n                        }\n                        // If outIdx 1 is a mint qty output, no further validation required\n                        continue;\n                    }\n                }\n                if ('isMintBaton' in output && output.isMintBaton === true) {\n                    // NB that genesis txs and MINT txs both are limited to a single mint baton at outIdx 2-255\n                    if (hasExtendedMintingMintBaton) {\n                        // If this is the 2nd mint baton we have found, throw\n                        throw new Error(`An ${tokenType.type} ${typeof genesisAction !== 'undefined'\n                            ? 'GENESIS'\n                            : 'MINT'} tx may only specify exactly 1 mint baton. Found second mint baton at outIdx ${i}.`);\n                    }\n                    if (i < 2 || i > 255) {\n                        // If the outIdx of the mint baton is off spec, throw\n                        throw new Error(`An ${tokenType.type} ${typeof genesisAction !== 'undefined'\n                            ? 'GENESIS'\n                            : 'MINT'} tx mint baton, if present, must be at outIdx 2-255. Mint baton found at outIdx ${i}.`);\n                    }\n                    hasExtendedMintingMintBaton = true;\n                    continue;\n                }\n                if (('tokenId' in output &&\n                    !output.isMintBaton &&\n                    mintActionTokenIds.has(output.tokenId)) ||\n                    (typeof genesisAction !== 'undefined' &&\n                        'tokenId' in output &&\n                        output.tokenId ===\n                            ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER &&\n                        !output.isMintBaton)) {\n                    // Genesis tx and MINT tx cannot have any mint qty output other than the one at outIdx 1\n                    throw new Error(`An ${tokenType.type} ${typeof genesisAction !== 'undefined'\n                        ? 'GENESIS'\n                        : 'MINT'} tx may have only one mint qty output and it must be at outIdx 1. Found another mint qty output at outIdx ${i}.`);\n                }\n            }\n            break;\n        }\n        case 'ALP_TOKEN_TYPE_STANDARD': {\n            /**\n             * ALP_TOKEN_TYPE_STANDARD\n             *\n             * - May only have a single genesisAction\n             * - May not combine MINT and SEND actions for the same tokenId\n             * - May have multiple mint batons, but must be consecutive and have higher index than qty outputs\n             * - May have multiple mint quantities\n             * - For now, all outputs must be at outIdx 1 <= outIdx <= 29\n             */\n            /**\n             * For an ALP_TOKEN_TYPE_STANDARD Action,\n             * we cannot have SEND and MINT outputs for the same tokenId\n             */\n            if (sendActionTokenIds.size > 0 && mintActionTokenIds.size > 0) {\n                sendActionTokenIds.forEach(sentTokenId => {\n                    if (mintActionTokenIds.has(sentTokenId)) {\n                        throw new Error(`An ALP ALP_TOKEN_TYPE_STANDARD Action cannot have SEND and MINT outputs for the same tokenId. Found SEND and MINT outputs for tokenId ${sentTokenId}.`);\n                    }\n                });\n            }\n            // Flags for validating mint baton(s)\n            let lastOutputMintBatonTokenId;\n            const tokenIdsWithMintBatons = new Set();\n            for (let i = 0; i < outputs.length; i += 1) {\n                const output = outputs[i];\n                if ('tokenId' in output) {\n                    // If this is a token output\n                    if (i > ecash_lib_1.ALP_POLICY_MAX_OUTPUTS) {\n                        /**\n                         * For an ALP ALP_TOKEN_TYPE_STANDARD action, we cannot have\n                         * more than ALP_POLICY_MAX_OUTPUTS (29) total token outputs.\n                         *\n                         * This is the 1-tx limit given current OP_RETURN limit (223 bytes).\n                         *\n                         * We will support Actions with more than 29 outputs when we support\n                         * chained txs, but even in this case there are additional rules (i.e.\n                         * we will probably only support chained txs of sends, not mint or genesis)\n                         *\n                         * If the outIdx is higher than ALP_POLICY_MAX_OUTPUTS, throw\n                         * NB we need to validate not just for max outputs, but also for max outIdx, this approach does both\n                         */\n                        throw new Error(`An ALP ALP_TOKEN_TYPE_STANDARD Action may not have more than ${ecash_lib_1.ALP_POLICY_MAX_OUTPUTS} token outputs, and no outputs may be at outIdx > ${ecash_lib_1.ALP_POLICY_MAX_OUTPUTS}. Found output at outIdx ${i}.`);\n                    }\n                    if ('atoms' in output &&\n                        output.isMintBaton === false &&\n                        'tokenId' in output &&\n                        sendActionTokenIds.has(output.tokenId)) {\n                        // If this is a non-mint baton non-mint send output\n                        // Update lastAtomsOutIdx for this tokenId to this index\n                        lastAtomsOutIdxMap.set(output.tokenId, i);\n                    }\n                }\n                if ('isMintBaton' in output && output.isMintBaton === true) {\n                    // If the output is a mint baton\n                    // NB this also includes GENESIS mint batons\n                    const tokenIdThisOutput = 'tokenId' in output\n                        ? output.tokenId\n                        : ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER;\n                    const isFirstMintBatonThisTokenId = !tokenIdsWithMintBatons.has(tokenIdThisOutput);\n                    if (isFirstMintBatonThisTokenId) {\n                        // If this is the first mint baton for this tokenId,\n                        // set lastAtomsOutIdx for this tokenId to i-1\n                        lastAtomsOutIdxMap.set(tokenIdThisOutput, i - 1);\n                        // Initialize batons map\n                        numBatonsMap.set(tokenIdThisOutput, 1);\n                    }\n                    else {\n                        // If this is NOT the first mint baton if this tokenId, then it must\n                        // be part of a consecutive string of mint baton outputs of this tokenId\n                        if (lastOutputMintBatonTokenId !== tokenIdThisOutput) {\n                            // If the last mint baton was not for this tokenId, throw\n                            throw new Error(`An ALP ALP_TOKEN_TYPE_STANDARD Action may only have consecutive mint baton outputs for the same tokenId. Found non-consecutive mint baton output at outIdx ${i} for ${tokenIdThisOutput ===\n                                ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER\n                                ? `GENESIS action`\n                                : `tokenId ${tokenIdThisOutput}`}.`);\n                        }\n                        // Increment numBatonsMap\n                        numBatonsMap.set(tokenIdThisOutput, numBatonsMap.get(tokenIdThisOutput) + 1);\n                    }\n                    // Update flag\n                    lastOutputMintBatonTokenId = tokenIdThisOutput;\n                    tokenIdsWithMintBatons.add(tokenIdThisOutput);\n                    // Validation complete for this output, go to the next one\n                    continue;\n                }\n                if (('tokenId' in output &&\n                    mintActionTokenIds.has(output.tokenId) &&\n                    !output.isMintBaton) ||\n                    ('tokenId' in output &&\n                        output.tokenId ===\n                            ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER &&\n                        !output.isMintBaton)) {\n                    // If this is a mint qty output (MINT or GENESIS)\n                    const tokenIdThisOutput = 'tokenId' in output\n                        ? output.tokenId\n                        : ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER;\n                    if (tokenIdsWithMintBatons.has(tokenIdThisOutput)) {\n                        // If we have already seen mint batons for this tokenId, throw\n                        throw new Error(`For a given tokenId, an ALP ALP_TOKEN_TYPE_STANDARD Action may not have mint qty outputs at a higher outIdx than mint baton outputs. Mint qty output for ${tokenIdThisOutput ===\n                            ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER\n                            ? `GENESIS action`\n                            : `a tokenId`} with preceding mint batons found at outIdx ${i}.`);\n                    }\n                    // Update lastAtomsOutIdx for this tokenId\n                    lastAtomsOutIdxMap.set(tokenIdThisOutput, i);\n                    // NB we could validate atoms here, but this is validated by alp methods in ecash-lib\n                }\n                // Reset the lastOutputMintBatonTokenId flag for all outputs that are not mint batons\n                lastOutputMintBatonTokenId = undefined;\n            }\n            break;\n        }\n        default: {\n            throw new Error(`Unsupported tokenType ${tokenType.type}.`);\n        }\n    }\n    /**\n     * Validation complete and any generated outputs added to outputs array\n     * Now we can build the OP_RETURN\n     *\n     * We do it in this function because the same validation steps are required\n     * So, if we separate the function, it doesn't really work as a stand-alone\n     */\n    /**\n     * Required genesis info\n     *\n     * ALP\n     * atomsArray, numBatons\n     *\n     * SLP\n     * atoms\n     * mintBatonOutIdx\n     */\n    let opReturnScript;\n    switch (tokenType.type) {\n        case 'SLP_TOKEN_TYPE_MINT_VAULT': {\n            /**\n             * NB for SLP_TOKEN_TYPE_MINT_VAULT, lastAtomsOutIdx is only relevant for a send tx\n             * We do not need this info for genesis as there can be only one qty output\n             * We would need this info for MINT, but this is not yet supported\n             *\n             * NB for SLP_TOKEN_TYPE_MINT_VAULT, we expect only 1 or 0 entries in lastAtomsOutIdxMap\n             */\n            // GENESIS action mint qty, if applicable\n            let mintQuantity;\n            // We only expect 0 or 1 entries in lastAtomsKeyValueArr for SLP_TOKEN_TYPE_FUNGIBLE\n            const lastAtomsKeyValueArr = lastAtomsOutIdxMap\n                .entries()\n                .next().value;\n            const lastAtomsOutIdx = typeof lastAtomsKeyValueArr !== 'undefined'\n                ? lastAtomsKeyValueArr[1]\n                : undefined;\n            // Will only have one for SLP. Necessary for SEND.\n            // NB SLP MINT txs may only have 1 mint qty and 1 mint baton\n            const atomsArray = [];\n            // NB we start iterating at i=1 bc we do not have to do anything for the outIdx 0 OP_RETURN output\n            for (let i = 1; i < outputs.length; i += 1) {\n                const output = outputs[i];\n                if ('tokenId' in output) {\n                    if (sendActionTokenIds.has(output.tokenId)) {\n                        // If this is a token SEND output, we must add its atoms to the atomsArray\n                        // NB for SLP_TOKEN_TYPE_FUNGIBLE we only use atomsArray for SEND action\n                        atomsArray.push(output.atoms);\n                    }\n                }\n                if ('tokenId' in output &&\n                    output.tokenId === ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER) {\n                    // If this is a mint qty output (GENESIS or MINT)\n                    mintQuantity = output.atoms;\n                }\n                if (atomsArray.length !== i &&\n                    i <= ecash_lib_1.SLP_MAX_SEND_OUTPUTS &&\n                    typeof lastAtomsOutIdx === 'number' &&\n                    i <= lastAtomsOutIdx) {\n                    // If we did not add atoms to atomsArray for this outIdx\n                    // AND we are still dealing with outIdx values that are associated\n                    // with SLP tokens\n                    // AND we still expect another outIdx associated with this token send later\n                    // THEN add 0n placeholder\n                    // NB we only use atomsArray for SLP SEND or BURN for SLP_TOKEN_TYPE_FUNGIBLE\n                    atomsArray.push(0n);\n                }\n            }\n            if (typeof mintQuantity !== 'undefined') {\n                // If we have a mint quantity (for SLP_TOKEN_TYPE_FUNGIBLE, this is required\n                // for all GENESIS and MINT actions)\n                if (typeof genesisAction !== 'undefined') {\n                    // If this is a GENESIS tx, build a GENESIS OP_RETURN\n                    opReturnScript = (0, ecash_lib_1.slpGenesis)(genesisAction.tokenType.number, genesisAction.genesisInfo, mintQuantity);\n                }\n            }\n            else if (burnActionTokenIds.size > 0) {\n                const burnAtoms = tokenActions[0]\n                    .burnAtoms;\n                opReturnScript = (0, ecash_lib_1.slpBurn)(tokenActions[0].tokenId, tokenType.number, burnAtoms);\n            }\n            else {\n                // SEND\n                opReturnScript = (0, ecash_lib_1.slpSend)(tokenActions[0].tokenId, tokenType.number, atomsArray);\n            }\n            // Write over the blank OP_RETURN output at index 0\n            outputs[0].script = opReturnScript;\n            break;\n        }\n        // Intentional fall through as SLP_TOKEN_TYPE_NFT1_GROUP tokens have same spec as SLP_TOKEN_TYPE_FUNGIBLE tokens\n        // Intentional fall through as SLP_TOKEN_TYPE_NFT1_CHILD tokens have same spec as SLP_TOKEN_TYPE_FUNGIBLE tokens\n        case 'SLP_TOKEN_TYPE_NFT1_GROUP':\n        case 'SLP_TOKEN_TYPE_NFT1_CHILD':\n        case 'SLP_TOKEN_TYPE_FUNGIBLE': {\n            /**\n             * NB for SLP_TOKEN_TYPE_FUNGIBLE, lastAtomsOutIdx is only relevant for a send tx\n             * We do not need this info for mint or genesis as there can be only one qty output\n             * and it must be at outIdx 1, and only 1 mint baton\n             *\n             * NB for SLP_TOKEN_TYPE_FUNGIBLE, we expect only 1 or 0 entries in lastAtomsOutIdxMap\n             */\n            // GENESIS or MINT action mint qty, if applicable\n            let mintQuantity;\n            // GENESIS or MINT action mint baton outIdx, if applicable\n            let mintBatonOutIdx;\n            // We only expect 0 or 1 entries in lastAtomsKeyValueArr for SLP_TOKEN_TYPE_FUNGIBLE\n            const lastAtomsKeyValueArr = lastAtomsOutIdxMap\n                .entries()\n                .next().value;\n            const lastAtomsOutIdx = typeof lastAtomsKeyValueArr !== 'undefined'\n                ? lastAtomsKeyValueArr[1]\n                : undefined;\n            // Will only have one for SLP. Necessary for SEND.\n            // NB SLP MINT txs may only have 1 mint qty and 1 mint baton\n            const atomsArray = [];\n            // NB we start iterating at i=1 bc we do not have to do anything for the outIdx 0 OP_RETURN output\n            for (let i = 1; i < outputs.length; i += 1) {\n                const output = outputs[i];\n                if ('tokenId' in output) {\n                    if (sendActionTokenIds.has(output.tokenId)) {\n                        // If this is a token SEND output, we must add its atoms to the atomsArray\n                        // NB for SLP_TOKEN_TYPE_FUNGIBLE we only use atomsArray for SEND action\n                        atomsArray.push(output.atoms);\n                    }\n                }\n                if (('tokenId' in output &&\n                    mintActionTokenIds.has(output.tokenId) &&\n                    !output.isMintBaton) ||\n                    ('tokenId' in output &&\n                        output.tokenId ===\n                            ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER &&\n                        !output.isMintBaton)) {\n                    // If this is a mint qty output (GENESIS or MINT)\n                    mintQuantity = output.atoms;\n                }\n                if ('isMintBaton' in output && output.isMintBaton === true) {\n                    // If this is a mint baton output (GENESIS or MINT)\n                    mintBatonOutIdx = i;\n                }\n                if (atomsArray.length !== i &&\n                    i <= ecash_lib_1.SLP_MAX_SEND_OUTPUTS &&\n                    typeof lastAtomsOutIdx === 'number' &&\n                    i <= lastAtomsOutIdx) {\n                    // If we did not add atoms to atomsArray for this outIdx\n                    // AND we are still dealing with outIdx values that are associated\n                    // with SLP tokens\n                    // AND we still expect another outIdx associated with this token send later\n                    // THEN add 0n placeholder\n                    // NB we only use atomsArray for SLP SEND or BURN for SLP_TOKEN_TYPE_FUNGIBLE\n                    atomsArray.push(0n);\n                }\n            }\n            if (typeof mintQuantity !== 'undefined') {\n                // If we have a mint quantity (for SLP_TOKEN_TYPE_FUNGIBLE, this is required\n                // for all GENESIS and MINT actions)\n                if (typeof genesisAction !== 'undefined') {\n                    // Validate quantity 1n for NFT genesis\n                    if (genesisAction.tokenType.type ===\n                        ecash_lib_1.SLP_TOKEN_TYPE_NFT1_CHILD.type) {\n                        // We validate that SLP_TOKEN_TYPE_NFT1_CHILD mints are only for qty 1n\n                        // NB chronik will also throw an error if this broadcasts as it fails token checks\n                        if (mintQuantity !== 1n) {\n                            throw new Error(`An SLP_TOKEN_TYPE_NFT1_CHILD GENESIS tx must have 1 atom at outIdx 1. Found ${mintQuantity} atoms.`);\n                        }\n                    }\n                    // If this is a GENESIS tx, build a GENESIS OP_RETURN\n                    opReturnScript = (0, ecash_lib_1.slpGenesis)(genesisAction.tokenType.number, genesisAction.genesisInfo, mintQuantity, \n                    // NB mintBatonOutIdx may be undefined, implying a genesis tx with no mint baton\n                    mintBatonOutIdx);\n                }\n                else {\n                    // This is a MINT tx\n                    opReturnScript = (0, ecash_lib_1.slpMint)(tokenActions[0]\n                        .tokenId, tokenType.number, mintQuantity, mintBatonOutIdx);\n                }\n            }\n            else if (burnActionTokenIds.size > 0) {\n                const burnAtoms = tokenActions[0]\n                    .burnAtoms;\n                opReturnScript = (0, ecash_lib_1.slpBurn)(tokenActions[0].tokenId, tokenType.number, burnAtoms);\n            }\n            else {\n                // SEND\n                opReturnScript = (0, ecash_lib_1.slpSend)(tokenActions[0].tokenId, tokenType.number, atomsArray);\n            }\n            // Write over the blank OP_RETURN output at index 0\n            outputs[0].script = opReturnScript;\n            break;\n        }\n        case 'ALP_TOKEN_TYPE_STANDARD': {\n            // ALP token txs may have multiple actions, each with its own EMPP push within emppScriptArr\n            // NB there may be only one GENESIS push and it must be at the beginning\n            // NB we have already validated for the condition of \"one genesis\"\n            const emppScriptArr = [];\n            // ALP txs may have multiple atomsArrays for multiple tokenIds\n            // ALP genesis tx also needs an atomsArray as ALP genesis supports multiple mint qtys and mint batons,\n            // unlike SLP genesis\n            // tokenId => atomsArray\n            const atomsArrayMap = new Map();\n            // Init atomsArrayMap with an empty array for each tokenId that will need an atomsArray in this tx\n            lastAtomsOutIdxMap.forEach((_lastAtomsOutIdx, tokenId) => {\n                atomsArrayMap.set(tokenId, []);\n            });\n            // Build atomsArray for each tokenId that needs one\n            for (let i = 0; i < outputs.length; i++) {\n                const output = outputs[i];\n                /**\n                 * Conditions to add a 0 to atoms array\n                 * - i < lastAtomsOutIdx for this tokenId\n                 * - output is not related to the tokenId of the atoms array\n                 */\n                atomsArrayMap.forEach((atomsArray, tokenId) => {\n                    if (i === 0) {\n                        // The atomsArrays do not require an input for index 0\n                        return;\n                    }\n                    const lastAtomsOutIdxThisTokenId = lastAtomsOutIdxMap.get(tokenId);\n                    if (i <= lastAtomsOutIdxThisTokenId) {\n                        // If we have not yet passed lastAtomsOutIdx for this tokenId\n                        if (tokenId === ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER &&\n                            'atoms' in output) {\n                            // If this is a genesis output and we are working with the genesis atomsArray\n                            // add atoms\n                            atomsArray.push(output.atoms);\n                        }\n                        else if ('tokenId' in output &&\n                            output.tokenId === tokenId) {\n                            // If this is a non-genesis token-associated output\n                            // and it is associated with this tokenId\n                            atomsArray.push(output.atoms);\n                        }\n                        else {\n                            // If this output should not be colored for this tokenId\n                            // but we are not yet to lasAtomsOutIdx, add 0n\n                            atomsArray.push(0n);\n                        }\n                    }\n                });\n            }\n            // Now we have all the atomsArray(s) we need\n            // Build the OP_RETURN\n            // Build the OP_RETURN in order of specified tokenActions\n            for (const action of tokenActions) {\n                const { type } = action;\n                switch (type) {\n                    case 'GENESIS': {\n                        const genesisEmppPush = (0, ecash_lib_1.alpGenesis)(genesisAction.tokenType.number, genesisAction.genesisInfo, {\n                            atomsArray: atomsArrayMap.get(ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER),\n                            numBatons: numBatonsMap.get(ecash_lib_1.payment.GENESIS_TOKEN_ID_PLACEHOLDER) ?? 0,\n                        });\n                        emppScriptArr.push(genesisEmppPush);\n                        break;\n                    }\n                    case 'SEND': {\n                        const { tokenId } = action;\n                        const thisAtomsArray = atomsArrayMap.get(tokenId);\n                        emppScriptArr.push((0, ecash_lib_1.alpSend)(tokenId, tokenType.number, thisAtomsArray));\n                        break;\n                    }\n                    case 'MINT': {\n                        const { tokenId } = action;\n                        const thisAtomsArray = atomsArrayMap.get(tokenId);\n                        emppScriptArr.push((0, ecash_lib_1.alpMint)(tokenId, tokenType.number, {\n                            atomsArray: thisAtomsArray,\n                            numBatons: numBatonsMap.get(tokenId) ?? 0,\n                        }));\n                        break;\n                    }\n                    case 'BURN': {\n                        // NB we have already handled atomsArray for case 'SEND' for actions that send and burn\n                        const { tokenId, burnAtoms } = action;\n                        emppScriptArr.push((0, ecash_lib_1.alpBurn)(tokenId, tokenType.number, burnAtoms));\n                        break;\n                    }\n                    case 'DATA': {\n                        // Add the arbitrary data as an EMPP push\n                        const { data } = action;\n                        emppScriptArr.push(data);\n                        break;\n                    }\n                    default: {\n                        // Should never happen as we have already validated actions\n                        throw new Error(`Unsupported token action type: ${type}.`);\n                    }\n                }\n            }\n            // Combine all ALP EMPP pushes into the OP_RETURN\n            opReturnScript = (0, ecash_lib_1.emppScript)(emppScriptArr);\n            const opReturnBytes = opReturnScript.bytecode.length;\n            if (opReturnBytes > ecash_lib_1.OP_RETURN_MAX_BYTES) {\n                throw new Error(`Specified action results in OP_RETURN of ${opReturnBytes} bytes, vs max allowed of ${ecash_lib_1.OP_RETURN_MAX_BYTES}.`);\n            }\n            // Write over the blank OP_RETURN output at index 0\n            outputs[0].script = opReturnScript;\n            break;\n        }\n        default: {\n            break;\n        }\n    }\n    return (0, exports.paymentOutputsToTxOutputs)(outputs, dustSats);\n};\nexports.finalizeOutputs = finalizeOutputs;\n/**\n * Punchlist\n *\n * [] New diff: UX of burning mint batons and associated regtest\n * [] New diff: support remaining token types\n * [] New diff: chained txs\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qiw2QkFBNkIsNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLDZCQUE2Qix5QkFBeUIsTUFBTSwwQ0FBMEMsRUFBRTtBQUN4RyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTLEtBQUssd0JBQXdCO0FBQ3pFLFNBQVM7QUFDVCxvREFBb0Qsd0JBQXdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGFBQWE7QUFDN0Y7QUFDQTtBQUNBLHNGQUFzRixhQUFhLDRCQUE0Qiw0QkFBNEI7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxnQkFBZ0IsTUFBTSxzQkFBc0I7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSSxVQUFVO0FBQzdJLGdFQUFnRSxvQkFBb0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsaURBQWlELHFCQUFxQjtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsZ0NBQWdDLG1CQUFtQixnREFBZ0Q7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixVQUFVO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUyxhQUFhLG9CQUFvQix3Q0FBd0MscUJBQXFCO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsUUFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csUUFBUSxtREFBbUQsaUJBQWlCLHNEQUFzRCxvQkFBb0IsTUFBTSxlQUFlO0FBQy9RO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0gsd0JBQXdCO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLGtDQUFrQyxtREFBbUQsaUNBQWlDLDJCQUEyQixFQUFFO0FBQzdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlMQUF5TCxFQUFFO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0IsNkRBQTZELHdCQUF3QjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQixnQ0FBZ0Msa0NBQWtDLG1EQUFtRCxpQ0FBaUMsMkJBQTJCLEVBQUU7QUFDclA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQixxR0FBcUcsZ0JBQWdCO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0IscUdBQXFHLGdCQUFnQjtBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCLEVBQUU7QUFDaEU7QUFDQSxzQ0FBc0MsOEVBQThFLEVBQUU7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQixFQUFFO0FBQ2hFO0FBQ0Esc0NBQXNDLGlGQUFpRixFQUFFO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQixFQUFFO0FBQzVEO0FBQ0Esa0NBQWtDLDJHQUEyRyxFQUFFO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlMQUFpTCxZQUFZO0FBQzdMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLG9DQUFvQyxtREFBbUQsbUNBQW1DLDJCQUEyQixFQUFFO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwTUFBME0sR0FBRyxNQUFNO0FBQ25OO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9NQUFvTTtBQUNwTTtBQUNBO0FBQ0EsMkNBQTJDLDZDQUE2QyxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySCxjQUFjO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsS0FBSztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlLDJCQUEyQixnQ0FBZ0M7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtd2FsbGV0L2Rpc3Qvc3JjL3dhbGxldC5qcz8xZDZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI1IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmluYWxpemVPdXRwdXRzID0gZXhwb3J0cy5wYXltZW50T3V0cHV0c1RvVHhPdXRwdXRzID0gZXhwb3J0cy5nZXRUb2tlblR5cGUgPSBleHBvcnRzLnNlbGVjdFV0eG9zID0gZXhwb3J0cy5TYXRzU2VsZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLmdldEFjdGlvblRvdGFscyA9IGV4cG9ydHMudmFsaWRhdGVUb2tlbkFjdGlvbnMgPSBleHBvcnRzLmdldE5mdENoaWxkR2VuZXNpc0lucHV0ID0gZXhwb3J0cy5nZXRUb2tlblV0eG9zV2l0aEV4YWN0QXRvbXMgPSBleHBvcnRzLldhbGxldCA9IHZvaWQgMDtcbmNvbnN0IGVjYXNoX2xpYl8xID0gcmVxdWlyZShcImVjYXNoLWxpYlwiKTtcbi8qKlxuICogV2FsbGV0XG4gKlxuICogSW1wbGVtZW50cyBhIG9uZS1hZGRyZXNzIGVDYXNoIChYRUMpIHdhbGxldFxuICogVXNlZnVsIGZvciBydW5uaW5nIGEgc2ltcGxlIGhvdCB3YWxsZXRcbiAqL1xuY2xhc3MgV2FsbGV0IHtcbiAgICBjb25zdHJ1Y3RvcihzaywgY2hyb25paykge1xuICAgICAgICB0aGlzLnNrID0gc2s7XG4gICAgICAgIHRoaXMuY2hyb25payA9IGNocm9uaWs7XG4gICAgICAgIHRoaXMuZWNjID0gbmV3IGVjYXNoX2xpYl8xLkVjYygpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWVzIGRlcml2ZWQgZnJvbSB0aGUgc2tcbiAgICAgICAgdGhpcy5wayA9IHRoaXMuZWNjLmRlcml2ZVB1YmtleShzayk7XG4gICAgICAgIHRoaXMucGtoID0gKDAsIGVjYXNoX2xpYl8xLnNoYVJtZDE2MCkodGhpcy5wayk7XG4gICAgICAgIHRoaXMuc2NyaXB0ID0gZWNhc2hfbGliXzEuU2NyaXB0LnAycGtoKHRoaXMucGtoKTtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gZWNhc2hfbGliXzEuQWRkcmVzcy5wMnBraCh0aGlzLnBraCkudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gQ29uc3RydWN0b3JzIGNhbm5vdCBiZSBhc3luYywgc28gd2UgbXVzdCBzeW5jKCkgdG8gZ2V0IHV0eG9zIGFuZCB0aXBIZWlnaHRcbiAgICAgICAgdGhpcy50aXBIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLnV0eG9zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBXYWxsZXRcbiAgICAgKiAtIFNldCB1dHhvcyB0byBsYXRlc3QgZnJvbSBjaHJvbmlrXG4gICAgICogLSBTZXQgdGlwSGVpZ2h0IHRvIGxhdGVzdCBmcm9tIGNocm9uaWtcbiAgICAgKlxuICAgICAqIE5CIHRoZSByZWFzb24gd2UgdXBkYXRlIHRpcEhlaWdodCB3aXRoIHN5bmMoKSBpc1xuICAgICAqIHRvIGRldGVybWluZSB3aGljaCAoaWYgYW55KSBjb2luYmFzZSB1dHhvc1xuICAgICAqIGFyZSBzcGVuZGFibGUgd2hlbiB3ZSBidWlsZCB0eHNcbiAgICAgKi9cbiAgICBhc3luYyBzeW5jKCkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHV0eG8gc2V0XG4gICAgICAgIGNvbnN0IHV0eG9zID0gKGF3YWl0IHRoaXMuY2hyb25pay5hZGRyZXNzKHRoaXMuYWRkcmVzcykudXR4b3MoKSkudXR4b3M7XG4gICAgICAgIC8vIEdldCB0aXBIZWlnaHQgb2YgbGFzdCBzeW5jKClcbiAgICAgICAgY29uc3QgdGlwSGVpZ2h0ID0gKGF3YWl0IHRoaXMuY2hyb25pay5ibG9ja2NoYWluSW5mbygpKS50aXBIZWlnaHQ7XG4gICAgICAgIC8vIE9ubHkgc2V0IGNocm9uaWstZGVwZW5kZW50IGZpZWxkcyBpZiB3ZSBnb3Qgbm8gZXJyb3JzXG4gICAgICAgIHRoaXMudXR4b3MgPSB1dHhvcztcbiAgICAgICAgdGhpcy50aXBIZWlnaHQgPSB0aXBIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgc3BlbmRhYmxlIFVUWE9zIG9ubHkgY29udGFpbmluZyBzYXRzIGFuZCBubyB0b2tlbnNcbiAgICAgKlxuICAgICAqIC0gQW55IHNwZW5kYWJsZSBjb2luYmFzZSBVVFhPIHdpdGhvdXQgdG9rZW5zXG4gICAgICogLSBBbnkgbm9uLWNvaW5iYXNlIFVUWE8gd2l0aG91dCB0b2tlbnNcbiAgICAgKi9cbiAgICBzcGVuZGFibGVTYXRzT25seVV0eG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51dHhvc1xuICAgICAgICAgICAgLmZpbHRlcih1dHhvID0+IHR5cGVvZiB1dHhvLnRva2VuID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdXR4by5pc0NvaW5iYXNlID09PSBmYWxzZSlcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5fc3BlbmRhYmxlQ29pbmJhc2VVdHhvcygpLmZpbHRlcih1dHhvID0+IHR5cGVvZiB1dHhvLnRva2VuID09PSAndW5kZWZpbmVkJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHNwZW5kYWJsZSB1dHhvc1xuICAgICAqL1xuICAgIHNwZW5kYWJsZVV0eG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51dHhvc1xuICAgICAgICAgICAgLmZpbHRlcih1dHhvID0+IHV0eG8uaXNDb2luYmFzZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMuX3NwZW5kYWJsZUNvaW5iYXNlVXR4b3MoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgc3BlbmRhYmxlIGNvaW5iYXNlIHV0eG9zXG4gICAgICogaS5lLiBjb2luYmFzZSB1dHhvcyB3aXRoIENPSU5CQVNFX01BVFVSSVRZIGNvbmZpcm1hdGlvbnNcbiAgICAgKi9cbiAgICBfc3BlbmRhYmxlQ29pbmJhc2VVdHhvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXR4b3MuZmlsdGVyKHV0eG8gPT4gdXR4by5pc0NvaW5iYXNlID09PSB0cnVlICYmXG4gICAgICAgICAgICB0aGlzLnRpcEhlaWdodCAtIHV0eG8uYmxvY2tIZWlnaHQgPj0gZWNhc2hfbGliXzEuQ09JTkJBU0VfTUFUVVJJVFkpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGNsYXNzIHRoYXQgc3VwcG9ydHMgYWN0aW9uLWZ1bGZpbGxpbmcgbWV0aG9kcyAgKi9cbiAgICBhY3Rpb24oXG4gICAgLyoqXG4gICAgICogVXNlci1zcGVjaWZpZWQgaW5zdHJ1Y3Rpb25zIGZvciBkZXNpcmVkIG9uLWNoYWluIGFjdGlvbihzKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFuIEFjdGlvbiBtYXkgdGFrZSBtb3JlIHRoYW4gMSB0eCB0byBmdWxmaWxsXG4gICAgICovXG4gICAgYWN0aW9uLCBcbiAgICAvKipcbiAgICAgKiBTdHJhdGVneSBmb3Igc2VsZWN0aW5nIHNhdG9zaGlzIGluIFVUWE8gc2VsZWN0aW9uXG4gICAgICogQGRlZmF1bHQgU2F0c1NlbGVjdGlvblN0cmF0ZWd5LlJFUVVJUkVfU0FUU1xuICAgICAqL1xuICAgIHNhdHNTdHJhdGVneSA9IFNhdHNTZWxlY3Rpb25TdHJhdGVneS5SRVFVSVJFX1NBVFMpIHtcbiAgICAgICAgcmV0dXJuIFdhbGxldEFjdGlvbi5mcm9tQWN0aW9uKHRoaXMsIGFjdGlvbiwgc2F0c1N0cmF0ZWd5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIFNjcmlwdFV0eG8gaW50byBhIFR4QnVpbGRlcklucHV0XG4gICAgICovXG4gICAgcDJwa2hVdHhvVG9CdWlsZGVySW5wdXQodXR4bywgc2lnaGFzaCA9IGVjYXNoX2xpYl8xLkFMTF9CSVAxNDMpIHtcbiAgICAgICAgLy8gU2lnbiBhbmQgcHJlcCB1dHhvcyBmb3IgZWNhc2gtbGliIGlucHV0c1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICAgICAgICBwcmV2T3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHR4aWQ6IHV0eG8ub3V0cG9pbnQudHhpZCxcbiAgICAgICAgICAgICAgICAgICAgb3V0SWR4OiB1dHhvLm91dHBvaW50Lm91dElkeCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpZ25EYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNhdHM6IHV0eG8uc2F0cyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2NyaXB0OiB0aGlzLnNjcmlwdCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25hdG9yeTogKDAsIGVjYXNoX2xpYl8xLlAyUEtIU2lnbmF0b3J5KSh0aGlzLnNrLCB0aGlzLnBrLCBzaWdoYXNoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3RhdGljIGNvbnN0cnVjdG9yIGZvciBzayBhcyBVaW50OEFycmF5XG4gICAgICovXG4gICAgc3RhdGljIGZyb21TayhzaywgY2hyb25paykge1xuICAgICAgICByZXR1cm4gbmV3IFdhbGxldChzaywgY2hyb25payk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHN0YXRpYyBjb25zdHJ1Y3RvciBmcm9tIG1uZW1vbmljXG4gICAgICpcbiAgICAgKiBOQiBlY2FzaC1saWIgbW5lbW9uaWNUb1NlZWQgZG9lcyBub3QgdmFsaWRhdGUgZm9yIGJpcDM5IG1uZW1vbmljc1xuICAgICAqIEFueSBzdHJpbmcgd2lsbCBiZSB3YWxsZXRpemVkXG4gICAgICovXG4gICAgc3RhdGljIGZyb21NbmVtb25pYyhtbmVtb25pYywgY2hyb25paykge1xuICAgICAgICBjb25zdCBzZWVkID0gKDAsIGVjYXNoX2xpYl8xLm1uZW1vbmljVG9TZWVkKShtbmVtb25pYyk7XG4gICAgICAgIGNvbnN0IG1hc3RlciA9IGVjYXNoX2xpYl8xLkhkTm9kZS5mcm9tU2VlZChzZWVkKTtcbiAgICAgICAgLy8gZWNhc2gtd2FsbGV0IFdhbGxldHMgYXJlIHRva2VuIGF3YXJlLCBzbyB3ZSB1c2UgdGhlIHRva2VuLWF3YXJlIGRlcml2YXRpb24gcGF0aFxuICAgICAgICBjb25zdCB4ZWNNYXN0ZXIgPSBtYXN0ZXIuZGVyaXZlUGF0aChlY2FzaF9saWJfMS5YRUNfVE9LRU5fQVdBUkVfREVSSVZBVElPTl9QQVRIKTtcbiAgICAgICAgY29uc3Qgc2sgPSB4ZWNNYXN0ZXIuc2Vja2V5KCk7XG4gICAgICAgIHJldHVybiBXYWxsZXQuZnJvbVNrKHNrLCBjaHJvbmlrKTtcbiAgICB9XG59XG5leHBvcnRzLldhbGxldCA9IFdhbGxldDtcbi8qKlxuICogUmV0dXJuIHRvdGFsIHF1YW50aXR5IG9mIHNhdG9zaGlzIGhlbGRcbiAqIGJ5IGFyYml0cmFyeSBhcnJheSBvZiB1dHhvc1xuICovXG5XYWxsZXQuc3VtVXR4b3NTYXRzID0gKHV0eG9zKSA9PiB7XG4gICAgcmV0dXJuIHV0eG9zXG4gICAgICAgIC5tYXAodXR4byA9PiB1dHhvLnNhdHMpXG4gICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHByZXYgKyBjdXJyLCAwbik7XG59O1xuLyoqXG4gKiBlQ2FzaCB0eChzKSB0aGF0IGZ1bGZpbGwocykgYW4gQWN0aW9uXG4gKi9cbmNsYXNzIFdhbGxldEFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iod2FsbGV0LCBhY3Rpb24sIHNlbGVjdFV0eG9zUmVzdWx0LCBhY3Rpb25Ub3RhbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgbmVlZCB0byBidWlsZCBhbmQgc2lnbiBhIHR4IHRvIGNvbmZpcm1cbiAgICAgICAgICogd2UgaGF2ZSBzdWZmaWNpZW50IGlucHV0c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2V0QnVpbHRUeCA9IChpbnB1dHMsIG91dHB1dHMsIGZlZVBlcktiLCBkdXN0U2F0cykgPT4ge1xuICAgICAgICAgICAgLy8gQ2FuIHlvdSBjb3ZlciB0aGUgdHggd2l0aG91dCBmdWVsVXR4b3M/XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4QnVpbGRlciA9IG5ldyBlY2FzaF9saWJfMS5UeEJ1aWxkZXIoe1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVjYXNoLXdhbGxldCBhbHdheXMgYWRkcyBhIGxlZnRvdmVyIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbLi4ub3V0cHV0cywgdGhpcy5fd2FsbGV0LnNjcmlwdF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc1R4ID0gdHhCdWlsZGVyLnNpZ24oe1xuICAgICAgICAgICAgICAgICAgICBmZWVQZXJLYixcbiAgICAgICAgICAgICAgICAgICAgZHVzdFNhdHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhTaXplID0gdGhpc1R4LnNlclNpemUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eEZlZSA9ICgwLCBlY2FzaF9saWJfMS5jYWxjVHhGZWUpKHR4U2l6ZSwgZmVlUGVyS2IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0U2F0cyA9IGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKGlucHV0ID0+IGlucHV0LmlucHV0LnNpZ25EYXRhLnNhdHMpXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwbik7XG4gICAgICAgICAgICAgICAgLy8gRG8geW91ciBpbnB1dHMgY292ZXIgb3V0cHV0U3VtICsgdHhGZWU/XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2F0cyA+PSB0aGlzLmFjdGlvblRvdGFsLnNhdHMgKyB0eEZlZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtaWdodFRoZXNlVXR4b3NXb3JrIC0tPiBub3cgd2UgaGF2ZSBjb25maXJtZWQgdGhleSB3aWxsIHdvcmtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsdFR4OiBuZXcgQnVpbHRUeCh0aGlzLl93YWxsZXQsIHRoaXNUeCwgZmVlUGVyS2IpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBpcyBleHBlY3RlZCBpZiB3ZSBkbyBub3QgaGF2ZSBlbm91Z2ggdXR4b3NcbiAgICAgICAgICAgICAgICAvLyBTbyBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dhbGxldCA9IHdhbGxldDtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIHRoaXMuc2VsZWN0VXR4b3NSZXN1bHQgPSBzZWxlY3RVdHhvc1Jlc3VsdDtcbiAgICAgICAgdGhpcy5hY3Rpb25Ub3RhbCA9IGFjdGlvblRvdGFsO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFjdGlvbih3YWxsZXQsIGFjdGlvbiwgc2F0c1N0cmF0ZWd5ID0gU2F0c1NlbGVjdGlvblN0cmF0ZWd5LlJFUVVJUkVfU0FUUykge1xuICAgICAgICBjb25zdCBzZWxlY3RVdHhvc1Jlc3VsdCA9ICgwLCBleHBvcnRzLnNlbGVjdFV0eG9zKShhY3Rpb24sIHdhbGxldC5zcGVuZGFibGVVdHhvcygpLCBzYXRzU3RyYXRlZ3kpO1xuICAgICAgICAvLyBOQiBhY3Rpb25Ub3RhbCBpcyBhbiBpbnRlcm1lZGlhdGUgdmFsdWUgY2FsY3VsYXRlZCBpbiBzZWxlY3RVdHhvc1xuICAgICAgICAvLyBTaW5jZSBpdCBpcyBkZXBlbmRlbnQgb24gYWN0aW9uIGFuZCBzcGVuZGFibGUgdXR4b3MsIHdlIGRvIG5vdCB3YW50IGl0XG4gICAgICAgIC8vIHRvIGJlIGEgc3RhbmRhbG9uZSBwYXJhbSBmb3Igc2VsZWN0VXR4b3NcbiAgICAgICAgLy8gV2UgbmVlZCBpdCBoZXJlIHRvIGdldCBzYXQgdG90YWxzIGZvciB0eCBidWlsZGluZ1xuICAgICAgICBjb25zdCBhY3Rpb25Ub3RhbCA9ICgwLCBleHBvcnRzLmdldEFjdGlvblRvdGFscykoYWN0aW9uKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFdhbGxldEFjdGlvbiB3aXRoIHRoZSBzYW1lIHdhbGxldCBhbmQgYWN0aW9uXG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0QWN0aW9uKHdhbGxldCwgYWN0aW9uLCBzZWxlY3RVdHhvc1Jlc3VsdCwgYWN0aW9uVG90YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCAoYnV0IGRvIG5vdCBicm9hZGNhc3QpIGFuIGVDYXNoIHR4IHRvIGhhbmRsZSB0aGVcbiAgICAgKiBhY3Rpb24gc3BlY2lmaWVkIGJ5IHRoZSBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogTkIgdGhhdCwgZm9yIG5vdywgd2Ugd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBjYW5ub3QgaGFuZGxlXG4gICAgICogYWxsIGluc3RydWN0aW9ucyBpbiBhIHNpbmdsZSB0eFxuICAgICAqL1xuICAgIGJ1aWxkKHNpZ2hhc2ggPSBlY2FzaF9saWJfMS5BTExfQklQMTQzKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdFV0eG9zUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5zZWxlY3RVdHhvc1Jlc3VsdC51dHhvcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0VXR4b3NSZXN1bHQubWlzc2luZ1NhdHMgPiAwbikge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBlcnJvcnMgZmllbGQgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgY29uc3RydWN0IGEgZ2VuZXJpYyBlcnJvclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0VXR4b3NSZXN1bHQuZXJyb3JzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RVdHhvc1Jlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnNlbGVjdFV0eG9zUmVzdWx0LmVycm9ycy5qb2luKCc7ICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBidWlsZCgpIG1ldGhvZCBvbmx5IHdvcmtzIGZvciB0aGUgUkVRVUlSRV9TQVRTIHN0cmF0ZWd5XG4gICAgICAgICAgICAvLyBUT0RPIGFkZCBhbm90aGVyIG1ldGhvZCB0byBoYW5kbGUgbWlzc2luZ1NhdHMgc2VsZWN0VXR4b3NcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IHNhdHMgdG8gY29tcGxldGUgdHguIE5lZWQgJHt0aGlzLnNlbGVjdFV0eG9zUmVzdWx0Lm1pc3NpbmdTYXRzfSBhZGRpdGlvbmFsIHNhdG9zaGlzIHRvIGNvbXBsZXRlIHRoaXMgQWN0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkVXR4b3MgPSB0aGlzLnNlbGVjdFV0eG9zUmVzdWx0LnV0eG9zO1xuICAgICAgICBjb25zdCBkdXN0U2F0cyA9IHRoaXMuYWN0aW9uLmR1c3RTYXRzIHx8IGVjYXNoX2xpYl8xLkRFRkFVTFRfRFVTVF9TQVRTO1xuICAgICAgICBjb25zdCBmZWVQZXJLYiA9IHRoaXMuYWN0aW9uLmZlZVBlcktiIHx8IGVjYXNoX2xpYl8xLkRFRkFVTFRfRkVFX1NBVFNfUEVSX0tCO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdGUgb3V0cHV0cyBBTkQgYWRkIHRva2VuLXJlcXVpcmVkIGdlbmVyYXRlZCBvdXRwdXRzXG4gICAgICAgICAqIGkuZS4gdG9rZW4gY2hhbmdlIG9yIGJ1cm4tYWRqdXN0ZWQgdG9rZW4gY2hhbmdlXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gKDAsIGV4cG9ydHMuZmluYWxpemVPdXRwdXRzKSh0aGlzLmFjdGlvbiwgc2VsZWN0ZWRVdHhvcywgdGhpcy5fd2FsbGV0LnNjcmlwdCwgZHVzdFNhdHMpO1xuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGV4YWN0IHV0eG9zIHdlIG5lZWQgZm9yIHRoaXMgdHggYnkgYnVpbGRpbmcgYW5kIHNpZ25pbmcgdGhlIHR4XG4gICAgICAgIGxldCBpbnB1dFNhdHMgPSBXYWxsZXQuc3VtVXR4b3NTYXRzKHNlbGVjdGVkVXR4b3MpO1xuICAgICAgICBjb25zdCBvdXRwdXRTYXRzID0gdGhpcy5hY3Rpb25Ub3RhbC5zYXRzO1xuICAgICAgICBsZXQgbmVlZHNBbm90aGVyVXR4byA9IGZhbHNlO1xuICAgICAgICBsZXQgdHhGZWU7XG4gICAgICAgIGNvbnN0IGZpbmFsaXplZElucHV0cyA9IHNlbGVjdGVkVXR4b3MubWFwKHV0eG8gPT4gdGhpcy5fd2FsbGV0LnAycGtoVXR4b1RvQnVpbGRlcklucHV0KHV0eG8sIHNpZ2hhc2gpKTtcbiAgICAgICAgLy8gQ2FuIHlvdSBjb3ZlciB0aGUgdHggd2l0aG91dCBmdWVsVXR4b3M/XG4gICAgICAgIGNvbnN0IGJ1aWx0VHhSZXN1bHQgPSB0aGlzLl9nZXRCdWlsdFR4KGZpbmFsaXplZElucHV0cywgb3V0cHV0cywgZmVlUGVyS2IsIGR1c3RTYXRzKTtcbiAgICAgICAgaWYgKGJ1aWx0VHhSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWx0VHhSZXN1bHQuYnVpbHRUeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRzQW5vdGhlclV0eG8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBuZWVkIG1vcmUgdXR4b3NcbiAgICAgICAgLy8gRnVlbCB1dHhvcyBhcmUgc3BlbmRhYmxlU2F0c1V0eG9zIHRoYXQgYXJlIG5vdCBhbHJlYWR5IGluY2x1ZGVkIGluIHNlbGVjdGVkVXR4b3NcbiAgICAgICAgY29uc3QgZnVlbFV0eG9zID0gdGhpcy5fd2FsbGV0XG4gICAgICAgICAgICAuc3BlbmRhYmxlU2F0c09ubHlVdHhvcygpXG4gICAgICAgICAgICAuZmlsdGVyKHNwZW5kYWJsZVNhdHNPbmx5VXR4byA9PiAhc2VsZWN0ZWRVdHhvcy5zb21lKHNlbGVjdGVkVXR4byA9PiBzZWxlY3RlZFV0eG8ub3V0cG9pbnQudHhpZCA9PT1cbiAgICAgICAgICAgIHNwZW5kYWJsZVNhdHNPbmx5VXR4by5vdXRwb2ludC50eGlkICYmXG4gICAgICAgICAgICBzZWxlY3RlZFV0eG8ub3V0cG9pbnQub3V0SWR4ID09PVxuICAgICAgICAgICAgICAgIHNwZW5kYWJsZVNhdHNPbmx5VXR4by5vdXRwb2ludC5vdXRJZHgpKTtcbiAgICAgICAgZm9yIChjb25zdCB1dHhvIG9mIGZ1ZWxVdHhvcykge1xuICAgICAgICAgICAgLy8gSWYgb3VyIGlucHV0cyBjb3ZlciBvdXIgb3V0cHV0cywgd2UgbWlnaHQgaGF2ZSBlbm91Z2hcbiAgICAgICAgICAgIC8vIEJ1dCB3ZSBkb24ndCByZWFsbHkga25vdyBzaW5jZSB3ZSBtdXN0IGNhbGN1bGF0ZSB0aGUgZmVlXG4gICAgICAgICAgICBsZXQgbWlnaHRUaGVzZVV0eG9zV29yayA9IGlucHV0U2F0cyA+PSBvdXRwdXRTYXRzO1xuICAgICAgICAgICAgaWYgKCFtaWdodFRoZXNlVXR4b3NXb3JrIHx8IG5lZWRzQW5vdGhlclV0eG8pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBrbm93IHRoZXNlIHV0eG9zIGFyZSBpbnN1ZmZpY2llbnQgdG8gY292ZXIgdGhlIHR4LCBhZGQgYSB1dHhvXG4gICAgICAgICAgICAgICAgaW5wdXRTYXRzICs9IHV0eG8uc2F0cztcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZWRJbnB1dHMucHVzaCh0aGlzLl93YWxsZXQucDJwa2hVdHhvVG9CdWlsZGVySW5wdXQodXR4bywgc2lnaGFzaCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIG1pZ2h0VGhlc2VVdHhvc1dvcmsgYXMgbm93IHdlIGhhdmUgYW5vdGhlciBpbnB1dFxuICAgICAgICAgICAgbWlnaHRUaGVzZVV0eG9zV29yayA9IGlucHV0U2F0cyA+IG91dHB1dFNhdHM7XG4gICAgICAgICAgICBpZiAobWlnaHRUaGVzZVV0eG9zV29yaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1aWx0VHhSZXN1bHQgPSB0aGlzLl9nZXRCdWlsdFR4KGZpbmFsaXplZElucHV0cywgb3V0cHV0cywgZmVlUGVyS2IsIGR1c3RTYXRzKTtcbiAgICAgICAgICAgICAgICBpZiAoYnVpbHRUeFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWlsdFR4UmVzdWx0LmJ1aWx0VHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZWVkc0Fub3RoZXJVdHhvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgcnVuIG91dCBvZiBhdmFpbGFibGVVdHhvcyB3aXRob3V0IHJldHVybmluZyBpbnB1dHMsIHdlIGNhbid0IGFmZm9yZCB0aGlzIHR4XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IHNhdG9zaGlzIGluIGF2YWlsYWJsZSB1dHhvcyAoJHtpbnB1dFNhdHN9KSB0byBjb3ZlciBvdXRwdXRzIG9mIHRoaXMgdHggKCR7b3V0cHV0U2F0c30pICsgZmVlJHt0eXBlb2YgdHhGZWUgIT09ICd1bmRlZmluZWQnID8gYCAoJHt0eEZlZX0pYCA6IGBgfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIHBvc3RhZ2UgdHJhbnNhY3Rpb24gdGhhdCBpcyBzdHJ1Y3R1cmFsbHkgdmFsaWQgYnV0IGZpbmFuY2lhbGx5IGluc3VmZmljaWVudFxuICAgICAqIFRoaXMgaXMgdXNlZCBmb3IgcG9zdGFnZSBzY2VuYXJpb3Mgd2hlcmUgZnVlbCBpbnB1dHMgd2lsbCBiZSBhZGRlZCBsYXRlclxuICAgICAqL1xuICAgIGJ1aWxkUG9zdGFnZShzaWdoYXNoID0gZWNhc2hfbGliXzEuQUxMX0FOWU9ORUNBTlBBWV9CSVAxNDMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0VXR4b3NSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLnNlbGVjdFV0eG9zUmVzdWx0LnV0eG9zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBlcnJvcnMgZmllbGQgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgY29uc3RydWN0IGEgZ2VuZXJpYyBlcnJvclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0VXR4b3NSZXN1bHQuZXJyb3JzICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RVdHhvc1Jlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLnNlbGVjdFV0eG9zUmVzdWx0LmVycm9ycy5qb2luKCc7ICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHNlbGVjdCByZXF1aXJlZCBVVFhPcyBmb3IgdGhpcyBBY3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRVdHhvcyA9IHRoaXMuc2VsZWN0VXR4b3NSZXN1bHQudXR4b3M7XG4gICAgICAgIGNvbnN0IGR1c3RTYXRzID0gdGhpcy5hY3Rpb24uZHVzdFNhdHMgfHwgZWNhc2hfbGliXzEuREVGQVVMVF9EVVNUX1NBVFM7XG4gICAgICAgIGNvbnN0IGZlZVBlcktiID0gdGhpcy5hY3Rpb24uZmVlUGVyS2IgfHwgZWNhc2hfbGliXzEuREVGQVVMVF9GRUVfU0FUU19QRVJfS0I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0ZSBvdXRwdXRzIEFORCBhZGQgdG9rZW4tcmVxdWlyZWQgZ2VuZXJhdGVkIG91dHB1dHNcbiAgICAgICAgICogaS5lLiB0b2tlbiBjaGFuZ2Ugb3IgYnVybi1hZGp1c3RlZCB0b2tlbiBjaGFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSAoMCwgZXhwb3J0cy5maW5hbGl6ZU91dHB1dHMpKHRoaXMuYWN0aW9uLCBzZWxlY3RlZFV0eG9zLCB0aGlzLl93YWxsZXQuc2NyaXB0LCBkdXN0U2F0cyk7XG4gICAgICAgIC8vIENyZWF0ZSBpbnB1dHMgd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ2hhc2hcbiAgICAgICAgY29uc3QgZmluYWxpemVkSW5wdXRzID0gc2VsZWN0ZWRVdHhvcy5tYXAodXR4byA9PiB0aGlzLl93YWxsZXQucDJwa2hVdHhvVG9CdWlsZGVySW5wdXQodXR4bywgc2lnaGFzaCkpO1xuICAgICAgICAvLyBDcmVhdGUgYSBQb3N0YWdlVHggKHN0cnVjdHVyYWxseSB2YWxpZCBidXQgZmluYW5jaWFsbHkgaW5zdWZmaWNpZW50KVxuICAgICAgICByZXR1cm4gbmV3IFBvc3RhZ2VUeCh0aGlzLl93YWxsZXQsIGZpbmFsaXplZElucHV0cywgb3V0cHV0cywgZmVlUGVyS2IsIGR1c3RTYXRzLCB0aGlzLmFjdGlvblRvdGFsKTtcbiAgICB9XG59XG5jbGFzcyBCdWlsdFR4IHtcbiAgICBjb25zdHJ1Y3Rvcih3YWxsZXQsIHR4LCBmZWVQZXJLYikge1xuICAgICAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgIHRoaXMudHggPSB0eDtcbiAgICAgICAgdGhpcy5mZWVQZXJLYiA9IGZlZVBlcktiO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eC5zZXJTaXplKCk7XG4gICAgfVxuICAgIGZlZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBlY2FzaF9saWJfMS5jYWxjVHhGZWUpKHRoaXMuc2l6ZSgpLCB0aGlzLmZlZVBlcktiKTtcbiAgICB9XG4gICAgYXN5bmMgYnJvYWRjYXN0KCkge1xuICAgICAgICAvLyBOQiB3ZSBnZXQgdGhlIHNhbWUgcmVzdWx0IGhlcmUgaWYgd2UgZG8gbm90IHVzZSB0b0hleFxuICAgICAgICAvLyBXZSB1c2UgdG9IZXggYmVjYXVzZSBpdCBzaW1wbGlmaWVzIGNyZWF0aW5nIGFuZCBzdG9yaW5nXG4gICAgICAgIC8vIG1vY2tzIGZvciBtb2NrLWNocm9uaWstY2xpZW50IGluIHRlc3RzXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl93YWxsZXQuY2hyb25pay5icm9hZGNhc3RUeCgoMCwgZWNhc2hfbGliXzEudG9IZXgpKHRoaXMudHguc2VyKCkpKTtcbiAgICB9XG59XG4vKipcbiAqIFBvc3RhZ2VUeCByZXByZXNlbnRzIGEgdHJhbnNhY3Rpb24gdGhhdCBpcyBzdHJ1Y3R1cmFsbHkgdmFsaWQgYnV0IGZpbmFuY2lhbGx5IGluc3VmZmljaWVudFxuICogSXQgY2FuIGJlIHVzZWQgZm9yIHBvc3RhZ2Ugc2NlbmFyaW9zIHdoZXJlIGZ1ZWwgaW5wdXRzIG5lZWQgdG8gYmUgYWRkZWQgbGF0ZXJcbiAqL1xuY2xhc3MgUG9zdGFnZVR4IHtcbiAgICBjb25zdHJ1Y3Rvcih3YWxsZXQsIGlucHV0cywgb3V0cHV0cywgZmVlUGVyS2IsIGR1c3RTYXRzLCBhY3Rpb25Ub3RhbCkge1xuICAgICAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmZlZVBlcktiID0gZmVlUGVyS2I7XG4gICAgICAgIHRoaXMuZHVzdFNhdHMgPSBkdXN0U2F0cztcbiAgICAgICAgdGhpcy5hY3Rpb25Ub3RhbCA9IGFjdGlvblRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgZnVlbCBpbnB1dHMgYW5kIGNyZWF0ZSBhIGJyb2FkY2FzdGFibGUgdHJhbnNhY3Rpb25cbiAgICAgKiBVc2VzIHRoZSBzYW1lIGZlZSBjYWxjdWxhdGlvbiBhcHByb2FjaCBhcyBidWlsZCgpIG1ldGhvZFxuICAgICAqL1xuICAgIGFkZEZ1ZWxBbmRTaWduKGZ1ZWxXYWxsZXQsIHNpZ2hhc2ggPSBlY2FzaF9saWJfMS5BTExfQklQMTQzKSB7XG4gICAgICAgIGNvbnN0IGZ1ZWxVdHhvcyA9IGZ1ZWxXYWxsZXQuc3BlbmRhYmxlU2F0c09ubHlVdHhvcygpO1xuICAgICAgICBpZiAoZnVlbFV0eG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBYRUMgVVRYT3MgYXZhaWxhYmxlIGluIGZ1ZWwgd2FsbGV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgd2l0aCBwb3N0YWdlIGlucHV0cyAodG9rZW4gVVRYT3Mgd2l0aCBpbnN1ZmZpY2llbnQgc2F0cylcbiAgICAgICAgY29uc3QgYWxsSW5wdXRzID0gWy4uLnRoaXMuaW5wdXRzXTtcbiAgICAgICAgbGV0IGlucHV0U2F0cyA9IGFsbElucHV0cy5yZWR1Y2UoKHN1bSwgaW5wdXQpID0+IHN1bSArIGlucHV0LmlucHV0LnNpZ25EYXRhLnNhdHMsIDBuKTtcbiAgICAgICAgY29uc3QgYmFzZU91dHB1dHMgPSBbLi4udGhpcy5vdXRwdXRzXTtcbiAgICAgICAgY29uc3Qgb3V0cHV0U2F0cyA9IGJhc2VPdXRwdXRzLnJlZHVjZSgoc3VtLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgIGlmICgnc2F0cycgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIG91dHB1dC5zYXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMG4pO1xuICAgICAgICAvLyBBZGQgYSBsZWZ0b3ZlciBvdXRwdXQgKGNoYW5nZSkgYXMganVzdCB0aGUgU2NyaXB0LCBub3Qge3NjcmlwdCwgc2F0c31cbiAgICAgICAgY29uc3Qgb3V0cHV0c1dpdGhDaGFuZ2UgPSBbXG4gICAgICAgICAgICAuLi5iYXNlT3V0cHV0cyxcbiAgICAgICAgICAgIGZ1ZWxXYWxsZXQuc2NyaXB0LCAvLyBUaGlzIHNpZ25hbHMgVHhCdWlsZGVyIHRvIGNhbGN1bGF0ZSBjaGFuZ2UgYW5kIGZlZVxuICAgICAgICBdO1xuICAgICAgICAvLyBUcnkgdG8gYnVpbGQgd2l0aCBqdXN0IHBvc3RhZ2UgaW5wdXRzIGZpcnN0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eEJ1aWxkZXIgPSBuZXcgZWNhc2hfbGliXzEuVHhCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGFsbElucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzV2l0aENoYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHggPSB0eEJ1aWxkZXIuc2lnbih7XG4gICAgICAgICAgICAgICAgZmVlUGVyS2I6IHRoaXMuZmVlUGVyS2IsXG4gICAgICAgICAgICAgICAgZHVzdFNhdHM6IHRoaXMuZHVzdFNhdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVpbHRUeChmdWVsV2FsbGV0LCBzaWduZWRUeCwgdGhpcy5mZWVQZXJLYik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gRXhwZWN0ZWQgLSBwb3N0YWdlIGlucHV0cyBhcmUgaW5zdWZmaWNpZW50XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIG5lZWQgZnVlbCBVVFhPc1xuICAgICAgICAvLyBBZGQgZnVlbCBVVFhPcyBvbmUgYnkgb25lIGFuZCB0cnkgdG8gYnVpbGQgYWZ0ZXIgZWFjaCBhZGRpdGlvblxuICAgICAgICBmb3IgKGNvbnN0IGZ1ZWxVdHhvIG9mIGZ1ZWxVdHhvcykge1xuICAgICAgICAgICAgaW5wdXRTYXRzICs9IGZ1ZWxVdHhvLnNhdHM7XG4gICAgICAgICAgICBhbGxJbnB1dHMucHVzaChmdWVsV2FsbGV0LnAycGtoVXR4b1RvQnVpbGRlcklucHV0KGZ1ZWxVdHhvLCBzaWdoYXNoKSk7XG4gICAgICAgICAgICAvLyBUcnkgdG8gYnVpbGQgd2l0aCBjdXJyZW50IGlucHV0c1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eEJ1aWxkZXIgPSBuZXcgZWNhc2hfbGliXzEuVHhCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBhbGxJbnB1dHMsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHNXaXRoQ2hhbmdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFR4ID0gdHhCdWlsZGVyLnNpZ24oe1xuICAgICAgICAgICAgICAgICAgICBmZWVQZXJLYjogdGhpcy5mZWVQZXJLYixcbiAgICAgICAgICAgICAgICAgICAgZHVzdFNhdHM6IHRoaXMuZHVzdFNhdHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWlsdFR4KGZ1ZWxXYWxsZXQsIHNpZ25lZFR4LCB0aGlzLmZlZVBlcktiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB0byBuZXh0IGZ1ZWwgVVRYT1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHJ1biBvdXQgb2YgZnVlbCBVVFhPcyB3aXRob3V0IHN1Y2Nlc3MsIHdlIGNhbid0IGFmZm9yZCB0aGlzIHR4XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGZ1ZWw6IGNhbm5vdCBjb3ZlciBvdXRwdXRzICgke291dHB1dFNhdHN9KSArIGZlZSB3aXRoIGF2YWlsYWJsZSBmdWVsIFVUWE9zICgke2lucHV0U2F0c30gdG90YWwgc2F0cylgKTtcbiAgICB9XG59XG4vKipcbiAqIEZpbmRzIGEgY29tYmluYXRpb24gb2YgVVRYT3MgZm9yIGEgZ2l2ZW4gdG9rZW5JZCB3aG9zZSBhdG9tcyBleGFjdGx5IHN1bSB0byBidXJuQXRvbXMuXG4gKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBVVFhPcyBvciB0aHJvd3MgYW4gZXJyb3IgaWYgbm8gZXhhY3QgbWF0Y2ggaXMgZm91bmQuXG4gKlxuICogQHBhcmFtIGF2YWlsYWJsZVV0eG9zIC0gQXJyYXkgb2YgVVRYT3MgdG8gc2VhcmNoIHRocm91Z2hcbiAqIEBwYXJhbSB0b2tlbklkIC0gVGhlIHRva2VuIElEIHRvIG1hdGNoXG4gKiBAcGFyYW0gYnVybkF0b21zIC0gVGhlIGV4YWN0IGFtb3VudCBvZiBhdG9tcyB0byBidXJuXG4gKiBAcmV0dXJucyBBcnJheSBvZiBVVFhPcyB3aG9zZSBhdG9tcyBzdW0gZXhhY3RseSB0byBidXJuQXRvbXNcbiAqL1xuY29uc3QgZ2V0VG9rZW5VdHhvc1dpdGhFeGFjdEF0b21zID0gKGF2YWlsYWJsZVV0eG9zLCB0b2tlbklkLCBidXJuQXRvbXMpID0+IHtcbiAgICBpZiAoYnVybkF0b21zIDw9IDBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYnVybkF0b21zIG9mICR7YnVybkF0b21zfSBzcGVjaWZpZWQgZm9yICR7dG9rZW5JZH0uIGJ1cm5BdG9tcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwbi5gKTtcbiAgICB9XG4gICAgLy8gRmlsdGVyIFVUWE9zIGZvciB0aGUgZ2l2ZW4gdG9rZW5JZCBhbmQgdmFsaWQgdG9rZW4gZGF0YVxuICAgIGNvbnN0IHJlbGV2YW50VXR4b3MgPSBhdmFpbGFibGVVdHhvcy5maWx0ZXIodXR4byA9PiB1dHhvLnRva2VuPy50b2tlbklkID09PSB0b2tlbklkICYmXG4gICAgICAgIHV0eG8udG9rZW4uYXRvbXMgPiAwbiAmJlxuICAgICAgICAhdXR4by50b2tlbi5pc01pbnRCYXRvbik7XG4gICAgaWYgKHJlbGV2YW50VXR4b3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGJ1cm4gJHt0b2tlbklkfSBhcyBubyBVVFhPcyBhcmUgYXZhaWxhYmxlLmApO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdG90YWwgYXRvbXMgYXZhaWxhYmxlXG4gICAgY29uc3QgdG90YWxBdG9tcyA9IHJlbGV2YW50VXR4b3MucmVkdWNlKChzdW0sIHV0eG8pID0+IHN1bSArIHV0eG8udG9rZW4uYXRvbXMsIDBuKTtcbiAgICBpZiAodG90YWxBdG9tcyA8IGJ1cm5BdG9tcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJ1cm5BdG9tcyBvZiAke2J1cm5BdG9tc30gc3BlY2lmaWVkIGZvciAke3Rva2VuSWR9LCBidXQgb25seSAke3RvdGFsQXRvbXN9IGFyZSBhdmFpbGFibGUuYCk7XG4gICAgfVxuICAgIGlmICh0b3RhbEF0b21zID09PSBidXJuQXRvbXMpIHtcbiAgICAgICAgLy8gSWYgdG90YWwgZXF1YWxzIGJ1cm5BdG9tcywgcmV0dXJuIGFsbCByZWxldmFudCBVVFhPc1xuICAgICAgICByZXR1cm4gcmVsZXZhbnRVdHhvcztcbiAgICB9XG4gICAgLy8gVXNlIGR5bmFtaWMgcHJvZ3JhbW1pbmcgdG8gZmluZCB0aGUgZXhhY3Qgc3VtIGFuZCB0cmFjayBVVFhPc1xuICAgIGNvbnN0IGRwID0gbmV3IE1hcCgpO1xuICAgIGRwLnNldCgwbiwgW10pO1xuICAgIGZvciAoY29uc3QgdXR4byBvZiByZWxldmFudFV0eG9zKSB7XG4gICAgICAgIGNvbnN0IGF0b21zID0gdXR4by50b2tlbi5hdG9tcztcbiAgICAgICAgY29uc3QgbmV3RW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtjdXJyZW50U3VtLCB1dHhvc10gb2YgZHApIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N1bSA9IGN1cnJlbnRTdW0gKyBhdG9tcztcbiAgICAgICAgICAgIGlmIChuZXdTdW0gPD0gYnVybkF0b21zKSB7XG4gICAgICAgICAgICAgICAgbmV3RW50cmllcy5wdXNoKFtuZXdTdW0sIFsuLi51dHhvcywgdXR4b11dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtuZXdTdW0sIHV0eG9zXSBvZiBuZXdFbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAobmV3U3VtID09PSBidXJuQXRvbXMpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBleGFjdCBtYXRjaFxuICAgICAgICAgICAgICAgIHJldHVybiB1dHhvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRwLnNldChuZXdTdW0sIHV0eG9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIFVUWE9zIGZvciAke3Rva2VuSWR9IHdpdGggZXhhY3RseSAke2J1cm5BdG9tc30gYXRvbXMuIENyZWF0ZSBhIFVUWE8gd2l0aCAke2J1cm5BdG9tc30gYXRvbXMgdG8gYnVybiB3aXRob3V0IGEgU0VORCBhY3Rpb24uYCk7XG59O1xuZXhwb3J0cy5nZXRUb2tlblV0eG9zV2l0aEV4YWN0QXRvbXMgPSBnZXRUb2tlblV0eG9zV2l0aEV4YWN0QXRvbXM7XG4vKipcbiAqIFdlIG5lZWQgYSBxdHktMSBpbnB1dCBvZiB0aGlzIHRva2VuSWQgYXQgaW5kZXggMCBvZiBpbnB1dHMgdG8gbWludCBhbiBORlRcbiAqIC0gVHJ5IHRvIGdldCB0aGlzXG4gKiAtIElmIHdlIGNhbid0IGdldCB0aGlzLCBnZXQgdGhlIGJpZ2dlc3QgcXR5IHV0eG9cbiAqIC0gSWYgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZywgcmV0dXJuIHVuZGVmaW5lZFxuICovXG5jb25zdCBnZXROZnRDaGlsZEdlbmVzaXNJbnB1dCA9ICh0b2tlbklkLCBzbHBVdHhvcykgPT4ge1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBkbyBub3QgdXNlIC5maWx0ZXIoKSBhcyB3ZSBkbyBpbiBtb3N0IFwiZ2V0SW5wdXRcIiBmdW5jdGlvbnMgZm9yIFNMUCxcbiAgICAvLyBiZWNhdXNlIGluIHRoaXMgY2FzZSB3ZSBvbmx5IHdhbnQgZXhhY3RseSAxIHV0eG9cbiAgICBmb3IgKGNvbnN0IHV0eG8gb2Ygc2xwVXR4b3MpIHtcbiAgICAgICAgaWYgKHV0eG8udG9rZW4/LnRva2VuSWQgPT09IHRva2VuSWQgJiZcbiAgICAgICAgICAgIHV0eG8udG9rZW4/LmlzTWludEJhdG9uID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdXR4by50b2tlbj8uYXRvbXMgPT09IDFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdXR4bztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGV4YWN0bHkgMSBpbnB1dCwgbG9vayBmb3IgdGhlIGlucHV0IHdpdGggdGhlIGhpZ2hlc3QgcXR5XG4gICAgbGV0IGhpZ2hlc3RRdHlVdHhvID0gdW5kZWZpbmVkO1xuICAgIGxldCBoaWdoZXN0UXR5ID0gMG47XG4gICAgZm9yIChjb25zdCB1dHhvIG9mIHNscFV0eG9zKSB7XG4gICAgICAgIGlmICh1dHhvLnRva2VuPy50b2tlbklkID09PSB0b2tlbklkICYmXG4gICAgICAgICAgICB1dHhvLnRva2VuPy5pc01pbnRCYXRvbiA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHV0eG8udG9rZW4/LmF0b21zID4gaGlnaGVzdFF0eSkge1xuICAgICAgICAgICAgaGlnaGVzdFF0eVV0eG8gPSB1dHhvO1xuICAgICAgICAgICAgaGlnaGVzdFF0eSA9IHV0eG8udG9rZW4uYXRvbXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBoaWdoZXN0IHF0eSB1dHhvIGlmIGZvdW5kXG4gICAgcmV0dXJuIGhpZ2hlc3RRdHlVdHhvO1xufTtcbmV4cG9ydHMuZ2V0TmZ0Q2hpbGRHZW5lc2lzSW5wdXQgPSBnZXROZnRDaGlsZEdlbmVzaXNJbnB1dDtcbi8qKlxuICogVmFsaWRhdGUgb25seSB1c2VyLXNwZWNpZmllZCB0b2tlbiBhY3Rpb25zXG4gKiBGb3IgdjAgb2YgZWNhc2gtd2FsbGV0LCB3ZSBvbmx5IHN1cHBvcnQgc2luZ2xlLXR4IGFjdGlvbnMsIHdoaWNoXG4gKiBtZWFucyBzb21lIGNvbWJpbmF0aW9ucyBvZiBhY3Rpb25zIGFyZSBhbHdheXMgaW52YWxpZCwgb3JcbiAqIHVuc3VwcG9ydGVkIGJ5IHRoZSBsaWJcbiAqXG4gKiBGdWxsIHZhbGlkYXRpb24gb2YgdG9rZW5BY3Rpb25zIGlzIGNvbXBsZXggYW5kIGRlcGVuZHMgb24gYXZhaWxhYmxlIHV0eG9zXG4gKiBhbmQgdXNlci1zcGVjaWZpZWQgb3V0cHV0cy4gSW4gdGhpcyBmdW5jdGlvbiwgd2UgZG8gYWxsIHRoZSB2YWxpZGF0aW9uXG4gKiB3ZSBjYW4gd2l0aG91dCBrbm93aW5nIGFueXRoaW5nIGFib3V0IHRva2VuIHR5cGUsIHV0eG9zLCBvciBvdXRwdXRzXG4gKlxuICogLSBObyBkdXBsaWNhdGUgYWN0aW9uc1xuICogLSBPbmx5IDAgb3IgMSBHZW5lc2lzQWN0aW9uIGFuZCBtdXN0IGJlIGZpcnN0XG4gKiAtIE5vIE1JTlQgYW5kIFNFTkQgZm9yIHRoZSBzYW1lIHRva2VuSWRcbiAqL1xuY29uc3QgdmFsaWRhdGVUb2tlbkFjdGlvbnMgPSAodG9rZW5BY3Rpb25zKSA9PiB7XG4gICAgY29uc3QgbWludFRva2VuSWRzID0gW107XG4gICAgY29uc3Qgc2VuZFRva2VuSWRzID0gW107XG4gICAgY29uc3QgYnVyblRva2VuSWRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbkFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9rZW5BY3Rpb24gPSB0b2tlbkFjdGlvbnNbaV07XG4gICAgICAgIHN3aXRjaCAodG9rZW5BY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnR0VORVNJUyc6IHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFsc28gaGFuZGxlcyB0aGUgdmFsaWRhdGlvbiBjb25kaXRpb24gb2YgXCJubyBtb3JlIHRoYW4gb25lIGdlbmVzaXMgYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZW5lc2lzQWN0aW9uIG11c3QgYmUgYXQgaW5kZXggMCBvZiB0b2tlbkFjdGlvbnMuIEZvdW5kIEdlbmVzaXNBY3Rpb24gYXQgaW5kZXggJHtpfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuQWN0aW9uLnRva2VuVHlwZS50eXBlID09PSAnU0xQX1RPS0VOX1RZUEVfTkZUMV9DSElMRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbkFjdGlvbi5ncm91cFRva2VuSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTEQgZ2VuZXNpcyB0eHMgbXVzdCBzcGVjaWZ5IGEgZ3JvdXBUb2tlbklkLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuQWN0aW9uLmdyb3VwVG9rZW5JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0b2tlbkFjdGlvbi50b2tlblR5cGUudHlwZX0gZ2VuZXNpcyB0eHMgbXVzdCBub3Qgc3BlY2lmeSBhIGdyb3VwVG9rZW5JZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NFTkQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlbklkIH0gPSB0b2tlbkFjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoc2VuZFRva2VuSWRzLmluY2x1ZGVzKHRva2VuSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIFNFTkQgYWN0aW9uIGZvciB0b2tlbklkICR7dG9rZW5JZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbnRUb2tlbklkcy5pbmNsdWRlcyh0b2tlbklkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVjYXNoLXdhbGxldCBkb2VzIG5vdCBzdXBwb3J0IG1pbnRpbmcgYW5kIHNlbmRpbmcgdGhlIHNhbWUgdG9rZW4gaW4gdGhlIHNhbWUgQWN0aW9uLiB0b2tlbkFjdGlvbnMgTUlOVCBhbmQgU0VORCAke3Rva2VuSWR9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZW5kVG9rZW5JZHMucHVzaCh0b2tlbklkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ01JTlQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlbklkLCB0b2tlblR5cGUgfSA9IHRva2VuQWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblR5cGUudHlwZSA9PT0gJ1NMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZWNhc2gtd2FsbGV0IGRvZXMgbm90IGN1cnJlbnRseSBzdXBwb3J0IG1pbnRpbmcgU0xQX1RPS0VOX1RZUEVfTUlOVF9WQVVMVCB0b2tlbnMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtaW50VG9rZW5JZHMuaW5jbHVkZXModG9rZW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgTUlOVCBhY3Rpb24gZm9yIHRva2VuSWQgJHt0b2tlbklkfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VuZFRva2VuSWRzLmluY2x1ZGVzKHRva2VuSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZWNhc2gtd2FsbGV0IGRvZXMgbm90IHN1cHBvcnQgbWludGluZyBhbmQgc2VuZGluZyB0aGUgc2FtZSB0b2tlbiBpbiB0aGUgc2FtZSBBY3Rpb24uIHRva2VuQWN0aW9ucyBNSU5UIGFuZCBTRU5EICR7dG9rZW5JZH0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pbnRUb2tlbklkcy5wdXNoKHRva2VuSWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQlVSTic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuSWQgfSA9IHRva2VuQWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChidXJuVG9rZW5JZHMuaW5jbHVkZXModG9rZW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgQlVSTiBhY3Rpb24gZm9yIHRva2VuSWQgJHt0b2tlbklkfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidXJuVG9rZW5JZHMucHVzaCh0b2tlbklkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0RBVEEnOiB7XG4gICAgICAgICAgICAgICAgLy8gRGF0YUFjdGlvbiB2YWxpZGF0aW9uIGlzIGhhbmRsZWQgaW4gZmluYWxpemVPdXRwdXRzXG4gICAgICAgICAgICAgICAgLy8gTm8gc3BlY2lmaWMgdmFsaWRhdGlvbiBuZWVkZWQgaGVyZVxuICAgICAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB2YWxpZGF0ZSBkYXRhIGFjdGlvbnMgaGVyZSBiZWNhdXNlIHdlIHdvdWxkIG5lZWQgdG8ga25vdyB0b2tlbiB0eXBlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRva2VuIGFjdGlvbiBhdCBpbmRleCAke2l9IG9mIHRva2VuQWN0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMudmFsaWRhdGVUb2tlbkFjdGlvbnMgPSB2YWxpZGF0ZVRva2VuQWN0aW9ucztcbi8qKlxuICogUGFyc2UgYWN0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHRvdGFsIHF1YW50aXR5IG9mIHNhdG9zaGlzXG4gKiBhbmQgdG9rZW4gYXRvbXMgKG9mIGVhY2ggdG9rZW4pIHJlcXVpcmVkIHRvIGZ1bGZpbGwgdGhlIEFjdGlvblxuICovXG5jb25zdCBnZXRBY3Rpb25Ub3RhbHMgPSAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgeyBvdXRwdXRzIH0gPSBhY3Rpb247XG4gICAgY29uc3QgdG9rZW5BY3Rpb25zID0gYWN0aW9uLnRva2VuQWN0aW9ucyA/PyBbXTtcbiAgICAvLyBJdGVyYXRlIG92ZXIgdG9rZW5BY3Rpb25zIHRvIGZpZ3VyZSBvdXQgd2hpY2ggb3V0cHV0cyBhcmUgYXNzb2NpYXRlZCB3aXRoIHdoaWNoIGFjdGlvbnNcbiAgICBjb25zdCBzZW5kQWN0aW9uVG9rZW5JZHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYnVybkFjdGlvblRva2VuSWRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGJ1cm5XaXRoQ2hhbmdlVG9rZW5JZHMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgYnVybkFsbFRva2VuSWRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1pbnRBY3Rpb25Ub2tlbklkcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgZ3JvdXBUb2tlbklkID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGJ1cm5BdG9tc01hcCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiB0b2tlbkFjdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnU0VORCc6IHtcbiAgICAgICAgICAgICAgICBzZW5kQWN0aW9uVG9rZW5JZHMuYWRkKGFjdGlvbi50b2tlbklkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0JVUk4nOiB7XG4gICAgICAgICAgICAgICAgYnVybkFjdGlvblRva2VuSWRzLmFkZChhY3Rpb24udG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgYnVybkF0b21zTWFwLnNldChhY3Rpb24udG9rZW5JZCwgYWN0aW9uLmJ1cm5BdG9tcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdNSU5UJzoge1xuICAgICAgICAgICAgICAgIG1pbnRBY3Rpb25Ub2tlbklkcy5hZGQoYWN0aW9uLnRva2VuSWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnR0VORVNJUyc6IHtcbiAgICAgICAgICAgICAgICAvLyBHRU5FU0lTIHR4cyBvbmx5IHJlcXVpcmUgc3BlY2lmaWMgaW5wdXRzIGlmIHRoZXkgYXJlIGZvciBTTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbi50b2tlblR5cGUudHlwZSA9PT0gJ1NMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTEQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5CIHdlIGFscmVhZHkgdmFsaWRhdGUgdGhhdCBhIGdlbmVzaXMgYWN0aW9uIGZvciBTTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEIGhhcyBhIGdyb3VwVG9rZW5JZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB2YWxpZGF0ZVRva2VuQWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBncm91cFRva2VuSWQgPSBhY3Rpb24uZ3JvdXBUb2tlbklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHcm91cCBidXJuIGFjdGlvbiB0b2tlbklkcyBpbnRvIHR3byBzZXRzIHdpdGggZGlmZmVyZW50IGlucHV0IHJlcXVpcmVtZW50c1xuICAgIGJ1cm5BY3Rpb25Ub2tlbklkcy5mb3JFYWNoKHRva2VuSWQgPT4ge1xuICAgICAgICBpZiAoc2VuZEFjdGlvblRva2VuSWRzLmhhcyh0b2tlbklkKSkge1xuICAgICAgICAgICAgYnVybldpdGhDaGFuZ2VUb2tlbklkcy5hZGQodG9rZW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidXJuQWxsVG9rZW5JZHMuYWRkKHRva2VuSWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZHVzdFNhdHMgPSBhY3Rpb24uZHVzdFNhdHMgPz8gZWNhc2hfbGliXzEuREVGQVVMVF9EVVNUX1NBVFM7XG4gICAgLy8gTkIgd2UgZG8gbm90IHJlcXVpcmUgYW55IHRva2VuIGlucHV0cyBmb3IgZ2VuZXNpc0FjdGlvblxuICAgIC8vIEluaXRpYWxpemUgbWFwIHRvIHN0b3JlIHRva2VuIHJlcXVpcmVtZW50c1xuICAgIGNvbnN0IHJlcXVpcmVkVG9rZW5JbnB1dHNNYXAgPSBuZXcgTWFwKCk7XG4gICAgLy8gR2V0IGFsbCBvdXRwdXRzIHRoYXQgcmVxdWlyZSBpbnB1dCBhdG9tc1xuICAgIGNvbnN0IHRva2VuU2VuZE91dHB1dHMgPSBvdXRwdXRzLmZpbHRlcigob3V0cHV0KSA9PiAndG9rZW5JZCcgaW4gb3V0cHV0ICYmXG4gICAgICAgIHR5cGVvZiBvdXRwdXQudG9rZW5JZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgKHNlbmRBY3Rpb25Ub2tlbklkcy5oYXMob3V0cHV0LnRva2VuSWQpIHx8XG4gICAgICAgICAgICBidXJuQWN0aW9uVG9rZW5JZHMuaGFzKG91dHB1dC50b2tlbklkKSkpO1xuICAgIC8vIFByb2Nlc3MgdG9rZW4gc2VuZCBvdXRwdXRzXG4gICAgZm9yIChjb25zdCB0b2tlblNlbmRPdXRwdXQgb2YgdG9rZW5TZW5kT3V0cHV0cykge1xuICAgICAgICBjb25zdCB7IHRva2VuSWQsIGF0b21zIH0gPSB0b2tlblNlbmRPdXRwdXQ7XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkVG9rZW5JbnB1dHMgPSByZXF1aXJlZFRva2VuSW5wdXRzTWFwLmdldCh0b2tlbklkKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1aXJlZFRva2VuSW5wdXRzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZVxuICAgICAgICAgICAgcmVxdWlyZWRUb2tlbklucHV0c01hcC5zZXQodG9rZW5JZCwge1xuICAgICAgICAgICAgICAgIGF0b21zLFxuICAgICAgICAgICAgICAgIGF0b21zTXVzdEJlRXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5lZWRzTWludEJhdG9uOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSW5jcmVtZW50IGF0b21zXG4gICAgICAgICAgICByZXF1aXJlZFRva2VuSW5wdXRzLmF0b21zICs9IGF0b21zO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgYnVybiB3aXRoIGNoYW5nZSBhY3Rpb25zXG4gICAgLy8gV2Ugb25seSBuZWVkIHV0eG9zIHdpdGggYXRvbXMgPj0gYnVybkF0b21zIGZvciB0aGVzZSB0b2tlbklkc1xuICAgIGJ1cm5XaXRoQ2hhbmdlVG9rZW5JZHMuZm9yRWFjaCh0b2tlbklkID0+IHtcbiAgICAgICAgY29uc3QgYnVybkF0b21zID0gYnVybkF0b21zTWFwLmdldCh0b2tlbklkKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRUb2tlbklucHV0cyA9IHJlcXVpcmVkVG9rZW5JbnB1dHNNYXAuZ2V0KHRva2VuSWQpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkVG9rZW5JbnB1dHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplXG4gICAgICAgICAgICByZXF1aXJlZFRva2VuSW5wdXRzTWFwLnNldCh0b2tlbklkLCB7XG4gICAgICAgICAgICAgICAgYXRvbXM6IGJ1cm5BdG9tcyxcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgb25seSBsb29raW5nIGF0IHRoZSB0b2tlbnMgdGhhdCBidXJuIHdpdGggY2hhbmdlXG4gICAgICAgICAgICAgICAgYXRvbXNNdXN0QmVFeGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmVlZHNNaW50QmF0b246IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbmNyZW1lbnQgYXRvbXNcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgZ2V0IGhlcmUgaWYgdGhlIHVzZXIgaXMgU0VORGluZyBhbmQgQlVSTmluZyB0aGUgc2FtZSB0b2tlbklkXG4gICAgICAgICAgICAvLyBOQiB3ZSBkbyBuZWVkIE1PUkUgYXRvbXMgaW4gaW5wdXRzIHRvIGJ1cm4sIGFzIHRoZSB1c2VyLXNwZWNpZmllZCBvdXRwdXRzIGFyZSBOT1QgYnVybmVkXG4gICAgICAgICAgICAvLyBTbyB3ZSBuZWVkIGlucHV0cyB0byBjb3ZlciB0aGUgc3BlY2lmaWVkIG91dHB1dHMgQU5EIHRoZSBidXJuXG4gICAgICAgICAgICByZXF1aXJlZFRva2VuSW5wdXRzLmF0b21zICs9IGJ1cm5BdG9tcztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFByb2Nlc3MgYnVybkFsbCBhY3Rpb25zXG4gICAgLy8gV2UgbXVzdCBmaW5kIHV0eG9zIHdpdGggYXRvbXMgdGhhdCBleGFjdGx5IG1hdGNoIGJ1cm5BdG9tcyBmb3IgdGhlc2UgdG9rZW5JZHNcbiAgICBidXJuQWxsVG9rZW5JZHMuZm9yRWFjaCh0b2tlbklkID0+IHtcbiAgICAgICAgY29uc3QgYnVybkF0b21zID0gYnVybkF0b21zTWFwLmdldCh0b2tlbklkKTtcbiAgICAgICAgLy8gTm8gaW5jcmVtZW50IGhlcmUsIHdlIG5lZWQgZXhhY3QgYXRvbXMgYW5kXG4gICAgICAgIC8vIHdlIHdpbGwgbm90IGhhdmUgYW55IGF0b20gcmVxdWlyZW1lbnRzIGZvciB0aGVzZSB0b2tlbklkcyBmcm9tIFNFTkQgb3V0cHV0c1xuICAgICAgICByZXF1aXJlZFRva2VuSW5wdXRzTWFwLnNldCh0b2tlbklkLCB7XG4gICAgICAgICAgICBhdG9tczogYnVybkF0b21zLFxuICAgICAgICAgICAgYXRvbXNNdXN0QmVFeGFjdDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZWRzTWludEJhdG9uOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gUHJvY2VzcyBtaW50IGFjdGlvbnNcbiAgICBtaW50QWN0aW9uVG9rZW5JZHMuZm9yRWFjaCh0b2tlbklkID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRUb2tlbklucHV0cyA9IHJlcXVpcmVkVG9rZW5JbnB1dHNNYXAuZ2V0KHRva2VuSWQpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkVG9rZW5JbnB1dHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXF1aXJlZFRva2VuSW5wdXRzTWFwLnNldCh0b2tlbklkLCB7XG4gICAgICAgICAgICAgICAgYXRvbXM6IDBuLFxuICAgICAgICAgICAgICAgIGF0b21zTXVzdEJlRXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5lZWRzTWludEJhdG9uOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFscmVhZHkgZGVmaW5lZCB0aGlzLCBpLmUuIGlmIHdlIGFyZSBhbHNvIEJVUk5pbmcgdGhpcyB0b2tlbklkXG4gICAgICAgICAgICAvLyBpbiB0aGlzIHR4LCB0aGVuIGRvIG5vdCBtb2RpZnkgYXRvbXMuIE1ha2Ugc3VyZSB3ZSBhZGQgbWludEJhdG9uIHRob3VnaC5cbiAgICAgICAgICAgIHJlcXVpcmVkVG9rZW5JbnB1dHMubmVlZHNNaW50QmF0b24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gV2UgbmVlZCB0byBrbm93IHNhdHMgZm9yIGFsbCBvdXRwdXRzIGluIHRoZSB0eFxuICAgIGxldCByZXF1aXJlZFNhdHMgPSAwbjtcbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgICAgIGlmICgnYnl0ZWNvZGUnIGluIG91dHB1dCkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBvdXRwdXQgaXMgYSBTY3JpcHQgb3V0cHV0XG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgc3VtIHRoaXMgYXMgYW4gb3V0cHV0LCBhcyBpdHMgdmFsdWUgbXVzdCBiZVxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlZCBkeW5hbWljYWxseSBieSB0aGUgdHhCdWlsZGVyLnNpZ24gbWV0aG9kXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXF1aXJlZFNhdHMgKz0gb3V0cHV0LnNhdHMgPz8gZHVzdFNhdHM7XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvblRvdGFsID0geyBzYXRzOiByZXF1aXJlZFNhdHMgfTtcbiAgICBpZiAocmVxdWlyZWRUb2tlbklucHV0c01hcC5zaXplID4gMCkge1xuICAgICAgICBhY3Rpb25Ub3RhbC50b2tlbnMgPSByZXF1aXJlZFRva2VuSW5wdXRzTWFwO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdyb3VwVG9rZW5JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYWN0aW9uVG90YWwuZ3JvdXBUb2tlbklkID0gZ3JvdXBUb2tlbklkO1xuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uVG90YWw7XG59O1xuZXhwb3J0cy5nZXRBY3Rpb25Ub3RhbHMgPSBnZXRBY3Rpb25Ub3RhbHM7XG4vKipcbiAqIFN0cmF0ZWd5IGZvciBzZWxlY3Rpbmcgc2F0b3NoaXMgaW4gVVRYTyBzZWxlY3Rpb25cbiAqL1xudmFyIFNhdHNTZWxlY3Rpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoU2F0c1NlbGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgLyoqIE11c3Qgc2VsZWN0IGVub3VnaCBzYXRzIHRvIGNvdmVyIG91dHB1dHMgKyBmZWUsIG90aGVyd2lzZSBlcnJvciAoZGVmYXVsdCBiZWhhdmlvcikgKi9cbiAgICBTYXRzU2VsZWN0aW9uU3RyYXRlZ3lbXCJSRVFVSVJFX1NBVFNcIl0gPSBcIlJFUVVJUkVfU0FUU1wiO1xuICAgIC8qKiBUcnkgdG8gY292ZXIgc2F0cywgb3RoZXJ3aXNlIHJldHVybiBVVFhPcyB3aGljaCBjb3ZlciBsZXNzIHRoYW4gYXNrZWQgZm9yICovXG4gICAgU2F0c1NlbGVjdGlvblN0cmF0ZWd5W1wiQVRURU1QVF9TQVRTXCJdID0gXCJBVFRFTVBUX1NBVFNcIjtcbiAgICAvKiogRG9uJ3QgYWRkIHNhdHMsIGV2ZW4gaWYgdGhleSdyZSBhdmFpbGFibGUgKGZvciBwb3N0YWdlLXBhaWQtaW4tZnVsbCBzY2VuYXJpb3MpICovXG4gICAgU2F0c1NlbGVjdGlvblN0cmF0ZWd5W1wiTk9fU0FUU1wiXSA9IFwiTk9fU0FUU1wiO1xufSkoU2F0c1NlbGVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLlNhdHNTZWxlY3Rpb25TdHJhdGVneSA9IFNhdHNTZWxlY3Rpb25TdHJhdGVneSA9IHt9KSk7XG4vKipcbiAqIFNlbGVjdCB1dHhvcyB0byBmdWxmaWxsIHRoZSByZXF1aXJlbWVudHMgb2YgYW4gQWN0aW9uXG4gKlxuICogTm90ZXMgYWJvdXQgbWludGluZyBTTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEIHRva2Vuc1xuICpcbiAqIFRoZXNlIHRva2VucywgYWthIFwiTkZUc1wiLCBhcmUgbWludGVkIGJ5IGJ1cm5pbmcgZXhhY3RseSAxIFNMUF9UT0tFTl9UWVBFX05GVDFfR1JPVVAgdG9rZW5cbiAqIEhvd2V2ZXIsIGEgdXNlciBtYXkgbm90IGhhdmUgdGhlc2UgcXVhbnRpdHktMSBTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQIHRva2VucyBhdmFpbGFibGVcbiAqIFdlIHJldHVybiBhIHVuaXF1ZSBlcnJvciBtc2cgZm9yIHRoZSBjYXNlIG9mIFwidXNlciBoYXMgbm8gcXR5LTEgU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUCB0b2tlbnNcIlxuICogdnMgXCJ1c2VyIGhhcyBvbmx5IHF0eS1tb3JlLXRoYW4tMSBTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQIHRva2Vuc1wiXG4gKlxuICogcmVmIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1wbGVsZWRnZXIvc2xwLXNwZWNpZmljYXRpb25zL2Jsb2IvbWFzdGVyL3NscC1uZnQtMS5tZFxuICogTkIgd2UgYWN0dWFsbHkgXCJjb3VsZFwiIG1pbnQgTkZUIGJ5IGJ1cm5pbmcgYW4gU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUCB3aXRoIHF0eSA+IDEuXG4gKiBIb3dldmVyIHdlIGNhbm5vdCBoYXZlIFwiY2hhbmdlXCIgZm9yIHRoZSBTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQIGluIHRoaXMgdHgsIGJlY2F1c2VcbiAqIFNMUCBvbmx5IHN1cHBvcnRzIG9uZSBhY3Rpb24sIGFuZCB0aGUgbWludCBhY3Rpb24gbXVzdCBiZSBmb3IgdG9rZW4gdHlwZSBTTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEXG4gKiBTbywgdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gcGVyZm9ybSBmYW4tb3V0IHR4c1xuICpcbiAqIGVjYXNoLXdhbGxldCBjb3VsZCBoYW5kbGUgdGhpcyB3aXRoIGNoYWluZWQgdHhzLCBlaXRoZXIgYmVmb3JlIE1JTlQgb3IgYWZ0ZXIgdGhlIGdlbmVzaXMgb2YgdGhlXG4gKiBTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQIHRva2VuLiBGb3Igbm93LCB0aGUgdXNlciBtdXN0IHBlcmZvcm0gZmFuLW91dCB0eHMgbWFudWFsbHkuXG4gKlxuICogTkIgdGhlIGZvbGxvd2luZyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQ6XG4gKiAtIE1pbnRpbmcgb2YgU0xQX1RPS0VOX1RZUEVfTUlOVF9WQVVMVCB0b2tlbnNcbiAqL1xuY29uc3Qgc2VsZWN0VXR4b3MgPSAoYWN0aW9uLCBcbi8qKlxuICogQWxsIHNwZW5kYWJsZSB1dHhvcyBhdmFpbGFibGUgdG8gdGhlIHdhbGxldFxuICogLSBUb2tlbiB1dHhvc1xuICogLSBOb24tdG9rZW4gdXR4b3NcbiAqIC0gQ29pbmJhc2UgdXR4b3Mgd2l0aCBhdCBsZWFzdCBDT0lOQkFTRV9NQVRVUklUWSBjb25maXJtYXRpb25zXG4gKi9cbnNwZW5kYWJsZVV0eG9zLCBcbi8qKlxuICogU3RyYXRlZ3kgZm9yIHNlbGVjdGluZyBzYXRvc2hpc1xuICogQGRlZmF1bHQgU2F0c1NlbGVjdGlvblN0cmF0ZWd5LlJFUVVJUkVfU0FUU1xuICovXG5zYXRzU3RyYXRlZ3kgPSBTYXRzU2VsZWN0aW9uU3RyYXRlZ3kuUkVRVUlSRV9TQVRTKSA9PiB7XG4gICAgY29uc3QgeyBzYXRzLCB0b2tlbnMsIGdyb3VwVG9rZW5JZCB9ID0gKDAsIGV4cG9ydHMuZ2V0QWN0aW9uVG90YWxzKShhY3Rpb24pO1xuICAgIGxldCB0b2tlbklkc1dpdGhSZXF1aXJlZFV0eG9zID0gW107XG4gICAgLy8gQnVybiBhbGwgdG9rZW5JZHMgcmVxdWlyZSBzcGVjaWFsIGhhbmRsaW5nIGFzIHdlIG11c3QgY29sbGVjdFxuICAgIC8vIHV0eG9zIHdoZXJlIHRoZSBhdG9tcyBleGFjdGx5IHN1bSB0byBidXJuQXRvbXNcbiAgICBjb25zdCBidXJuQWxsVG9rZW5JZHMgPSBbXTtcbiAgICBpZiAodHlwZW9mIHRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdG9rZW5JZHNXaXRoUmVxdWlyZWRVdHhvcyA9IEFycmF5LmZyb20odG9rZW5zLmtleXMoKSk7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW5JZCBvZiB0b2tlbklkc1dpdGhSZXF1aXJlZFV0eG9zKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZFRva2VuSW5wdXRzID0gdG9rZW5zLmdldCh0b2tlbklkKTtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZFRva2VuSW5wdXRzLmF0b21zTXVzdEJlRXhhY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHRva2VuSWQgcmVxdWlyZXMgYW4gZXhhY3QgYnVyblxuICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBjb2xsZWN0IHV0eG9zIHRoYXQgZXhhY3RseSBzdW0gdG8gYnVybkF0b21zXG4gICAgICAgICAgICAgICAgYnVybkFsbFRva2VuSWRzLnB1c2godG9rZW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgbmVlZCBleGFjdGx5IDEgcXR5LTEgaW5wdXQgb2YgdGhpcyB0b2tlbklkIGF0IGluZGV4IDAgb2YgaW5wdXRzIHRvIG1pbnQgYW4gTkZUXG4gICAgLy8gSWYgd2UgaGF2ZSBpdCwgdXNlIGl0LCBhbmQgd2UgY2FuIG1ha2UgdGhpcyBtaW50IGluIDEgdHhcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGlucHV0IHdpdGggcXR5ID4gMSwgd2UgbmVlZCB0byBjaGFpbiBhIGZhbi1vdXQgdHg7IHJldHVybiBhcHByb3ByaWF0ZSBlcnJvciBtc2dcbiAgICAvLyBJZiB3ZSBoYXZlIG5vIGlucHV0cywgcmV0dXJuIGFwcHJvcHJpYXRlIGVycm9yIG1zZ1xuICAgIGxldCBuZnRNaW50SW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG5lZWRzTmZ0TWludElucHV0ID0gZmFsc2U7XG4gICAgbGV0IG5lZWRzTmZ0RmFub3V0ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBncm91cFRva2VuSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5mdE1pbnRJbnB1dCA9ICgwLCBleHBvcnRzLmdldE5mdENoaWxkR2VuZXNpc0lucHV0KShncm91cFRva2VuSWQsIHNwZW5kYWJsZVV0eG9zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZnRNaW50SW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgaGF2ZSB0aGUgaW5wdXRzIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIFNvIHRoYXQgd2UgY2FuIHN0aWxsIHVzZSB0aGUgZXhpc3RpbmcgdG9rZW5zIGFuZCBzYXRzIGxvZ2ljIG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGJlbG93LCBhZGQgdGhpcyBhcyBhIG1pc3NpbmcgdG9rZW5cbiAgICAgICAgICAgIG5lZWRzTmZ0TWludElucHV0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZnRNaW50SW5wdXQudG9rZW4/LmF0b21zICYmIG5mdE1pbnRJbnB1dC50b2tlbi5hdG9tcyA+IDFuKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGl0IGJ1dCBub3QgdGhlIHJpZ2h0IHF0eVxuICAgICAgICAgICAgbmVlZHNOZnRGYW5vdXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5CIGZvciBhIG5vbi10b2tlbiB0eCwgd2Ugb25seSB1c2Ugbm9uLXRva2VuIHV0eG9zXG4gICAgLy8gQXMgdGhpcyBmdW5jdGlvbiBpcyBleHRlbmRlZCwgd2Ugd2lsbCBuZWVkIHRvIGNvdW50IHRoZSBzYXRzXG4gICAgLy8gaW4gdG9rZW4gdXR4b3NcbiAgICBjb25zdCBzZWxlY3RlZFV0eG9zID0gW107XG4gICAgbGV0IHNlbGVjdGVkVXR4b3NTYXRzID0gMG47XG4gICAgLy8gQWRkIE5GVCBtaW50IGlucHV0IGlmIHdlIGhhdmUgb25lXG4gICAgaWYgKHR5cGVvZiBncm91cFRva2VuSWQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBuZnRNaW50SW5wdXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICFuZWVkc05mdEZhbm91dCkge1xuICAgICAgICAvLyBXZSBvbmx5IGFkZCBpZiBpdCBpcyBhIHF0eS0xIGlucHV0XG4gICAgICAgIC8vIFRlY2huaWNhbGx5LCBhIGhpZ2hlciBxdHkgaW5wdXQgd291bGQgXCJ3b3JrXCIgcGVyIHNwZWNcbiAgICAgICAgLy8gQnV0IHdlIGVuZm9yY2UgdXNpbmcgb25seSBxdHktMSBpbnB1dHNcbiAgICAgICAgLy8gVE9ETyB3ZSBjb3VsZCBwZXJoYXBzIGF1dG8tZmFuLWFuZC1taW50IHVzaW5nIHRoaXMgbGlicmFyeVxuICAgICAgICBzZWxlY3RlZFV0eG9zLnB1c2gobmZ0TWludElucHV0KTtcbiAgICAgICAgc2VsZWN0ZWRVdHhvc1NhdHMgKz0gbmZ0TWludElucHV0LnNhdHM7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBidXJuQWxsIHRva2VuSWRzIGZpcnN0XG4gICAgZm9yIChjb25zdCBidXJuQWxsVG9rZW5JZCBvZiBidXJuQWxsVG9rZW5JZHMpIHtcbiAgICAgICAgY29uc3QgdXR4b3NUaGlzQnVybkFsbFRva2VuSWQgPSAoMCwgZXhwb3J0cy5nZXRUb2tlblV0eG9zV2l0aEV4YWN0QXRvbXMpKHNwZW5kYWJsZVV0eG9zLCBidXJuQWxsVG9rZW5JZCwgdG9rZW5zLmdldChidXJuQWxsVG9rZW5JZCkuYXRvbXMpO1xuICAgICAgICBmb3IgKGNvbnN0IHV0eG8gb2YgdXR4b3NUaGlzQnVybkFsbFRva2VuSWQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkVXR4b3MucHVzaCh1dHhvKTtcbiAgICAgICAgICAgIHNlbGVjdGVkVXR4b3NTYXRzICs9IHV0eG8uc2F0cztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIG5vdyBhZGRlZCB1dHhvcyB0byBjb3ZlciB0aGUgcmVxdWlyZWQgYXRvbXMgZm9yIHRoaXMgdG9rZW5JZFxuICAgICAgICBpZiAodHlwZW9mIHRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgdG9rZW5zIHRvIGhhbmRsZVxuICAgICAgICAgICAgLy8gKHdlIGFsd2F5cyB3aWxsIGlmIHdlIGFyZSBoZXJlLCB0cyBhc3NlcnRpb24gaXNzdWUpXG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZFRva2VuSW5wdXRzID0gdG9rZW5zLmdldChidXJuQWxsVG9rZW5JZCk7XG4gICAgICAgICAgICBpZiAoIXJlcXVpcmVkVG9rZW5JbnB1dHMubmVlZHNNaW50QmF0b24pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkbyBub3QgbmVlZCBhIG1pbnQgYmF0b25cbiAgICAgICAgICAgICAgICAvLyBUaGVuIHdlIG5vIGxvbmdlciBuZWVkIHV0eG9zIGZvciB0aGlzIHRva2VuXG4gICAgICAgICAgICAgICAgdG9rZW5JZHNXaXRoUmVxdWlyZWRVdHhvcyA9IHRva2VuSWRzV2l0aFJlcXVpcmVkVXR4b3MuZmlsdGVyKHRva2VuSWQgPT4gdG9rZW5JZCAhPT0gYnVybkFsbFRva2VuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlJ3ZlIG9ubHkgZGVhbHQgd2l0aCB0aGUgYXRvbXNcbiAgICAgICAgICAgICAgICByZXF1aXJlZFRva2VuSW5wdXRzLmF0b21zID0gMG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhpcyB0eCBpcyBPTkxZIGEgYnVybiBhbGwgdHgsIHdlIG1heSBoYXZlIGVub3VnaCBhbHJlYWR5XG4gICAgaWYgKHR5cGVvZiBncm91cFRva2VuSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIG5vdCBhbiBORlQgbWludCB0eFxuICAgICAgICBpZiAoKHNlbGVjdGVkVXR4b3NTYXRzID49IHNhdHMgfHxcbiAgICAgICAgICAgIHNhdHNTdHJhdGVneSA9PT0gU2F0c1NlbGVjdGlvblN0cmF0ZWd5Lk5PX1NBVFMpICYmXG4gICAgICAgICAgICB0b2tlbklkc1dpdGhSZXF1aXJlZFV0eG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSWYgc2VsZWN0ZWRVdHhvcyBmdWxmaWxsIHRoZSByZXF1aXJlbWVudHMgb2YgdGhpcyBBY3Rpb24sIHJldHVybiB0aGVtXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgdXR4b3M6IHNlbGVjdGVkVXR4b3MsXG4gICAgICAgICAgICAgICAgLy8gT25seSBleHBlY3RlZCB0byBiZSA+IDBuIGlmIHNhdHNTdHJhdGVneSBpcyBOT19TQVRTXG4gICAgICAgICAgICAgICAgbWlzc2luZ1NhdHM6IHNlbGVjdGVkVXR4b3NTYXRzID49IHNhdHMgPyAwbiA6IHNhdHMgLSBzZWxlY3RlZFV0eG9zU2F0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB1dHhvIG9mIHNwZW5kYWJsZVV0eG9zKSB7XG4gICAgICAgIGlmICgndG9rZW4nIGluIHV0eG8gJiYgdHlwZW9mIHV0eG8udG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdG9rZW4gdXR4b1xuICAgICAgICAgICAgaWYgKHRva2VuSWRzV2l0aFJlcXVpcmVkVXR4b3MuaW5jbHVkZXModXR4by50b2tlbi50b2tlbklkKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgcmVtYWluaW5nIHJlcXVpcmVtZW50cyBmb3IgYSB1dHhvIHdpdGggdGhpcyB0b2tlbklkXG4gICAgICAgICAgICAgICAgLy8gdG8gY29tcGxldGUgdGhpcyB1c2VyLXNwZWNpZmllZCBBY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZFRva2VuSW5wdXRzVGhpc1Rva2VuID0gdG9rZW5zLmdldCh1dHhvLnRva2VuLnRva2VuSWQpO1xuICAgICAgICAgICAgICAgIGlmICh1dHhvLnRva2VuLmlzTWludEJhdG9uICYmXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkVG9rZW5JbnB1dHNUaGlzVG9rZW4ubmVlZHNNaW50QmF0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG1pbnQgYmF0b24gYW5kIHdlIG5lZWQgYSBtaW50IGJhdG9uLCBhZGQgdGhpcyB1dHhvIHRvIHNlbGVjdGVkVXR4b3NcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRVdHhvcy5wdXNoKHV0eG8pO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFV0eG9zU2F0cyArPSB1dHhvLnNhdHM7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBubyBsb25nZXIgbmVlZCBhIG1pbnQgYmF0b25cbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRUb2tlbklucHV0c1RoaXNUb2tlbi5uZWVkc01pbnRCYXRvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRUb2tlbklucHV0c1RoaXNUb2tlbi5hdG9tcyA9PT0gMG4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFyZXF1aXJlZFRva2VuSW5wdXRzVGhpc1Rva2VuLm5lZWRzTWludEJhdG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBubyBsb25nZXIgcmVxdWlyZSBhbnkgdXR4b3MgZm9yIHRoaXMgdG9rZW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRva2VuSWRzV2l0aFJlcXVpcmVkVXR4b3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuSWRzV2l0aFJlcXVpcmVkVXR4b3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuSWRzV2l0aFJlcXVpcmVkVXR4b3MuZmlsdGVyKHRva2VuSWQgPT4gdG9rZW5JZCAhPT0gdXR4by50b2tlbi50b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdXR4b3MgaWYgd2UgaGF2ZSBlbm91Z2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzZWxlY3RlZFV0eG9zU2F0cyA+PSBzYXRzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXRzU3RyYXRlZ3kgPT09IFNhdHNTZWxlY3Rpb25TdHJhdGVneS5OT19TQVRTKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5JZHNXaXRoUmVxdWlyZWRVdHhvcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dHhvczogc2VsZWN0ZWRVdHhvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGV4cGVjdGVkIHRvIGJlID4gMG4gaWYgc2F0c1N0cmF0ZWd5IGlzIE5PX1NBVFNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU2F0czogc2VsZWN0ZWRVdHhvc1NhdHMgPj0gc2F0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDBuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2F0cyAtIHNlbGVjdGVkVXR4b3NTYXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdXR4by50b2tlbi5pc01pbnRCYXRvbiAmJlxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFRva2VuSW5wdXRzVGhpc1Rva2VuLmF0b21zID4gMG4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRva2VuIHV0eG8gYW5kIHdlIG5lZWQgYXRvbXMsIGFkZCB0aGlzIHV0eG8gdG8gc2VsZWN0ZWRVdHhvc1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFV0eG9zLnB1c2godXR4byk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVXR4b3NTYXRzICs9IHV0eG8uc2F0cztcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugbm93IHJlcXVpcmUgZmV3ZXIgYXRvbXMgb2YgdGhpcyB0b2tlbklkLiBVcGRhdGUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQXRvbXNSZW1haW5pbmdUaGlzVG9rZW4gPSAocmVxdWlyZWRUb2tlbklucHV0c1RoaXNUb2tlbi5hdG9tcyAtPVxuICAgICAgICAgICAgICAgICAgICAgICAgdXR4by50b2tlbi5hdG9tcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByZXF1aXJlZCBhdG9tcyByZW1haW5pbmcgZm9yIHRoaXMgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRUb2tlbklucHV0c1RoaXNUb2tlbi5hdG9tcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEF0b21zUmVtYWluaW5nVGhpc1Rva2VuID4gMG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlcXVpcmVkQXRvbXNSZW1haW5pbmdUaGlzVG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDBuO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRUb2tlbklucHV0c1RoaXNUb2tlbi5hdG9tcyA9PT0gMG4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFyZXF1aXJlZFRva2VuSW5wdXRzVGhpc1Rva2VuLm5lZWRzTWludEJhdG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBubyBsb25nZXIgcmVxdWlyZSB1dHhvcyBmb3IgdGhpcyB0b2tlbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRva2VuSWQgZnJvbSB0b2tlbklkc1dpdGhSZXF1aXJlZFV0eG9zXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbklkc1dpdGhSZXF1aXJlZFV0eG9zID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbklkc1dpdGhSZXF1aXJlZFV0eG9zLmZpbHRlcih0b2tlbklkID0+IHRva2VuSWQgIT09IHV0eG8udG9rZW4udG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChzZWxlY3RlZFV0eG9zU2F0cyA+PSBzYXRzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXRzU3RyYXRlZ3kgPT09IFNhdHNTZWxlY3Rpb25TdHJhdGVneS5OT19TQVRTKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5JZHNXaXRoUmVxdWlyZWRVdHhvcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNlbGVjdGVkVXR4b3MgZnVsZmlsbCB0aGUgcmVxdWlyZW1lbnRzIG9mIHRoaXMgQWN0aW9uLCByZXR1cm4gdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0eG9zOiBzZWxlY3RlZFV0eG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZXhwZWN0ZWQgdG8gYmUgPiAwbiBpZiBzYXRzU3RyYXRlZ3kgaXMgTk9fU0FUU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdTYXRzOiBzZWxlY3RlZFV0eG9zU2F0cyA+PSBzYXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzYXRzIC0gc2VsZWN0ZWRVdHhvc1NhdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9uZSBwcm9jZXNzaW5nIHRva2VuIHV0eG8sIGdvIHRoZSBuZXh0IHV0eG9cbiAgICAgICAgICAgIC8vIE5CIHdlIERPIE5PVCBhZGQgYW55IHRva2VuVXR4byB0byBzZWxlY3RlZFV0eG9zIHVubGVzcyB0aGVyZSBpc1xuICAgICAgICAgICAgLy8gYSB0b2tlbi1yZWxhdGVkIG5lZWQgZm9yIGl0IHNwZWNpZmllZCBpbiB0aGUgQWN0aW9uXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2F0c1N0cmF0ZWd5ID09PSBTYXRzU2VsZWN0aW9uU3RyYXRlZ3kuTk9fU0FUUykge1xuICAgICAgICAgICAgLy8gV2UgZG8gbm90IG5lZWQgYW55IGZ1ZWwgdXR4b3MgaWYgd2UgYXJlIGdhc2xlc3NcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBBVFRFTVBUX1NBVFMgYW5kIFJFUVVJUkVfU0FUUywgd2UgY29sbGVjdCBzYXRzIHV0eG9zXG4gICAgICAgIC8vIEFUVEVNUFRfU0FUUyB3aWxsIHJldHVybiB3aGF0IHdlIGhhdmUgZXZlbiBpZiBpbmNvbXBsZXRlXG4gICAgICAgIC8vIFJFUVVJUkVfU0FUUyB3aWxsIG9ubHkgcmV0dXJuIGlmIHdlIGhhdmUgZW5vdWdoXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbm90IHJldHVybmVkIHNlbGVjdGVkVXR4b3MgeWV0LCB3ZSBzdGlsbCBuZWVkIG1vcmUgc2F0c1xuICAgICAgICAvLyBTbywgYWRkIHRoaXMgdXR4b1xuICAgICAgICBzZWxlY3RlZFV0eG9zLnB1c2godXR4byk7XG4gICAgICAgIHNlbGVjdGVkVXR4b3NTYXRzICs9IHV0eG8uc2F0cztcbiAgICAgICAgaWYgKHNlbGVjdGVkVXR4b3NTYXRzID49IHNhdHMgJiZcbiAgICAgICAgICAgIHRva2VuSWRzV2l0aFJlcXVpcmVkVXR4b3MubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAhbmVlZHNOZnRNaW50SW5wdXQgJiZcbiAgICAgICAgICAgICFuZWVkc05mdEZhbm91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHV0eG9zOiBzZWxlY3RlZFV0eG9zLFxuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyAwIGhlcmUsIGRldGVybWluZWQgYnkgY29uZGl0aW9uIG9mIHRoaXMgaWYgYmxvY2tcbiAgICAgICAgICAgICAgICBtaXNzaW5nU2F0czogMG4sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBkbyBub3QgaGF2ZSBzdWZmaWNpZW50IHV0eG9zXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgaWYgKHRva2VuSWRzV2l0aFJlcXVpcmVkVXR4b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBBZGQgaHVtYW4tcmVhZGFibGUgZXJyb3IgbXNnIGZvciBtaXNzaW5nIHRva2VuIHV0eG9zXG4gICAgICAgIHRva2Vucz8uZm9yRWFjaChyZXF1aXJlZFRva2VuSW5mbyA9PiB7XG4gICAgICAgICAgICByZXF1aXJlZFRva2VuSW5mby5lcnJvciA9IGAke3JlcXVpcmVkVG9rZW5JbmZvLm5lZWRzTWludEJhdG9uXG4gICAgICAgICAgICAgICAgPyBgTWlzc2luZyBtaW50IGJhdG9uYFxuICAgICAgICAgICAgICAgIDogYE1pc3NpbmcgJHtyZXF1aXJlZFRva2VuSW5mby5hdG9tc30gYXRvbSR7cmVxdWlyZWRUb2tlbkluZm8uYXRvbXMgIT09IDFuID8gJ3MnIDogJyd9YH1gO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9rZW5FcnJvck1zZyA9IFtdO1xuICAgICAgICAvLyBTb3J0IGJ5IHRva2VuSWQgdG8gZW5zdXJlIGNvbnNpc3RlbnQgb3JkZXJcbiAgICAgICAgY29uc3Qgc29ydGVkVG9rZW5JZHMgPSBBcnJheS5mcm9tKHRva2Vucy5rZXlzKCkpLnNvcnQoKTtcbiAgICAgICAgc29ydGVkVG9rZW5JZHMuZm9yRWFjaCh0b2tlbklkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkVG9rZW5JbmZvID0gdG9rZW5zLmdldCh0b2tlbklkKTtcbiAgICAgICAgICAgIHRva2VuRXJyb3JNc2cucHVzaChgICR7dG9rZW5JZH0gPT4gJHtyZXF1aXJlZFRva2VuSW5mby5lcnJvcn1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVycm9ycy5wdXNoKGBNaXNzaW5nIHJlcXVpcmVkIHRva2VuIHV0eG9zOiR7dG9rZW5FcnJvck1zZy5qb2luKCcsJyl9YCk7XG4gICAgICAgIC8vIE1pc3NpbmcgdG9rZW5zIGFsd2F5cyBjYXVzZSBmYWlsdXJlLCByZWdhcmRsZXNzIG9mIHN0cmF0ZWd5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1pc3NpbmdUb2tlbnM6IHRva2VucyxcbiAgICAgICAgICAgIG1pc3NpbmdTYXRzOiBzZWxlY3RlZFV0eG9zU2F0cyA+PSBzYXRzID8gMG4gOiBzYXRzIC0gc2VsZWN0ZWRVdHhvc1NhdHMsXG4gICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChuZWVkc05mdE1pbnRJbnB1dCB8fCBuZWVkc05mdEZhbm91dCkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlcmUgdXNlciB3YW50cyB0byBtaW50IGFuIE5GVCBidXQgbGFja3MgYW55IGlucHV0c1xuICAgICAgICBjb25zdCBtaXNzaW5nVG9rZW5zQ3VzdG9tID0gbmV3IE1hcCgpO1xuICAgICAgICBtaXNzaW5nVG9rZW5zQ3VzdG9tLnNldChncm91cFRva2VuSWQsIHtcbiAgICAgICAgICAgIGF0b21zOiAxbixcbiAgICAgICAgICAgIG5lZWRzTWludEJhdG9uOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIG1pc3NpbmdUb2tlbnM6IG1pc3NpbmdUb2tlbnNDdXN0b20sXG4gICAgICAgICAgICBtaXNzaW5nU2F0czogc2VsZWN0ZWRVdHhvc1NhdHMgPj0gc2F0cyA/IDBuIDogc2F0cyAtIHNlbGVjdGVkVXR4b3NTYXRzLFxuICAgICAgICAgICAgZXJyb3JzOiBuZWVkc05mdE1pbnRJbnB1dFxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICBgTWlzc2luZyBTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQIGlucHV0IGZvciBncm91cFRva2VuSWQgJHtncm91cFRva2VuSWR9YCxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgICAgIGBNaXNzaW5nIHF0eS0xIFNMUF9UT0tFTl9UWVBFX05GVDFfR1JPVVAgaW5wdXQgZm9yIGdyb3VwVG9rZW5JZCAke2dyb3VwVG9rZW5JZH0uIFlvdSBtdXN0IHNwbGl0IHlvdXIgcXR5LSR7bmZ0TWludElucHV0Py50b2tlbj8uYXRvbXN9IGlucHV0IGludG8gcXR5LTEgaW5wdXRzLmAsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbWlzc2luZ1NhdHMgPSBzZWxlY3RlZFV0eG9zU2F0cyA+PSBzYXRzID8gMG4gOiBzYXRzIC0gc2VsZWN0ZWRVdHhvc1NhdHM7XG4gICAgaWYgKG1pc3NpbmdTYXRzID4gMG4pIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYEluc3VmZmljaWVudCBzYXRzIHRvIGNvbXBsZXRlIHR4LiBOZWVkICR7bWlzc2luZ1NhdHN9IGFkZGl0aW9uYWwgc2F0b3NoaXMgdG8gY29tcGxldGUgdGhpcyBBY3Rpb24uYCk7XG4gICAgfVxuICAgIGlmIChzYXRzU3RyYXRlZ3kgPT09IFNhdHNTZWxlY3Rpb25TdHJhdGVneS5SRVFVSVJFX1NBVFMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgbWlzc2luZ1NhdHMsXG4gICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEZvciBBVFRFTVBUX1NBVFMgYW5kIE5PX1NBVFMgc3RyYXRlZ2llcywgcmV0dXJuIHdoYXQgd2UgaGF2ZSBldmVuIGlmIGluY29tcGxldGVcbiAgICAvLyBEbyBub3QgaW5jbHVkZSBlcnJvcnMgZmllbGQgZm9yIG1pc3Npbmcgc2F0cyBpZiByZXR1cm5pbmcgc3VjY2Vzc1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHV0eG9zOiBzZWxlY3RlZFV0eG9zLFxuICAgICAgICBtaXNzaW5nU2F0cyxcbiAgICAgICAgLy8gTkIgd2UgZG8gbm90IGhhdmUgZXJyb3JzIGZvciBtaXNzaW5nU2F0cyB3aXRoIHRoZXNlIHN0cmF0ZWdpZXNcbiAgICB9O1xufTtcbmV4cG9ydHMuc2VsZWN0VXR4b3MgPSBzZWxlY3RVdHhvcztcbi8qKlxuICogZWNhc2gtd2FsbGV0IG9ubHkgc3VwcG9ydHMgb25lIHRva2VuIHR5cGUgcGVyIGFjdGlvbiAoZm9yIG5vdylcbiAqIC0gV2UgY291bGQgc3VwcG9ydCBtdWx0aXBsZSBBTFAgdHlwZXMgaW4gb25lIHR4LCBpZiBhbmQgd2hlbiB3ZSBoYXZlIG11bHRpcGxlIEFMUCB0eXBlc1xuICogLSBXZSBjb3VsZCBzdXBwb3J0IG11bHRpcGxlIHR5cGVzIGluIG11bHRpcGxlIHR4cy4gU3VwcG9ydCBmb3IgbXVsdGlwbGUgdHhzIGlzIHBsYW5uZWQuXG4gKiBQYXJzZSB0b2tlbkFjdGlvbnMgZm9yIHRva2VuVHlwZVxuICpcbiAqIFRPRE8gKG93biBkaWZmKSB3aWxsIG5lZWQgc3BlY2lhbCBoYW5kbGluZyAoaS5lLiBtdWx0aXBsZSB0b2tlbiB0eXBlcykgZm9yIG1pbnRpbmcgb2YgU0xQIE5GVDFcbiAqXG4gKiBSZXR1cm5zIFRva2VuVHlwZSBvZiB0aGUgdG9rZW4gYXNzb2NpYXRlZCB3aXRoIHRoaXMgYWN0aW9uLCBpZiBhY3Rpb24gaXMgdmFsaWRcbiAqIFRocm93cyBpZiBhY3Rpb24gc3BlY2lmaWVzIG1vcmUgdGhhbiBvbmUgVG9rZW5UeXBlIGluIGEgc2luZ2xlIHR4XG4gKiBSZXR1cm5zIHVuZGVmaW5lZCBmb3Igbm9uLXRva2VuIHR4XG4gKi9cbmNvbnN0IGdldFRva2VuVHlwZSA9IChhY3Rpb24pID0+IHtcbiAgICBsZXQgdG9rZW5UeXBlO1xuICAgIGNvbnN0IHsgdG9rZW5BY3Rpb25zIH0gPSBhY3Rpb247XG4gICAgaWYgKHR5cGVvZiB0b2tlbkFjdGlvbnMgPT0gJ3VuZGVmaW5lZCcgfHwgdG9rZW5BY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBubyB0b2tlbkFjdGlvbnMgYXJlIHNwZWNpZmllZFxuICAgICAgICByZXR1cm4gdG9rZW5UeXBlO1xuICAgIH1cbiAgICBjb25zdCBnZW5lc2lzQWN0aW9uID0gYWN0aW9uLnRva2VuQWN0aW9ucz8uZmluZChhY3Rpb24gPT4gYWN0aW9uLnR5cGUgPT09ICdHRU5FU0lTJyk7XG4gICAgaWYgKHR5cGVvZiBnZW5lc2lzQWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBXZSBoYXZlIHNwZWNpZmllZCB0b2tlbiBhY3Rpb25zXG4gICAgICAgIC8vIEdlbmVzaXMgdHhzIG11c3Qgc3BlY2lmeSBhIHRva2VuIHR5cGUgaW4gdGhlIHRva2VuIGFjdGlvblxuICAgICAgICAvLyBQYXJzZSBmb3IgdGhpc1xuICAgICAgICB0b2tlblR5cGUgPSBnZW5lc2lzQWN0aW9uLnRva2VuVHlwZTtcbiAgICB9XG4gICAgLy8gQ29uZmlybSBubyBvdGhlciB0b2tlbiB0eXBlcyBhcmUgc3BlY2lmaWVkXG4gICAgZm9yIChjb25zdCBhY3Rpb24gb2YgdG9rZW5BY3Rpb25zKSB7XG4gICAgICAgIGlmICgndG9rZW5UeXBlJyBpbiBhY3Rpb24gJiYgdHlwZW9mIGFjdGlvbi50b2tlblR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdG9rZW4gYWN0aW9uIChpLmUuIE5PVCBhIGRhdGEgYWN0aW9uKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlblR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBub3QgeWV0IGRlZmluZWQgdG9rZW5UeXBlLCBkZWZpbmUgaXRcbiAgICAgICAgICAgICAgICB0b2tlblR5cGUgPSBhY3Rpb24udG9rZW5UeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBkZWZpbmVkIHRva2VuVHlwZSwgdmVyaWZ5IHdlIGRvIG5vdCBoYXZlIG11bHRpcGxlIHRva2VuVHlwZXNcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5UeXBlLnR5cGUgIT09IGFjdGlvbi50b2tlblR5cGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGlvbiBtdXN0IGluY2x1ZGUgb25seSBvbmUgdG9rZW4gdHlwZS4gRm91bmQgKGF0IGxlYXN0KSB0d286ICR7dG9rZW5UeXBlLnR5cGV9IGFuZCAke2FjdGlvbi50b2tlblR5cGUudHlwZX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5CIHdlIGRvIG5vdCBleHBlY3QgdG8gZmluZCB0b2tlblR5cGUgaW4gYSBkYXRhIGFjdGlvblxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5UeXBlO1xufTtcbmV4cG9ydHMuZ2V0VG9rZW5UeXBlID0gZ2V0VG9rZW5UeXBlO1xuLy8gQ29udmVydCB1c2VyLXNwZWNpZmllZCBlY2FzaC13YWxsZXQgT3V0cHV0W10gdG8gVHhPdXRwdXRbXSwgc28gd2UgY2FuIGJ1aWxkXG4vLyBhbmQgc2lnbiB0aGUgdHggdGhhdCBmdWxmaWxscyB0aGlzIEFjdGlvblxuY29uc3QgcGF5bWVudE91dHB1dHNUb1R4T3V0cHV0cyA9IChvdXRwdXRzLCBkdXN0U2F0cykgPT4ge1xuICAgIGNvbnN0IHR4QnVpbGRlck91dHB1dHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgICAgIHR4QnVpbGRlck91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICBzYXRzOiBvdXRwdXQuc2F0cyA/PyBkdXN0U2F0cyxcbiAgICAgICAgICAgIHNjcmlwdDogb3V0cHV0LnNjcmlwdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0eEJ1aWxkZXJPdXRwdXRzO1xufTtcbmV4cG9ydHMucGF5bWVudE91dHB1dHNUb1R4T3V0cHV0cyA9IHBheW1lbnRPdXRwdXRzVG9UeE91dHB1dHM7XG4vKipcbiAqIGZpbmFsaXplT3V0cHV0c1xuICpcbiAqIEFjY2VwdCB1c2VyLXNwZWNpZmllZCBvdXRwdXRzIGFuZCBwcmVwYXJlIHRoZW0gZm9yIG5ldHdvcmsgYnJvYWRjYXN0XG4gKiAtIFBhcnNlIGFuZCB2YWxpZGF0ZSB0b2tlbiBpbnB1dHMgYW5kIG91dHB1dHMgYWNjb3JkaW5nIHRvIHJlbGV2YW50IHRva2VuIHNwZWNcbiAqIC0gQWRkIHRva2VuIGNoYW5nZSBvdXRwdXRzIHRvIGZ1bGZpbGwgdXNlciBTRU5EIGFuZC9vciBCVVJOIGluc3RydWN0aW9uc1xuICogLSBCdWlsZCBPUF9SRVRVUk4gdG8gZnVsZmlsbCBpbnRlbmRlZCB1c2VyIGFjdGlvbiBwZXIgdG9rZW4gc3BlY1xuICogLSBWYWxpZGF0ZSBvdXRwdXRzIGZvciB0b2tlbiBhbmQgbm9uLXRva2VuIGFjdGlvbnNcbiAqIC0gQ29udmVydCB1c2VyLXNwZWNpZmllZCBlY2FzaC13YWxsZXQgUGF5bWVudE91dHB1dFtdIGludG8gVHhCdWlsZGVyT3V0cHV0W10gcmVhZHkgZm9yIHNpZ25pbmcvYnJvYWRjYXN0XG4gKlxuICogU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEVcbiAqIC0gTWF5IG9ubHkgaGF2ZSAxIG1pbnQgcXVhbnRpdHkgYW5kIGl0IG11c3QgYmUgYXQgb3V0SWR4IDFcbiAqIC0gTWF5IG9ubHkgaGF2ZSAxIG1pbnQgYmF0b24gYW5kIGl0IG11c3QgYmUgYXQgb3V0SWR4ID49IDIgYW5kIDw9IDB4ZmYgKDI1NSlcbiAqIC0gQWxsIHNlbmQgb3V0cHV0cyBtdXN0IGJlIGF0IDE8PW91dElkeDw9MTlcbiAqXG4gKiBTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQIGlzIHRoZSBzYW1lIHNwZWMgcnVsZXMgYXMgU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEUgZXhjZXB0IGRpZmZlcmVudCB0eXBlIGJ5dGVcbiAqIFdpbGwgaGF2ZSBzb21lIGRpc3RpbmN0aW9ucyBhZGRlZCB3aGVuIHdlIHN1cHBvcnQgU0xQX1RPS0VOX1RZUEVfTkZUMV9DSElMRFxuICpcbiAqIFNMUCBzcGVjIHJ1bGVzIHByZXZlbnQgZXhjZWVkaW5nIDIyMyBieXRlcyBpbiB0aGUgT1BfUkVUVVJOLiBTbywgZXZlbiBpZiB0aGlzXG4gKiBsaW1pdCBpbmNyZWFzZSBpbiBmdXR1cmUsIFNMUCB0eHMgd2lsbCBiZSB0aGUgc2FtZS5cbiAqXG4gKiBBTFBfVE9LRU5fVFlQRV9TVEFOREFSRFxuICogTUlOVCBvciBHRU5FU0lTXG4gKiAtIE1heSBoYXZlIG4gbWludCBxdWFudGl0aWVzXG4gKiAtIE1heSBoYXZlIG4gbWludCBiYXRvbnMsIGJ1dCBtdXN0IGJlIGNvbnNlY3V0aXZlIGFuZCBoYXZlIGhpZ2hlciBpbmRleCB0aGFuIHF0eSBvdXRwdXRzXG4gKiAtIFdpdGggY3VycmVudCAyMjMtYnl0ZSBPUF9SRVRVUk4gbGltaXQsIG5vIGluZGljZXMgaGlnaGVyIHRoYW4gMjlcbiAqIFNFTkRcbiAqIC0gQWxsIHNlbmQgb3V0cHV0cyBtdXN0IGJlIGF0IDE8PW91dElkeDw9MjlcbiAqIC0gV2UgY2Fubm90IGhhdmUgU0VORCBhbmQgTUlOVCBmb3IgdGhlIHNhbWUgdG9rZW5JZFxuICogLSBXZSBjYW5ub3QgaGF2ZSBtb3JlIHRoYW4gb25lIGdlbmVzaXNcbiAqXG4gKiBBc3N1bXB0aW9uc1xuICogLSBPbmx5IG9uZSB0b2tlbiB0eXBlIHBlciB0eFxuICogLSBXZSBkbyBub3Qgc3VwcG9ydCBTTFAgaW50ZW50aW9uYWwgYnVybnNcbiAqIC0gV2UgZG8gbm90IHN1cHBvcnQgQUxQIGNvbWJpbmVkIE1JTlQgLyBCVVJOIHR4c1xuICpcbiAqIFJldHVybnM6IFRoZSBhY3Rpb24gb3V0cHV0cy4gVGhlIHNjcmlwdCBmaWVsZCBvZiBlYWNoIG91dHB1dCB3aWxsIGJlIHNldCBpZlxuICogdGhlIGFkZHJlc3Mgd2FzIHNwZWNpZmllZC5cbiAqL1xuY29uc3QgZmluYWxpemVPdXRwdXRzID0gKGFjdGlvbiwgcmVxdWlyZWRVdHhvcywgY2hhbmdlU2NyaXB0LCBkdXN0U2F0cyA9IGVjYXNoX2xpYl8xLkRFRkFVTFRfRFVTVF9TQVRTKSA9PiB7XG4gICAgLy8gTWFrZSBhIGRlZXAgY29weSBvZiBvdXRwdXRzIHRvIGF2b2lkIG11dGF0aW5nIHRoZSBhY3Rpb24gb2JqZWN0XG4gICAgY29uc3Qgb3V0cHV0cyA9IGFjdGlvbi5vdXRwdXRzLm1hcChvdXRwdXQgPT4gKHsgLi4ub3V0cHV0IH0pKTtcbiAgICBjb25zdCB0b2tlbkFjdGlvbnMgPSBhY3Rpb24udG9rZW5BY3Rpb25zO1xuICAgIGlmIChvdXRwdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG91dHB1dHMgc3BlY2lmaWVkLiBBbGwgYWN0aW9ucyBtdXN0IGhhdmUgb3V0cHV0cy5gKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBhbnkgYWRkcmVzcyBmaWVsZHMgdG8gc2NyaXB0IGZpZWxkcyBiZWZvcmUgcHJvY2Vzc2luZ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICBpZiAoJ2FkZHJlc3MnIGluIG91dHB1dCAmJiBvdXRwdXQuYWRkcmVzcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCBmcm9tIGFkZHJlc3MgdmFyaWFudCB0byBzY3JpcHQgdmFyaWFudCBvZiB0aGUgdW5pb24gdHlwZVxuICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzLCAuLi5yZXN0T2ZPdXRwdXQgfSA9IG91dHB1dDtcbiAgICAgICAgICAgIG91dHB1dHNbaV0gPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVzdE9mT3V0cHV0LFxuICAgICAgICAgICAgICAgIHNjcmlwdDogZWNhc2hfbGliXzEuU2NyaXB0LmZyb21BZGRyZXNzKGFkZHJlc3MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkbyBub3Qgc3VwcG9ydCBtYW51YWxseS1zcGVjaWZpZWQgbGVmdG92ZXIgb3V0cHV0c1xuICAgIC8vIGVjYXNoLXdhbGxldCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGEgbGVmdG92ZXIgb3V0cHV0XG4gICAgLy8gV2UgbWF5IGFkZCBzdXBwb3J0IGZvciBtYW51YWxseSBzcGVjaWZ5aW5nIE5PIGxlZnRvdmVyLCBidXQgcHJvYmFibHkgbm90XG4gICAgY29uc3QgbGVmdG92ZXJPdXRwdXRBcnIgPSBvdXRwdXRzLmZpbHRlcihvdXRwdXQgPT4gJ2J5dGVjb2RlJyBpbiBvdXRwdXQpO1xuICAgIGlmIChsZWZ0b3Zlck91dHB1dEFyci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZWNhc2gtd2FsbGV0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYSBsZWZ0b3ZlciBvdXRwdXQuIERvIG5vdCBzcGVjaWZ5IGEgbGVmdG92ZXIgb3V0cHV0IGluIHRoZSBvdXRwdXRzIGFycmF5LmApO1xuICAgIH1cbiAgICBjb25zdCB0b2tlblR5cGUgPSAoMCwgZXhwb3J0cy5nZXRUb2tlblR5cGUpKGFjdGlvbik7XG4gICAgY29uc3QgaXNUb2tlblR4ID0gdHlwZW9mIHRva2VuVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgLy8gQ2hlY2sgZm9yIGRhdGEgYWN0aW9uc1xuICAgIGNvbnN0IGRhdGFBY3Rpb25zID0gdG9rZW5BY3Rpb25zPy5maWx0ZXIoYWN0aW9uID0+IGFjdGlvbi50eXBlID09PSAnREFUQScpO1xuICAgIGlmIChkYXRhQWN0aW9ucyAmJiBkYXRhQWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIERhdGEgYWN0aW9ucyBhcmUgb25seSBzdXBwb3J0ZWQgZm9yIEFMUF9UT0tFTl9UWVBFX1NUQU5EQVJEIHRva2VuIGFjdGlvbnNcbiAgICAgICAgLy8gVXNlcnMgd2hvIHdhbnQgc3RyYWlnaHQtdXAgRU1QUCBpbiBhIHR4IG9yIHN0cmFpZ2h0LXVwIE9QX1JFVFVSTiBkbyBub3QgaW5jbHVkZVxuICAgICAgICAvLyBEYXRhQWN0aW9uIGluIHRva2VuQWN0aW9ucywgYnV0IGluc3RlYWQgc3BlY2lmeSB0aGVpciBPUF9SRVRVUk4gb3V0cHV0XG4gICAgICAgIGlmICh0b2tlblR5cGU/LnR5cGUgIT09ICdBTFBfVE9LRU5fVFlQRV9TVEFOREFSRCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSBhY3Rpb25zIGFyZSBvbmx5IHN1cHBvcnRlZCBmb3IgQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkQgdG9rZW4gYWN0aW9ucy5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBjYW4gaGF2ZSBvbmx5IDEgT1BfUkVUVVJOIG91dHB1dFxuICAgIC8vIEEgbm9uLXRva2VuIHR4IG11c3Qgc3BlY2lmeSBPUF9SRVRVUk4gb3V0cHV0IG1hbnVhbGx5XG4gICAgLy8gQSB0b2tlbiB0eCBtdXN0IHNwZWNpZnkgYSBibGFuayBPUF9SRVRVUk4gb3V0cHV0IGF0IGluZGV4IDBcbiAgICBjb25zdCBtYXhPcFJldHVybk91dHB1dHMgPSBpc1Rva2VuVHggPyAwIDogMTtcbiAgICAvLyBWYWxpZGF0ZSBPUF9SRVRVUk4gKHdlIGNhbiBoYXZlIG9ubHkgMSB0aGF0IGRvZXMgbm90IGJ1cm4gc2F0cylcbiAgICBjb25zdCBvcFJldHVybkFyciA9IG91dHB1dHMuZmlsdGVyKG91dHB1dCA9PiAnc2NyaXB0JyBpbiBvdXRwdXQgJiZcbiAgICAgICAgdHlwZW9mIG91dHB1dC5zY3JpcHQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG91dHB1dC5zY3JpcHQuYnl0ZWNvZGVbMF0gPT09IGVjYXNoX2xpYl8xLk9QX1JFVFVSTik7XG4gICAgaWYgKG9wUmV0dXJuQXJyLmxlbmd0aCA+IG1heE9wUmV0dXJuT3V0cHV0cykge1xuICAgICAgICBjb25zdCBvcFJldHVybkVyck1zZyA9IGlzVG9rZW5UeFxuICAgICAgICAgICAgPyBgQSB0b2tlbiB0eCBjYW5ub3Qgc3BlY2lmeSBhbnkgbWFudWFsIE9QX1JFVFVSTiBvdXRwdXRzLiBUb2tlbiB0eHMgY2FuIG9ubHkgaW5jbHVkZSBhIGJsYW5rIE9QX1JFVFVSTiBvdXRwdXQgKGkuZS4geyBzYXRzOiAwbn0gYXQgaW5kZXggMC5gXG4gICAgICAgICAgICA6IGBlY2FzaC13YWxsZXQgb25seSBzdXBwb3J0cyAxIE9QX1JFVFVSTiBwZXIgdHguICR7b3BSZXR1cm5BcnIubGVuZ3RofSBPUF9SRVRVUk4gb3V0cHV0cyBzcGVjaWZpZWQuYDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9wUmV0dXJuRXJyTXNnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3BSZXR1cm5BcnIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IG9wUmV0dXJuU2F0cyA9IG9wUmV0dXJuQXJyWzBdLnNhdHM7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgZXhhY3RseSAxIE9QX1JFVFVSTiwgdmFsaWRhdGUgd2UgZG8gbm90IGJ1cm4gc2F0c1xuICAgICAgICBpZiAob3BSZXR1cm5TYXRzICE9PSAwbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeCBidXJucyAke29wUmV0dXJuU2F0c30gc2F0b3NoaXMgaW4gT1BfUkVUVVJOIG91dHB1dC4gZWNhc2gtd2FsbGV0IGRvZXMgbm90IHN1cHBvcnQgYnVybmluZyBYRUMgaW4gdGhlIE9QX1JFVFVSTi5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHRva2VuVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5vbi10b2tlbiB0eCwgaS5lLiB0aGVyZSBhcmUgbm8gdG9rZW4gaW5wdXRzIG9yIG91dHB1dHNcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIERPIE5PVCBoYXZlIGEgYmxhbmsgT1BfUkVUVVJOIG91dHB1dFxuICAgICAgICBjb25zdCBibGFua09wUmV0dXJuT3V0cHV0ID0gb3V0cHV0cy5maWx0ZXIob3V0cHV0ID0+IE9iamVjdC5rZXlzKG91dHB1dCkubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAnc2F0cycgaW4gb3V0cHV0ICYmXG4gICAgICAgICAgICBvdXRwdXQuc2F0cyA9PT0gMG4pO1xuICAgICAgICBpZiAoYmxhbmtPcFJldHVybk91dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgYmxhbmsgT1BfUkVUVVJOIG91dHB1dCAoaS5lLiB7c2F0czogMG59KSBpcyBub3QgYWxsb3dlZCBpbiBhIG5vbi10b2tlbiB0eC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgdGhpcyBjYXNlLCB2YWxpZGF0aW9uIGlzIGZpbmlzaGVkXG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5wYXltZW50T3V0cHV0c1RvVHhPdXRwdXRzKShvdXRwdXRzLCBkdXN0U2F0cyk7XG4gICAgfVxuICAgIC8vIEV2ZXJ5dGhpbmcgYmVsb3cgaXMgZm9yIHRva2VuIHR4c1xuICAgIGlmICh0eXBlb2YgdG9rZW5BY3Rpb25zID09PSAndW5kZWZpbmVkJyB8fCB0b2tlbkFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgaW1wbGllZCB0b2tlbiBhY3Rpb24gYnkgb3V0cHV0cyBidXQgbm90IHRva2VuIGFjdGlvbnMgYXJlIHNwZWNpZmllZFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNwZWNpZmllZCBvdXRwdXRzIGltcGx5IHRva2VuIGFjdGlvbnMsIGJ1dCBubyB0b2tlbkFjdGlvbnMgc3BlY2lmaWVkLmApO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBhY3Rpb25zXG4gICAgKDAsIGV4cG9ydHMudmFsaWRhdGVUb2tlbkFjdGlvbnMpKHRva2VuQWN0aW9ucyk7XG4gICAgaWYgKHRva2VuVHlwZS5wcm90b2NvbCA9PT0gJ1NMUCcpIHtcbiAgICAgICAgLy8gU0xQIHRva2VucyBtYXkgaGF2ZSBvbmx5IG9uZSB0b2tlbiBhY3Rpb25cbiAgICAgICAgLy8gV2UgaGF2ZSBhIGtpbmQgb2YgZXhjZXB0aW9uIGZvciBtaW50aW5nIFNMUCBORlRzLCB3aGVyZSB3ZSBtdXN0IGNvbnN1bWUgLyBidXJuIGEgUGFyZW50IHRva2VuIHRvIG1pbnQgYSBjaGlsZFxuICAgICAgICAvLyBCdXQgZWNhc2gtd2FsbGV0IHRyZWF0cyB0aGlzIGFzIG9uZSBhY3Rpb24sIHNpbmNlIGl0IGlzIGEgdW5pcXVlIGNhc2VcbiAgICAgICAgaWYgKHRva2VuQWN0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBBbmQgd2UgaGF2ZSBtb3JlIHRoYW4gMSB0b2tlbkFjdGlvbiBzcGVjaWZpZWRcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0b2tlblR5cGUudHlwZX0gdG9rZW4gdHhzIG1heSBvbmx5IGhhdmUgYSBzaW5nbGUgdG9rZW4gYWN0aW9uLiAke3Rva2VuQWN0aW9ucy5sZW5ndGh9IHRva2VuQWN0aW9ucyBzcGVjaWZpZWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTkIgd2UgaGF2ZSBhbHJlYWR5IHZhbGlkYXRlZCB0aGF0LCBpZiBHZW5lc2lzQWN0aW9uIGV4aXN0cywgaXQgaXMgYXQgaW5kZXggMFxuICAgIGNvbnN0IGdlbmVzaXNBY3Rpb24gPSB0b2tlbkFjdGlvbnMuZmluZChhY3Rpb24gPT4gYWN0aW9uLnR5cGUgPT09ICdHRU5FU0lTJyk7XG4gICAgY29uc3QgZ2VuZXNpc0FjdGlvbk91dHB1dHMgPSBvdXRwdXRzLmZpbHRlcigobykgPT4gJ3Rva2VuSWQnIGluIG8gJiZcbiAgICAgICAgby50b2tlbklkID09PSBlY2FzaF9saWJfMS5wYXltZW50LkdFTkVTSVNfVE9LRU5fSURfUExBQ0VIT0xERVIpO1xuICAgIGlmIChnZW5lc2lzQWN0aW9uT3V0cHV0cy5sZW5ndGggPiAwICYmXG4gICAgICAgIHR5cGVvZiBnZW5lc2lzQWN0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdlbmVzaXMgb3V0cHV0cyBzcGVjaWZpZWQgd2l0aG91dCBHZW5lc2lzQWN0aW9uLiBNdXN0IGluY2x1ZGUgR2VuZXNpc0FjdGlvbiBvciByZW1vdmUgZ2VuZXNpcyBvdXRwdXRzLmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBTFBcbiAgICAgKiAtIFdlIGNhbiBoYXZlIG11bHRpcGxlIG1pbnQgYWN0aW9ucyAoYnV0IGVhY2ggbXVzdCBiZSBmb3IgYSBkaWZmZXJlbnQgdG9rZW5JZClcbiAgICAgKiBTTFBcbiAgICAgKiAtIFdlIGNhbiBoYXZlIE9OTFkgT05FIG1pbnQgYWN0aW9uXG4gICAgICovXG4gICAgY29uc3QgbWludEFjdGlvblRva2VuSWRzID0gbmV3IFNldCh0b2tlbkFjdGlvbnNcbiAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gYWN0aW9uLnR5cGUgPT09ICdNSU5UJylcbiAgICAgICAgLm1hcChhY3Rpb24gPT4gYWN0aW9uLnRva2VuSWQpKTtcbiAgICBjb25zdCBpbnZhbGlkTWludEJhdG9uT3V0cHV0cyA9IG91dHB1dHMuZmlsdGVyKChvdXRwdXQpID0+ICdpc01pbnRCYXRvbicgaW4gb3V0cHV0ICYmXG4gICAgICAgIG91dHB1dC5pc01pbnRCYXRvbiAmJlxuICAgICAgICAnYXRvbXMnIGluIG91dHB1dCAmJlxuICAgICAgICBvdXRwdXQuYXRvbXMgIT09IDBuKTtcbiAgICBpZiAoaW52YWxpZE1pbnRCYXRvbk91dHB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pbnQgYmF0b24gb3V0cHV0cyBtdXN0IGhhdmUgMCBhdG9tcy4gRm91bmQgJHtpbnZhbGlkTWludEJhdG9uT3V0cHV0cy5sZW5ndGh9IG1pbnQgYmF0b24gb3V0cHV0JHtpbnZhbGlkTWludEJhdG9uT3V0cHV0cy5sZW5ndGggPT0gMSA/ICcnIDogJ3MnfSB3aXRoIG5vbi16ZXJvIGF0b21zLmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBTFBcbiAgICAgKiAtIFdlIGNhbiBoYXZlIG11bHRpcGxlIGJ1cm4gYWN0aW9ucyAoYnV0IGVhY2ggbXVzdCBiZSBmb3IgYSBkaWZmZXJlbnQgdG9rZW5JZClcbiAgICAgKiBTTFBcbiAgICAgKiAtIFdlIGNhbiBoYXZlIE9OTFkgT05FIGJ1cm4gYWN0aW9uXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBhIGJ1cm4gYWN0aW9uIHNwZWNpZmllZCB3aXRoIG5vIHNwZWNpZmllZCBvdXRwdXRzIGFzc29jaWF0ZWRcbiAgICAgKiB3aXRoIHRoaXMgdG9rZW5JZC5cbiAgICAgKlxuICAgICAqIEZvciBBTFAsIGNhbiBhbHNvIHNwZWNpZnkgYSBTRU5EIGFjdGlvbiB3aXRoIGEgQlVSTiBhY3Rpb24sIGFuZCBubyBvdXRwdXRzLCBhbmQgZmluYWxpemVPdXRwdXRzXG4gICAgICogd2lsbCBhdXRvbWF0aWNhbGx5IHNpemUgYSBjaGFuZ2Ugb3V0cHV0IHRvIGFsbG93IGludGVudGlvbmFsIGJ1cm4gb2YgdXNlci1zcGVjaWZpZWQgYnVybkF0b21zLlxuICAgICAqXG4gICAgICogVGhpcyB3b3VsZCBiZSBleHBlY3RlZCBiZWhhdmlvciBmb3IgYW4gaW50ZW50aW9uYWwgQUxQIG9yIFNMUCBidXJuIG9mIDEwMCUgb2YgdG9rZW4gaW5wdXRzLlxuICAgICAqL1xuICAgIGNvbnN0IGJ1cm5BY3Rpb25Ub2tlbklkcyA9IG5ldyBTZXQodG9rZW5BY3Rpb25zXG4gICAgICAgIC5maWx0ZXIoYWN0aW9uID0+IGFjdGlvbi50eXBlID09PSAnQlVSTicpXG4gICAgICAgIC5tYXAoYWN0aW9uID0+IGFjdGlvbi50b2tlbklkKSk7XG4gICAgLy8gV2UgaWRlbnRpZnkgU0VORCBvdXRwdXRzIGZyb20gdXNlciBzcGVjaWZpZWQgU0VORCBhY3Rpb25cbiAgICBjb25zdCBzZW5kQWN0aW9uVG9rZW5JZHMgPSBuZXcgU2V0KHRva2VuQWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiBhY3Rpb24udHlwZSA9PT0gJ1NFTkQnKVxuICAgICAgICAubWFwKGFjdGlvbiA9PiBhY3Rpb24udG9rZW5JZCkpO1xuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdG9rZW5JZHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQWN0aW9uIGZyb20gdGhlIE91dHB1dHNcbiAgICAgKi9cbiAgICBjb25zdCB0b2tlbklkc1RoaXNBY3Rpb24gPSBuZXcgU2V0KG91dHB1dHNcbiAgICAgICAgLmZpbHRlcihvID0+ICd0b2tlbklkJyBpbiBvICYmXG4gICAgICAgIHR5cGVvZiBvLnRva2VuSWQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG8udG9rZW5JZCAhPT0gZWNhc2hfbGliXzEucGF5bWVudC5HRU5FU0lTX1RPS0VOX0lEX1BMQUNFSE9MREVSKVxuICAgICAgICAubWFwKG8gPT4gby50b2tlbklkKSk7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGRvIG5vdCBoYXZlIGFueSBvdXRwdXQtc3BlY2lmaWVkIHRva2VuSWRzIHRoYXQgYXJlIG5vdFxuICAgIC8vIGFzc29jaWF0ZWQgd2l0aCBhbnkgYWN0aW9uXG4gICAgZm9yIChjb25zdCB0b2tlbklkVGhpc0FjdGlvbiBvZiB0b2tlbklkc1RoaXNBY3Rpb24pIHtcbiAgICAgICAgaWYgKCFzZW5kQWN0aW9uVG9rZW5JZHMuaGFzKHRva2VuSWRUaGlzQWN0aW9uKSAmJlxuICAgICAgICAgICAgIWJ1cm5BY3Rpb25Ub2tlbklkcy5oYXModG9rZW5JZFRoaXNBY3Rpb24pICYmXG4gICAgICAgICAgICAhbWludEFjdGlvblRva2VuSWRzLmhhcyh0b2tlbklkVGhpc0FjdGlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT3V0cHV0LXNwZWNpZmllZCB0b2tlbklkICR7dG9rZW5JZFRoaXNBY3Rpb259IGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYW55IGFjdGlvbi4gUGxlYXNlIGVuc3VyZSB0aGF0IHRoZSB0b2tlbkFjdGlvbnMgbWF0Y2ggdGhlIG91dHB1dHMgc3BlY2lmaWVkIGluIHRoZSBhY3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2luY2UgdGhpcyBpcyBhIHRva2VuIEFjdGlvbiwgdmFsaWRhdGUgd2UgaGF2ZSBhIGJsYW5rIE9QX1JFVFVSTiB0ZW1wbGF0ZSBvdXRwdXQgYXQgb3V0SWR4IDBcbiAgICBjb25zdCBpbmRleFplcm9PdXRwdXQgPSBvdXRwdXRzWzBdO1xuICAgIGNvbnN0IGluZGV4WmVyb091dHB1dEtleXMgPSBPYmplY3Qua2V5cyhpbmRleFplcm9PdXRwdXQpO1xuICAgIGNvbnN0IGhhc0luZGV4WmVyb09wUmV0dXJuQmxhbmsgPSBpbmRleFplcm9PdXRwdXRLZXlzLmxlbmd0aCA9PT0gMSAmJiBpbmRleFplcm9PdXRwdXRLZXlzWzBdID09PSAnc2F0cyc7XG4gICAgaWYgKCFoYXNJbmRleFplcm9PcFJldHVybkJsYW5rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gYWN0aW9uIHJlcXVpcmVzIGEgYnVpbHQgT1BfUkVUVVJOIGF0IGluZGV4IDAgb2Ygb3V0cHV0cywgaS5lLiB7IHNhdHM6IDBuIH0uYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYSBTRU5EIG9yIEJVUk4gdHgsIHdlIChtYXkpIG5lZWQgdG8gZ2VuZXJhdGUgYW5kIGFkZCBjaGFuZ2Ugb3V0cHV0c1xuICAgICAqXG4gICAgICogV2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlbSB0byB2YWxpZGF0ZSB0aGVtLCBzbyB3ZSBtaWdodCBhcyB3ZWxsIGRvIHRoYXQgaGVyZVxuICAgICAqXG4gICAgICogQmVjYXVzZSBBY3Rpb24gaXMgYW4gb2JqZWN0IGFuZCBhIHBhcmFtIGluIHRoaXMgZnVuY3Rpb24sIGNoYW5nZXMgd2UgbWFrZSB0byB0aGUgb3V0cHV0cyBhcnJheVxuICAgICAqIGluIEFjdGlvbiB3aWxsIHBlcnNpc3Qgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbiB0aGUgY2xhc3NcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBJZiBhIHRva2VuIGlzXG4gICAgICogLSBTZW50IEFORCBidXJuZWRcbiAgICAgKiAgIC0gV2UgbWF5IG5lZWQgdG8gY2FsY3VsYXRlIGEgY2hhbmdlIG91dHB1dCB0aGF0IGZ1bGZpbGxzIGJ1cm5BdG9tcyBmcm9tIEJ1cm5BY3Rpb25cbiAgICAgKiAtIFNlbnQgb25seVxuICAgICAqICAgLSBXZSBtYXkgbmVlZCB0byBjYWxjdWxhdGUgYSBjaGFuZ2Ugb3V0cHV0IGJhc2VkIG9uIGF2YWlsYWJsZSBpbnB1dHMgdGhhdCBwcmV2ZW50c1xuICAgICAqICAgICBhIHRva2VuIGJ1cm5cbiAgICAgKlxuICAgICAqIFdlIG1heSBuZWVkIHRvIGdlbmVyYXRlIGFuIG91dHB1dCB0byBmdWxmaWxsIHRoZSB1c2VyLXNwZWNpZmllZCBhY3Rpb25cbiAgICAgKlxuICAgICAqIElmIGEgdG9rZW4gaXNcbiAgICAgKlxuICAgICAqIC0gQnVybmVkIG9ubHlcbiAgICAgKiAtIE1pbnRlZCBhbmQgYnVybmVkXG4gICAgICpcbiAgICAgKiBUaGVuIHdlIGNhbiBvbmx5IGJ1cm4gcXVhbnRpdGllcyB0aGF0IGV4YWN0bHkgbWF0Y2ggYXRvbXMgb2YgdGhpcyB0b2tlbiBpbiB0aGUgaW5wdXRzXG4gICAgICogV2Ugd2lsbCBub3QgZ2VuZXJhdGUgYW55IG91dHB1dHNcbiAgICAgKi9cbiAgICAvLyBHZXQgYWxsIHRva2VuSWRzIHRoYXQgYXJlIFNFTlQgYW5kIEJVUk5FRFxuICAgIGNvbnN0IHNlbmRBbmRCdXJuQWN0aW9uVG9rZW5JZHMgPSBuZXcgU2V0KCk7XG4gICAgc2VuZEFjdGlvblRva2VuSWRzLmZvckVhY2godG9rZW5JZCA9PiB7XG4gICAgICAgIGlmIChidXJuQWN0aW9uVG9rZW5JZHMuaGFzKHRva2VuSWQpKSB7XG4gICAgICAgICAgICBzZW5kQW5kQnVybkFjdGlvblRva2VuSWRzLmFkZCh0b2tlbklkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzZW5kQWN0aW9uVG9rZW5JZHMuc2l6ZSA+IDAgfHwgc2VuZEFuZEJ1cm5BY3Rpb25Ub2tlbklkcy5zaXplID4gMCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIGlmIHdlIG5lZWQgYSB0b2tlbiBjaGFuZ2Ugb3V0cHV0IChvciBvdXRwdXRzLCBwb3NzaWJseSwgaWYgQUxQKVxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgcmVxdWlyZWRVdHhvcyBpcyBhIGdlbmVyYXRlZCB2YWx1ZSwgc28gd2UgZG8gbm90IGV4cGVjdFxuICAgICAgICAgKiB0aGUgdmFsaWRhdGlvbiBlcnJvcnMgY2hlY2tlZCBoZXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IGlzIGV4cGVjdGVkIHRvIGhhdmUgPj0gYXRvbXMgbmVlZGVkIGZvciBhbnkgU0VORCBvciBCVVJOIGFjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gUG9zc2libGUgdXNlciBzcGVjaWZpZXMgYSBidXJuIGZvciBhIHRva2VuSWQgd2l0aCBubyBzcGVjaWZpZWQgU0VORCBvdXRwdXRzXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIGFsbCB0b2tlbklkcyB0aGF0IGFyZSBTRU5UIG9yIEJVUk5lZFxuICAgICAgICBjb25zdCBzZW5kT3JTZW5kQW5kQnVyblRva2VucyA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgLi4uc2VuZEFjdGlvblRva2VuSWRzLFxuICAgICAgICAgICAgLi4uc2VuZEFuZEJ1cm5BY3Rpb25Ub2tlbklkcyxcbiAgICAgICAgXSk7XG4gICAgICAgIHNlbmRPclNlbmRBbmRCdXJuVG9rZW5zLmZvckVhY2godG9rZW5JZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGVVdHhvc1RoaXNUb2tlbiA9IHJlcXVpcmVkVXR4b3MuZmlsdGVyKHV0eG8gPT4gJ3Rva2VuJyBpbiB1dHhvICYmIHV0eG8udG9rZW4/LnRva2VuSWQgPT09IHRva2VuSWQpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRBdG9tc1RoaXNUb2tlbiA9IGF2YWlsYWJsZVV0eG9zVGhpc1Rva2VuXG4gICAgICAgICAgICAgICAgLm1hcCh1dHhvID0+IHV0eG8udG9rZW4uYXRvbXMpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIGN1cnIsIDBuKTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dHNUaGlzVG9rZW4gPSBvdXRwdXRzLmZpbHRlcihvdXRwdXQgPT4gJ3Rva2VuSWQnIGluIG91dHB1dCAmJiBvdXRwdXQudG9rZW5JZCA9PT0gdG9rZW5JZCk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRBdG9tc1RoaXNUb2tlbiA9IG91dHB1dHNUaGlzVG9rZW5cbiAgICAgICAgICAgICAgICAubWFwKG91dHB1dCA9PiBvdXRwdXQuYXRvbXMpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgocHJldiwgY3VycikgPT4gcHJldiArIGN1cnIsIDBuKTtcbiAgICAgICAgICAgIGlmIChpbnB1dEF0b21zVGhpc1Rva2VuIDwgb3V0cHV0QXRvbXNUaGlzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgZXhwZWN0ZWQgdG8gaGFwcGVuIGluIGVjYXNoLXdhbGxldCwgYXMgd2Ugb25seSBjYWxsIGZpbmFsaXplT3V0cHV0cyB3aXRoXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlZCByZXF1aXJlZFV0eG9zXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgYXRvbXMgb2YgJHt0b2tlbklkfSBpbiBpbnB1dHMgKCR7aW5wdXRBdG9tc1RoaXNUb2tlbn0pIHRvIGNvdmVyIGF0b21zIHNwZWNpZmllZCBpbiBvdXRwdXRzICR7b3V0cHV0QXRvbXNUaGlzVG9rZW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRBdG9tc1RoaXNUb2tlbiA+PSBvdXRwdXRBdG9tc1RoaXNUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIG1heSBuZWVkIGEgY2hhbmdlIG91dHB1dC4gQ2hlY2sgZm9yIGludGVudGlvbmFsQnVybnNcbiAgICAgICAgICAgICAgICBsZXQgaW50ZW50aW9uYWxCdXJuQXRvbXNUaGlzVG9rZW4gPSAwbjtcbiAgICAgICAgICAgICAgICBpZiAoc2VuZEFuZEJ1cm5BY3Rpb25Ub2tlbklkcy5oYXModG9rZW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBidXJuIGF0b21zIGZvciB0aGlzIHRva2VuXG4gICAgICAgICAgICAgICAgICAgIGludGVudGlvbmFsQnVybkF0b21zVGhpc1Rva2VuID0gdG9rZW5BY3Rpb25zLmZpbmQoYnVybkFjdGlvbiA9PiBidXJuQWN0aW9uLnRva2VuSWQgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbklkICYmICdidXJuQXRvbXMnIGluIGJ1cm5BY3Rpb24pLmJ1cm5BdG9tcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG91dHB1dEF0b21zVGhpc1Rva2VuID5cbiAgICAgICAgICAgICAgICAgICAgaW5wdXRBdG9tc1RoaXNUb2tlbiAtIGludGVudGlvbmFsQnVybkF0b21zVGhpc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgXCJ0b28gbWFueVwiIG91dHB1dCBhdG9tcyBvZiBhIHRva2VuIGhlIHdpc2hlcyB0byBidXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5CIHdlIGRvIG5vdCBleHBlY3QgdGhpcyB0byBoYXBwZW4gaW4gZWNhc2gtd2FsbGV0IHVzYWdlIGFzIHRoZSBpbnB1dHMgd2lsbCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGVkIHRvIHN1cHBvcnQgdGhlIGJ1cm5BY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcHJvY2VzcyBidXJuIGFjdGlvbiBmb3IgJHt0b2tlbklkfTogb3V0cHV0IGF0b21zIGV4Y2VlZCBpbnB1dCBhdG9tcyBsZXNzIGJ1cm4gYXRvbXMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdGVkT3V0cHV0QXRvbXNUaGlzVG9rZW4gPSBvdXRwdXRBdG9tc1RoaXNUb2tlbiAtIGludGVudGlvbmFsQnVybkF0b21zVGhpc1Rva2VuO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dEF0b21zVGhpc1Rva2VuID4gYWRqdXN0ZWRPdXRwdXRBdG9tc1RoaXNUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIGEgY2hhbmdlIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VBdG9tcyA9IGlucHV0QXRvbXNUaGlzVG9rZW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0QXRvbXNUaGlzVG9rZW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZW50aW9uYWxCdXJuQXRvbXNUaGlzVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIC8vIE5CIGFkZGluZyBhIGNoYW5nZSBvdXRwdXQgY2FuIG1ha2UgdGhlIHR4IGludmFsaWQgYmFzZWQgb24gdGhlIG91dElkeCBvZlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2hhbmdlIG91dHB1dC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNoYW5nZSBvdXRwdXQgd2lsbCBiZSBhZGRlZCBhdCB0aGUgZW5kIG9mIHRoZSBvdXRwdXRzIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYXBwcm9hY2ggcHJlc2VydmVzIHRoZSBvdXRJZHggb2YgdGhlIHVzZXItc3BlY2lmaWVkIG91dHB1dHNcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY291bGQgYXR0ZW1wdCB0byBkbyBzb21ldGhpbmcgbGlrZSwgb25seSBhZGQgdG9rZW4gY2hhbmdlIG91dHB1dHNcbiAgICAgICAgICAgICAgICAgICAgLy8gYXQgYSB2YWxpZCBvdXRJZHgsIGlmIGF2YWlsYWJsZSAuLi4gYnV0IHRoaXMgd291bGQgZ2V0IGNvbmZ1c2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyB2ZXJ5IGZhc3QsIHdlIGRvIG5vdCB3YW50IHRvIGNoYW5nZSB0aGUgb3V0SWR4IG9mIHVzZXItc3BlY2lmaWVkIG91dHB1dHNcbiAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCB0aHJvdyBhIHNwZWNpZmljIGVycm9yIG1zZ1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VPdXRwdXRJZHggPSBvdXRwdXRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgU0xQIG9yIEFMUCBtYXggb3V0cHV0IHJ1bGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZU91dHB1dElkeE1heCA9IHRva2VuVHlwZS5wcm90b2NvbCA9PT0gJ1NMUCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZWNhc2hfbGliXzEuU0xQX01BWF9TRU5EX09VVFBVVFNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZWNhc2hfbGliXzEuQUxQX1BPTElDWV9NQVhfT1VUUFVUUztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZU91dHB1dElkeCA+IGNoYW5nZU91dHB1dElkeE1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeCBuZWVkcyBhIHRva2VuIGNoYW5nZSBvdXRwdXQgdG8gYXZvaWQgYnVybmluZyBhdG9tcyBvZiAke3Rva2VuSWR9LCBidXQgdGhlIHRva2VuIGNoYW5nZSBvdXRwdXQgd291bGQgYmUgYXQgb3V0SWR4ICR7Y2hhbmdlT3V0cHV0SWR4fSB3aGljaCBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBvdXRJZHggb2YgJHtjaGFuZ2VPdXRwdXRJZHhNYXh9IGZvciAke3Rva2VuVHlwZS50eXBlfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhZGQgYSB0b2tlbiBjaGFuZ2Ugb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXRzOiBkdXN0U2F0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuSWQ6IHRva2VuSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdG9tczogY2hhbmdlQXRvbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc01pbnRCYXRvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQ6IGNoYW5nZVNjcmlwdCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG1hcCB0byBzdG9yZSBsYXN0QXRvbXNPdXRJZHhcbiAgICAgKiB0b2tlbklkID0+IGxhc3RBdG9tc091dElkeFxuICAgICAqXG4gICAgICogRm9yIFNMUCwgY2FuIG9ubHkgZXZlciBoYXZlIG9uZSB0b2tlbklkXG4gICAgICogRm9yIEFMUCwgY2FuIGhhdmUgbWFueVxuICAgICAqL1xuICAgIC8vIHRva2VuSWQgPT4gbGFzdEF0b21zT3V0SWR4XG4gICAgY29uc3QgbGFzdEF0b21zT3V0SWR4TWFwID0gbmV3IE1hcCgpO1xuICAgIC8vIHRva2VuSWQgPT4gbnVtQmF0b25zXG4gICAgLy8gT25seSBuZWVkZWQgZm9yIEFMUF9UT0tFTl9UWVBFX1NUQU5EQVJEXG4gICAgY29uc3QgbnVtQmF0b25zTWFwID0gbmV3IE1hcCgpO1xuICAgIHN3aXRjaCAodG9rZW5UeXBlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnU0xQX1RPS0VOX1RZUEVfTUlOVF9WQVVMVCc6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmFsaWRhdGUgZm9yIHRva2VuSWQocykgYW5kIGFjdGlvbnNcbiAgICAgICAgICAgICAqIC0gU0xQIFNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQgY2FuIGhhdmUgT05MWSBnZW5lc2lzIG9yXG4gICAgICAgICAgICAgKiAgIE9OTFkgc2VuZCBvciBPTkxZIG1pbnQsIE9OTFkgd2l0aCBhIHNpbmdsZSB0b2tlbklkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTkIgZWNhc2gtd2FsbGV0IGRvZXMgbm90IGN1cnJlbnRseSBzdXBwb3J0IE1JTlQgZm9yIFNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQgdG9rZW5zXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGhhbmRsZWQgaW4gdmFsaWRhdGVUb2tlbkFjdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRva2VuSWRzVGhpc0FjdGlvbi5zaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gU0xQIFNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQgQWN0aW9uIG1heSBvbmx5IGJlIGFzc29jaWF0ZWQgd2l0aCBhIHNpbmdsZSB0b2tlbklkLiBGb3VuZCAke3Rva2VuSWRzVGhpc0FjdGlvbi5zaXplfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2VuZXNpc0FjdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICB0b2tlbklkc1RoaXNBY3Rpb24uc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBnZW5lc2lzIGFjdGlvbiBhbmQgYW55IG90aGVyIGFzc29jaWF0ZWQgdG9rZW5JZHNcbiAgICAgICAgICAgICAgICAvLyBOQiB0aGlzIGNvdmVycyB0aGUgY2FzZSBvZiBhdHRlbXB0aW5nIHRvIGNvbWJpbmUgR0VORVNJUyBhbmQgQlVSTlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gU0xQIFNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQgQWN0aW9uIHdpdGggYSBzcGVjaWZpZWQgZ2VuZXNpc0FjdGlvbiBtYXkgbm90IGhhdmUgYW55IG90aGVyIGFzc29jaWF0ZWQgdG9rZW4gYWN0aW9ucy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yIGFuIFNMUCBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSBBY3Rpb24sXG4gICAgICAgICAgICAgKiBpZiB3ZSBoYXZlIGFueSBzZW5kIG91dHB1dHMsIHRoZW4gd2UgY2Fubm90IGhhdmUgYW55IG90aGVyIHRva2VuIG91dHB1dHNcbiAgICAgICAgICAgICAqIGFuZCB3ZSBtYXkgT05MWSBoYXZlIGEgYnVybiBhY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHNlbmRBY3Rpb25Ub2tlbklkcy5zaXplID4gMCAmJiBtaW50QWN0aW9uVG9rZW5JZHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIFNMUCBTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxUIEFjdGlvbiB3aXRoIFNFTkQgb3V0cHV0cyBtYXkgbm90IGhhdmUgYW55IE1JTlQgb3V0cHV0cy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm93IHRoYXQgd2UgaGF2ZSB2YWxpZGF0ZWQgZXZlcnl0aGluZyB3ZSBjYW4gdmFsaWRhdGUgYXQgdGhlIEFjdGlvbiBhbmRcbiAgICAgICAgICAgICAqIE91dHB1dCBsZXZlbCwgaXRlcmF0ZSBvdmVyIG91dHB1dHMgdG8gdmFsaWRhdGUgZm9yIHNwZWMtcmVsYXRlZCByZXF1aXJlbWVudHNcbiAgICAgICAgICAgICAqIHJlbGF0ZWQgdG8gb3V0cHV0IG9yZGVyaW5nIGFuZCBpbmRpY2VzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU3BlY1xuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2JhZGdlci1jYXNoL3NscC1zcGVjaWZpY2F0aW9ucy9ibG9iL21hc3Rlci9zbHAtdG9rZW4tdHlwZS0yLm1kXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLSBNaW50IHF0eSBtdXN0IGJlIGF0IG91dElkeCAxIGZvciBHRU5FU0lTIHR4cyAoY2FuIGJlIGF0IDEgYW5kIG1vcmUgZm9yIE1JTlQgdHhzKVxuICAgICAgICAgICAgICogLSBNaW50IHR4cyBhcmUgb25seSB2YWxpZCBpZiB0aGVpciBibG9ja2hlaWdodCBpcyA+IGdlbmVzaXMgdHggYmxvY2toZWlnaHRcbiAgICAgICAgICAgICAqIC0gTm8gbWludCBiYXRvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoJ3Rva2VuSWQnIGluIG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0LmlzTWludEJhdG9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIFNMUCBTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxUIEFjdGlvbiBtYXkgbm90IGhhdmUgYW55IG1pbnQgYmF0b25zLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0b2tlbiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBlY2FzaF9saWJfMS5TTFBfTUFYX1NFTkRfT1VUUFVUUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBGb3IgYW4gU0xQIFNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQgYWN0aW9uLCB3ZSBjYW5ub3QgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogbW9yZSB0aGFuIFNMUF9NQVhfU0VORF9PVVRQVVRTICgxOSkgdG90YWwgdG9rZW4gb3V0cHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFdlIHdpbGwgc3VwcG9ydCBBY3Rpb25zIHdpdGggbW9yZSB0aGFuIDE5IG91dHB1dHMgd2hlbiB3ZSBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjaGFpbmVkIHR4cywgYnV0IGV2ZW4gaW4gdGhpcyBjYXNlIHRoZXJlIGFyZSBhZGRpdGlvbmFsIHJ1bGVzIChpLmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3ZSB3b3VsZCBvbmx5IHN1cHBvcnQgY2hhaW5lZCB0eHMgb2Ygc2VuZHMsIG5vdCBtaW50IG9yIGdlbmVzaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIG91dElkeCBpcyBoaWdoZXIgdGhhbiBTTFBfTUFYX1NFTkRfT1VUUFVUUywgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIE5CIHdlIG5lZWQgdG8gdmFsaWRhdGUgbm90IGp1c3QgZm9yIG1heCBvdXRwdXRzLCBidXQgYWxzbyBmb3IgbWF4IG91dElkeCwgdGhpcyBhcHByb2FjaCBkb2VzIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBTTFAgU0xQX1RPS0VOX1RZUEVfTUlOVF9WQVVMVCBBY3Rpb24gbWF5IG5vdCBoYXZlIG1vcmUgdGhhbiAke2VjYXNoX2xpYl8xLlNMUF9NQVhfU0VORF9PVVRQVVRTfSB0b2tlbiBvdXRwdXRzLCBhbmQgbm8gb3V0cHV0cyBtYXkgYmUgYXQgb3V0SWR4ID4gJHtlY2FzaF9saWJfMS5TTFBfTUFYX1NFTkRfT1VUUFVUU30uIEZvdW5kIG91dHB1dCBhdCBvdXRJZHggJHtpfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VuZEFjdGlvblRva2VuSWRzLmhhcyhvdXRwdXQudG9rZW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0b2tlbiBzZW5kIG91dHB1dCwgdXBkYXRlIGxhc3RBdG9tc091dElkeCBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RBdG9tc091dElkeE1hcC5zZXQob3V0cHV0LnRva2VuSWQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhdCBvdXRJZHggb2YgMVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdlbmVzaXNBY3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgZ2VuZXNpcyBhY3Rpb24gc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgndG9rZW5JZCcgaW4gb3V0cHV0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC50b2tlbklkICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2FzaF9saWJfMS5wYXltZW50LkdFTkVTSVNfVE9LRU5fSURfUExBQ0VIT0xERVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBpZiBvdXRwdXQgYXQgb3V0SWR4IDEgaXMgTk9UIGEgZ2VuZXNpcy1yZWxhdGVkIG1pbnQgcXVhbnRpdHkgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHZW5lc2lzIGFjdGlvbiBmb3IgU0xQX1RPS0VOX1RZUEVfTUlOVF9WQVVMVCB0b2tlbiBzcGVjaWZpZWQsIGJ1dCBubyBtaW50IHF1YW50aXR5IG91dHB1dCBmb3VuZCBhdCBvdXRJZHggMS4gVGhpcyBpcyBhIHNwZWMgcmVxdWlyZW1lbnQgZm9yIFNMUCBTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxUIHRva2Vucy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgY29udGludWUgdG8gdGhlIG5leHQgb3V0cHV0LCBubyBmdXJ0aGVyIHZhbGlkYXRpb24gcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZ2VuZXNpc0FjdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgJ3Rva2VuSWQnIGluIG91dHB1dCAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudG9rZW5JZCA9PT0gZWNhc2hfbGliXzEucGF5bWVudC5HRU5FU0lTX1RPS0VOX0lEX1BMQUNFSE9MREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVzaXMgdHggY2Fubm90IGhhdmUgYW55IG1pbnQgcXR5IG91dHB1dCBvdGhlciB0aGFuIHRoZSBvbmUgYXQgb3V0SWR4IDFcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBTTFAgU0xQX1RPS0VOX1RZUEVfTUlOVF9WQVVMVCBHRU5FU0lTIHR4IG1heSBoYXZlIG9ubHkgb25lIG1pbnQgcXR5IG91dHB1dCBhbmQgaXQgbXVzdCBiZSBhdCBvdXRJZHggMS4gRm91bmQgYW5vdGhlciBtaW50IHF0eSBvdXRwdXQgYXQgb3V0SWR4ICR7aX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWwgZmFsbCB0aHJvdWdoIGFzIFNMUF9UT0tFTl9UWVBFX05GVDFfR1JPVVAgdG9rZW5zIGhhdmUgc2FtZSBzcGVjIGFzIFNMUF9UT0tFTl9UWVBFX0ZVTkdJQkxFIHRva2Vuc1xuICAgICAgICAvLyBJbnRlbnRpb25hbCBmYWxsIHRocm91Z2ggYXMgU0xQX1RPS0VOX1RZUEVfTkZUMV9DSElMRCB0b2tlbnMgaGF2ZSBzYW1lIHNwZWMgYXMgU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEUgdG9rZW5zXG4gICAgICAgIC8vIFRoZXJlIGlzIGEgdW5pcXVlIGNhc2Ugd2hlcmUgd2UgYnVybiBleGFjdGx5IDEgU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUCwgYnV0IHRoYXQgaXMgaGFuZGxlZCBpbiB0aGUgaW5wdXRzLCBuZWVkZWQgZm9yIHNlbGVjdGluZyB1dHhvcywgb25seSBmb3IgbWludGluZyBhIFNMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTERcbiAgICAgICAgLy8gSXQgaXMgbm90IHRlY2huaWNhbGx5IGEgQlVSTiBhY3Rpb25cbiAgICAgICAgY2FzZSAnU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUCc6XG4gICAgICAgIGNhc2UgJ1NMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTEQnOlxuICAgICAgICBjYXNlICdTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSc6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmFsaWRcbiAgICAgICAgICAgICAqIC0gbm8gdG9rZW4gYWN0aW9ucyBhbmQgbm8gdG9rZW4gb3V0cHV0c1xuICAgICAgICAgICAgICogLSBubyB0b2tlbiBhY3Rpb25zIGFuZCBzZW5kIG91dHB1dHMgb2YgYSBzaW5nbGUgdG9rZW5JZCBPTkxZXG4gICAgICAgICAgICAgKiAtIG5vIHRva2VuIGFjdGlvbnMgYW5kIGJ1cm4gb3V0cHV0cyBPTkxZXG4gICAgICAgICAgICAgKiAtIE1JTlQgYWN0aW9uIG9ubHkgYW5kIG5vIHNlbmQgb3V0cHV0c1xuICAgICAgICAgICAgICogLSBHRU5FU0lTIGFjdGlvbiBvbmx5IGFuZCBubyBzZW5kIG91dHB1dHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gRmxhZ3MgdG8gdmFsaWRhdGUgd2UgRE8gTk9UIGhhdmUgbW9yZSB0aGFuIG9uZSBtaW50IGJhdG9uXG4gICAgICAgICAgICBsZXQgaGFzRXh0ZW5kZWRNaW50aW5nTWludEJhdG9uID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZhbGlkYXRlIGZvciB0b2tlbklkKHMpIGFuZCBhY3Rpb25zXG4gICAgICAgICAgICAgKiAtIFNMUCBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSBjYW4gaGF2ZSBPTkxZIGdlbmVzaXMgb3JcbiAgICAgICAgICAgICAqICAgT05MWSBzZW5kIG9yIE9OTFkgbWludCwgT05MWSB3aXRoIGEgc2luZ2xlIHRva2VuSWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRva2VuSWRzVGhpc0FjdGlvbi5zaXplID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gU0xQICR7dG9rZW5UeXBlLnR5cGV9IEFjdGlvbiBtYXkgb25seSBiZSBhc3NvY2lhdGVkIHdpdGggYSBzaW5nbGUgdG9rZW5JZC4gRm91bmQgJHt0b2tlbklkc1RoaXNBY3Rpb24uc2l6ZX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdlbmVzaXNBY3Rpb24gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgdG9rZW5JZHNUaGlzQWN0aW9uLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgZ2VuZXNpcyBhY3Rpb24gYW5kIGFueSBvdGhlciBhc3NvY2lhdGVkIHRva2VuSWRzXG4gICAgICAgICAgICAgICAgLy8gTkIgdGhpcyBjb3ZlcnMgdGhlIGNhc2Ugb2YgYXR0ZW1wdGluZyB0byBjb21iaW5lIEdFTkVTSVMgYW5kIEJVUk5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIFNMUCAke3Rva2VuVHlwZS50eXBlfSBBY3Rpb24gd2l0aCBhIHNwZWNpZmllZCBnZW5lc2lzQWN0aW9uIG1heSBub3QgaGF2ZSBhbnkgb3RoZXIgYXNzb2NpYXRlZCB0b2tlbiBhY3Rpb25zLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGb3IgYW4gU0xQIFNMUF9UT0tFTl9UWVBFX0ZVTkdJQkxFIEFjdGlvbixcbiAgICAgICAgICAgICAqIGlmIHdlIGhhdmUgYW55IHNlbmQgb3V0cHV0cywgdGhlbiB3ZSBjYW5ub3QgaGF2ZSBhbnkgb3RoZXIgdG9rZW4gb3V0cHV0c1xuICAgICAgICAgICAgICogYW5kIHdlIG1heSBPTkxZIGhhdmUgYSBidXJuIGFjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc2VuZEFjdGlvblRva2VuSWRzLnNpemUgPiAwICYmIG1pbnRBY3Rpb25Ub2tlbklkcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gU0xQICR7dG9rZW5UeXBlLnR5cGV9IEFjdGlvbiB3aXRoIFNFTkQgb3V0cHV0cyBtYXkgbm90IGhhdmUgYW55IE1JTlQgb3V0cHV0cy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm93IHRoYXQgd2UgaGF2ZSB2YWxpZGF0ZWQgZXZlcnl0aGluZyB3ZSBjYW4gdmFsaWRhdGUgYXQgdGhlIEFjdGlvbiBhbmRcbiAgICAgICAgICAgICAqIE91dHB1dCBsZXZlbCwgaXRlcmF0ZSBvdmVyIG91dHB1dHMgdG8gdmFsaWRhdGUgZm9yIHNwZWMtcmVsYXRlZCByZXF1aXJlbWVudHNcbiAgICAgICAgICAgICAqIHJlbGF0ZWQgdG8gb3V0cHV0IG9yZGVyaW5nIGFuZCBpbmRpY2VzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRm9yIFNMUCBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSwgbWludCBxdHkgYW5kIG1pbnQgYmF0b24gb3V0cHV0IHZhbGlkYXRpb24gaXNcbiAgICAgICAgICAgICAqIHNpbXBsaWZpZWQgYnkgc3RyaWN0IHNwZWMgcmVxdWlyZW1lbnRzXG4gICAgICAgICAgICAgKiAtIE1pbnQgcXR5IG11c3QgYmUgYXQgb3V0SWR4IDFcbiAgICAgICAgICAgICAqIC0gQ2FuIG9ubHkgaGF2ZSAxIG1pbnQgYmF0b24sIG11c3QgYmUgYXQgb3V0SWR4IDItMjU1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCd0b2tlbklkJyBpbiBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRva2VuIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IGVjYXNoX2xpYl8xLlNMUF9NQVhfU0VORF9PVVRQVVRTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEZvciBhbiBTTFAgU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEUgYWN0aW9uLCB3ZSBjYW5ub3QgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogbW9yZSB0aGFuIFNMUF9NQVhfU0VORF9PVVRQVVRTICgxOSkgdG90YWwgdG9rZW4gb3V0cHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFdlIHdpbGwgc3VwcG9ydCBBY3Rpb25zIHdpdGggbW9yZSB0aGFuIDE5IG91dHB1dHMgd2hlbiB3ZSBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBjaGFpbmVkIHR4cywgYnV0IGV2ZW4gaW4gdGhpcyBjYXNlIHRoZXJlIGFyZSBhZGRpdGlvbmFsIHJ1bGVzIChpLmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3ZSB3b3VsZCBvbmx5IHN1cHBvcnQgY2hhaW5lZCB0eHMgb2Ygc2VuZHMsIG5vdCBtaW50IG9yIGdlbmVzaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIG91dElkeCBpcyBoaWdoZXIgdGhhbiBTTFBfTUFYX1NFTkRfT1VUUFVUUywgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIE5CIHdlIG5lZWQgdG8gdmFsaWRhdGUgbm90IGp1c3QgZm9yIG1heCBvdXRwdXRzLCBidXQgYWxzbyBmb3IgbWF4IG91dElkeCwgdGhpcyBhcHByb2FjaCBkb2VzIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBTTFAgJHt0b2tlblR5cGUudHlwZX0gQWN0aW9uIG1heSBub3QgaGF2ZSBtb3JlIHRoYW4gJHtlY2FzaF9saWJfMS5TTFBfTUFYX1NFTkRfT1VUUFVUU30gdG9rZW4gb3V0cHV0cywgYW5kIG5vIG91dHB1dHMgbWF5IGJlIGF0IG91dElkeCA+ICR7ZWNhc2hfbGliXzEuU0xQX01BWF9TRU5EX09VVFBVVFN9LiBGb3VuZCBvdXRwdXQgYXQgb3V0SWR4ICR7aX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbmRBY3Rpb25Ub2tlbklkcy5oYXMob3V0cHV0LnRva2VuSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdG9rZW4gc2VuZCBvdXRwdXQsIHVwZGF0ZSBsYXN0QXRvbXNPdXRJZHggbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0QXRvbXNPdXRJZHhNYXAuc2V0KG91dHB1dC50b2tlbklkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYXQgb3V0SWR4IG9mIDFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW5lc2lzQWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGdlbmVzaXMgYWN0aW9uIHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ3Rva2VuSWQnIGluIG91dHB1dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudG9rZW5JZCAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWNhc2hfbGliXzEucGF5bWVudC5HRU5FU0lTX1RPS0VOX0lEX1BMQUNFSE9MREVSIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmlzTWludEJhdG9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgaWYgb3V0cHV0IGF0IG91dElkeCAxIGlzIE5PVCBhIGdlbmVzaXMtcmVsYXRlZCBtaW50IHF1YW50aXR5IG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR2VuZXNpcyBhY3Rpb24gZm9yICR7dG9rZW5UeXBlLnR5cGV9IHRva2VuIHNwZWNpZmllZCwgYnV0IG5vIG1pbnQgcXVhbnRpdHkgb3V0cHV0IGZvdW5kIGF0IG91dElkeCAxLiBUaGlzIGlzIGEgc3BlYyByZXF1aXJlbWVudCBmb3IgU0xQICR7dG9rZW5UeXBlLnR5cGV9IHRva2Vucy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgY29udGludWUgdG8gdGhlIG5leHQgb3V0cHV0LCBubyBmdXJ0aGVyIHZhbGlkYXRpb24gcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1pbnRBY3Rpb25Ub2tlbklkcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG5vbi1nZW5lc2lzIG1pbnQgYWN0aW9uIGltcGxpZWQgYnkgb3V0cHV0c1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ3Rva2VuSWQnIGluIG91dHB1dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhbWludEFjdGlvblRva2VuSWRzLmhhcyhvdXRwdXQudG9rZW5JZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaXNNaW50QmF0b24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3V0cHV0IGF0IG91dElkeCAxIGZvciBhbiBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSB0eCB3aXRoIGEgbWludCBxdHkgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgTk9UIGEgbWludCBxdWFudGl0eSBvdXRwdXQsIHRocm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWMgcmVxdWlyZW1lbnQgZm9yIFNMUCBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSB0b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pbnQgYWN0aW9uIGZvciAke3Rva2VuVHlwZS50eXBlfSB0b2tlbiBzcGVjaWZpZWQsIGJ1dCBubyBtaW50IHF1YW50aXR5IG91dHB1dCBmb3VuZCBhdCBvdXRJZHggMS4gVGhpcyBpcyBhIHNwZWMgcmVxdWlyZW1lbnQgZm9yIFNMUCAke3Rva2VuVHlwZS50eXBlfSB0b2tlbnMuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBvdXRJZHggMSBpcyBhIG1pbnQgcXR5IG91dHB1dCwgbm8gZnVydGhlciB2YWxpZGF0aW9uIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ2lzTWludEJhdG9uJyBpbiBvdXRwdXQgJiYgb3V0cHV0LmlzTWludEJhdG9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5CIHRoYXQgZ2VuZXNpcyB0eHMgYW5kIE1JTlQgdHhzIGJvdGggYXJlIGxpbWl0ZWQgdG8gYSBzaW5nbGUgbWludCBiYXRvbiBhdCBvdXRJZHggMi0yNTVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0V4dGVuZGVkTWludGluZ01pbnRCYXRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgMm5kIG1pbnQgYmF0b24gd2UgaGF2ZSBmb3VuZCwgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gJHt0b2tlblR5cGUudHlwZX0gJHt0eXBlb2YgZ2VuZXNpc0FjdGlvbiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdHRU5FU0lTJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ01JTlQnfSB0eCBtYXkgb25seSBzcGVjaWZ5IGV4YWN0bHkgMSBtaW50IGJhdG9uLiBGb3VuZCBzZWNvbmQgbWludCBiYXRvbiBhdCBvdXRJZHggJHtpfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IDIgfHwgaSA+IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG91dElkeCBvZiB0aGUgbWludCBiYXRvbiBpcyBvZmYgc3BlYywgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gJHt0b2tlblR5cGUudHlwZX0gJHt0eXBlb2YgZ2VuZXNpc0FjdGlvbiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdHRU5FU0lTJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ01JTlQnfSB0eCBtaW50IGJhdG9uLCBpZiBwcmVzZW50LCBtdXN0IGJlIGF0IG91dElkeCAyLTI1NS4gTWludCBiYXRvbiBmb3VuZCBhdCBvdXRJZHggJHtpfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYXNFeHRlbmRlZE1pbnRpbmdNaW50QmF0b24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgndG9rZW5JZCcgaW4gb3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICFvdXRwdXQuaXNNaW50QmF0b24gJiZcbiAgICAgICAgICAgICAgICAgICAgbWludEFjdGlvblRva2VuSWRzLmhhcyhvdXRwdXQudG9rZW5JZCkpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2VuZXNpc0FjdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b2tlbklkJyBpbiBvdXRwdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC50b2tlbklkID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjYXNoX2xpYl8xLnBheW1lbnQuR0VORVNJU19UT0tFTl9JRF9QTEFDRUhPTERFUiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIW91dHB1dC5pc01pbnRCYXRvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXNpcyB0eCBhbmQgTUlOVCB0eCBjYW5ub3QgaGF2ZSBhbnkgbWludCBxdHkgb3V0cHV0IG90aGVyIHRoYW4gdGhlIG9uZSBhdCBvdXRJZHggMVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuICR7dG9rZW5UeXBlLnR5cGV9ICR7dHlwZW9mIGdlbmVzaXNBY3Rpb24gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdHRU5FU0lTJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnTUlOVCd9IHR4IG1heSBoYXZlIG9ubHkgb25lIG1pbnQgcXR5IG91dHB1dCBhbmQgaXQgbXVzdCBiZSBhdCBvdXRJZHggMS4gRm91bmQgYW5vdGhlciBtaW50IHF0eSBvdXRwdXQgYXQgb3V0SWR4ICR7aX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkQnOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFMUF9UT0tFTl9UWVBFX1NUQU5EQVJEXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLSBNYXkgb25seSBoYXZlIGEgc2luZ2xlIGdlbmVzaXNBY3Rpb25cbiAgICAgICAgICAgICAqIC0gTWF5IG5vdCBjb21iaW5lIE1JTlQgYW5kIFNFTkQgYWN0aW9ucyBmb3IgdGhlIHNhbWUgdG9rZW5JZFxuICAgICAgICAgICAgICogLSBNYXkgaGF2ZSBtdWx0aXBsZSBtaW50IGJhdG9ucywgYnV0IG11c3QgYmUgY29uc2VjdXRpdmUgYW5kIGhhdmUgaGlnaGVyIGluZGV4IHRoYW4gcXR5IG91dHB1dHNcbiAgICAgICAgICAgICAqIC0gTWF5IGhhdmUgbXVsdGlwbGUgbWludCBxdWFudGl0aWVzXG4gICAgICAgICAgICAgKiAtIEZvciBub3csIGFsbCBvdXRwdXRzIG11c3QgYmUgYXQgb3V0SWR4IDEgPD0gb3V0SWR4IDw9IDI5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yIGFuIEFMUF9UT0tFTl9UWVBFX1NUQU5EQVJEIEFjdGlvbixcbiAgICAgICAgICAgICAqIHdlIGNhbm5vdCBoYXZlIFNFTkQgYW5kIE1JTlQgb3V0cHV0cyBmb3IgdGhlIHNhbWUgdG9rZW5JZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc2VuZEFjdGlvblRva2VuSWRzLnNpemUgPiAwICYmIG1pbnRBY3Rpb25Ub2tlbklkcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbmRBY3Rpb25Ub2tlbklkcy5mb3JFYWNoKHNlbnRUb2tlbklkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbnRBY3Rpb25Ub2tlbklkcy5oYXMoc2VudFRva2VuSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIEFMUCBBTFBfVE9LRU5fVFlQRV9TVEFOREFSRCBBY3Rpb24gY2Fubm90IGhhdmUgU0VORCBhbmQgTUlOVCBvdXRwdXRzIGZvciB0aGUgc2FtZSB0b2tlbklkLiBGb3VuZCBTRU5EIGFuZCBNSU5UIG91dHB1dHMgZm9yIHRva2VuSWQgJHtzZW50VG9rZW5JZH0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZsYWdzIGZvciB2YWxpZGF0aW5nIG1pbnQgYmF0b24ocylcbiAgICAgICAgICAgIGxldCBsYXN0T3V0cHV0TWludEJhdG9uVG9rZW5JZDtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuSWRzV2l0aE1pbnRCYXRvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICgndG9rZW5JZCcgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0b2tlbiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBlY2FzaF9saWJfMS5BTFBfUE9MSUNZX01BWF9PVVRQVVRTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEZvciBhbiBBTFAgQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkQgYWN0aW9uLCB3ZSBjYW5ub3QgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogbW9yZSB0aGFuIEFMUF9QT0xJQ1lfTUFYX09VVFBVVFMgKDI5KSB0b3RhbCB0b2tlbiBvdXRwdXRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgdGhlIDEtdHggbGltaXQgZ2l2ZW4gY3VycmVudCBPUF9SRVRVUk4gbGltaXQgKDIyMyBieXRlcykuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogV2Ugd2lsbCBzdXBwb3J0IEFjdGlvbnMgd2l0aCBtb3JlIHRoYW4gMjkgb3V0cHV0cyB3aGVuIHdlIHN1cHBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGNoYWluZWQgdHhzLCBidXQgZXZlbiBpbiB0aGlzIGNhc2UgdGhlcmUgYXJlIGFkZGl0aW9uYWwgcnVsZXMgKGkuZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdlIHdpbGwgcHJvYmFibHkgb25seSBzdXBwb3J0IGNoYWluZWQgdHhzIG9mIHNlbmRzLCBub3QgbWludCBvciBnZW5lc2lzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBvdXRJZHggaXMgaGlnaGVyIHRoYW4gQUxQX1BPTElDWV9NQVhfT1VUUFVUUywgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIE5CIHdlIG5lZWQgdG8gdmFsaWRhdGUgbm90IGp1c3QgZm9yIG1heCBvdXRwdXRzLCBidXQgYWxzbyBmb3IgbWF4IG91dElkeCwgdGhpcyBhcHByb2FjaCBkb2VzIGJvdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBBTFAgQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkQgQWN0aW9uIG1heSBub3QgaGF2ZSBtb3JlIHRoYW4gJHtlY2FzaF9saWJfMS5BTFBfUE9MSUNZX01BWF9PVVRQVVRTfSB0b2tlbiBvdXRwdXRzLCBhbmQgbm8gb3V0cHV0cyBtYXkgYmUgYXQgb3V0SWR4ID4gJHtlY2FzaF9saWJfMS5BTFBfUE9MSUNZX01BWF9PVVRQVVRTfS4gRm91bmQgb3V0cHV0IGF0IG91dElkeCAke2l9LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgnYXRvbXMnIGluIG91dHB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmlzTWludEJhdG9uID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Rva2VuSWQnIGluIG91dHB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZEFjdGlvblRva2VuSWRzLmhhcyhvdXRwdXQudG9rZW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBub24tbWludCBiYXRvbiBub24tbWludCBzZW5kIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxhc3RBdG9tc091dElkeCBmb3IgdGhpcyB0b2tlbklkIHRvIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RBdG9tc091dElkeE1hcC5zZXQob3V0cHV0LnRva2VuSWQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnaXNNaW50QmF0b24nIGluIG91dHB1dCAmJiBvdXRwdXQuaXNNaW50QmF0b24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG91dHB1dCBpcyBhIG1pbnQgYmF0b25cbiAgICAgICAgICAgICAgICAgICAgLy8gTkIgdGhpcyBhbHNvIGluY2x1ZGVzIEdFTkVTSVMgbWludCBiYXRvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZFRoaXNPdXRwdXQgPSAndG9rZW5JZCcgaW4gb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IG91dHB1dC50b2tlbklkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVjYXNoX2xpYl8xLnBheW1lbnQuR0VORVNJU19UT0tFTl9JRF9QTEFDRUhPTERFUjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGaXJzdE1pbnRCYXRvblRoaXNUb2tlbklkID0gIXRva2VuSWRzV2l0aE1pbnRCYXRvbnMuaGFzKHRva2VuSWRUaGlzT3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RNaW50QmF0b25UaGlzVG9rZW5JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgbWludCBiYXRvbiBmb3IgdGhpcyB0b2tlbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGxhc3RBdG9tc091dElkeCBmb3IgdGhpcyB0b2tlbklkIHRvIGktMVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEF0b21zT3V0SWR4TWFwLnNldCh0b2tlbklkVGhpc091dHB1dCwgaSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBiYXRvbnMgbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1CYXRvbnNNYXAuc2V0KHRva2VuSWRUaGlzT3V0cHV0LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgTk9UIHRoZSBmaXJzdCBtaW50IGJhdG9uIGlmIHRoaXMgdG9rZW5JZCwgdGhlbiBpdCBtdXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSBwYXJ0IG9mIGEgY29uc2VjdXRpdmUgc3RyaW5nIG9mIG1pbnQgYmF0b24gb3V0cHV0cyBvZiB0aGlzIHRva2VuSWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0T3V0cHV0TWludEJhdG9uVG9rZW5JZCAhPT0gdG9rZW5JZFRoaXNPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBtaW50IGJhdG9uIHdhcyBub3QgZm9yIHRoaXMgdG9rZW5JZCwgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIEFMUCBBTFBfVE9LRU5fVFlQRV9TVEFOREFSRCBBY3Rpb24gbWF5IG9ubHkgaGF2ZSBjb25zZWN1dGl2ZSBtaW50IGJhdG9uIG91dHB1dHMgZm9yIHRoZSBzYW1lIHRva2VuSWQuIEZvdW5kIG5vbi1jb25zZWN1dGl2ZSBtaW50IGJhdG9uIG91dHB1dCBhdCBvdXRJZHggJHtpfSBmb3IgJHt0b2tlbklkVGhpc091dHB1dCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWNhc2hfbGliXzEucGF5bWVudC5HRU5FU0lTX1RPS0VOX0lEX1BMQUNFSE9MREVSXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYEdFTkVTSVMgYWN0aW9uYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGB0b2tlbklkICR7dG9rZW5JZFRoaXNPdXRwdXR9YH0uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnQgbnVtQmF0b25zTWFwXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1CYXRvbnNNYXAuc2V0KHRva2VuSWRUaGlzT3V0cHV0LCBudW1CYXRvbnNNYXAuZ2V0KHRva2VuSWRUaGlzT3V0cHV0KSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBmbGFnXG4gICAgICAgICAgICAgICAgICAgIGxhc3RPdXRwdXRNaW50QmF0b25Ub2tlbklkID0gdG9rZW5JZFRoaXNPdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuSWRzV2l0aE1pbnRCYXRvbnMuYWRkKHRva2VuSWRUaGlzT3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGlvbiBjb21wbGV0ZSBmb3IgdGhpcyBvdXRwdXQsIGdvIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgndG9rZW5JZCcgaW4gb3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIG1pbnRBY3Rpb25Ub2tlbklkcy5oYXMob3V0cHV0LnRva2VuSWQpICYmXG4gICAgICAgICAgICAgICAgICAgICFvdXRwdXQuaXNNaW50QmF0b24pIHx8XG4gICAgICAgICAgICAgICAgICAgICgndG9rZW5JZCcgaW4gb3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudG9rZW5JZCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2FzaF9saWJfMS5wYXltZW50LkdFTkVTSVNfVE9LRU5fSURfUExBQ0VIT0xERVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFvdXRwdXQuaXNNaW50QmF0b24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBtaW50IHF0eSBvdXRwdXQgKE1JTlQgb3IgR0VORVNJUylcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZFRoaXNPdXRwdXQgPSAndG9rZW5JZCcgaW4gb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IG91dHB1dC50b2tlbklkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVjYXNoX2xpYl8xLnBheW1lbnQuR0VORVNJU19UT0tFTl9JRF9QTEFDRUhPTERFUjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuSWRzV2l0aE1pbnRCYXRvbnMuaGFzKHRva2VuSWRUaGlzT3V0cHV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbHJlYWR5IHNlZW4gbWludCBiYXRvbnMgZm9yIHRoaXMgdG9rZW5JZCwgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9yIGEgZ2l2ZW4gdG9rZW5JZCwgYW4gQUxQIEFMUF9UT0tFTl9UWVBFX1NUQU5EQVJEIEFjdGlvbiBtYXkgbm90IGhhdmUgbWludCBxdHkgb3V0cHV0cyBhdCBhIGhpZ2hlciBvdXRJZHggdGhhbiBtaW50IGJhdG9uIG91dHB1dHMuIE1pbnQgcXR5IG91dHB1dCBmb3IgJHt0b2tlbklkVGhpc091dHB1dCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2FzaF9saWJfMS5wYXltZW50LkdFTkVTSVNfVE9LRU5fSURfUExBQ0VIT0xERVJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBHRU5FU0lTIGFjdGlvbmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBhIHRva2VuSWRgfSB3aXRoIHByZWNlZGluZyBtaW50IGJhdG9ucyBmb3VuZCBhdCBvdXRJZHggJHtpfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbGFzdEF0b21zT3V0SWR4IGZvciB0aGlzIHRva2VuSWRcbiAgICAgICAgICAgICAgICAgICAgbGFzdEF0b21zT3V0SWR4TWFwLnNldCh0b2tlbklkVGhpc091dHB1dCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5CIHdlIGNvdWxkIHZhbGlkYXRlIGF0b21zIGhlcmUsIGJ1dCB0aGlzIGlzIHZhbGlkYXRlZCBieSBhbHAgbWV0aG9kcyBpbiBlY2FzaC1saWJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGxhc3RPdXRwdXRNaW50QmF0b25Ub2tlbklkIGZsYWcgZm9yIGFsbCBvdXRwdXRzIHRoYXQgYXJlIG5vdCBtaW50IGJhdG9uc1xuICAgICAgICAgICAgICAgIGxhc3RPdXRwdXRNaW50QmF0b25Ub2tlbklkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0b2tlblR5cGUgJHt0b2tlblR5cGUudHlwZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGlvbiBjb21wbGV0ZSBhbmQgYW55IGdlbmVyYXRlZCBvdXRwdXRzIGFkZGVkIHRvIG91dHB1dHMgYXJyYXlcbiAgICAgKiBOb3cgd2UgY2FuIGJ1aWxkIHRoZSBPUF9SRVRVUk5cbiAgICAgKlxuICAgICAqIFdlIGRvIGl0IGluIHRoaXMgZnVuY3Rpb24gYmVjYXVzZSB0aGUgc2FtZSB2YWxpZGF0aW9uIHN0ZXBzIGFyZSByZXF1aXJlZFxuICAgICAqIFNvLCBpZiB3ZSBzZXBhcmF0ZSB0aGUgZnVuY3Rpb24sIGl0IGRvZXNuJ3QgcmVhbGx5IHdvcmsgYXMgYSBzdGFuZC1hbG9uZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIGdlbmVzaXMgaW5mb1xuICAgICAqXG4gICAgICogQUxQXG4gICAgICogYXRvbXNBcnJheSwgbnVtQmF0b25zXG4gICAgICpcbiAgICAgKiBTTFBcbiAgICAgKiBhdG9tc1xuICAgICAqIG1pbnRCYXRvbk91dElkeFxuICAgICAqL1xuICAgIGxldCBvcFJldHVyblNjcmlwdDtcbiAgICBzd2l0Y2ggKHRva2VuVHlwZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1NMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQnOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5CIGZvciBTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxULCBsYXN0QXRvbXNPdXRJZHggaXMgb25seSByZWxldmFudCBmb3IgYSBzZW5kIHR4XG4gICAgICAgICAgICAgKiBXZSBkbyBub3QgbmVlZCB0aGlzIGluZm8gZm9yIGdlbmVzaXMgYXMgdGhlcmUgY2FuIGJlIG9ubHkgb25lIHF0eSBvdXRwdXRcbiAgICAgICAgICAgICAqIFdlIHdvdWxkIG5lZWQgdGhpcyBpbmZvIGZvciBNSU5ULCBidXQgdGhpcyBpcyBub3QgeWV0IHN1cHBvcnRlZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5CIGZvciBTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxULCB3ZSBleHBlY3Qgb25seSAxIG9yIDAgZW50cmllcyBpbiBsYXN0QXRvbXNPdXRJZHhNYXBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gR0VORVNJUyBhY3Rpb24gbWludCBxdHksIGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGxldCBtaW50UXVhbnRpdHk7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGV4cGVjdCAwIG9yIDEgZW50cmllcyBpbiBsYXN0QXRvbXNLZXlWYWx1ZUFyciBmb3IgU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEVcbiAgICAgICAgICAgIGNvbnN0IGxhc3RBdG9tc0tleVZhbHVlQXJyID0gbGFzdEF0b21zT3V0SWR4TWFwXG4gICAgICAgICAgICAgICAgLmVudHJpZXMoKVxuICAgICAgICAgICAgICAgIC5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBsYXN0QXRvbXNPdXRJZHggPSB0eXBlb2YgbGFzdEF0b21zS2V5VmFsdWVBcnIgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyBsYXN0QXRvbXNLZXlWYWx1ZUFyclsxXVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gV2lsbCBvbmx5IGhhdmUgb25lIGZvciBTTFAuIE5lY2Vzc2FyeSBmb3IgU0VORC5cbiAgICAgICAgICAgIC8vIE5CIFNMUCBNSU5UIHR4cyBtYXkgb25seSBoYXZlIDEgbWludCBxdHkgYW5kIDEgbWludCBiYXRvblxuICAgICAgICAgICAgY29uc3QgYXRvbXNBcnJheSA9IFtdO1xuICAgICAgICAgICAgLy8gTkIgd2Ugc3RhcnQgaXRlcmF0aW5nIGF0IGk9MSBiYyB3ZSBkbyBub3QgaGF2ZSB0byBkbyBhbnl0aGluZyBmb3IgdGhlIG91dElkeCAwIE9QX1JFVFVSTiBvdXRwdXRcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3V0cHV0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCd0b2tlbklkJyBpbiBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbmRBY3Rpb25Ub2tlbklkcy5oYXMob3V0cHV0LnRva2VuSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdG9rZW4gU0VORCBvdXRwdXQsIHdlIG11c3QgYWRkIGl0cyBhdG9tcyB0byB0aGUgYXRvbXNBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTkIgZm9yIFNMUF9UT0tFTl9UWVBFX0ZVTkdJQkxFIHdlIG9ubHkgdXNlIGF0b21zQXJyYXkgZm9yIFNFTkQgYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBhdG9tc0FycmF5LnB1c2gob3V0cHV0LmF0b21zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3Rva2VuSWQnIGluIG91dHB1dCAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudG9rZW5JZCA9PT0gZWNhc2hfbGliXzEucGF5bWVudC5HRU5FU0lTX1RPS0VOX0lEX1BMQUNFSE9MREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBtaW50IHF0eSBvdXRwdXQgKEdFTkVTSVMgb3IgTUlOVClcbiAgICAgICAgICAgICAgICAgICAgbWludFF1YW50aXR5ID0gb3V0cHV0LmF0b21zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXRvbXNBcnJheS5sZW5ndGggIT09IGkgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA8PSBlY2FzaF9saWJfMS5TTFBfTUFYX1NFTkRfT1VUUFVUUyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdEF0b21zT3V0SWR4ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICBpIDw9IGxhc3RBdG9tc091dElkeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWQgbm90IGFkZCBhdG9tcyB0byBhdG9tc0FycmF5IGZvciB0aGlzIG91dElkeFxuICAgICAgICAgICAgICAgICAgICAvLyBBTkQgd2UgYXJlIHN0aWxsIGRlYWxpbmcgd2l0aCBvdXRJZHggdmFsdWVzIHRoYXQgYXJlIGFzc29jaWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBTTFAgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIC8vIEFORCB3ZSBzdGlsbCBleHBlY3QgYW5vdGhlciBvdXRJZHggYXNzb2NpYXRlZCB3aXRoIHRoaXMgdG9rZW4gc2VuZCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAvLyBUSEVOIGFkZCAwbiBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAvLyBOQiB3ZSBvbmx5IHVzZSBhdG9tc0FycmF5IGZvciBTTFAgU0VORCBvciBCVVJOIGZvciBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRVxuICAgICAgICAgICAgICAgICAgICBhdG9tc0FycmF5LnB1c2goMG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWludFF1YW50aXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtaW50IHF1YW50aXR5IChmb3IgU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEUsIHRoaXMgaXMgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAvLyBmb3IgYWxsIEdFTkVTSVMgYW5kIE1JTlQgYWN0aW9ucylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdlbmVzaXNBY3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBHRU5FU0lTIHR4LCBidWlsZCBhIEdFTkVTSVMgT1BfUkVUVVJOXG4gICAgICAgICAgICAgICAgICAgIG9wUmV0dXJuU2NyaXB0ID0gKDAsIGVjYXNoX2xpYl8xLnNscEdlbmVzaXMpKGdlbmVzaXNBY3Rpb24udG9rZW5UeXBlLm51bWJlciwgZ2VuZXNpc0FjdGlvbi5nZW5lc2lzSW5mbywgbWludFF1YW50aXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChidXJuQWN0aW9uVG9rZW5JZHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidXJuQXRvbXMgPSB0b2tlbkFjdGlvbnNbMF1cbiAgICAgICAgICAgICAgICAgICAgLmJ1cm5BdG9tcztcbiAgICAgICAgICAgICAgICBvcFJldHVyblNjcmlwdCA9ICgwLCBlY2FzaF9saWJfMS5zbHBCdXJuKSh0b2tlbkFjdGlvbnNbMF0udG9rZW5JZCwgdG9rZW5UeXBlLm51bWJlciwgYnVybkF0b21zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNFTkRcbiAgICAgICAgICAgICAgICBvcFJldHVyblNjcmlwdCA9ICgwLCBlY2FzaF9saWJfMS5zbHBTZW5kKSh0b2tlbkFjdGlvbnNbMF0udG9rZW5JZCwgdG9rZW5UeXBlLm51bWJlciwgYXRvbXNBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXcml0ZSBvdmVyIHRoZSBibGFuayBPUF9SRVRVUk4gb3V0cHV0IGF0IGluZGV4IDBcbiAgICAgICAgICAgIG91dHB1dHNbMF0uc2NyaXB0ID0gb3BSZXR1cm5TY3JpcHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbCBmYWxsIHRocm91Z2ggYXMgU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUCB0b2tlbnMgaGF2ZSBzYW1lIHNwZWMgYXMgU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEUgdG9rZW5zXG4gICAgICAgIC8vIEludGVudGlvbmFsIGZhbGwgdGhyb3VnaCBhcyBTTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEIHRva2VucyBoYXZlIHNhbWUgc3BlYyBhcyBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSB0b2tlbnNcbiAgICAgICAgY2FzZSAnU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUCc6XG4gICAgICAgIGNhc2UgJ1NMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTEQnOlxuICAgICAgICBjYXNlICdTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSc6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTkIgZm9yIFNMUF9UT0tFTl9UWVBFX0ZVTkdJQkxFLCBsYXN0QXRvbXNPdXRJZHggaXMgb25seSByZWxldmFudCBmb3IgYSBzZW5kIHR4XG4gICAgICAgICAgICAgKiBXZSBkbyBub3QgbmVlZCB0aGlzIGluZm8gZm9yIG1pbnQgb3IgZ2VuZXNpcyBhcyB0aGVyZSBjYW4gYmUgb25seSBvbmUgcXR5IG91dHB1dFxuICAgICAgICAgICAgICogYW5kIGl0IG11c3QgYmUgYXQgb3V0SWR4IDEsIGFuZCBvbmx5IDEgbWludCBiYXRvblxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5CIGZvciBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSwgd2UgZXhwZWN0IG9ubHkgMSBvciAwIGVudHJpZXMgaW4gbGFzdEF0b21zT3V0SWR4TWFwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIEdFTkVTSVMgb3IgTUlOVCBhY3Rpb24gbWludCBxdHksIGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGxldCBtaW50UXVhbnRpdHk7XG4gICAgICAgICAgICAvLyBHRU5FU0lTIG9yIE1JTlQgYWN0aW9uIG1pbnQgYmF0b24gb3V0SWR4LCBpZiBhcHBsaWNhYmxlXG4gICAgICAgICAgICBsZXQgbWludEJhdG9uT3V0SWR4O1xuICAgICAgICAgICAgLy8gV2Ugb25seSBleHBlY3QgMCBvciAxIGVudHJpZXMgaW4gbGFzdEF0b21zS2V5VmFsdWVBcnIgZm9yIFNMUF9UT0tFTl9UWVBFX0ZVTkdJQkxFXG4gICAgICAgICAgICBjb25zdCBsYXN0QXRvbXNLZXlWYWx1ZUFyciA9IGxhc3RBdG9tc091dElkeE1hcFxuICAgICAgICAgICAgICAgIC5lbnRyaWVzKClcbiAgICAgICAgICAgICAgICAubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbGFzdEF0b21zT3V0SWR4ID0gdHlwZW9mIGxhc3RBdG9tc0tleVZhbHVlQXJyICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gbGFzdEF0b21zS2V5VmFsdWVBcnJbMV1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIFdpbGwgb25seSBoYXZlIG9uZSBmb3IgU0xQLiBOZWNlc3NhcnkgZm9yIFNFTkQuXG4gICAgICAgICAgICAvLyBOQiBTTFAgTUlOVCB0eHMgbWF5IG9ubHkgaGF2ZSAxIG1pbnQgcXR5IGFuZCAxIG1pbnQgYmF0b25cbiAgICAgICAgICAgIGNvbnN0IGF0b21zQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIC8vIE5CIHdlIHN0YXJ0IGl0ZXJhdGluZyBhdCBpPTEgYmMgd2UgZG8gbm90IGhhdmUgdG8gZG8gYW55dGhpbmcgZm9yIHRoZSBvdXRJZHggMCBPUF9SRVRVUk4gb3V0cHV0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG91dHB1dHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICgndG9rZW5JZCcgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZW5kQWN0aW9uVG9rZW5JZHMuaGFzKG91dHB1dC50b2tlbklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRva2VuIFNFTkQgb3V0cHV0LCB3ZSBtdXN0IGFkZCBpdHMgYXRvbXMgdG8gdGhlIGF0b21zQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5CIGZvciBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSB3ZSBvbmx5IHVzZSBhdG9tc0FycmF5IGZvciBTRU5EIGFjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgYXRvbXNBcnJheS5wdXNoKG91dHB1dC5hdG9tcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgndG9rZW5JZCcgaW4gb3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIG1pbnRBY3Rpb25Ub2tlbklkcy5oYXMob3V0cHV0LnRva2VuSWQpICYmXG4gICAgICAgICAgICAgICAgICAgICFvdXRwdXQuaXNNaW50QmF0b24pIHx8XG4gICAgICAgICAgICAgICAgICAgICgndG9rZW5JZCcgaW4gb3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQudG9rZW5JZCA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlY2FzaF9saWJfMS5wYXltZW50LkdFTkVTSVNfVE9LRU5fSURfUExBQ0VIT0xERVIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFvdXRwdXQuaXNNaW50QmF0b24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBtaW50IHF0eSBvdXRwdXQgKEdFTkVTSVMgb3IgTUlOVClcbiAgICAgICAgICAgICAgICAgICAgbWludFF1YW50aXR5ID0gb3V0cHV0LmF0b21zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ2lzTWludEJhdG9uJyBpbiBvdXRwdXQgJiYgb3V0cHV0LmlzTWludEJhdG9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBtaW50IGJhdG9uIG91dHB1dCAoR0VORVNJUyBvciBNSU5UKVxuICAgICAgICAgICAgICAgICAgICBtaW50QmF0b25PdXRJZHggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXRvbXNBcnJheS5sZW5ndGggIT09IGkgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA8PSBlY2FzaF9saWJfMS5TTFBfTUFYX1NFTkRfT1VUUFVUUyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdEF0b21zT3V0SWR4ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgICAgICBpIDw9IGxhc3RBdG9tc091dElkeCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWQgbm90IGFkZCBhdG9tcyB0byBhdG9tc0FycmF5IGZvciB0aGlzIG91dElkeFxuICAgICAgICAgICAgICAgICAgICAvLyBBTkQgd2UgYXJlIHN0aWxsIGRlYWxpbmcgd2l0aCBvdXRJZHggdmFsdWVzIHRoYXQgYXJlIGFzc29jaWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBTTFAgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIC8vIEFORCB3ZSBzdGlsbCBleHBlY3QgYW5vdGhlciBvdXRJZHggYXNzb2NpYXRlZCB3aXRoIHRoaXMgdG9rZW4gc2VuZCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAvLyBUSEVOIGFkZCAwbiBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAvLyBOQiB3ZSBvbmx5IHVzZSBhdG9tc0FycmF5IGZvciBTTFAgU0VORCBvciBCVVJOIGZvciBTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRVxuICAgICAgICAgICAgICAgICAgICBhdG9tc0FycmF5LnB1c2goMG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWludFF1YW50aXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtaW50IHF1YW50aXR5IChmb3IgU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEUsIHRoaXMgaXMgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAvLyBmb3IgYWxsIEdFTkVTSVMgYW5kIE1JTlQgYWN0aW9ucylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdlbmVzaXNBY3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHF1YW50aXR5IDFuIGZvciBORlQgZ2VuZXNpc1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXNpc0FjdGlvbi50b2tlblR5cGUudHlwZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVjYXNoX2xpYl8xLlNMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTEQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgdmFsaWRhdGUgdGhhdCBTTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEIG1pbnRzIGFyZSBvbmx5IGZvciBxdHkgMW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5CIGNocm9uaWsgd2lsbCBhbHNvIHRocm93IGFuIGVycm9yIGlmIHRoaXMgYnJvYWRjYXN0cyBhcyBpdCBmYWlscyB0b2tlbiBjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW50UXVhbnRpdHkgIT09IDFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBTTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEIEdFTkVTSVMgdHggbXVzdCBoYXZlIDEgYXRvbSBhdCBvdXRJZHggMS4gRm91bmQgJHttaW50UXVhbnRpdHl9IGF0b21zLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBHRU5FU0lTIHR4LCBidWlsZCBhIEdFTkVTSVMgT1BfUkVUVVJOXG4gICAgICAgICAgICAgICAgICAgIG9wUmV0dXJuU2NyaXB0ID0gKDAsIGVjYXNoX2xpYl8xLnNscEdlbmVzaXMpKGdlbmVzaXNBY3Rpb24udG9rZW5UeXBlLm51bWJlciwgZ2VuZXNpc0FjdGlvbi5nZW5lc2lzSW5mbywgbWludFF1YW50aXR5LCBcbiAgICAgICAgICAgICAgICAgICAgLy8gTkIgbWludEJhdG9uT3V0SWR4IG1heSBiZSB1bmRlZmluZWQsIGltcGx5aW5nIGEgZ2VuZXNpcyB0eCB3aXRoIG5vIG1pbnQgYmF0b25cbiAgICAgICAgICAgICAgICAgICAgbWludEJhdG9uT3V0SWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBNSU5UIHR4XG4gICAgICAgICAgICAgICAgICAgIG9wUmV0dXJuU2NyaXB0ID0gKDAsIGVjYXNoX2xpYl8xLnNscE1pbnQpKHRva2VuQWN0aW9uc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRva2VuSWQsIHRva2VuVHlwZS5udW1iZXIsIG1pbnRRdWFudGl0eSwgbWludEJhdG9uT3V0SWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChidXJuQWN0aW9uVG9rZW5JZHMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidXJuQXRvbXMgPSB0b2tlbkFjdGlvbnNbMF1cbiAgICAgICAgICAgICAgICAgICAgLmJ1cm5BdG9tcztcbiAgICAgICAgICAgICAgICBvcFJldHVyblNjcmlwdCA9ICgwLCBlY2FzaF9saWJfMS5zbHBCdXJuKSh0b2tlbkFjdGlvbnNbMF0udG9rZW5JZCwgdG9rZW5UeXBlLm51bWJlciwgYnVybkF0b21zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNFTkRcbiAgICAgICAgICAgICAgICBvcFJldHVyblNjcmlwdCA9ICgwLCBlY2FzaF9saWJfMS5zbHBTZW5kKSh0b2tlbkFjdGlvbnNbMF0udG9rZW5JZCwgdG9rZW5UeXBlLm51bWJlciwgYXRvbXNBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXcml0ZSBvdmVyIHRoZSBibGFuayBPUF9SRVRVUk4gb3V0cHV0IGF0IGluZGV4IDBcbiAgICAgICAgICAgIG91dHB1dHNbMF0uc2NyaXB0ID0gb3BSZXR1cm5TY3JpcHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdBTFBfVE9LRU5fVFlQRV9TVEFOREFSRCc6IHtcbiAgICAgICAgICAgIC8vIEFMUCB0b2tlbiB0eHMgbWF5IGhhdmUgbXVsdGlwbGUgYWN0aW9ucywgZWFjaCB3aXRoIGl0cyBvd24gRU1QUCBwdXNoIHdpdGhpbiBlbXBwU2NyaXB0QXJyXG4gICAgICAgICAgICAvLyBOQiB0aGVyZSBtYXkgYmUgb25seSBvbmUgR0VORVNJUyBwdXNoIGFuZCBpdCBtdXN0IGJlIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIC8vIE5CIHdlIGhhdmUgYWxyZWFkeSB2YWxpZGF0ZWQgZm9yIHRoZSBjb25kaXRpb24gb2YgXCJvbmUgZ2VuZXNpc1wiXG4gICAgICAgICAgICBjb25zdCBlbXBwU2NyaXB0QXJyID0gW107XG4gICAgICAgICAgICAvLyBBTFAgdHhzIG1heSBoYXZlIG11bHRpcGxlIGF0b21zQXJyYXlzIGZvciBtdWx0aXBsZSB0b2tlbklkc1xuICAgICAgICAgICAgLy8gQUxQIGdlbmVzaXMgdHggYWxzbyBuZWVkcyBhbiBhdG9tc0FycmF5IGFzIEFMUCBnZW5lc2lzIHN1cHBvcnRzIG11bHRpcGxlIG1pbnQgcXR5cyBhbmQgbWludCBiYXRvbnMsXG4gICAgICAgICAgICAvLyB1bmxpa2UgU0xQIGdlbmVzaXNcbiAgICAgICAgICAgIC8vIHRva2VuSWQgPT4gYXRvbXNBcnJheVxuICAgICAgICAgICAgY29uc3QgYXRvbXNBcnJheU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8vIEluaXQgYXRvbXNBcnJheU1hcCB3aXRoIGFuIGVtcHR5IGFycmF5IGZvciBlYWNoIHRva2VuSWQgdGhhdCB3aWxsIG5lZWQgYW4gYXRvbXNBcnJheSBpbiB0aGlzIHR4XG4gICAgICAgICAgICBsYXN0QXRvbXNPdXRJZHhNYXAuZm9yRWFjaCgoX2xhc3RBdG9tc091dElkeCwgdG9rZW5JZCkgPT4ge1xuICAgICAgICAgICAgICAgIGF0b21zQXJyYXlNYXAuc2V0KHRva2VuSWQsIFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQnVpbGQgYXRvbXNBcnJheSBmb3IgZWFjaCB0b2tlbklkIHRoYXQgbmVlZHMgb25lXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvbmRpdGlvbnMgdG8gYWRkIGEgMCB0byBhdG9tcyBhcnJheVxuICAgICAgICAgICAgICAgICAqIC0gaSA8IGxhc3RBdG9tc091dElkeCBmb3IgdGhpcyB0b2tlbklkXG4gICAgICAgICAgICAgICAgICogLSBvdXRwdXQgaXMgbm90IHJlbGF0ZWQgdG8gdGhlIHRva2VuSWQgb2YgdGhlIGF0b21zIGFycmF5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYXRvbXNBcnJheU1hcC5mb3JFYWNoKChhdG9tc0FycmF5LCB0b2tlbklkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXRvbXNBcnJheXMgZG8gbm90IHJlcXVpcmUgYW4gaW5wdXQgZm9yIGluZGV4IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXRvbXNPdXRJZHhUaGlzVG9rZW5JZCA9IGxhc3RBdG9tc091dElkeE1hcC5nZXQodG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDw9IGxhc3RBdG9tc091dElkeFRoaXNUb2tlbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vdCB5ZXQgcGFzc2VkIGxhc3RBdG9tc091dElkeCBmb3IgdGhpcyB0b2tlbklkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5JZCA9PT0gZWNhc2hfbGliXzEucGF5bWVudC5HRU5FU0lTX1RPS0VOX0lEX1BMQUNFSE9MREVSICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2F0b21zJyBpbiBvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgZ2VuZXNpcyBvdXRwdXQgYW5kIHdlIGFyZSB3b3JraW5nIHdpdGggdGhlIGdlbmVzaXMgYXRvbXNBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhdG9tc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0b21zQXJyYXkucHVzaChvdXRwdXQuYXRvbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJ3Rva2VuSWQnIGluIG91dHB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC50b2tlbklkID09PSB0b2tlbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5vbi1nZW5lc2lzIHRva2VuLWFzc29jaWF0ZWQgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGl0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRva2VuSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdG9tc0FycmF5LnB1c2gob3V0cHV0LmF0b21zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgb3V0cHV0IHNob3VsZCBub3QgYmUgY29sb3JlZCBmb3IgdGhpcyB0b2tlbklkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdlIGFyZSBub3QgeWV0IHRvIGxhc0F0b21zT3V0SWR4LCBhZGQgMG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdG9tc0FycmF5LnB1c2goMG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgd2UgaGF2ZSBhbGwgdGhlIGF0b21zQXJyYXkocykgd2UgbmVlZFxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIE9QX1JFVFVSTlxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIE9QX1JFVFVSTiBpbiBvcmRlciBvZiBzcGVjaWZpZWQgdG9rZW5BY3Rpb25zXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiB0b2tlbkFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHR5cGUgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnR0VORVNJUyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVzaXNFbXBwUHVzaCA9ICgwLCBlY2FzaF9saWJfMS5hbHBHZW5lc2lzKShnZW5lc2lzQWN0aW9uLnRva2VuVHlwZS5udW1iZXIsIGdlbmVzaXNBY3Rpb24uZ2VuZXNpc0luZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdG9tc0FycmF5OiBhdG9tc0FycmF5TWFwLmdldChlY2FzaF9saWJfMS5wYXltZW50LkdFTkVTSVNfVE9LRU5fSURfUExBQ0VIT0xERVIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUJhdG9uczogbnVtQmF0b25zTWFwLmdldChlY2FzaF9saWJfMS5wYXltZW50LkdFTkVTSVNfVE9LRU5fSURfUExBQ0VIT0xERVIpID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHBTY3JpcHRBcnIucHVzaChnZW5lc2lzRW1wcFB1c2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU0VORCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5JZCB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhpc0F0b21zQXJyYXkgPSBhdG9tc0FycmF5TWFwLmdldCh0b2tlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHBTY3JpcHRBcnIucHVzaCgoMCwgZWNhc2hfbGliXzEuYWxwU2VuZCkodG9rZW5JZCwgdG9rZW5UeXBlLm51bWJlciwgdGhpc0F0b21zQXJyYXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ01JTlQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuSWQgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNBdG9tc0FycmF5ID0gYXRvbXNBcnJheU1hcC5nZXQodG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBwU2NyaXB0QXJyLnB1c2goKDAsIGVjYXNoX2xpYl8xLmFscE1pbnQpKHRva2VuSWQsIHRva2VuVHlwZS5udW1iZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdG9tc0FycmF5OiB0aGlzQXRvbXNBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1CYXRvbnM6IG51bUJhdG9uc01hcC5nZXQodG9rZW5JZCkgPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0JVUk4nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOQiB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBhdG9tc0FycmF5IGZvciBjYXNlICdTRU5EJyBmb3IgYWN0aW9ucyB0aGF0IHNlbmQgYW5kIGJ1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5JZCwgYnVybkF0b21zIH0gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXBwU2NyaXB0QXJyLnB1c2goKDAsIGVjYXNoX2xpYl8xLmFscEJ1cm4pKHRva2VuSWQsIHRva2VuVHlwZS5udW1iZXIsIGJ1cm5BdG9tcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnREFUQSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgYXJiaXRyYXJ5IGRhdGEgYXMgYW4gRU1QUCBwdXNoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHBTY3JpcHRBcnIucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW4gYXMgd2UgaGF2ZSBhbHJlYWR5IHZhbGlkYXRlZCBhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRva2VuIGFjdGlvbiB0eXBlOiAke3R5cGV9LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tYmluZSBhbGwgQUxQIEVNUFAgcHVzaGVzIGludG8gdGhlIE9QX1JFVFVSTlxuICAgICAgICAgICAgb3BSZXR1cm5TY3JpcHQgPSAoMCwgZWNhc2hfbGliXzEuZW1wcFNjcmlwdCkoZW1wcFNjcmlwdEFycik7XG4gICAgICAgICAgICBjb25zdCBvcFJldHVybkJ5dGVzID0gb3BSZXR1cm5TY3JpcHQuYnl0ZWNvZGUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9wUmV0dXJuQnl0ZXMgPiBlY2FzaF9saWJfMS5PUF9SRVRVUk5fTUFYX0JZVEVTKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTcGVjaWZpZWQgYWN0aW9uIHJlc3VsdHMgaW4gT1BfUkVUVVJOIG9mICR7b3BSZXR1cm5CeXRlc30gYnl0ZXMsIHZzIG1heCBhbGxvd2VkIG9mICR7ZWNhc2hfbGliXzEuT1BfUkVUVVJOX01BWF9CWVRFU30uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXcml0ZSBvdmVyIHRoZSBibGFuayBPUF9SRVRVUk4gb3V0cHV0IGF0IGluZGV4IDBcbiAgICAgICAgICAgIG91dHB1dHNbMF0uc2NyaXB0ID0gb3BSZXR1cm5TY3JpcHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIGV4cG9ydHMucGF5bWVudE91dHB1dHNUb1R4T3V0cHV0cykob3V0cHV0cywgZHVzdFNhdHMpO1xufTtcbmV4cG9ydHMuZmluYWxpemVPdXRwdXRzID0gZmluYWxpemVPdXRwdXRzO1xuLyoqXG4gKiBQdW5jaGxpc3RcbiAqXG4gKiBbXSBOZXcgZGlmZjogVVggb2YgYnVybmluZyBtaW50IGJhdG9ucyBhbmQgYXNzb2NpYXRlZCByZWd0ZXN0XG4gKiBbXSBOZXcgZGlmZjogc3VwcG9ydCByZW1haW5pbmcgdG9rZW4gdHlwZXNcbiAqIFtdIE5ldyBkaWZmOiBjaGFpbmVkIHR4c1xuICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6876\n\n}")},6886:(__unused_webpack_module,exports)=>{eval("{let toSJISFunction\nconst CODEWORDS_COUNT = [\n  0, // Not used\n  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n]\n\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nexports.getSymbolSize = function getSymbolSize (version) {\n  if (!version) throw new Error('\"version\" cannot be null or undefined')\n  if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40')\n  return version * 4 + 17\n}\n\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nexports.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {\n  return CODEWORDS_COUNT[version]\n}\n\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nexports.getBCHDigit = function (data) {\n  let digit = 0\n\n  while (data !== 0) {\n    digit++\n    data >>>= 1\n  }\n\n  return digit\n}\n\nexports.setToSJISFunction = function setToSJISFunction (f) {\n  if (typeof f !== 'function') {\n    throw new Error('\"toSJISFunc\" is not a valid function.')\n  }\n\n  toSJISFunction = f\n}\n\nexports.isKanjiModeEnabled = function () {\n  return typeof toSJISFunction !== 'undefined'\n}\n\nexports.toSJIS = function toSJIS (kanji) {\n  return toSJISFunction(kanji)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg4Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2NvcmUvdXRpbHMuanM/N2JmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgdG9TSklTRnVuY3Rpb25cbmNvbnN0IENPREVXT1JEU19DT1VOVCA9IFtcbiAgMCwgLy8gTm90IHVzZWRcbiAgMjYsIDQ0LCA3MCwgMTAwLCAxMzQsIDE3MiwgMTk2LCAyNDIsIDI5MiwgMzQ2LFxuICA0MDQsIDQ2NiwgNTMyLCA1ODEsIDY1NSwgNzMzLCA4MTUsIDkwMSwgOTkxLCAxMDg1LFxuICAxMTU2LCAxMjU4LCAxMzY0LCAxNDc0LCAxNTg4LCAxNzA2LCAxODI4LCAxOTIxLCAyMDUxLCAyMTg1LFxuICAyMzIzLCAyNDY1LCAyNjExLCAyNzYxLCAyODc2LCAzMDM0LCAzMTk2LCAzMzYyLCAzNTMyLCAzNzA2XG5dXG5cbi8qKlxuICogUmV0dXJucyB0aGUgUVIgQ29kZSBzaXplIGZvciB0aGUgc3BlY2lmaWVkIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHZlcnNpb24gUVIgQ29kZSB2ZXJzaW9uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgc2l6ZSBvZiBRUiBjb2RlXG4gKi9cbmV4cG9ydHMuZ2V0U3ltYm9sU2l6ZSA9IGZ1bmN0aW9uIGdldFN5bWJvbFNpemUgKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKSB0aHJvdyBuZXcgRXJyb3IoJ1widmVyc2lvblwiIGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpXG4gIGlmICh2ZXJzaW9uIDwgMSB8fCB2ZXJzaW9uID4gNDApIHRocm93IG5ldyBFcnJvcignXCJ2ZXJzaW9uXCIgc2hvdWxkIGJlIGluIHJhbmdlIGZyb20gMSB0byA0MCcpXG4gIHJldHVybiB2ZXJzaW9uICogNCArIDE3XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGNvZGV3b3JkcyB1c2VkIHRvIHN0b3JlIGRhdGEgYW5kIEVDIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBEYXRhIGxlbmd0aCBpbiBiaXRzXG4gKi9cbmV4cG9ydHMuZ2V0U3ltYm9sVG90YWxDb2Rld29yZHMgPSBmdW5jdGlvbiBnZXRTeW1ib2xUb3RhbENvZGV3b3JkcyAodmVyc2lvbikge1xuICByZXR1cm4gQ09ERVdPUkRTX0NPVU5UW3ZlcnNpb25dXG59XG5cbi8qKlxuICogRW5jb2RlIGRhdGEgd2l0aCBCb3NlLUNoYXVkaHVyaS1Ib2NxdWVuZ2hlbVxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gZGF0YSBWYWx1ZSB0byBlbmNvZGVcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICBFbmNvZGVkIHZhbHVlXG4gKi9cbmV4cG9ydHMuZ2V0QkNIRGlnaXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBsZXQgZGlnaXQgPSAwXG5cbiAgd2hpbGUgKGRhdGEgIT09IDApIHtcbiAgICBkaWdpdCsrXG4gICAgZGF0YSA+Pj49IDFcbiAgfVxuXG4gIHJldHVybiBkaWdpdFxufVxuXG5leHBvcnRzLnNldFRvU0pJU0Z1bmN0aW9uID0gZnVuY3Rpb24gc2V0VG9TSklTRnVuY3Rpb24gKGYpIHtcbiAgaWYgKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcInRvU0pJU0Z1bmNcIiBpcyBub3QgYSB2YWxpZCBmdW5jdGlvbi4nKVxuICB9XG5cbiAgdG9TSklTRnVuY3Rpb24gPSBmXG59XG5cbmV4cG9ydHMuaXNLYW5qaU1vZGVFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIHRvU0pJU0Z1bmN0aW9uICE9PSAndW5kZWZpbmVkJ1xufVxuXG5leHBvcnRzLnRvU0pJUyA9IGZ1bmN0aW9uIHRvU0pJUyAoa2FuamkpIHtcbiAgcmV0dXJuIHRvU0pJU0Z1bmN0aW9uKGthbmppKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6886\n\n}")},6907:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// browserify by default only pulls in files that are hard coded in requires\n// In order of last to first in this file, the default wordlist will be chosen\n// based on what is present. (Bundles may remove wordlists they don\'t need)\nconst wordlists = {};\nexports.wordlists = wordlists;\nlet _default;\nexports._default = _default;\ntry {\n    exports._default = _default = __webpack_require__(2607);\n    wordlists.czech = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(5898);\n    wordlists.chinese_simplified = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(81);\n    wordlists.chinese_traditional = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(5428);\n    wordlists.korean = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(5040);\n    wordlists.french = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(5576);\n    wordlists.italian = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(5376);\n    wordlists.spanish = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(7967);\n    wordlists.japanese = _default;\n    wordlists.JA = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(7357);\n    wordlists.portuguese = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = __webpack_require__(7736);\n    wordlists.english = _default;\n    wordlists.EN = _default;\n}\ncatch (err) { }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkwNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLElBQUksZ0JBQWdCLGNBQWMsbUJBQU8sQ0FBQyxJQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLGNBQWMsbUJBQU8sQ0FBQyxJQUFxQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLGNBQWMsbUJBQU8sQ0FBQyxFQUFzQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLGNBQWMsbUJBQU8sQ0FBQyxJQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLGNBQWMsbUJBQU8sQ0FBQyxJQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLGNBQWMsbUJBQU8sQ0FBQyxJQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLGNBQWMsbUJBQU8sQ0FBQyxJQUEwQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLGNBQWMsbUJBQU8sQ0FBQyxJQUEyQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0IsY0FBYyxtQkFBTyxDQUFDLElBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0IsY0FBYyxtQkFBTyxDQUFDLElBQTBCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9iaXAzOS9zcmMvX3dvcmRsaXN0cy5qcz85MDg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gYnJvd3NlcmlmeSBieSBkZWZhdWx0IG9ubHkgcHVsbHMgaW4gZmlsZXMgdGhhdCBhcmUgaGFyZCBjb2RlZCBpbiByZXF1aXJlc1xuLy8gSW4gb3JkZXIgb2YgbGFzdCB0byBmaXJzdCBpbiB0aGlzIGZpbGUsIHRoZSBkZWZhdWx0IHdvcmRsaXN0IHdpbGwgYmUgY2hvc2VuXG4vLyBiYXNlZCBvbiB3aGF0IGlzIHByZXNlbnQuIChCdW5kbGVzIG1heSByZW1vdmUgd29yZGxpc3RzIHRoZXkgZG9uJ3QgbmVlZClcbmNvbnN0IHdvcmRsaXN0cyA9IHt9O1xuZXhwb3J0cy53b3JkbGlzdHMgPSB3b3JkbGlzdHM7XG5sZXQgX2RlZmF1bHQ7XG5leHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQ7XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2N6ZWNoLmpzb24nKTtcbiAgICB3b3JkbGlzdHMuY3plY2ggPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9jaGluZXNlX3NpbXBsaWZpZWQuanNvbicpO1xuICAgIHdvcmRsaXN0cy5jaGluZXNlX3NpbXBsaWZpZWQgPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9jaGluZXNlX3RyYWRpdGlvbmFsLmpzb24nKTtcbiAgICB3b3JkbGlzdHMuY2hpbmVzZV90cmFkaXRpb25hbCA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2tvcmVhbi5qc29uJyk7XG4gICAgd29yZGxpc3RzLmtvcmVhbiA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2ZyZW5jaC5qc29uJyk7XG4gICAgd29yZGxpc3RzLmZyZW5jaCA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG50cnkge1xuICAgIGV4cG9ydHMuX2RlZmF1bHQgPSBfZGVmYXVsdCA9IHJlcXVpcmUoJy4vd29yZGxpc3RzL2l0YWxpYW4uanNvbicpO1xuICAgIHdvcmRsaXN0cy5pdGFsaWFuID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbnRyeSB7XG4gICAgZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0ID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvc3BhbmlzaC5qc29uJyk7XG4gICAgd29yZGxpc3RzLnNwYW5pc2ggPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9qYXBhbmVzZS5qc29uJyk7XG4gICAgd29yZGxpc3RzLmphcGFuZXNlID0gX2RlZmF1bHQ7XG4gICAgd29yZGxpc3RzLkpBID0gX2RlZmF1bHQ7XG59XG5jYXRjaCAoZXJyKSB7IH1cbnRyeSB7XG4gICAgZXhwb3J0cy5fZGVmYXVsdCA9IF9kZWZhdWx0ID0gcmVxdWlyZSgnLi93b3JkbGlzdHMvcG9ydHVndWVzZS5qc29uJyk7XG4gICAgd29yZGxpc3RzLnBvcnR1Z3Vlc2UgPSBfZGVmYXVsdDtcbn1cbmNhdGNoIChlcnIpIHsgfVxudHJ5IHtcbiAgICBleHBvcnRzLl9kZWZhdWx0ID0gX2RlZmF1bHQgPSByZXF1aXJlKCcuL3dvcmRsaXN0cy9lbmdsaXNoLmpzb24nKTtcbiAgICB3b3JkbGlzdHMuZW5nbGlzaCA9IF9kZWZhdWx0O1xuICAgIHdvcmRsaXN0cy5FTiA9IF9kZWZhdWx0O1xufVxuY2F0Y2ggKGVycikgeyB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6907\n\n}')},6942:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\n/**\n * @license\n * https://reviews.bitcoinabc.org\n * Copyright (c) 2017-2020 Emilio Almansi\n * Copyright (c) 2023-2024 Bitcoin ABC\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getOutputScriptFromTypeAndHash = exports.VALID_PREFIXES = void 0;\nexports.encodeCashAddress = encodeCashAddress;\nexports.decodeCashAddress = decodeCashAddress;\nexports.uint8arrayToHexString = uint8arrayToHexString;\nexports.getTypeAndHashFromOutputScript = getTypeAndHashFromOutputScript;\nexports.encodeOutputScript = encodeOutputScript;\nexports.isValidCashAddress = isValidCashAddress;\nexports.getOutputScriptFromAddress = getOutputScriptFromAddress;\nconst base32_1 = __importDefault(__webpack_require__(6102));\nconst convertBits_1 = __importDefault(__webpack_require__(6595));\nconst validation_1 = __importDefault(__webpack_require__(3377));\nconst { validate, ValidationError } = validation_1.default;\n/**\n * Encoding and decoding of the new Cash Address format for eCash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md}\n * @module cashaddr\n */\n/**\n * Encodes a hash from a given type into an eCash address with the given prefix.\n *\n * @param prefix Cash address prefix. E.g.: 'ecash'.\n * @param type Type of address to generate\n * @param hash Hash to encode represented as an array of 8-bit integers.\n * @throws {ValidationError}\n */\nfunction encodeCashAddress(prefix, type, hash) {\n    validate(typeof prefix === 'string' && isValidPrefix(prefix), 'Invalid prefix: ' + prefix + '.');\n    validate(type === 'p2pkh' || type === 'p2sh', 'Invalid type: ' + type + '.');\n    validate(hash instanceof Uint8Array || typeof hash === 'string', 'Invalid hash: ' + hash + '. Must be string or Uint8Array.');\n    if (typeof hash === 'string') {\n        hash = stringToUint8Array(hash);\n    }\n    const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n    const versionByte = getTypeBits(type) + getHashSizeBits(hash);\n    const payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));\n    const checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));\n    const payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));\n    return prefix + ':' + base32_1.default.encode(payload);\n}\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n *\n * @param address Address to decode. E.g.: 'ecash:qpm2qsznhks23z7629mms6s4cwef74vcwva87rkuu2'.\n * @throws {ValidationError}\n */\nfunction decodeCashAddress(address) {\n    validate(typeof address === 'string' && hasSingleCase(address), 'Invalid address: ' + address + '.');\n    const pieces = address.toLowerCase().split(':');\n    // if there is no prefix, it might still be valid\n    let prefix, payload;\n    if (pieces.length === 1) {\n        // Check and see if it has a valid checksum for accepted prefixes\n        let hasValidChecksum = false;\n        for (let i = 0; i < exports.VALID_PREFIXES.length; i += 1) {\n            const testedPrefix = exports.VALID_PREFIXES[i];\n            const prefixlessPayload = base32_1.default.decode(pieces[0]);\n            hasValidChecksum = validChecksum(testedPrefix, prefixlessPayload);\n            if (hasValidChecksum) {\n                // Here's your prefix\n                prefix = testedPrefix;\n                payload = prefixlessPayload;\n                // Stop testing other prefixes\n                break;\n            }\n        }\n        validate(hasValidChecksum, `Prefixless address ${address} does not have valid checksum for any valid prefix (${exports.VALID_PREFIXES.join(', ')})`);\n    }\n    else {\n        validate(pieces.length === 2, 'Invalid address: ' + address + '.');\n        prefix = pieces[0];\n        payload = base32_1.default.decode(pieces[1]);\n        validate(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');\n    }\n    // We assert that payload will be defined here, as we validate above\n    const payloadData = fromUint5Array(payload.subarray(0, -8));\n    const versionByte = payloadData[0];\n    const hash = payloadData.subarray(1);\n    validate(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');\n    const type = getType(versionByte);\n    return {\n        prefix: prefix,\n        type,\n        hash: uint8arrayToHexString(hash),\n    };\n}\n/**\n * All valid address prefixes\n * Note that as of 2.0.0 we do not validate against these prefixes\n * However we do use them to guess prefix for prefixless addrs\n *\n * @private\n */\nexports.VALID_PREFIXES = [\n    'ecash',\n    'bitcoincash',\n    'simpleledger',\n    'etoken',\n    'ectest',\n    'ecregtest',\n    'bchtest',\n    'bchreg',\n];\n/**\n * Checks whether a string is a valid prefix\n * ie., it has a single letter case and no spaces\n * Could be extended to validate for accepted prefixes\n *\n * @private\n * @param prefix\n */\nfunction isValidPrefix(prefix) {\n    return hasSingleCase(prefix) && !prefix.includes(' ');\n}\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param prefix Cash address prefix. E.g.: 'ecash'.\n */\nfunction prefixToUint5Array(prefix) {\n    const result = new Uint8Array(prefix.length);\n    for (let i = 0; i < prefix.length; ++i) {\n        result[i] = prefix[i].charCodeAt(0) & 31;\n    }\n    return result;\n}\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param checksum Computed checksum.\n * TODO update big-integer so we can use correct types\n */\nfunction checksumToUint5Array(checksum) {\n    const result = new Uint8Array(8);\n    for (let i = 0; i < 8; ++i) {\n        // Extract the least significant 5 bits (31 is 11111 in binary)\n        result[7 - i] = Number(checksum & 31n);\n        // Shift right by 5 bits\n        checksum >>= 5n;\n    }\n    return result;\n}\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param type Address type. Either 'P2PKH' or 'P2SH'.\n * @throws {ValidationError}\n */\nfunction getTypeBits(type) {\n    switch (type) {\n        case 'p2pkh':\n            return 0;\n        case 'p2sh':\n            return 8;\n        default:\n            throw new ValidationError('Invalid type: ' + type + '.');\n    }\n}\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param versionByte\n */\nfunction getType(versionByte) {\n    switch (versionByte & 120) {\n        case 0:\n            return 'p2pkh';\n        case 8:\n            return 'p2sh';\n        default:\n            throw new ValidationError('Invalid address type in version byte: ' + versionByte + '.');\n    }\n}\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param hash Hash to encode represented as an array of 8-bit integers.\n * @throws {ValidationError}\n */\nfunction getHashSizeBits(hash) {\n    switch (hash.length * 8) {\n        case 160:\n            return 0;\n        case 192:\n            return 1;\n        case 224:\n            return 2;\n        case 256:\n            return 3;\n        case 320:\n            return 4;\n        case 384:\n            return 5;\n        case 448:\n            return 6;\n        case 512:\n            return 7;\n        default:\n            throw new ValidationError('Invalid hash size: ' + hash.length + '.');\n    }\n}\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param versionByte\n */\nfunction getHashSize(versionByte) {\n    switch (versionByte & 7) {\n        case 0:\n            return 160;\n        case 1:\n            return 192;\n        case 2:\n            return 224;\n        case 3:\n            return 256;\n        case 4:\n            return 320;\n        case 5:\n            return 384;\n        case 6:\n            return 448;\n        case 7:\n            return 512;\n        default:\n            throw new Error('Invalid input');\n    }\n}\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n */\nfunction toUint5Array(data) {\n    return (0, convertBits_1.default)(data, 8, 5);\n}\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param data\n * @throws {ValidationError}\n */\nfunction fromUint5Array(data) {\n    return (0, convertBits_1.default)(data, 5, 8, true);\n}\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param a\n * @param b\n * @throws {ValidationError}\n */\nfunction concat(a, b) {\n    const ab = new Uint8Array(a.length + b.length);\n    ab.set(a);\n    ab.set(b, a.length);\n    return ab;\n}\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param data Array of 5-bit integers over which the checksum is to be computed.\n */\nfunction polymod(data) {\n    const GENERATOR = [\n        BigInt('0x98f2bc8e61'),\n        BigInt('0x79b76d99e2'),\n        BigInt('0xf33e5fb3c4'),\n        BigInt('0xae2eabe2a8'),\n        BigInt('0x1e4f43e470'),\n    ];\n    let checksum = 1n; // BigInt for 1\n    for (let i = 0; i < data.length; i += 1) {\n        const value = BigInt(data[i]);\n        const topBits = checksum >> 35n;\n        checksum = ((checksum & 0x07ffffffffn) << 5n) ^ value;\n        for (let j = 0; j < GENERATOR.length; ++j) {\n            if ((topBits >> BigInt(j)) & 1n) {\n                checksum ^= GENERATOR[j];\n            }\n        }\n    }\n    return checksum ^ 1n;\n}\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n *\n * @private\n * @param prefix Cash address prefix. E.g.: 'ecash'.\n * @param payload Array of 5-bit integers containing the address' payload.\n */\nfunction validChecksum(prefix, payload) {\n    const prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n    const checksumData = concat(prefixData, payload);\n    return polymod(checksumData) === 0n;\n}\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param string Input string.\n */\nfunction hasSingleCase(string) {\n    return string === string.toLowerCase() || string === string.toUpperCase();\n}\n/**\n * Returns a uint8array for a given string input\n *\n * @private\n * @param string Input string.\n */\nfunction stringToUint8Array(string) {\n    const array = new Uint8Array(string.length / 2);\n    for (let i = 0; i < string.length; i += 2) {\n        // Convert each pair of characters to an integer\n        array[i / 2] = parseInt(string.slice(i, i + 2), 16);\n    }\n    return array;\n}\n/**\n * Returns a uint8array for a given string input\n *\n * @private\n * @param uint8Array Input string.\n */\nfunction uint8arrayToHexString(uint8Array) {\n    let hexString = '';\n    for (let i = 0; i < uint8Array.length; i++) {\n        let hex = uint8Array[i].toString(16);\n        // Ensure we have 2 digits for each byte\n        hex = hex.length === 1 ? '0' + hex : hex;\n        hexString += hex;\n    }\n    return hexString;\n}\n/**\n * Get type and hash from an outputScript\n *\n * Supported outputScripts:\n *\n * P2PKH: 76a914<hash>88ac\n * P2SH:  a914<hash>87\n *\n * Validates for supported outputScript and hash length *\n *\n * @param outputScript an ecash tx outputScript\n * @throws {ValidationError}\n */\nfunction getTypeAndHashFromOutputScript(outputScript) {\n    const p2pkhPrefix = '76a914';\n    const p2pkhSuffix = '88ac';\n    const p2shPrefix = 'a914';\n    const p2shSuffix = '87';\n    let hash, type;\n    // If outputScript begins with '76a914' and ends with '88ac'\n    if (outputScript.slice(0, p2pkhPrefix.length) === p2pkhPrefix &&\n        outputScript.slice(-1 * p2pkhSuffix.length) === p2pkhSuffix) {\n        // We have type p2pkh\n        type = 'p2pkh';\n        // hash is the string in between '76a194' and '88ac'\n        hash = outputScript.substring(outputScript.indexOf(p2pkhPrefix) + p2pkhPrefix.length, outputScript.lastIndexOf(p2pkhSuffix));\n        // If outputScript begins with 'a914' and ends with '87'\n    }\n    else if (outputScript.slice(0, p2shPrefix.length) === p2shPrefix &&\n        outputScript.slice(-1 * p2shSuffix.length) === p2shSuffix) {\n        // We have type p2sh\n        type = 'p2sh';\n        // hash is the string in between 'a914' and '87'\n        hash = outputScript.substring(outputScript.indexOf(p2shPrefix) + p2shPrefix.length, outputScript.lastIndexOf(p2shSuffix));\n    }\n    else {\n        // Throw validation error if outputScript not of these two types\n        throw new ValidationError('Unsupported outputScript: ' + outputScript);\n    }\n    // Throw validation error if hash is of invalid size\n    // Per spec, valid hash sizes in bytes\n    const VALID_SIZES = [20, 24, 28, 32, 40, 48, 56, 64];\n    if (!VALID_SIZES.includes(hash.length / 2)) {\n        throw new ValidationError('Invalid hash size in outputScript: ' + outputScript);\n    }\n    return { type, hash };\n}\nconst getOutputScriptFromTypeAndHash = (type, hash) => {\n    validate(type === 'p2pkh' || type === 'p2sh', 'Invalid type: ' + type + '.');\n    let outputScript;\n    if (type === 'p2pkh') {\n        outputScript = `76a914${hash}88ac`;\n    }\n    else {\n        outputScript = `a914${hash}87`;\n    }\n    return outputScript;\n};\nexports.getOutputScriptFromTypeAndHash = getOutputScriptFromTypeAndHash;\n/**\n * Encodes a given outputScript into an eCash address using the optionally specified prefix.\n *\n * @static\n * @param outputScript an ecash tx outputScript\n * @param prefix Cash address prefix. E.g.: 'ecash'.\n * @throws {ValidationError}\n */\nfunction encodeOutputScript(outputScript, prefix = 'ecash') {\n    // Get type and hash from outputScript\n    const { type, hash } = getTypeAndHashFromOutputScript(outputScript);\n    // The encode function validates hash for correct length\n    return encodeCashAddress(prefix, type, hash);\n}\n/**\n * Return true for a valid cashaddress\n * Prefixless addresses with valid checksum are also valid\n *\n * @static\n * @param testedAddress a string tested for cashaddress validity\n * @param optionalPrefix cashaddr prefix\n * @throws {ValidationError}\n */\nfunction isValidCashAddress(cashaddress, optionalPrefix = false) {\n    try {\n        const { prefix } = decodeCashAddress(cashaddress);\n        if (optionalPrefix) {\n            return prefix === optionalPrefix;\n        }\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Return true for a valid cashaddress\n * Prefixless addresses with valid checksum are also valid\n *\n * @static\n * @param address a valid p2pkh or p2sh cash address\n * @returns the outputScript associated with this address and type\n * @throws {ValidationError} if decode fails\n */\nfunction getOutputScriptFromAddress(address) {\n    const { type, hash } = decodeCashAddress(address);\n    let registrationOutputScript;\n    if (type === 'p2pkh') {\n        registrationOutputScript = `76a914${hash}88ac`;\n    }\n    else {\n        registrationOutputScript = `a914${hash}87`;\n    }\n    return registrationOutputScript;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk0Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyxzQkFBc0I7QUFDL0QseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0Isc0NBQXNDO0FBQ3RDLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsa0NBQWtDO0FBQ2xDLGlDQUFpQyxtQkFBTyxDQUFDLElBQVU7QUFDbkQsc0NBQXNDLG1CQUFPLENBQUMsSUFBZTtBQUM3RCxxQ0FBcUMsbUJBQU8sQ0FBQyxJQUFjO0FBQzNELFFBQVEsNEJBQTRCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUyxxREFBcUQsa0NBQWtDO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoYWRkcmpzL2Rpc3QvY2FzaGFkZHIuanM/NzVkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIGh0dHBzOi8vcmV2aWV3cy5iaXRjb2luYWJjLm9yZ1xuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMjAgRW1pbGlvIEFsbWFuc2lcbiAqIENvcHlyaWdodCAoYykgMjAyMy0yMDI0IEJpdGNvaW4gQUJDXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4gKiBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0T3V0cHV0U2NyaXB0RnJvbVR5cGVBbmRIYXNoID0gZXhwb3J0cy5WQUxJRF9QUkVGSVhFUyA9IHZvaWQgMDtcbmV4cG9ydHMuZW5jb2RlQ2FzaEFkZHJlc3MgPSBlbmNvZGVDYXNoQWRkcmVzcztcbmV4cG9ydHMuZGVjb2RlQ2FzaEFkZHJlc3MgPSBkZWNvZGVDYXNoQWRkcmVzcztcbmV4cG9ydHMudWludDhhcnJheVRvSGV4U3RyaW5nID0gdWludDhhcnJheVRvSGV4U3RyaW5nO1xuZXhwb3J0cy5nZXRUeXBlQW5kSGFzaEZyb21PdXRwdXRTY3JpcHQgPSBnZXRUeXBlQW5kSGFzaEZyb21PdXRwdXRTY3JpcHQ7XG5leHBvcnRzLmVuY29kZU91dHB1dFNjcmlwdCA9IGVuY29kZU91dHB1dFNjcmlwdDtcbmV4cG9ydHMuaXNWYWxpZENhc2hBZGRyZXNzID0gaXNWYWxpZENhc2hBZGRyZXNzO1xuZXhwb3J0cy5nZXRPdXRwdXRTY3JpcHRGcm9tQWRkcmVzcyA9IGdldE91dHB1dFNjcmlwdEZyb21BZGRyZXNzO1xuY29uc3QgYmFzZTMyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYmFzZTMyXCIpKTtcbmNvbnN0IGNvbnZlcnRCaXRzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29udmVydEJpdHNcIikpO1xuY29uc3QgdmFsaWRhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIikpO1xuY29uc3QgeyB2YWxpZGF0ZSwgVmFsaWRhdGlvbkVycm9yIH0gPSB2YWxpZGF0aW9uXzEuZGVmYXVsdDtcbi8qKlxuICogRW5jb2RpbmcgYW5kIGRlY29kaW5nIG9mIHRoZSBuZXcgQ2FzaCBBZGRyZXNzIGZvcm1hdCBmb3IgZUNhc2guIDxiciAvPlxuICogQ29tcGxpYW50IHdpdGggdGhlIG9yaWdpbmFsIGNhc2hhZGRyIHNwZWNpZmljYXRpb246XG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5jYXNob3JnL2JpdGNvaW5jYXNoLm9yZy9ibG9iL21hc3Rlci9zcGVjL2Nhc2hhZGRyLm1kfVxuICogQG1vZHVsZSBjYXNoYWRkclxuICovXG4vKipcbiAqIEVuY29kZXMgYSBoYXNoIGZyb20gYSBnaXZlbiB0eXBlIGludG8gYW4gZUNhc2ggYWRkcmVzcyB3aXRoIHRoZSBnaXZlbiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHByZWZpeCBDYXNoIGFkZHJlc3MgcHJlZml4LiBFLmcuOiAnZWNhc2gnLlxuICogQHBhcmFtIHR5cGUgVHlwZSBvZiBhZGRyZXNzIHRvIGdlbmVyYXRlXG4gKiBAcGFyYW0gaGFzaCBIYXNoIHRvIGVuY29kZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiA4LWJpdCBpbnRlZ2Vycy5cbiAqIEB0aHJvd3Mge1ZhbGlkYXRpb25FcnJvcn1cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQ2FzaEFkZHJlc3MocHJlZml4LCB0eXBlLCBoYXNoKSB7XG4gICAgdmFsaWRhdGUodHlwZW9mIHByZWZpeCA9PT0gJ3N0cmluZycgJiYgaXNWYWxpZFByZWZpeChwcmVmaXgpLCAnSW52YWxpZCBwcmVmaXg6ICcgKyBwcmVmaXggKyAnLicpO1xuICAgIHZhbGlkYXRlKHR5cGUgPT09ICdwMnBraCcgfHwgdHlwZSA9PT0gJ3Ayc2gnLCAnSW52YWxpZCB0eXBlOiAnICsgdHlwZSArICcuJyk7XG4gICAgdmFsaWRhdGUoaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZW9mIGhhc2ggPT09ICdzdHJpbmcnLCAnSW52YWxpZCBoYXNoOiAnICsgaGFzaCArICcuIE11c3QgYmUgc3RyaW5nIG9yIFVpbnQ4QXJyYXkuJyk7XG4gICAgaWYgKHR5cGVvZiBoYXNoID09PSAnc3RyaW5nJykge1xuICAgICAgICBoYXNoID0gc3RyaW5nVG9VaW50OEFycmF5KGhhc2gpO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXhEYXRhID0gY29uY2F0KHByZWZpeFRvVWludDVBcnJheShwcmVmaXgpLCBuZXcgVWludDhBcnJheSgxKSk7XG4gICAgY29uc3QgdmVyc2lvbkJ5dGUgPSBnZXRUeXBlQml0cyh0eXBlKSArIGdldEhhc2hTaXplQml0cyhoYXNoKTtcbiAgICBjb25zdCBwYXlsb2FkRGF0YSA9IHRvVWludDVBcnJheShjb25jYXQobmV3IFVpbnQ4QXJyYXkoW3ZlcnNpb25CeXRlXSksIGhhc2gpKTtcbiAgICBjb25zdCBjaGVja3N1bURhdGEgPSBjb25jYXQoY29uY2F0KHByZWZpeERhdGEsIHBheWxvYWREYXRhKSwgbmV3IFVpbnQ4QXJyYXkoOCkpO1xuICAgIGNvbnN0IHBheWxvYWQgPSBjb25jYXQocGF5bG9hZERhdGEsIGNoZWNrc3VtVG9VaW50NUFycmF5KHBvbHltb2QoY2hlY2tzdW1EYXRhKSkpO1xuICAgIHJldHVybiBwcmVmaXggKyAnOicgKyBiYXNlMzJfMS5kZWZhdWx0LmVuY29kZShwYXlsb2FkKTtcbn1cbi8qKlxuICogRGVjb2RlcyB0aGUgZ2l2ZW4gYWRkcmVzcyBpbnRvIGl0cyBjb25zdGl0dXRpbmcgcHJlZml4LCB0eXBlIGFuZCBoYXNoLiBTZWUgWyNlbmNvZGUoKV17QGxpbmsgZW5jb2RlfS5cbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyBBZGRyZXNzIHRvIGRlY29kZS4gRS5nLjogJ2VjYXNoOnFwbTJxc3puaGtzMjN6NzYyOW1tczZzNGN3ZWY3NHZjd3ZhODdya3V1MicuXG4gKiBAdGhyb3dzIHtWYWxpZGF0aW9uRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZUNhc2hBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB2YWxpZGF0ZSh0eXBlb2YgYWRkcmVzcyA9PT0gJ3N0cmluZycgJiYgaGFzU2luZ2xlQ2FzZShhZGRyZXNzKSwgJ0ludmFsaWQgYWRkcmVzczogJyArIGFkZHJlc3MgKyAnLicpO1xuICAgIGNvbnN0IHBpZWNlcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5zcGxpdCgnOicpO1xuICAgIC8vIGlmIHRoZXJlIGlzIG5vIHByZWZpeCwgaXQgbWlnaHQgc3RpbGwgYmUgdmFsaWRcbiAgICBsZXQgcHJlZml4LCBwYXlsb2FkO1xuICAgIGlmIChwaWVjZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIENoZWNrIGFuZCBzZWUgaWYgaXQgaGFzIGEgdmFsaWQgY2hlY2tzdW0gZm9yIGFjY2VwdGVkIHByZWZpeGVzXG4gICAgICAgIGxldCBoYXNWYWxpZENoZWNrc3VtID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwb3J0cy5WQUxJRF9QUkVGSVhFUy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgdGVzdGVkUHJlZml4ID0gZXhwb3J0cy5WQUxJRF9QUkVGSVhFU1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeGxlc3NQYXlsb2FkID0gYmFzZTMyXzEuZGVmYXVsdC5kZWNvZGUocGllY2VzWzBdKTtcbiAgICAgICAgICAgIGhhc1ZhbGlkQ2hlY2tzdW0gPSB2YWxpZENoZWNrc3VtKHRlc3RlZFByZWZpeCwgcHJlZml4bGVzc1BheWxvYWQpO1xuICAgICAgICAgICAgaWYgKGhhc1ZhbGlkQ2hlY2tzdW0pIHtcbiAgICAgICAgICAgICAgICAvLyBIZXJlJ3MgeW91ciBwcmVmaXhcbiAgICAgICAgICAgICAgICBwcmVmaXggPSB0ZXN0ZWRQcmVmaXg7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHByZWZpeGxlc3NQYXlsb2FkO1xuICAgICAgICAgICAgICAgIC8vIFN0b3AgdGVzdGluZyBvdGhlciBwcmVmaXhlc1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlKGhhc1ZhbGlkQ2hlY2tzdW0sIGBQcmVmaXhsZXNzIGFkZHJlc3MgJHthZGRyZXNzfSBkb2VzIG5vdCBoYXZlIHZhbGlkIGNoZWNrc3VtIGZvciBhbnkgdmFsaWQgcHJlZml4ICgke2V4cG9ydHMuVkFMSURfUFJFRklYRVMuam9pbignLCAnKX0pYCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZShwaWVjZXMubGVuZ3RoID09PSAyLCAnSW52YWxpZCBhZGRyZXNzOiAnICsgYWRkcmVzcyArICcuJyk7XG4gICAgICAgIHByZWZpeCA9IHBpZWNlc1swXTtcbiAgICAgICAgcGF5bG9hZCA9IGJhc2UzMl8xLmRlZmF1bHQuZGVjb2RlKHBpZWNlc1sxXSk7XG4gICAgICAgIHZhbGlkYXRlKHZhbGlkQ2hlY2tzdW0ocHJlZml4LCBwYXlsb2FkKSwgJ0ludmFsaWQgY2hlY2tzdW06ICcgKyBhZGRyZXNzICsgJy4nKTtcbiAgICB9XG4gICAgLy8gV2UgYXNzZXJ0IHRoYXQgcGF5bG9hZCB3aWxsIGJlIGRlZmluZWQgaGVyZSwgYXMgd2UgdmFsaWRhdGUgYWJvdmVcbiAgICBjb25zdCBwYXlsb2FkRGF0YSA9IGZyb21VaW50NUFycmF5KHBheWxvYWQuc3ViYXJyYXkoMCwgLTgpKTtcbiAgICBjb25zdCB2ZXJzaW9uQnl0ZSA9IHBheWxvYWREYXRhWzBdO1xuICAgIGNvbnN0IGhhc2ggPSBwYXlsb2FkRGF0YS5zdWJhcnJheSgxKTtcbiAgICB2YWxpZGF0ZShnZXRIYXNoU2l6ZSh2ZXJzaW9uQnl0ZSkgPT09IGhhc2gubGVuZ3RoICogOCwgJ0ludmFsaWQgaGFzaCBzaXplOiAnICsgYWRkcmVzcyArICcuJyk7XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUodmVyc2lvbkJ5dGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICB0eXBlLFxuICAgICAgICBoYXNoOiB1aW50OGFycmF5VG9IZXhTdHJpbmcoaGFzaCksXG4gICAgfTtcbn1cbi8qKlxuICogQWxsIHZhbGlkIGFkZHJlc3MgcHJlZml4ZXNcbiAqIE5vdGUgdGhhdCBhcyBvZiAyLjAuMCB3ZSBkbyBub3QgdmFsaWRhdGUgYWdhaW5zdCB0aGVzZSBwcmVmaXhlc1xuICogSG93ZXZlciB3ZSBkbyB1c2UgdGhlbSB0byBndWVzcyBwcmVmaXggZm9yIHByZWZpeGxlc3MgYWRkcnNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLlZBTElEX1BSRUZJWEVTID0gW1xuICAgICdlY2FzaCcsXG4gICAgJ2JpdGNvaW5jYXNoJyxcbiAgICAnc2ltcGxlbGVkZ2VyJyxcbiAgICAnZXRva2VuJyxcbiAgICAnZWN0ZXN0JyxcbiAgICAnZWNyZWd0ZXN0JyxcbiAgICAnYmNodGVzdCcsXG4gICAgJ2JjaHJlZycsXG5dO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHN0cmluZyBpcyBhIHZhbGlkIHByZWZpeFxuICogaWUuLCBpdCBoYXMgYSBzaW5nbGUgbGV0dGVyIGNhc2UgYW5kIG5vIHNwYWNlc1xuICogQ291bGQgYmUgZXh0ZW5kZWQgdG8gdmFsaWRhdGUgZm9yIGFjY2VwdGVkIHByZWZpeGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBwcmVmaXhcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFByZWZpeChwcmVmaXgpIHtcbiAgICByZXR1cm4gaGFzU2luZ2xlQ2FzZShwcmVmaXgpICYmICFwcmVmaXguaW5jbHVkZXMoJyAnKTtcbn1cbi8qKlxuICogRGVyaXZlcyBhbiBhcnJheSBmcm9tIHRoZSBnaXZlbiBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29tcHV0YXRpb25cbiAqIG9mIHRoZSBhZGRyZXNzJyBjaGVja3N1bS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHByZWZpeCBDYXNoIGFkZHJlc3MgcHJlZml4LiBFLmcuOiAnZWNhc2gnLlxuICovXG5mdW5jdGlvbiBwcmVmaXhUb1VpbnQ1QXJyYXkocHJlZml4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkocHJlZml4Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gcHJlZml4W2ldLmNoYXJDb2RlQXQoMCkgJiAzMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gY2hlY2tzdW0gdG8gYmUgZW5jb2RlZFxuICogd2l0aGluIHRoZSBhZGRyZXNzJyBwYXlsb2FkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gY2hlY2tzdW0gQ29tcHV0ZWQgY2hlY2tzdW0uXG4gKiBUT0RPIHVwZGF0ZSBiaWctaW50ZWdlciBzbyB3ZSBjYW4gdXNlIGNvcnJlY3QgdHlwZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tzdW1Ub1VpbnQ1QXJyYXkoY2hlY2tzdW0pIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSBsZWFzdCBzaWduaWZpY2FudCA1IGJpdHMgKDMxIGlzIDExMTExIGluIGJpbmFyeSlcbiAgICAgICAgcmVzdWx0WzcgLSBpXSA9IE51bWJlcihjaGVja3N1bSAmIDMxbik7XG4gICAgICAgIC8vIFNoaWZ0IHJpZ2h0IGJ5IDUgYml0c1xuICAgICAgICBjaGVja3N1bSA+Pj0gNW47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGJpdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdHlwZSB3aXRoaW4gdGhlIHZlcnNpb25cbiAqIGJ5dGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB0eXBlIEFkZHJlc3MgdHlwZS4gRWl0aGVyICdQMlBLSCcgb3IgJ1AyU0gnLlxuICogQHRocm93cyB7VmFsaWRhdGlvbkVycm9yfVxuICovXG5mdW5jdGlvbiBnZXRUeXBlQml0cyh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3AycGtoJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdwMnNoJzpcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignSW52YWxpZCB0eXBlOiAnICsgdHlwZSArICcuJyk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGFkZHJlc3MgdHlwZSBmcm9tIGl0cyBiaXQgcmVwcmVzZW50YXRpb24gd2l0aGluIHRoZVxuICogdmVyc2lvbiBieXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gdmVyc2lvbkJ5dGVcbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSh2ZXJzaW9uQnl0ZSkge1xuICAgIHN3aXRjaCAodmVyc2lvbkJ5dGUgJiAxMjApIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuICdwMnBraCc7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJldHVybiAncDJzaCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdJbnZhbGlkIGFkZHJlc3MgdHlwZSBpbiB2ZXJzaW9uIGJ5dGU6ICcgKyB2ZXJzaW9uQnl0ZSArICcuJyk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxlbmd0aCBpbiBiaXRzIG9mIHRoZSBnaXZlblxuICogaGFzaCB3aXRoaW4gdGhlIHZlcnNpb24gYnl0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIGhhc2ggSGFzaCB0byBlbmNvZGUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgOC1iaXQgaW50ZWdlcnMuXG4gKiBAdGhyb3dzIHtWYWxpZGF0aW9uRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGdldEhhc2hTaXplQml0cyhoYXNoKSB7XG4gICAgc3dpdGNoIChoYXNoLmxlbmd0aCAqIDgpIHtcbiAgICAgICAgY2FzZSAxNjA6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAxOTI6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSAyMjQ6XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgY2FzZSAzMjA6XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSAzODQ6XG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgY2FzZSA0NDg6XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgY2FzZSA1MTI6XG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ0ludmFsaWQgaGFzaCBzaXplOiAnICsgaGFzaC5sZW5ndGggKyAnLicpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSB0aGUgbGVuZ3RoIGluIGJpdHMgb2YgdGhlIGVuY29kZWQgaGFzaCBmcm9tIGl0cyBiaXRcbiAqIHJlcHJlc2VudGF0aW9uIHdpdGhpbiB0aGUgdmVyc2lvbiBieXRlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gdmVyc2lvbkJ5dGVcbiAqL1xuZnVuY3Rpb24gZ2V0SGFzaFNpemUodmVyc2lvbkJ5dGUpIHtcbiAgICBzd2l0Y2ggKHZlcnNpb25CeXRlICYgNykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gMTYwO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gMTkyO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gMjI0O1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gMjU2O1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gMzIwO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gMzg0O1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gNDQ4O1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gNTEyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0Jyk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiA4LWJpdCBpbnRlZ2VycyBpbnRvIGFuIGFycmF5IG9mIDUtYml0IGludGVnZXJzLFxuICogcmlnaHQtcGFkZGluZyB3aXRoIHplcm9lcyBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICovXG5mdW5jdGlvbiB0b1VpbnQ1QXJyYXkoZGF0YSkge1xuICAgIHJldHVybiAoMCwgY29udmVydEJpdHNfMS5kZWZhdWx0KShkYXRhLCA4LCA1KTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgNS1iaXQgaW50ZWdlcnMgYmFjayBpbnRvIGFuIGFycmF5IG9mIDgtYml0IGludGVnZXJzLFxuICogcmVtb3ZpbmcgZXh0cmEgemVyb2VzIGxlZnQgZnJvbSBwYWRkaW5nIGlmIG5lY2Vzc2FyeS5cbiAqIFRocm93cyBhIHtAbGluayBWYWxpZGF0aW9uRXJyb3J9IGlmIGlucHV0IGlzIG5vdCBhIHplcm8tcGFkZGVkIGFycmF5IG9mIDgtYml0IGludGVnZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZGF0YVxuICogQHRocm93cyB7VmFsaWRhdGlvbkVycm9yfVxuICovXG5mdW5jdGlvbiBmcm9tVWludDVBcnJheShkYXRhKSB7XG4gICAgcmV0dXJuICgwLCBjb252ZXJ0Qml0c18xLmRlZmF1bHQpKGRhdGEsIDUsIDgsIHRydWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIGEgYW5kIGIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICogQHRocm93cyB7VmFsaWRhdGlvbkVycm9yfVxuICovXG5mdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICAgIGNvbnN0IGFiID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgYWIuc2V0KGEpO1xuICAgIGFiLnNldChiLCBhLmxlbmd0aCk7XG4gICAgcmV0dXJuIGFiO1xufVxuLyoqXG4gKiBDb21wdXRlcyBhIGNoZWNrc3VtIGZyb20gdGhlIGdpdmVuIGlucHV0IGRhdGEgYXMgc3BlY2lmaWVkIGZvciB0aGUgQ2FzaEFkZHJcbiAqIGZvcm1hdDogaHR0cHM6Ly9naXRodWIuY29tL0JpdGNvaW4tVUFIRi9zcGVjL2Jsb2IvbWFzdGVyL2Nhc2hhZGRyLm1kLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZGF0YSBBcnJheSBvZiA1LWJpdCBpbnRlZ2VycyBvdmVyIHdoaWNoIHRoZSBjaGVja3N1bSBpcyB0byBiZSBjb21wdXRlZC5cbiAqL1xuZnVuY3Rpb24gcG9seW1vZChkYXRhKSB7XG4gICAgY29uc3QgR0VORVJBVE9SID0gW1xuICAgICAgICBCaWdJbnQoJzB4OThmMmJjOGU2MScpLFxuICAgICAgICBCaWdJbnQoJzB4NzliNzZkOTllMicpLFxuICAgICAgICBCaWdJbnQoJzB4ZjMzZTVmYjNjNCcpLFxuICAgICAgICBCaWdJbnQoJzB4YWUyZWFiZTJhOCcpLFxuICAgICAgICBCaWdJbnQoJzB4MWU0ZjQzZTQ3MCcpLFxuICAgIF07XG4gICAgbGV0IGNoZWNrc3VtID0gMW47IC8vIEJpZ0ludCBmb3IgMVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChkYXRhW2ldKTtcbiAgICAgICAgY29uc3QgdG9wQml0cyA9IGNoZWNrc3VtID4+IDM1bjtcbiAgICAgICAgY2hlY2tzdW0gPSAoKGNoZWNrc3VtICYgMHgwN2ZmZmZmZmZmbikgPDwgNW4pIF4gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgR0VORVJBVE9SLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBpZiAoKHRvcEJpdHMgPj4gQmlnSW50KGopKSAmIDFuKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW0gXj0gR0VORVJBVE9SW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bSBeIDFuO1xufVxuLyoqXG4gKiBWZXJpZnkgdGhhdCB0aGUgcGF5bG9hZCBoYXMgbm90IGJlZW4gY29ycnVwdGVkIGJ5IGNoZWNraW5nIHRoYXQgdGhlXG4gKiBjaGVja3N1bSBpcyB2YWxpZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHByZWZpeCBDYXNoIGFkZHJlc3MgcHJlZml4LiBFLmcuOiAnZWNhc2gnLlxuICogQHBhcmFtIHBheWxvYWQgQXJyYXkgb2YgNS1iaXQgaW50ZWdlcnMgY29udGFpbmluZyB0aGUgYWRkcmVzcycgcGF5bG9hZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRDaGVja3N1bShwcmVmaXgsIHBheWxvYWQpIHtcbiAgICBjb25zdCBwcmVmaXhEYXRhID0gY29uY2F0KHByZWZpeFRvVWludDVBcnJheShwcmVmaXgpLCBuZXcgVWludDhBcnJheSgxKSk7XG4gICAgY29uc3QgY2hlY2tzdW1EYXRhID0gY29uY2F0KHByZWZpeERhdGEsIHBheWxvYWQpO1xuICAgIHJldHVybiBwb2x5bW9kKGNoZWNrc3VtRGF0YSkgPT09IDBuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYsIGFuZCBvbmx5IGlmLCB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGVpdGhlciB1cHBlcmNhc2VcbiAqIG9yIGxvd2VyY2FzZSBsZXR0ZXJzLCBidXQgbm90IGJvdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBzdHJpbmcgSW5wdXQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBoYXNTaW5nbGVDYXNlKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcgPT09IHN0cmluZy50b0xvd2VyQ2FzZSgpIHx8IHN0cmluZyA9PT0gc3RyaW5nLnRvVXBwZXJDYXNlKCk7XG59XG4vKipcbiAqIFJldHVybnMgYSB1aW50OGFycmF5IGZvciBhIGdpdmVuIHN0cmluZyBpbnB1dFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gc3RyaW5nIElucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9VaW50OEFycmF5KHN0cmluZykge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIC8vIENvbnZlcnQgZWFjaCBwYWlyIG9mIGNoYXJhY3RlcnMgdG8gYW4gaW50ZWdlclxuICAgICAgICBhcnJheVtpIC8gMl0gPSBwYXJzZUludChzdHJpbmcuc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHVpbnQ4YXJyYXkgZm9yIGEgZ2l2ZW4gc3RyaW5nIGlucHV0XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB1aW50OEFycmF5IElucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdWludDhhcnJheVRvSGV4U3RyaW5nKHVpbnQ4QXJyYXkpIHtcbiAgICBsZXQgaGV4U3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBoZXggPSB1aW50OEFycmF5W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgMiBkaWdpdHMgZm9yIGVhY2ggYnl0ZVxuICAgICAgICBoZXggPSBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICAgICAgICBoZXhTdHJpbmcgKz0gaGV4O1xuICAgIH1cbiAgICByZXR1cm4gaGV4U3RyaW5nO1xufVxuLyoqXG4gKiBHZXQgdHlwZSBhbmQgaGFzaCBmcm9tIGFuIG91dHB1dFNjcmlwdFxuICpcbiAqIFN1cHBvcnRlZCBvdXRwdXRTY3JpcHRzOlxuICpcbiAqIFAyUEtIOiA3NmE5MTQ8aGFzaD44OGFjXG4gKiBQMlNIOiAgYTkxNDxoYXNoPjg3XG4gKlxuICogVmFsaWRhdGVzIGZvciBzdXBwb3J0ZWQgb3V0cHV0U2NyaXB0IGFuZCBoYXNoIGxlbmd0aCAqXG4gKlxuICogQHBhcmFtIG91dHB1dFNjcmlwdCBhbiBlY2FzaCB0eCBvdXRwdXRTY3JpcHRcbiAqIEB0aHJvd3Mge1ZhbGlkYXRpb25FcnJvcn1cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZUFuZEhhc2hGcm9tT3V0cHV0U2NyaXB0KG91dHB1dFNjcmlwdCkge1xuICAgIGNvbnN0IHAycGtoUHJlZml4ID0gJzc2YTkxNCc7XG4gICAgY29uc3QgcDJwa2hTdWZmaXggPSAnODhhYyc7XG4gICAgY29uc3QgcDJzaFByZWZpeCA9ICdhOTE0JztcbiAgICBjb25zdCBwMnNoU3VmZml4ID0gJzg3JztcbiAgICBsZXQgaGFzaCwgdHlwZTtcbiAgICAvLyBJZiBvdXRwdXRTY3JpcHQgYmVnaW5zIHdpdGggJzc2YTkxNCcgYW5kIGVuZHMgd2l0aCAnODhhYydcbiAgICBpZiAob3V0cHV0U2NyaXB0LnNsaWNlKDAsIHAycGtoUHJlZml4Lmxlbmd0aCkgPT09IHAycGtoUHJlZml4ICYmXG4gICAgICAgIG91dHB1dFNjcmlwdC5zbGljZSgtMSAqIHAycGtoU3VmZml4Lmxlbmd0aCkgPT09IHAycGtoU3VmZml4KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdHlwZSBwMnBraFxuICAgICAgICB0eXBlID0gJ3AycGtoJztcbiAgICAgICAgLy8gaGFzaCBpcyB0aGUgc3RyaW5nIGluIGJldHdlZW4gJzc2YTE5NCcgYW5kICc4OGFjJ1xuICAgICAgICBoYXNoID0gb3V0cHV0U2NyaXB0LnN1YnN0cmluZyhvdXRwdXRTY3JpcHQuaW5kZXhPZihwMnBraFByZWZpeCkgKyBwMnBraFByZWZpeC5sZW5ndGgsIG91dHB1dFNjcmlwdC5sYXN0SW5kZXhPZihwMnBraFN1ZmZpeCkpO1xuICAgICAgICAvLyBJZiBvdXRwdXRTY3JpcHQgYmVnaW5zIHdpdGggJ2E5MTQnIGFuZCBlbmRzIHdpdGggJzg3J1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRwdXRTY3JpcHQuc2xpY2UoMCwgcDJzaFByZWZpeC5sZW5ndGgpID09PSBwMnNoUHJlZml4ICYmXG4gICAgICAgIG91dHB1dFNjcmlwdC5zbGljZSgtMSAqIHAyc2hTdWZmaXgubGVuZ3RoKSA9PT0gcDJzaFN1ZmZpeCkge1xuICAgICAgICAvLyBXZSBoYXZlIHR5cGUgcDJzaFxuICAgICAgICB0eXBlID0gJ3Ayc2gnO1xuICAgICAgICAvLyBoYXNoIGlzIHRoZSBzdHJpbmcgaW4gYmV0d2VlbiAnYTkxNCcgYW5kICc4NydcbiAgICAgICAgaGFzaCA9IG91dHB1dFNjcmlwdC5zdWJzdHJpbmcob3V0cHV0U2NyaXB0LmluZGV4T2YocDJzaFByZWZpeCkgKyBwMnNoUHJlZml4Lmxlbmd0aCwgb3V0cHV0U2NyaXB0Lmxhc3RJbmRleE9mKHAyc2hTdWZmaXgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRocm93IHZhbGlkYXRpb24gZXJyb3IgaWYgb3V0cHV0U2NyaXB0IG5vdCBvZiB0aGVzZSB0d28gdHlwZXNcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignVW5zdXBwb3J0ZWQgb3V0cHV0U2NyaXB0OiAnICsgb3V0cHV0U2NyaXB0KTtcbiAgICB9XG4gICAgLy8gVGhyb3cgdmFsaWRhdGlvbiBlcnJvciBpZiBoYXNoIGlzIG9mIGludmFsaWQgc2l6ZVxuICAgIC8vIFBlciBzcGVjLCB2YWxpZCBoYXNoIHNpemVzIGluIGJ5dGVzXG4gICAgY29uc3QgVkFMSURfU0laRVMgPSBbMjAsIDI0LCAyOCwgMzIsIDQwLCA0OCwgNTYsIDY0XTtcbiAgICBpZiAoIVZBTElEX1NJWkVTLmluY2x1ZGVzKGhhc2gubGVuZ3RoIC8gMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignSW52YWxpZCBoYXNoIHNpemUgaW4gb3V0cHV0U2NyaXB0OiAnICsgb3V0cHV0U2NyaXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZSwgaGFzaCB9O1xufVxuY29uc3QgZ2V0T3V0cHV0U2NyaXB0RnJvbVR5cGVBbmRIYXNoID0gKHR5cGUsIGhhc2gpID0+IHtcbiAgICB2YWxpZGF0ZSh0eXBlID09PSAncDJwa2gnIHx8IHR5cGUgPT09ICdwMnNoJywgJ0ludmFsaWQgdHlwZTogJyArIHR5cGUgKyAnLicpO1xuICAgIGxldCBvdXRwdXRTY3JpcHQ7XG4gICAgaWYgKHR5cGUgPT09ICdwMnBraCcpIHtcbiAgICAgICAgb3V0cHV0U2NyaXB0ID0gYDc2YTkxNCR7aGFzaH04OGFjYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dHB1dFNjcmlwdCA9IGBhOTE0JHtoYXNofTg3YDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dFNjcmlwdDtcbn07XG5leHBvcnRzLmdldE91dHB1dFNjcmlwdEZyb21UeXBlQW5kSGFzaCA9IGdldE91dHB1dFNjcmlwdEZyb21UeXBlQW5kSGFzaDtcbi8qKlxuICogRW5jb2RlcyBhIGdpdmVuIG91dHB1dFNjcmlwdCBpbnRvIGFuIGVDYXNoIGFkZHJlc3MgdXNpbmcgdGhlIG9wdGlvbmFsbHkgc3BlY2lmaWVkIHByZWZpeC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gb3V0cHV0U2NyaXB0IGFuIGVjYXNoIHR4IG91dHB1dFNjcmlwdFxuICogQHBhcmFtIHByZWZpeCBDYXNoIGFkZHJlc3MgcHJlZml4LiBFLmcuOiAnZWNhc2gnLlxuICogQHRocm93cyB7VmFsaWRhdGlvbkVycm9yfVxuICovXG5mdW5jdGlvbiBlbmNvZGVPdXRwdXRTY3JpcHQob3V0cHV0U2NyaXB0LCBwcmVmaXggPSAnZWNhc2gnKSB7XG4gICAgLy8gR2V0IHR5cGUgYW5kIGhhc2ggZnJvbSBvdXRwdXRTY3JpcHRcbiAgICBjb25zdCB7IHR5cGUsIGhhc2ggfSA9IGdldFR5cGVBbmRIYXNoRnJvbU91dHB1dFNjcmlwdChvdXRwdXRTY3JpcHQpO1xuICAgIC8vIFRoZSBlbmNvZGUgZnVuY3Rpb24gdmFsaWRhdGVzIGhhc2ggZm9yIGNvcnJlY3QgbGVuZ3RoXG4gICAgcmV0dXJuIGVuY29kZUNhc2hBZGRyZXNzKHByZWZpeCwgdHlwZSwgaGFzaCk7XG59XG4vKipcbiAqIFJldHVybiB0cnVlIGZvciBhIHZhbGlkIGNhc2hhZGRyZXNzXG4gKiBQcmVmaXhsZXNzIGFkZHJlc3NlcyB3aXRoIHZhbGlkIGNoZWNrc3VtIGFyZSBhbHNvIHZhbGlkXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHRlc3RlZEFkZHJlc3MgYSBzdHJpbmcgdGVzdGVkIGZvciBjYXNoYWRkcmVzcyB2YWxpZGl0eVxuICogQHBhcmFtIG9wdGlvbmFsUHJlZml4IGNhc2hhZGRyIHByZWZpeFxuICogQHRocm93cyB7VmFsaWRhdGlvbkVycm9yfVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ2FzaEFkZHJlc3MoY2FzaGFkZHJlc3MsIG9wdGlvbmFsUHJlZml4ID0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gZGVjb2RlQ2FzaEFkZHJlc3MoY2FzaGFkZHJlc3MpO1xuICAgICAgICBpZiAob3B0aW9uYWxQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggPT09IG9wdGlvbmFsUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybiB0cnVlIGZvciBhIHZhbGlkIGNhc2hhZGRyZXNzXG4gKiBQcmVmaXhsZXNzIGFkZHJlc3NlcyB3aXRoIHZhbGlkIGNoZWNrc3VtIGFyZSBhbHNvIHZhbGlkXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIGFkZHJlc3MgYSB2YWxpZCBwMnBraCBvciBwMnNoIGNhc2ggYWRkcmVzc1xuICogQHJldHVybnMgdGhlIG91dHB1dFNjcmlwdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBhZGRyZXNzIGFuZCB0eXBlXG4gKiBAdGhyb3dzIHtWYWxpZGF0aW9uRXJyb3J9IGlmIGRlY29kZSBmYWlsc1xuICovXG5mdW5jdGlvbiBnZXRPdXRwdXRTY3JpcHRGcm9tQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgeyB0eXBlLCBoYXNoIH0gPSBkZWNvZGVDYXNoQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBsZXQgcmVnaXN0cmF0aW9uT3V0cHV0U2NyaXB0O1xuICAgIGlmICh0eXBlID09PSAncDJwa2gnKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbk91dHB1dFNjcmlwdCA9IGA3NmE5MTQke2hhc2h9ODhhY2A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWdpc3RyYXRpb25PdXRwdXRTY3JpcHQgPSBgYTkxNCR7aGFzaH04N2A7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3RyYXRpb25PdXRwdXRTY3JpcHQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6942\n\n}")},6946:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{// minimal library entry point.\n\n\nmodule.exports = __webpack_require__(4394);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk0Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFYTtBQUNiLDBDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9taW5pbWFsLmpzPzU0M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbWluaW1hbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LW1pbmltYWxcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6946\n\n}")},7044:(__unused_webpack_module,exports)=>{eval("{const numeric = '[0-9]+'\nconst alphanumeric = '[A-Z $%*+\\\\-./:]+'\nlet kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'\nkanji = kanji.replace(/u/g, '\\\\u')\n\nconst byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+'\n\nexports.KANJI = new RegExp(kanji, 'g')\nexports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g')\nexports.BYTE = new RegExp(byte, 'g')\nexports.NUMERIC = new RegExp(numeric, 'g')\nexports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')\n\nconst TEST_KANJI = new RegExp('^' + kanji + '$')\nconst TEST_NUMERIC = new RegExp('^' + numeric + '$')\nconst TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$')\n\nexports.testKanji = function testKanji (str) {\n  return TEST_KANJI.test(str)\n}\n\nexports.testNumeric = function testNumeric (str) {\n  return TEST_NUMERIC.test(str)\n}\n\nexports.testAlphanumeric = function testAlphanumeric (str) {\n  return TEST_ALPHANUMERIC.test(str)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA0NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWixlQUFlO0FBQ2Ysb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvY29yZS9yZWdleC5qcz8wNDI1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG51bWVyaWMgPSAnWzAtOV0rJ1xuY29uc3QgYWxwaGFudW1lcmljID0gJ1tBLVogJCUqK1xcXFwtLi86XSsnXG5sZXQga2FuamkgPSAnKD86W3UzMDAwLXUzMDNGXXxbdTMwNDAtdTMwOUZdfFt1MzBBMC11MzBGRl18JyArXG4gICdbdUZGMDAtdUZGRUZdfFt1NEUwMC11OUZBRl18W3UyNjA1LXUyNjA2XXxbdTIxOTAtdTIxOTVdfHUyMDNCfCcgK1xuICAnW3UyMDEwdTIwMTV1MjAxOHUyMDE5dTIwMjV1MjAyNnUyMDFDdTIwMUR1MjIyNXUyMjYwXXwnICtcbiAgJ1t1MDM5MS11MDQ1MV18W3UwMEE3dTAwQTh1MDBCMXUwMEI0dTAwRDd1MDBGN10pKydcbmthbmppID0ga2FuamkucmVwbGFjZSgvdS9nLCAnXFxcXHUnKVxuXG5jb25zdCBieXRlID0gJyg/Oig/IVtBLVowLTkgJCUqK1xcXFwtLi86XXwnICsga2FuamkgKyAnKSg/Oi58W1xcclxcbl0pKSsnXG5cbmV4cG9ydHMuS0FOSkkgPSBuZXcgUmVnRXhwKGthbmppLCAnZycpXG5leHBvcnRzLkJZVEVfS0FOSkkgPSBuZXcgUmVnRXhwKCdbXkEtWjAtOSAkJSorXFxcXC0uLzpdKycsICdnJylcbmV4cG9ydHMuQllURSA9IG5ldyBSZWdFeHAoYnl0ZSwgJ2cnKVxuZXhwb3J0cy5OVU1FUklDID0gbmV3IFJlZ0V4cChudW1lcmljLCAnZycpXG5leHBvcnRzLkFMUEhBTlVNRVJJQyA9IG5ldyBSZWdFeHAoYWxwaGFudW1lcmljLCAnZycpXG5cbmNvbnN0IFRFU1RfS0FOSkkgPSBuZXcgUmVnRXhwKCdeJyArIGthbmppICsgJyQnKVxuY29uc3QgVEVTVF9OVU1FUklDID0gbmV3IFJlZ0V4cCgnXicgKyBudW1lcmljICsgJyQnKVxuY29uc3QgVEVTVF9BTFBIQU5VTUVSSUMgPSBuZXcgUmVnRXhwKCdeW0EtWjAtOSAkJSorXFxcXC0uLzpdKyQnKVxuXG5leHBvcnRzLnRlc3RLYW5qaSA9IGZ1bmN0aW9uIHRlc3RLYW5qaSAoc3RyKSB7XG4gIHJldHVybiBURVNUX0tBTkpJLnRlc3Qoc3RyKVxufVxuXG5leHBvcnRzLnRlc3ROdW1lcmljID0gZnVuY3Rpb24gdGVzdE51bWVyaWMgKHN0cikge1xuICByZXR1cm4gVEVTVF9OVU1FUklDLnRlc3Qoc3RyKVxufVxuXG5leHBvcnRzLnRlc3RBbHBoYW51bWVyaWMgPSBmdW5jdGlvbiB0ZXN0QWxwaGFudW1lcmljIChzdHIpIHtcbiAgcmV0dXJuIFRFU1RfQUxQSEFOVU1FUklDLnRlc3Qoc3RyKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7044\n\n}")},7076:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nconst _md_ts_1 = __webpack_require__(7202);\nconst u64 = __webpack_require__(2318);\nconst utils_ts_1 = __webpack_require__(9175);\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMi5qcz84Yzc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGE1MTJfMjI0ID0gZXhwb3J0cy5zaGE1MTJfMjU2ID0gZXhwb3J0cy5zaGEzODQgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLlNIQTUxMl8yNTYgPSBleHBvcnRzLlNIQTUxMl8yMjQgPSBleHBvcnRzLlNIQTM4NCA9IGV4cG9ydHMuU0hBNTEyID0gZXhwb3J0cy5TSEEyMjQgPSBleHBvcnRzLlNIQTI1NiA9IHZvaWQgMDtcbi8qKlxuICogU0hBMiBoYXNoIGZ1bmN0aW9uLiBBLmsuYS4gc2hhMjU2LCBzaGEzODQsIHNoYTUxMiwgc2hhNTEyXzIyNCwgc2hhNTEyXzI1Ni5cbiAqIFNIQTI1NiBpcyB0aGUgZmFzdGVzdCBoYXNoIGltcGxlbWVudGFibGUgaW4gSlMsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogQ2hlY2sgb3V0IFtSRkMgNDYzNF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjM0KSBhbmRcbiAqIFtGSVBTIDE4MC00XShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmKS5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgX21kX3RzXzEgPSByZXF1aXJlKFwiLi9fbWQuanNcIik7XG5jb25zdCB1NjQgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX21kX3RzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRMZW4gPSAzMikge1xuICAgICAgICBzdXBlcig2NCwgb3V0cHV0TGVuLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBfbWRfdHNfMS5TSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBfbWRfdHNfMS5TSEEyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBfbWRfdHNfMS5TSEEyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBfbWRfdHNfMS5TSEEyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBfbWRfdHNfMS5TSEEyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBfbWRfdHNfMS5TSEEyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBfbWRfdHNfMS5TSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBfbWRfdHNfMS5TSEEyNTZfSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gKDAsIHV0aWxzX3RzXzEucm90cikoVzE1LCA3KSBeICgwLCB1dGlsc190c18xLnJvdHIpKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9ICgwLCB1dGlsc190c18xLnJvdHIpKFcyLCAxNykgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gKDAsIHV0aWxzX3RzXzEucm90cikoRSwgNikgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShFLCAxMSkgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgKDAsIF9tZF90c18xLkNoaSkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfdHNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc190c18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc190c18xLnJvdHIpKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArICgwLCBfbWRfdHNfMS5NYWopKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKFNIQTI1Nl9XKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyNTYgPSBTSEEyNTY7XG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgICAgIHRoaXMuQSA9IF9tZF90c18xLlNIQTIyNF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IF9tZF90c18xLlNIQTIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IF9tZF90c18xLlNIQTIyNF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IF9tZF90c18xLlNIQTIyNF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IF9tZF90c18xLlNIQTIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IF9tZF90c18xLlNIQTIyNF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IF9tZF90c18xLlNIQTIyNF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IF9tZF90c18xLlNIQTIyNF9JVls3XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyMjQgPSBTSEEyMjQ7XG4vLyBTSEEyLTUxMiBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cbi8vIFJvdW5kIGNvbnRhbnRzXG4vLyBGaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEs1MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG5jb25zdCBTSEE1MTJfS2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMF0pKCk7XG5jb25zdCBTSEE1MTJfS2wgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMV0pKCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY2xhc3MgU0hBNTEyIGV4dGVuZHMgX21kX3RzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRMZW4gPSA2NCkge1xuICAgICAgICBzdXBlcigxMjgsIG91dHB1dExlbiwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gX21kX3RzXzEuU0hBNTEyX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IF9tZF90c18xLlNIQTUxMl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gX21kX3RzXzEuU0hBNTEyX0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IF9tZF90c18xLlNIQTUxMl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBfbWRfdHNfMS5TSEE1MTJfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gX21kX3RzXzEuU0hBNTEyX0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IF9tZF90c18xLlNIQTUxMl9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gX21kX3RzXzEuU0hBNTEyX0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IF9tZF90c18xLlNIQTUxMl9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gX21kX3RzXzEuU0hBNTEyX0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IF9tZF90c18xLlNIQTUxMl9JVlsxNV0gfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKFNIQTUxMl9XX0gsIFNIQTUxMl9XX0wpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLlNIQTUxMiA9IFNIQTUxMjtcbmNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDQ4KTtcbiAgICAgICAgdGhpcy5BaCA9IF9tZF90c18xLlNIQTM4NF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBfbWRfdHNfMS5TSEEzODRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gX21kX3RzXzEuU0hBMzg0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IF9tZF90c18xLlNIQTM4NF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBfbWRfdHNfMS5TSEEzODRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gX21kX3RzXzEuU0hBMzg0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IF9tZF90c18xLlNIQTM4NF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBfbWRfdHNfMS5TSEEzODRfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gX21kX3RzXzEuU0hBMzg0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IF9tZF90c18xLlNIQTM4NF9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBfbWRfdHNfMS5TSEEzODRfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IF9tZF90c18xLlNIQTM4NF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gX21kX3RzXzEuU0hBMzg0X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBfbWRfdHNfMS5TSEEzODRfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IF9tZF90c18xLlNIQTM4NF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gX21kX3RzXzEuU0hBMzg0X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEzODQgPSBTSEEzODQ7XG4vKipcbiAqIFRydW5jYXRlZCBTSEE1MTIvMjU2IGFuZCBTSEE1MTIvMjI0LlxuICogU0hBNTEyX0lWIGlzIFhPUmVkIHdpdGggMHhhNWE1YTVhNWE1YTVhNWE1LCB0aGVuIHVzZWQgYXMgXCJpbnRlcm1lZGlhcnlcIiBJViBvZiBTSEE1MTIvdC5cbiAqIFRoZW4gdCBoYXNoZXMgc3RyaW5nIHRvIHByb2R1Y2UgcmVzdWx0IElWLlxuICogU2VlIGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgLlxuICovXG4vKiogU0hBNTEyLzIyNCBJViAqL1xuY29uc3QgVDIyNF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDhjM2QzN2M4LCAweDE5NTQ0ZGEyLCAweDczZTE5OTY2LCAweDg5ZGNkNGQ2LCAweDFkZmFiN2FlLCAweDMyZmY5YzgyLCAweDY3OWRkNTE0LCAweDU4MmY5ZmNmLFxuICAgIDB4MGY2ZDJiNjksIDB4N2JkNDRkYTgsIDB4NzdlMzZmNzMsIDB4MDRjNDg5NDIsIDB4M2Y5ZDg1YTgsIDB4NmExZDM2YzgsIDB4MTExMmU2YWQsIDB4OTFkNjkyYTEsXG5dKTtcbi8qKiBTSEE1MTIvMjU2IElWICovXG5jb25zdCBUMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MjIzMTIxOTQsIDB4ZmMyYmY3MmMsIDB4OWY1NTVmYTMsIDB4Yzg0YzY0YzIsIDB4MjM5M2I4NmIsIDB4NmY1M2IxNTEsIDB4OTYzODc3MTksIDB4NTk0MGVhYmQsXG4gICAgMHg5NjI4M2VlMiwgMHhhODhlZmZlMywgMHhiZTVlMWUyNSwgMHg1Mzg2Mzk5MiwgMHgyYjAxOTlmYywgMHgyYzg1YjhhYSwgMHgwZWI3MmRkYywgMHg4MWM1MmNhMixcbl0pO1xuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BaCA9IFQyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDIyNF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjI0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyMjRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDIyNF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDIyNF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDIyNF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDIyNF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDIyNF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDIyNF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyXzIyNCA9IFNIQTUxMl8yMjQ7XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMzIpO1xuICAgICAgICB0aGlzLkFoID0gVDI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjU2X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyNTZfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDI1Nl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjU2X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjU2X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjU2X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjU2X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjU2X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjU2X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTJfMjU2ID0gU0hBNTEyXzI1Njtcbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LlxuICpcbiAqIEl0IGlzIHRoZSBmYXN0ZXN0IEpTIGhhc2gsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogVG8gYnJlYWsgc2hhMjU2IHVzaW5nIGJpcnRoZGF5IGF0dGFjaywgYXR0YWNrZXJzIG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcy5cbiAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuLyoqIFNIQTItMjI0IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNCAqL1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vKiogU0hBMi01MTIgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0cy5zaGE1MTIgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEE1MTIoKSk7XG4vKiogU0hBMi0zODQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0cy5zaGEzODQgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vKipcbiAqIFNIQTItNTEyLzI1NiBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnRzLnNoYTUxMl8yNTYgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yMjQgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0cy5zaGE1MTJfMjI0ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7076\n\n}")},7148:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst ffi = __importStar(__webpack_require__(3650));\nconst ecash_lib_wasm_bg_browser_js_1 = __webpack_require__(1216);\nconst ecc_js_1 = __webpack_require__(3799);\nconst hash_js_1 = __webpack_require__(5632);\nconst publicKeyCrypto_js_1 = __webpack_require__(6247);\nconst wasmRaw = Uint8Array.from(atob(ecash_lib_wasm_bg_browser_js_1.ECASH_LIB_WASM_BASE64), c => c.charCodeAt(0));\nffi.initSync(wasmRaw);\n(0, ecc_js_1.__setEcc)(new ffi.Ecc());\n(0, hash_js_1.__setHashes)({\n    sha256: ffi.sha256,\n    sha256d: ffi.sha256d,\n    shaRmd160: ffi.shaRmd160,\n    sha512: ffi.sha512,\n    Sha256H: ffi.Sha256H,\n    Sha512H: ffi.Sha512H,\n});\n(0, publicKeyCrypto_js_1.__setPkc)({\n    algoSupported: ffi.publicKeyCryptoAlgoSupported,\n    verify: ffi.publicKeyCryptoVerify,\n});\n//# sourceMappingURL=initBrowser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE0OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLG1CQUFPLENBQUMsSUFBaUM7QUFDbEUsdUNBQXVDLG1CQUFPLENBQUMsSUFBb0M7QUFDbkYsaUJBQWlCLG1CQUFPLENBQUMsSUFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFXO0FBQ3JDLDZCQUE2QixtQkFBTyxDQUFDLElBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvaW5pdEJyb3dzZXIuanM/ZWM2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZmaSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9mZmkvZWNhc2hfbGliX3dhc21fYnJvd3Nlci5qc1wiKSk7XG5jb25zdCBlY2FzaF9saWJfd2FzbV9iZ19icm93c2VyX2pzXzEgPSByZXF1aXJlKFwiLi9mZmkvZWNhc2hfbGliX3dhc21fYmdfYnJvd3Nlci5qc1wiKTtcbmNvbnN0IGVjY19qc18xID0gcmVxdWlyZShcIi4vZWNjLmpzXCIpO1xuY29uc3QgaGFzaF9qc18xID0gcmVxdWlyZShcIi4vaGFzaC5qc1wiKTtcbmNvbnN0IHB1YmxpY0tleUNyeXB0b19qc18xID0gcmVxdWlyZShcIi4vcHVibGljS2V5Q3J5cHRvLmpzXCIpO1xuY29uc3Qgd2FzbVJhdyA9IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGVjYXNoX2xpYl93YXNtX2JnX2Jyb3dzZXJfanNfMS5FQ0FTSF9MSUJfV0FTTV9CQVNFNjQpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG5mZmkuaW5pdFN5bmMod2FzbVJhdyk7XG4oMCwgZWNjX2pzXzEuX19zZXRFY2MpKG5ldyBmZmkuRWNjKCkpO1xuKDAsIGhhc2hfanNfMS5fX3NldEhhc2hlcykoe1xuICAgIHNoYTI1NjogZmZpLnNoYTI1NixcbiAgICBzaGEyNTZkOiBmZmkuc2hhMjU2ZCxcbiAgICBzaGFSbWQxNjA6IGZmaS5zaGFSbWQxNjAsXG4gICAgc2hhNTEyOiBmZmkuc2hhNTEyLFxuICAgIFNoYTI1Nkg6IGZmaS5TaGEyNTZILFxuICAgIFNoYTUxMkg6IGZmaS5TaGE1MTJILFxufSk7XG4oMCwgcHVibGljS2V5Q3J5cHRvX2pzXzEuX19zZXRQa2MpKHtcbiAgICBhbGdvU3VwcG9ydGVkOiBmZmkucHVibGljS2V5Q3J5cHRvQWxnb1N1cHBvcnRlZCxcbiAgICB2ZXJpZnk6IGZmaS5wdWJsaWNLZXlDcnlwdG9WZXJpZnksXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXRCcm93c2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7148\n\n}')},7151:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnsignedTxInput = exports.UnsignedTx = void 0;\nconst hash_js_1 = __webpack_require__(5632);\nconst writerbytes_js_1 = __webpack_require__(8161);\nconst writerlength_js_1 = __webpack_require__(7408);\nconst varsize_js_1 = __webpack_require__(1451);\nconst op_js_1 = __webpack_require__(243);\nconst opcode_js_1 = __webpack_require__(2250);\nconst script_js_1 = __webpack_require__(6187);\nconst sigHashType_js_1 = __webpack_require__(1659);\nconst tx_js_1 = __webpack_require__(932);\n/** An unsigned tx, which helps us build the sighash preimage we need to sign */\nclass UnsignedTx {\n    constructor(params) {\n        this.tx = params.tx;\n        this.prevoutsHash = params.prevoutsHash;\n        this.sequencesHash = params.sequencesHash;\n        this.outputsHash = params.outputsHash;\n    }\n    /**\n     * Make an UnsignedTx from a Tx, will precompute the fields required to\n     * sign the tx\n     **/\n    static fromTx(tx) {\n        return new UnsignedTx({\n            tx,\n            prevoutsHash: txWriterHash(tx, writePrevouts),\n            sequencesHash: txWriterHash(tx, writeSequences),\n            outputsHash: txWriterHash(tx, writeOutputs),\n        });\n    }\n    /**\n     * Make a dummy UnsignedTx from a Tx, will set dummy values for the fields\n     * required to sign the tx. Useful for tx size estimation.\n     **/\n    static dummyFromTx(tx) {\n        return new UnsignedTx({\n            tx,\n            prevoutsHash: new Uint8Array(32),\n            sequencesHash: new Uint8Array(32),\n            outputsHash: new Uint8Array(32),\n        });\n    }\n    /** Return the unsigned tx input at the given input index */\n    inputAt(inputIdx) {\n        return new UnsignedTxInput({ inputIdx, unsignedTx: this });\n    }\n}\nexports.UnsignedTx = UnsignedTx;\n// Write the legacy preimage used pre-UAHF.\n// It's modeled closely after SignatureHash in interpreter.cpp.\nfunction writeLegacyPreimage(writer, tx, scriptCode, inputIdx, sigHashType) {\n    const hasAnyoneCanPay = sigHashType.inputType === sigHashType_js_1.SigHashTypeInputs.ANYONECANPAY;\n    const writeLegacyScriptCode = () => {\n        const ops = scriptCode.ops();\n        let nextOp = undefined;\n        const newOps = [];\n        // Filter out all code separators\n        while ((nextOp = ops.next()) !== undefined) {\n            if ((0, op_js_1.isPushOp)(nextOp) || nextOp != opcode_js_1.OP_CODESEPARATOR) {\n                newOps.push(nextOp);\n            }\n        }\n        script_js_1.Script.fromOps(newOps).writeWithSize(writer);\n    };\n    const writeLegacyInput = (idx) => {\n        // In case of SIGHASH_ANYONECANPAY, only the input being signed is\n        // serialized\n        if (hasAnyoneCanPay) {\n            idx = inputIdx;\n        }\n        const input = tx.inputs[idx];\n        // Serialize the prevout\n        (0, tx_js_1.writeOutPoint)(input.prevOut, writer);\n        // Serialize the script\n        if (idx != inputIdx) {\n            // Blank out other inputs' signatures\n            new script_js_1.Script().writeWithSize(writer);\n        }\n        else {\n            writeLegacyScriptCode();\n        }\n        // Serialize the nSequence\n        if (idx != inputIdx &&\n            (sigHashType.outputType === sigHashType_js_1.SigHashTypeOutputs.SINGLE ||\n                sigHashType.outputType === sigHashType_js_1.SigHashTypeOutputs.NONE)) {\n            // let the others update at will\n            writer.putU32(0);\n        }\n        else {\n            writer.putU32(input.sequence ?? tx_js_1.DEFAULT_SEQUENCE);\n        }\n    };\n    const writeLegacyOutput = (idx) => {\n        if (sigHashType.outputType === sigHashType_js_1.SigHashTypeOutputs.SINGLE &&\n            idx != inputIdx) {\n            // Do not lock-in the txout payee at other indices as txin\n            (0, tx_js_1.writeTxOutput)({ sats: 0n, script: new script_js_1.Script() }, writer);\n        }\n        else {\n            (0, tx_js_1.writeTxOutput)(tx.outputs[idx], writer);\n        }\n    };\n    writer.putU32(tx.version);\n    const numInputs = hasAnyoneCanPay ? 1 : tx.inputs.length;\n    (0, varsize_js_1.writeVarSize)(numInputs, writer);\n    for (let inputIdx = 0; inputIdx < numInputs; ++inputIdx) {\n        writeLegacyInput(inputIdx);\n    }\n    // Serialize vout\n    const numOutputs = (() => {\n        switch (sigHashType.outputType) {\n            case sigHashType_js_1.SigHashTypeOutputs.NONE:\n                return 0;\n            case sigHashType_js_1.SigHashTypeOutputs.SINGLE:\n                return inputIdx + 1;\n            default:\n                return tx.outputs.length;\n        }\n    })();\n    (0, varsize_js_1.writeVarSize)(numOutputs, writer);\n    for (let outputIdx = 0; outputIdx < numOutputs; outputIdx++) {\n        writeLegacyOutput(outputIdx);\n    }\n    // Serialize nLockTime\n    writer.putU32(tx.locktime);\n    // Serialize sigHashType\n    writer.putU32(sigHashType.toInt());\n}\n/**\n * An unsigned tx input, can be used to build a sighash preimage ready to be\n * signed\n **/\nclass UnsignedTxInput {\n    constructor(params) {\n        this.inputIdx = params.inputIdx;\n        this.unsignedTx = params.unsignedTx;\n    }\n    /**\n     * Build the sigHashPreimage for this input, with the given sigHashType\n     * and OP_CODESEPARATOR index\n     **/\n    sigHashPreimage(sigHashType, nCodesep) {\n        const tx = this.unsignedTx.tx;\n        const input = tx.inputs[this.inputIdx];\n        if (input.signData === undefined) {\n            throw new Error('Input must have signData set');\n        }\n        const signData = input.signData;\n        const redeemScript = signDataScriptCode(input.signData);\n        const scriptCode = nCodesep === undefined\n            ? redeemScript\n            : redeemScript.cutOutCodesep(nCodesep);\n        // Sign LEGACY signatures that don't use SIGHASH_FORKID\n        if (sigHashType.variant === sigHashType_js_1.SigHashTypeVariant.LEGACY) {\n            if (sigHashType.outputType == sigHashType_js_1.SigHashTypeOutputs.SINGLE &&\n                this.inputIdx >= tx.outputs.length) {\n                throw new Error('Invalid usage of SINGLE, input has no corresponding output');\n            }\n            const writePreimage = (writer) => {\n                writeLegacyPreimage(writer, this.unsignedTx.tx, scriptCode, this.inputIdx, sigHashType);\n            };\n            const preimageWriterLen = new writerlength_js_1.WriterLength();\n            writePreimage(preimageWriterLen);\n            const preimageWriter = new writerbytes_js_1.WriterBytes(preimageWriterLen.length);\n            writePreimage(preimageWriter);\n            return {\n                bytes: preimageWriter.data,\n                scriptCode,\n                redeemScript,\n            };\n        }\n        let hashOutputs;\n        switch (sigHashType.outputType) {\n            case sigHashType_js_1.SigHashTypeOutputs.ALL:\n                hashOutputs = this.unsignedTx.outputsHash;\n                break;\n            case sigHashType_js_1.SigHashTypeOutputs.NONE:\n                hashOutputs = new Uint8Array(32);\n                break;\n            case sigHashType_js_1.SigHashTypeOutputs.SINGLE:\n                if (this.inputIdx < tx.outputs.length) {\n                    const output = tx.outputs[this.inputIdx];\n                    const writerOutputLength = new writerlength_js_1.WriterLength();\n                    (0, tx_js_1.writeTxOutput)(output, writerOutputLength);\n                    const writerOutput = new writerbytes_js_1.WriterBytes(writerOutputLength.length);\n                    (0, tx_js_1.writeTxOutput)(output, writerOutput);\n                    hashOutputs = (0, hash_js_1.sha256d)(writerOutput.data);\n                }\n                else {\n                    hashOutputs = new Uint8Array(32);\n                }\n                break;\n        }\n        const writePreimage = (writer) => {\n            writer.putU32(tx.version);\n            if (sigHashType.inputType == sigHashType_js_1.SigHashTypeInputs.FIXED) {\n                writer.putBytes(this.unsignedTx.prevoutsHash);\n            }\n            else {\n                writer.putBytes(new Uint8Array(32));\n            }\n            if (sigHashType.inputType == sigHashType_js_1.SigHashTypeInputs.FIXED &&\n                sigHashType.outputType == sigHashType_js_1.SigHashTypeOutputs.ALL) {\n                writer.putBytes(this.unsignedTx.sequencesHash);\n            }\n            else {\n                writer.putBytes(new Uint8Array(32));\n            }\n            (0, tx_js_1.writeOutPoint)(input.prevOut, writer);\n            scriptCode.writeWithSize(writer);\n            writer.putU64(signData.sats);\n            writer.putU32(input.sequence ?? tx_js_1.DEFAULT_SEQUENCE);\n            writer.putBytes(hashOutputs);\n            writer.putU32(tx.locktime);\n            writer.putU32(sigHashType.toInt());\n        };\n        const preimageWriterLen = new writerlength_js_1.WriterLength();\n        writePreimage(preimageWriterLen);\n        const preimageWriter = new writerbytes_js_1.WriterBytes(preimageWriterLen.length);\n        writePreimage(preimageWriter);\n        return {\n            bytes: preimageWriter.data,\n            scriptCode,\n            redeemScript,\n        };\n    }\n    /** Return the TxInput of this UnsignedTxInput */\n    txInput() {\n        return this.unsignedTx.tx.inputs[this.inputIdx];\n    }\n}\nexports.UnsignedTxInput = UnsignedTxInput;\n/** Find the scriptCode that should be signed */\nfunction signDataScriptCode(signData) {\n    if (signData.outputScript !== undefined) {\n        if (signData.outputScript.isP2sh()) {\n            throw new Error('P2SH requires redeemScript to be set, not outputScript');\n        }\n        return signData.outputScript;\n    }\n    if (signData.redeemScript === undefined) {\n        throw new Error('Must either set outputScript or redeemScript');\n    }\n    return signData.redeemScript;\n}\nfunction txWriterHash(tx, fn) {\n    const writerLength = new writerlength_js_1.WriterLength();\n    fn(tx, writerLength);\n    const writer = new writerbytes_js_1.WriterBytes(writerLength.length);\n    fn(tx, writer);\n    return (0, hash_js_1.sha256d)(writer.data);\n}\nfunction writePrevouts(tx, writer) {\n    for (const input of tx.inputs) {\n        (0, tx_js_1.writeOutPoint)(input.prevOut, writer);\n    }\n}\nfunction writeSequences(tx, writer) {\n    for (const input of tx.inputs) {\n        writer.putU32(input.sequence ?? tx_js_1.DEFAULT_SEQUENCE);\n    }\n}\nfunction writeOutputs(tx, writer) {\n    for (const output of tx.outputs) {\n        (0, tx_js_1.writeTxOutput)(output, writer);\n    }\n}\n//# sourceMappingURL=unsignedTx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ly4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L3Vuc2lnbmVkVHguanM/ZGI2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVuc2lnbmVkVHhJbnB1dCA9IGV4cG9ydHMuVW5zaWduZWRUeCA9IHZvaWQgMDtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCIuL2hhc2guanNcIik7XG5jb25zdCB3cml0ZXJieXRlc19qc18xID0gcmVxdWlyZShcIi4vaW8vd3JpdGVyYnl0ZXMuanNcIik7XG5jb25zdCB3cml0ZXJsZW5ndGhfanNfMSA9IHJlcXVpcmUoXCIuL2lvL3dyaXRlcmxlbmd0aC5qc1wiKTtcbmNvbnN0IHZhcnNpemVfanNfMSA9IHJlcXVpcmUoXCIuL2lvL3ZhcnNpemUuanNcIik7XG5jb25zdCBvcF9qc18xID0gcmVxdWlyZShcIi4vb3AuanNcIik7XG5jb25zdCBvcGNvZGVfanNfMSA9IHJlcXVpcmUoXCIuL29wY29kZS5qc1wiKTtcbmNvbnN0IHNjcmlwdF9qc18xID0gcmVxdWlyZShcIi4vc2NyaXB0LmpzXCIpO1xuY29uc3Qgc2lnSGFzaFR5cGVfanNfMSA9IHJlcXVpcmUoXCIuL3NpZ0hhc2hUeXBlLmpzXCIpO1xuY29uc3QgdHhfanNfMSA9IHJlcXVpcmUoXCIuL3R4LmpzXCIpO1xuLyoqIEFuIHVuc2lnbmVkIHR4LCB3aGljaCBoZWxwcyB1cyBidWlsZCB0aGUgc2lnaGFzaCBwcmVpbWFnZSB3ZSBuZWVkIHRvIHNpZ24gKi9cbmNsYXNzIFVuc2lnbmVkVHgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICB0aGlzLnR4ID0gcGFyYW1zLnR4O1xuICAgICAgICB0aGlzLnByZXZvdXRzSGFzaCA9IHBhcmFtcy5wcmV2b3V0c0hhc2g7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VzSGFzaCA9IHBhcmFtcy5zZXF1ZW5jZXNIYXNoO1xuICAgICAgICB0aGlzLm91dHB1dHNIYXNoID0gcGFyYW1zLm91dHB1dHNIYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlIGFuIFVuc2lnbmVkVHggZnJvbSBhIFR4LCB3aWxsIHByZWNvbXB1dGUgdGhlIGZpZWxkcyByZXF1aXJlZCB0b1xuICAgICAqIHNpZ24gdGhlIHR4XG4gICAgICoqL1xuICAgIHN0YXRpYyBmcm9tVHgodHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KHtcbiAgICAgICAgICAgIHR4LFxuICAgICAgICAgICAgcHJldm91dHNIYXNoOiB0eFdyaXRlckhhc2godHgsIHdyaXRlUHJldm91dHMpLFxuICAgICAgICAgICAgc2VxdWVuY2VzSGFzaDogdHhXcml0ZXJIYXNoKHR4LCB3cml0ZVNlcXVlbmNlcyksXG4gICAgICAgICAgICBvdXRwdXRzSGFzaDogdHhXcml0ZXJIYXNoKHR4LCB3cml0ZU91dHB1dHMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBhIGR1bW15IFVuc2lnbmVkVHggZnJvbSBhIFR4LCB3aWxsIHNldCBkdW1teSB2YWx1ZXMgZm9yIHRoZSBmaWVsZHNcbiAgICAgKiByZXF1aXJlZCB0byBzaWduIHRoZSB0eC4gVXNlZnVsIGZvciB0eCBzaXplIGVzdGltYXRpb24uXG4gICAgICoqL1xuICAgIHN0YXRpYyBkdW1teUZyb21UeCh0eCkge1xuICAgICAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoe1xuICAgICAgICAgICAgdHgsXG4gICAgICAgICAgICBwcmV2b3V0c0hhc2g6IG5ldyBVaW50OEFycmF5KDMyKSxcbiAgICAgICAgICAgIHNlcXVlbmNlc0hhc2g6IG5ldyBVaW50OEFycmF5KDMyKSxcbiAgICAgICAgICAgIG91dHB1dHNIYXNoOiBuZXcgVWludDhBcnJheSgzMiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogUmV0dXJuIHRoZSB1bnNpZ25lZCB0eCBpbnB1dCBhdCB0aGUgZ2l2ZW4gaW5wdXQgaW5kZXggKi9cbiAgICBpbnB1dEF0KGlucHV0SWR4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5zaWduZWRUeElucHV0KHsgaW5wdXRJZHgsIHVuc2lnbmVkVHg6IHRoaXMgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5VbnNpZ25lZFR4ID0gVW5zaWduZWRUeDtcbi8vIFdyaXRlIHRoZSBsZWdhY3kgcHJlaW1hZ2UgdXNlZCBwcmUtVUFIRi5cbi8vIEl0J3MgbW9kZWxlZCBjbG9zZWx5IGFmdGVyIFNpZ25hdHVyZUhhc2ggaW4gaW50ZXJwcmV0ZXIuY3BwLlxuZnVuY3Rpb24gd3JpdGVMZWdhY3lQcmVpbWFnZSh3cml0ZXIsIHR4LCBzY3JpcHRDb2RlLCBpbnB1dElkeCwgc2lnSGFzaFR5cGUpIHtcbiAgICBjb25zdCBoYXNBbnlvbmVDYW5QYXkgPSBzaWdIYXNoVHlwZS5pbnB1dFR5cGUgPT09IHNpZ0hhc2hUeXBlX2pzXzEuU2lnSGFzaFR5cGVJbnB1dHMuQU5ZT05FQ0FOUEFZO1xuICAgIGNvbnN0IHdyaXRlTGVnYWN5U2NyaXB0Q29kZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3BzID0gc2NyaXB0Q29kZS5vcHMoKTtcbiAgICAgICAgbGV0IG5leHRPcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbmV3T3BzID0gW107XG4gICAgICAgIC8vIEZpbHRlciBvdXQgYWxsIGNvZGUgc2VwYXJhdG9yc1xuICAgICAgICB3aGlsZSAoKG5leHRPcCA9IG9wcy5uZXh0KCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgoMCwgb3BfanNfMS5pc1B1c2hPcCkobmV4dE9wKSB8fCBuZXh0T3AgIT0gb3Bjb2RlX2pzXzEuT1BfQ09ERVNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIG5ld09wcy5wdXNoKG5leHRPcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NyaXB0X2pzXzEuU2NyaXB0LmZyb21PcHMobmV3T3BzKS53cml0ZVdpdGhTaXplKHdyaXRlcik7XG4gICAgfTtcbiAgICBjb25zdCB3cml0ZUxlZ2FjeUlucHV0ID0gKGlkeCkgPT4ge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIFNJR0hBU0hfQU5ZT05FQ0FOUEFZLCBvbmx5IHRoZSBpbnB1dCBiZWluZyBzaWduZWQgaXNcbiAgICAgICAgLy8gc2VyaWFsaXplZFxuICAgICAgICBpZiAoaGFzQW55b25lQ2FuUGF5KSB7XG4gICAgICAgICAgICBpZHggPSBpbnB1dElkeDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHR4LmlucHV0c1tpZHhdO1xuICAgICAgICAvLyBTZXJpYWxpemUgdGhlIHByZXZvdXRcbiAgICAgICAgKDAsIHR4X2pzXzEud3JpdGVPdXRQb2ludCkoaW5wdXQucHJldk91dCwgd3JpdGVyKTtcbiAgICAgICAgLy8gU2VyaWFsaXplIHRoZSBzY3JpcHRcbiAgICAgICAgaWYgKGlkeCAhPSBpbnB1dElkeCkge1xuICAgICAgICAgICAgLy8gQmxhbmsgb3V0IG90aGVyIGlucHV0cycgc2lnbmF0dXJlc1xuICAgICAgICAgICAgbmV3IHNjcmlwdF9qc18xLlNjcmlwdCgpLndyaXRlV2l0aFNpemUod3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlTGVnYWN5U2NyaXB0Q29kZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgblNlcXVlbmNlXG4gICAgICAgIGlmIChpZHggIT0gaW5wdXRJZHggJiZcbiAgICAgICAgICAgIChzaWdIYXNoVHlwZS5vdXRwdXRUeXBlID09PSBzaWdIYXNoVHlwZV9qc18xLlNpZ0hhc2hUeXBlT3V0cHV0cy5TSU5HTEUgfHxcbiAgICAgICAgICAgICAgICBzaWdIYXNoVHlwZS5vdXRwdXRUeXBlID09PSBzaWdIYXNoVHlwZV9qc18xLlNpZ0hhc2hUeXBlT3V0cHV0cy5OT05FKSkge1xuICAgICAgICAgICAgLy8gbGV0IHRoZSBvdGhlcnMgdXBkYXRlIGF0IHdpbGxcbiAgICAgICAgICAgIHdyaXRlci5wdXRVMzIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3cml0ZXIucHV0VTMyKGlucHV0LnNlcXVlbmNlID8/IHR4X2pzXzEuREVGQVVMVF9TRVFVRU5DRSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdyaXRlTGVnYWN5T3V0cHV0ID0gKGlkeCkgPT4ge1xuICAgICAgICBpZiAoc2lnSGFzaFR5cGUub3V0cHV0VHlwZSA9PT0gc2lnSGFzaFR5cGVfanNfMS5TaWdIYXNoVHlwZU91dHB1dHMuU0lOR0xFICYmXG4gICAgICAgICAgICBpZHggIT0gaW5wdXRJZHgpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBsb2NrLWluIHRoZSB0eG91dCBwYXllZSBhdCBvdGhlciBpbmRpY2VzIGFzIHR4aW5cbiAgICAgICAgICAgICgwLCB0eF9qc18xLndyaXRlVHhPdXRwdXQpKHsgc2F0czogMG4sIHNjcmlwdDogbmV3IHNjcmlwdF9qc18xLlNjcmlwdCgpIH0sIHdyaXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoMCwgdHhfanNfMS53cml0ZVR4T3V0cHV0KSh0eC5vdXRwdXRzW2lkeF0sIHdyaXRlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdyaXRlci5wdXRVMzIodHgudmVyc2lvbik7XG4gICAgY29uc3QgbnVtSW5wdXRzID0gaGFzQW55b25lQ2FuUGF5ID8gMSA6IHR4LmlucHV0cy5sZW5ndGg7XG4gICAgKDAsIHZhcnNpemVfanNfMS53cml0ZVZhclNpemUpKG51bUlucHV0cywgd3JpdGVyKTtcbiAgICBmb3IgKGxldCBpbnB1dElkeCA9IDA7IGlucHV0SWR4IDwgbnVtSW5wdXRzOyArK2lucHV0SWR4KSB7XG4gICAgICAgIHdyaXRlTGVnYWN5SW5wdXQoaW5wdXRJZHgpO1xuICAgIH1cbiAgICAvLyBTZXJpYWxpemUgdm91dFxuICAgIGNvbnN0IG51bU91dHB1dHMgPSAoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHNpZ0hhc2hUeXBlLm91dHB1dFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc2lnSGFzaFR5cGVfanNfMS5TaWdIYXNoVHlwZU91dHB1dHMuTk9ORTpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2Ugc2lnSGFzaFR5cGVfanNfMS5TaWdIYXNoVHlwZU91dHB1dHMuU0lOR0xFOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dElkeCArIDE7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0eC5vdXRwdXRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgKDAsIHZhcnNpemVfanNfMS53cml0ZVZhclNpemUpKG51bU91dHB1dHMsIHdyaXRlcik7XG4gICAgZm9yIChsZXQgb3V0cHV0SWR4ID0gMDsgb3V0cHV0SWR4IDwgbnVtT3V0cHV0czsgb3V0cHV0SWR4KyspIHtcbiAgICAgICAgd3JpdGVMZWdhY3lPdXRwdXQob3V0cHV0SWR4KTtcbiAgICB9XG4gICAgLy8gU2VyaWFsaXplIG5Mb2NrVGltZVxuICAgIHdyaXRlci5wdXRVMzIodHgubG9ja3RpbWUpO1xuICAgIC8vIFNlcmlhbGl6ZSBzaWdIYXNoVHlwZVxuICAgIHdyaXRlci5wdXRVMzIoc2lnSGFzaFR5cGUudG9JbnQoKSk7XG59XG4vKipcbiAqIEFuIHVuc2lnbmVkIHR4IGlucHV0LCBjYW4gYmUgdXNlZCB0byBidWlsZCBhIHNpZ2hhc2ggcHJlaW1hZ2UgcmVhZHkgdG8gYmVcbiAqIHNpZ25lZFxuICoqL1xuY2xhc3MgVW5zaWduZWRUeElucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5pbnB1dElkeCA9IHBhcmFtcy5pbnB1dElkeDtcbiAgICAgICAgdGhpcy51bnNpZ25lZFR4ID0gcGFyYW1zLnVuc2lnbmVkVHg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSBzaWdIYXNoUHJlaW1hZ2UgZm9yIHRoaXMgaW5wdXQsIHdpdGggdGhlIGdpdmVuIHNpZ0hhc2hUeXBlXG4gICAgICogYW5kIE9QX0NPREVTRVBBUkFUT1IgaW5kZXhcbiAgICAgKiovXG4gICAgc2lnSGFzaFByZWltYWdlKHNpZ0hhc2hUeXBlLCBuQ29kZXNlcCkge1xuICAgICAgICBjb25zdCB0eCA9IHRoaXMudW5zaWduZWRUeC50eDtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0eC5pbnB1dHNbdGhpcy5pbnB1dElkeF07XG4gICAgICAgIGlmIChpbnB1dC5zaWduRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgaGF2ZSBzaWduRGF0YSBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduRGF0YSA9IGlucHV0LnNpZ25EYXRhO1xuICAgICAgICBjb25zdCByZWRlZW1TY3JpcHQgPSBzaWduRGF0YVNjcmlwdENvZGUoaW5wdXQuc2lnbkRhdGEpO1xuICAgICAgICBjb25zdCBzY3JpcHRDb2RlID0gbkNvZGVzZXAgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyByZWRlZW1TY3JpcHRcbiAgICAgICAgICAgIDogcmVkZWVtU2NyaXB0LmN1dE91dENvZGVzZXAobkNvZGVzZXApO1xuICAgICAgICAvLyBTaWduIExFR0FDWSBzaWduYXR1cmVzIHRoYXQgZG9uJ3QgdXNlIFNJR0hBU0hfRk9SS0lEXG4gICAgICAgIGlmIChzaWdIYXNoVHlwZS52YXJpYW50ID09PSBzaWdIYXNoVHlwZV9qc18xLlNpZ0hhc2hUeXBlVmFyaWFudC5MRUdBQ1kpIHtcbiAgICAgICAgICAgIGlmIChzaWdIYXNoVHlwZS5vdXRwdXRUeXBlID09IHNpZ0hhc2hUeXBlX2pzXzEuU2lnSGFzaFR5cGVPdXRwdXRzLlNJTkdMRSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRJZHggPj0gdHgub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNhZ2Ugb2YgU0lOR0xFLCBpbnB1dCBoYXMgbm8gY29ycmVzcG9uZGluZyBvdXRwdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyaXRlUHJlaW1hZ2UgPSAod3JpdGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgd3JpdGVMZWdhY3lQcmVpbWFnZSh3cml0ZXIsIHRoaXMudW5zaWduZWRUeC50eCwgc2NyaXB0Q29kZSwgdGhpcy5pbnB1dElkeCwgc2lnSGFzaFR5cGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHByZWltYWdlV3JpdGVyTGVuID0gbmV3IHdyaXRlcmxlbmd0aF9qc18xLldyaXRlckxlbmd0aCgpO1xuICAgICAgICAgICAgd3JpdGVQcmVpbWFnZShwcmVpbWFnZVdyaXRlckxlbik7XG4gICAgICAgICAgICBjb25zdCBwcmVpbWFnZVdyaXRlciA9IG5ldyB3cml0ZXJieXRlc19qc18xLldyaXRlckJ5dGVzKHByZWltYWdlV3JpdGVyTGVuLmxlbmd0aCk7XG4gICAgICAgICAgICB3cml0ZVByZWltYWdlKHByZWltYWdlV3JpdGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYnl0ZXM6IHByZWltYWdlV3JpdGVyLmRhdGEsXG4gICAgICAgICAgICAgICAgc2NyaXB0Q29kZSxcbiAgICAgICAgICAgICAgICByZWRlZW1TY3JpcHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYXNoT3V0cHV0cztcbiAgICAgICAgc3dpdGNoIChzaWdIYXNoVHlwZS5vdXRwdXRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIHNpZ0hhc2hUeXBlX2pzXzEuU2lnSGFzaFR5cGVPdXRwdXRzLkFMTDpcbiAgICAgICAgICAgICAgICBoYXNoT3V0cHV0cyA9IHRoaXMudW5zaWduZWRUeC5vdXRwdXRzSGFzaDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2lnSGFzaFR5cGVfanNfMS5TaWdIYXNoVHlwZU91dHB1dHMuTk9ORTpcbiAgICAgICAgICAgICAgICBoYXNoT3V0cHV0cyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2lnSGFzaFR5cGVfanNfMS5TaWdIYXNoVHlwZU91dHB1dHMuU0lOR0xFOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SWR4IDwgdHgub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gdHgub3V0cHV0c1t0aGlzLmlucHV0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyT3V0cHV0TGVuZ3RoID0gbmV3IHdyaXRlcmxlbmd0aF9qc18xLldyaXRlckxlbmd0aCgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgdHhfanNfMS53cml0ZVR4T3V0cHV0KShvdXRwdXQsIHdyaXRlck91dHB1dExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlck91dHB1dCA9IG5ldyB3cml0ZXJieXRlc19qc18xLldyaXRlckJ5dGVzKHdyaXRlck91dHB1dExlbmd0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgdHhfanNfMS53cml0ZVR4T3V0cHV0KShvdXRwdXQsIHdyaXRlck91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hPdXRwdXRzID0gKDAsIGhhc2hfanNfMS5zaGEyNTZkKSh3cml0ZXJPdXRwdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYXNoT3V0cHV0cyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JpdGVQcmVpbWFnZSA9ICh3cml0ZXIpID0+IHtcbiAgICAgICAgICAgIHdyaXRlci5wdXRVMzIodHgudmVyc2lvbik7XG4gICAgICAgICAgICBpZiAoc2lnSGFzaFR5cGUuaW5wdXRUeXBlID09IHNpZ0hhc2hUeXBlX2pzXzEuU2lnSGFzaFR5cGVJbnB1dHMuRklYRUQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIucHV0Qnl0ZXModGhpcy51bnNpZ25lZFR4LnByZXZvdXRzSGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIucHV0Qnl0ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWdIYXNoVHlwZS5pbnB1dFR5cGUgPT0gc2lnSGFzaFR5cGVfanNfMS5TaWdIYXNoVHlwZUlucHV0cy5GSVhFRCAmJlxuICAgICAgICAgICAgICAgIHNpZ0hhc2hUeXBlLm91dHB1dFR5cGUgPT0gc2lnSGFzaFR5cGVfanNfMS5TaWdIYXNoVHlwZU91dHB1dHMuQUxMKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnB1dEJ5dGVzKHRoaXMudW5zaWduZWRUeC5zZXF1ZW5jZXNIYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlci5wdXRCeXRlcyhuZXcgVWludDhBcnJheSgzMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIHR4X2pzXzEud3JpdGVPdXRQb2ludCkoaW5wdXQucHJldk91dCwgd3JpdGVyKTtcbiAgICAgICAgICAgIHNjcmlwdENvZGUud3JpdGVXaXRoU2l6ZSh3cml0ZXIpO1xuICAgICAgICAgICAgd3JpdGVyLnB1dFU2NChzaWduRGF0YS5zYXRzKTtcbiAgICAgICAgICAgIHdyaXRlci5wdXRVMzIoaW5wdXQuc2VxdWVuY2UgPz8gdHhfanNfMS5ERUZBVUxUX1NFUVVFTkNFKTtcbiAgICAgICAgICAgIHdyaXRlci5wdXRCeXRlcyhoYXNoT3V0cHV0cyk7XG4gICAgICAgICAgICB3cml0ZXIucHV0VTMyKHR4LmxvY2t0aW1lKTtcbiAgICAgICAgICAgIHdyaXRlci5wdXRVMzIoc2lnSGFzaFR5cGUudG9JbnQoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZWltYWdlV3JpdGVyTGVuID0gbmV3IHdyaXRlcmxlbmd0aF9qc18xLldyaXRlckxlbmd0aCgpO1xuICAgICAgICB3cml0ZVByZWltYWdlKHByZWltYWdlV3JpdGVyTGVuKTtcbiAgICAgICAgY29uc3QgcHJlaW1hZ2VXcml0ZXIgPSBuZXcgd3JpdGVyYnl0ZXNfanNfMS5Xcml0ZXJCeXRlcyhwcmVpbWFnZVdyaXRlckxlbi5sZW5ndGgpO1xuICAgICAgICB3cml0ZVByZWltYWdlKHByZWltYWdlV3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ5dGVzOiBwcmVpbWFnZVdyaXRlci5kYXRhLFxuICAgICAgICAgICAgc2NyaXB0Q29kZSxcbiAgICAgICAgICAgIHJlZGVlbVNjcmlwdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFJldHVybiB0aGUgVHhJbnB1dCBvZiB0aGlzIFVuc2lnbmVkVHhJbnB1dCAqL1xuICAgIHR4SW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkVHgudHguaW5wdXRzW3RoaXMuaW5wdXRJZHhdO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5zaWduZWRUeElucHV0ID0gVW5zaWduZWRUeElucHV0O1xuLyoqIEZpbmQgdGhlIHNjcmlwdENvZGUgdGhhdCBzaG91bGQgYmUgc2lnbmVkICovXG5mdW5jdGlvbiBzaWduRGF0YVNjcmlwdENvZGUoc2lnbkRhdGEpIHtcbiAgICBpZiAoc2lnbkRhdGEub3V0cHV0U2NyaXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNpZ25EYXRhLm91dHB1dFNjcmlwdC5pc1Ayc2goKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQMlNIIHJlcXVpcmVzIHJlZGVlbVNjcmlwdCB0byBiZSBzZXQsIG5vdCBvdXRwdXRTY3JpcHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbkRhdGEub3V0cHV0U2NyaXB0O1xuICAgIH1cbiAgICBpZiAoc2lnbkRhdGEucmVkZWVtU2NyaXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGVpdGhlciBzZXQgb3V0cHV0U2NyaXB0IG9yIHJlZGVlbVNjcmlwdCcpO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbkRhdGEucmVkZWVtU2NyaXB0O1xufVxuZnVuY3Rpb24gdHhXcml0ZXJIYXNoKHR4LCBmbikge1xuICAgIGNvbnN0IHdyaXRlckxlbmd0aCA9IG5ldyB3cml0ZXJsZW5ndGhfanNfMS5Xcml0ZXJMZW5ndGgoKTtcbiAgICBmbih0eCwgd3JpdGVyTGVuZ3RoKTtcbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgd3JpdGVyYnl0ZXNfanNfMS5Xcml0ZXJCeXRlcyh3cml0ZXJMZW5ndGgubGVuZ3RoKTtcbiAgICBmbih0eCwgd3JpdGVyKTtcbiAgICByZXR1cm4gKDAsIGhhc2hfanNfMS5zaGEyNTZkKSh3cml0ZXIuZGF0YSk7XG59XG5mdW5jdGlvbiB3cml0ZVByZXZvdXRzKHR4LCB3cml0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHR4LmlucHV0cykge1xuICAgICAgICAoMCwgdHhfanNfMS53cml0ZU91dFBvaW50KShpbnB1dC5wcmV2T3V0LCB3cml0ZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyaXRlU2VxdWVuY2VzKHR4LCB3cml0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHR4LmlucHV0cykge1xuICAgICAgICB3cml0ZXIucHV0VTMyKGlucHV0LnNlcXVlbmNlID8/IHR4X2pzXzEuREVGQVVMVF9TRVFVRU5DRSk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JpdGVPdXRwdXRzKHR4LCB3cml0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IG91dHB1dCBvZiB0eC5vdXRwdXRzKSB7XG4gICAgICAgICgwLCB0eF9qc18xLndyaXRlVHhPdXRwdXQpKG91dHB1dCwgd3JpdGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bnNpZ25lZFR4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7151\n\n}")},7202:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nconst utils_ts_1 = __webpack_require__(9175);\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexports.SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexports.SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxjQUFjO0FBQzlGLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsSUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanM/NTAzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0hBNTEyX0lWID0gZXhwb3J0cy5TSEEzODRfSVYgPSBleHBvcnRzLlNIQTIyNF9JViA9IGV4cG9ydHMuU0hBMjU2X0lWID0gZXhwb3J0cy5IYXNoTUQgPSB2b2lkIDA7XG5leHBvcnRzLnNldEJpZ1VpbnQ2NCA9IHNldEJpZ1VpbnQ2NDtcbmV4cG9ydHMuQ2hpID0gQ2hpO1xuZXhwb3J0cy5NYWogPSBNYWo7XG4vKipcbiAqIEludGVybmFsIE1lcmtsZS1EYW1nYXJkIGhhc2ggdXRpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8qKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0LiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2RhdGF2aWV3X3NldGJpZ3VpbnQ2NCAqL1xuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZnVuY3Rpb24gQ2hpKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeICh+YSAmIGMpO1xufVxuLyoqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWUuICovXG5mdW5jdGlvbiBNYWooYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG59XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuY2xhc3MgSGFzaE1EIGV4dGVuZHMgdXRpbHNfdHNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX3RzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZVZpZXcpKGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hb3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2hNRCA9IEhhc2hNRDtcbi8qKlxuICogSW5pdGlhbCBTSEEtMiBzdGF0ZTogZnJhY3Rpb25hbCBwYXJ0cyBvZiBzcXVhcmUgcm9vdHMgb2YgZmlyc3QgMTYgcHJpbWVzIDIuLjUzLlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgIGZvciByZWNvbXB1dGF0aW9uIGd1aWRlLlxuICovXG4vKiogSW5pdGlhbCBTSEEyNTYgc3RhdGUuIEJpdHMgMC4uMzIgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnRzLlNIQTI1Nl9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTksXG5dKTtcbi8qKiBJbml0aWFsIFNIQTIyNCBzdGF0ZS4gQml0cyAzMi4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0cy5TSEEyMjRfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LCAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEzODQgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0cy5TSEEzODRfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LCAweDYyOWEyOTJhLCAweDM2N2NkNTA3LCAweDkxNTkwMTVhLCAweDMwNzBkZDE3LCAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTUxMiBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydHMuU0hBNTEyX0lWID0gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCwgMHhiYjY3YWU4NSwgMHg4NGNhYTczYiwgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiwgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLCAweDliMDU2ODhjLCAweDJiM2U2YzFmLCAweDFmODNkOWFiLCAweGZiNDFiZDZiLCAweDViZTBjZDE5LCAweDEzN2UyMTc5LFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7202\n\n}")},7357:g=>{"use strict";g.exports=JSON.parse('["abacate","abaixo","abalar","abater","abduzir","abelha","aberto","abismo","abotoar","abranger","abreviar","abrigar","abrupto","absinto","absoluto","absurdo","abutre","acabado","acalmar","acampar","acanhar","acaso","aceitar","acelerar","acenar","acervo","acessar","acetona","achatar","acidez","acima","acionado","acirrar","aclamar","aclive","acolhida","acomodar","acoplar","acordar","acumular","acusador","adaptar","adega","adentro","adepto","adequar","aderente","adesivo","adeus","adiante","aditivo","adjetivo","adjunto","admirar","adorar","adquirir","adubo","adverso","advogado","aeronave","afastar","aferir","afetivo","afinador","afivelar","aflito","afluente","afrontar","agachar","agarrar","agasalho","agenciar","agilizar","agiota","agitado","agora","agradar","agreste","agrupar","aguardar","agulha","ajoelhar","ajudar","ajustar","alameda","alarme","alastrar","alavanca","albergue","albino","alcatra","aldeia","alecrim","alegria","alertar","alface","alfinete","algum","alheio","aliar","alicate","alienar","alinhar","aliviar","almofada","alocar","alpiste","alterar","altitude","alucinar","alugar","aluno","alusivo","alvo","amaciar","amador","amarelo","amassar","ambas","ambiente","ameixa","amenizar","amido","amistoso","amizade","amolador","amontoar","amoroso","amostra","amparar","ampliar","ampola","anagrama","analisar","anarquia","anatomia","andaime","anel","anexo","angular","animar","anjo","anomalia","anotado","ansioso","anterior","anuidade","anunciar","anzol","apagador","apalpar","apanhado","apego","apelido","apertada","apesar","apetite","apito","aplauso","aplicada","apoio","apontar","aposta","aprendiz","aprovar","aquecer","arame","aranha","arara","arcada","ardente","areia","arejar","arenito","aresta","argiloso","argola","arma","arquivo","arraial","arrebate","arriscar","arroba","arrumar","arsenal","arterial","artigo","arvoredo","asfaltar","asilado","aspirar","assador","assinar","assoalho","assunto","astral","atacado","atadura","atalho","atarefar","atear","atender","aterro","ateu","atingir","atirador","ativo","atoleiro","atracar","atrevido","atriz","atual","atum","auditor","aumentar","aura","aurora","autismo","autoria","autuar","avaliar","avante","avaria","avental","avesso","aviador","avisar","avulso","axila","azarar","azedo","azeite","azulejo","babar","babosa","bacalhau","bacharel","bacia","bagagem","baiano","bailar","baioneta","bairro","baixista","bajular","baleia","baliza","balsa","banal","bandeira","banho","banir","banquete","barato","barbado","baronesa","barraca","barulho","baseado","bastante","batata","batedor","batida","batom","batucar","baunilha","beber","beijo","beirada","beisebol","beldade","beleza","belga","beliscar","bendito","bengala","benzer","berimbau","berlinda","berro","besouro","bexiga","bezerro","bico","bicudo","bienal","bifocal","bifurcar","bigorna","bilhete","bimestre","bimotor","biologia","biombo","biosfera","bipolar","birrento","biscoito","bisneto","bispo","bissexto","bitola","bizarro","blindado","bloco","bloquear","boato","bobagem","bocado","bocejo","bochecha","boicotar","bolada","boletim","bolha","bolo","bombeiro","bonde","boneco","bonita","borbulha","borda","boreal","borracha","bovino","boxeador","branco","brasa","braveza","breu","briga","brilho","brincar","broa","brochura","bronzear","broto","bruxo","bucha","budismo","bufar","bule","buraco","busca","busto","buzina","cabana","cabelo","cabide","cabo","cabrito","cacau","cacetada","cachorro","cacique","cadastro","cadeado","cafezal","caiaque","caipira","caixote","cajado","caju","calafrio","calcular","caldeira","calibrar","calmante","calota","camada","cambista","camisa","camomila","campanha","camuflar","canavial","cancelar","caneta","canguru","canhoto","canivete","canoa","cansado","cantar","canudo","capacho","capela","capinar","capotar","capricho","captador","capuz","caracol","carbono","cardeal","careca","carimbar","carneiro","carpete","carreira","cartaz","carvalho","casaco","casca","casebre","castelo","casulo","catarata","cativar","caule","causador","cautelar","cavalo","caverna","cebola","cedilha","cegonha","celebrar","celular","cenoura","censo","centeio","cercar","cerrado","certeiro","cerveja","cetim","cevada","chacota","chaleira","chamado","chapada","charme","chatice","chave","chefe","chegada","cheiro","cheque","chicote","chifre","chinelo","chocalho","chover","chumbo","chutar","chuva","cicatriz","ciclone","cidade","cidreira","ciente","cigana","cimento","cinto","cinza","ciranda","circuito","cirurgia","citar","clareza","clero","clicar","clone","clube","coado","coagir","cobaia","cobertor","cobrar","cocada","coelho","coentro","coeso","cogumelo","coibir","coifa","coiote","colar","coleira","colher","colidir","colmeia","colono","coluna","comando","combinar","comentar","comitiva","comover","complexo","comum","concha","condor","conectar","confuso","congelar","conhecer","conjugar","consumir","contrato","convite","cooperar","copeiro","copiador","copo","coquetel","coragem","cordial","corneta","coronha","corporal","correio","cortejo","coruja","corvo","cosseno","costela","cotonete","couro","couve","covil","cozinha","cratera","cravo","creche","credor","creme","crer","crespo","criada","criminal","crioulo","crise","criticar","crosta","crua","cruzeiro","cubano","cueca","cuidado","cujo","culatra","culminar","culpar","cultura","cumprir","cunhado","cupido","curativo","curral","cursar","curto","cuspir","custear","cutelo","damasco","datar","debater","debitar","deboche","debulhar","decalque","decimal","declive","decote","decretar","dedal","dedicado","deduzir","defesa","defumar","degelo","degrau","degustar","deitado","deixar","delator","delegado","delinear","delonga","demanda","demitir","demolido","dentista","depenado","depilar","depois","depressa","depurar","deriva","derramar","desafio","desbotar","descanso","desenho","desfiado","desgaste","desigual","deslize","desmamar","desova","despesa","destaque","desviar","detalhar","detentor","detonar","detrito","deusa","dever","devido","devotado","dezena","diagrama","dialeto","didata","difuso","digitar","dilatado","diluente","diminuir","dinastia","dinheiro","diocese","direto","discreta","disfarce","disparo","disquete","dissipar","distante","ditador","diurno","diverso","divisor","divulgar","dizer","dobrador","dolorido","domador","dominado","donativo","donzela","dormente","dorsal","dosagem","dourado","doutor","drenagem","drible","drogaria","duelar","duende","dueto","duplo","duquesa","durante","duvidoso","eclodir","ecoar","ecologia","edificar","edital","educado","efeito","efetivar","ejetar","elaborar","eleger","eleitor","elenco","elevador","eliminar","elogiar","embargo","embolado","embrulho","embutido","emenda","emergir","emissor","empatia","empenho","empinado","empolgar","emprego","empurrar","emulador","encaixe","encenado","enchente","encontro","endeusar","endossar","enfaixar","enfeite","enfim","engajado","engenho","englobar","engomado","engraxar","enguia","enjoar","enlatar","enquanto","enraizar","enrolado","enrugar","ensaio","enseada","ensino","ensopado","entanto","enteado","entidade","entortar","entrada","entulho","envergar","enviado","envolver","enxame","enxerto","enxofre","enxuto","epiderme","equipar","ereto","erguido","errata","erva","ervilha","esbanjar","esbelto","escama","escola","escrita","escuta","esfinge","esfolar","esfregar","esfumado","esgrima","esmalte","espanto","espelho","espiga","esponja","espreita","espumar","esquerda","estaca","esteira","esticar","estofado","estrela","estudo","esvaziar","etanol","etiqueta","euforia","europeu","evacuar","evaporar","evasivo","eventual","evidente","evoluir","exagero","exalar","examinar","exato","exausto","excesso","excitar","exclamar","executar","exemplo","exibir","exigente","exonerar","expandir","expelir","expirar","explanar","exposto","expresso","expulsar","externo","extinto","extrato","fabricar","fabuloso","faceta","facial","fada","fadiga","faixa","falar","falta","familiar","fandango","fanfarra","fantoche","fardado","farelo","farinha","farofa","farpa","fartura","fatia","fator","favorita","faxina","fazenda","fechado","feijoada","feirante","felino","feminino","fenda","feno","fera","feriado","ferrugem","ferver","festejar","fetal","feudal","fiapo","fibrose","ficar","ficheiro","figurado","fileira","filho","filme","filtrar","firmeza","fisgada","fissura","fita","fivela","fixador","fixo","flacidez","flamingo","flanela","flechada","flora","flutuar","fluxo","focal","focinho","fofocar","fogo","foguete","foice","folgado","folheto","forjar","formiga","forno","forte","fosco","fossa","fragata","fralda","frango","frasco","fraterno","freira","frente","fretar","frieza","friso","fritura","fronha","frustrar","fruteira","fugir","fulano","fuligem","fundar","fungo","funil","furador","furioso","futebol","gabarito","gabinete","gado","gaiato","gaiola","gaivota","galega","galho","galinha","galocha","ganhar","garagem","garfo","gargalo","garimpo","garoupa","garrafa","gasoduto","gasto","gata","gatilho","gaveta","gazela","gelado","geleia","gelo","gemada","gemer","gemido","generoso","gengiva","genial","genoma","genro","geologia","gerador","germinar","gesso","gestor","ginasta","gincana","gingado","girafa","girino","glacial","glicose","global","glorioso","goela","goiaba","golfe","golpear","gordura","gorjeta","gorro","gostoso","goteira","governar","gracejo","gradual","grafite","gralha","grampo","granada","gratuito","graveto","graxa","grego","grelhar","greve","grilo","grisalho","gritaria","grosso","grotesco","grudado","grunhido","gruta","guache","guarani","guaxinim","guerrear","guiar","guincho","guisado","gula","guloso","guru","habitar","harmonia","haste","haver","hectare","herdar","heresia","hesitar","hiato","hibernar","hidratar","hiena","hino","hipismo","hipnose","hipoteca","hoje","holofote","homem","honesto","honrado","hormonal","hospedar","humorado","iate","ideia","idoso","ignorado","igreja","iguana","ileso","ilha","iludido","iluminar","ilustrar","imagem","imediato","imenso","imersivo","iminente","imitador","imortal","impacto","impedir","implante","impor","imprensa","impune","imunizar","inalador","inapto","inativo","incenso","inchar","incidir","incluir","incolor","indeciso","indireto","indutor","ineficaz","inerente","infantil","infestar","infinito","inflamar","informal","infrator","ingerir","inibido","inicial","inimigo","injetar","inocente","inodoro","inovador","inox","inquieto","inscrito","inseto","insistir","inspetor","instalar","insulto","intacto","integral","intimar","intocado","intriga","invasor","inverno","invicto","invocar","iogurte","iraniano","ironizar","irreal","irritado","isca","isento","isolado","isqueiro","italiano","janeiro","jangada","janta","jararaca","jardim","jarro","jasmim","jato","javali","jazida","jejum","joaninha","joelhada","jogador","joia","jornal","jorrar","jovem","juba","judeu","judoca","juiz","julgador","julho","jurado","jurista","juro","justa","labareda","laboral","lacre","lactante","ladrilho","lagarta","lagoa","laje","lamber","lamentar","laminar","lampejo","lanche","lapidar","lapso","laranja","lareira","largura","lasanha","lastro","lateral","latido","lavanda","lavoura","lavrador","laxante","lazer","lealdade","lebre","legado","legendar","legista","leigo","leiloar","leitura","lembrete","leme","lenhador","lentilha","leoa","lesma","leste","letivo","letreiro","levar","leveza","levitar","liberal","libido","liderar","ligar","ligeiro","limitar","limoeiro","limpador","linda","linear","linhagem","liquidez","listagem","lisura","litoral","livro","lixa","lixeira","locador","locutor","lojista","lombo","lona","longe","lontra","lorde","lotado","loteria","loucura","lousa","louvar","luar","lucidez","lucro","luneta","lustre","lutador","luva","macaco","macete","machado","macio","madeira","madrinha","magnata","magreza","maior","mais","malandro","malha","malote","maluco","mamilo","mamoeiro","mamute","manada","mancha","mandato","manequim","manhoso","manivela","manobrar","mansa","manter","manusear","mapeado","maquinar","marcador","maresia","marfim","margem","marinho","marmita","maroto","marquise","marreco","martelo","marujo","mascote","masmorra","massagem","mastigar","matagal","materno","matinal","matutar","maxilar","medalha","medida","medusa","megafone","meiga","melancia","melhor","membro","memorial","menino","menos","mensagem","mental","merecer","mergulho","mesada","mesclar","mesmo","mesquita","mestre","metade","meteoro","metragem","mexer","mexicano","micro","migalha","migrar","milagre","milenar","milhar","mimado","minerar","minhoca","ministro","minoria","miolo","mirante","mirtilo","misturar","mocidade","moderno","modular","moeda","moer","moinho","moita","moldura","moleza","molho","molinete","molusco","montanha","moqueca","morango","morcego","mordomo","morena","mosaico","mosquete","mostarda","motel","motim","moto","motriz","muda","muito","mulata","mulher","multar","mundial","munido","muralha","murcho","muscular","museu","musical","nacional","nadador","naja","namoro","narina","narrado","nascer","nativa","natureza","navalha","navegar","navio","neblina","nebuloso","negativa","negociar","negrito","nervoso","neta","neural","nevasca","nevoeiro","ninar","ninho","nitidez","nivelar","nobreza","noite","noiva","nomear","nominal","nordeste","nortear","notar","noticiar","noturno","novelo","novilho","novo","nublado","nudez","numeral","nupcial","nutrir","nuvem","obcecado","obedecer","objetivo","obrigado","obscuro","obstetra","obter","obturar","ocidente","ocioso","ocorrer","oculista","ocupado","ofegante","ofensiva","oferenda","oficina","ofuscado","ogiva","olaria","oleoso","olhar","oliveira","ombro","omelete","omisso","omitir","ondulado","oneroso","ontem","opcional","operador","oponente","oportuno","oposto","orar","orbitar","ordem","ordinal","orfanato","orgasmo","orgulho","oriental","origem","oriundo","orla","ortodoxo","orvalho","oscilar","ossada","osso","ostentar","otimismo","ousadia","outono","outubro","ouvido","ovelha","ovular","oxidar","oxigenar","pacato","paciente","pacote","pactuar","padaria","padrinho","pagar","pagode","painel","pairar","paisagem","palavra","palestra","palheta","palito","palmada","palpitar","pancada","panela","panfleto","panqueca","pantanal","papagaio","papelada","papiro","parafina","parcial","pardal","parede","partida","pasmo","passado","pastel","patamar","patente","patinar","patrono","paulada","pausar","peculiar","pedalar","pedestre","pediatra","pedra","pegada","peitoral","peixe","pele","pelicano","penca","pendurar","peneira","penhasco","pensador","pente","perceber","perfeito","pergunta","perito","permitir","perna","perplexo","persiana","pertence","peruca","pescado","pesquisa","pessoa","petiscar","piada","picado","piedade","pigmento","pilastra","pilhado","pilotar","pimenta","pincel","pinguim","pinha","pinote","pintar","pioneiro","pipoca","piquete","piranha","pires","pirueta","piscar","pistola","pitanga","pivete","planta","plaqueta","platina","plebeu","plumagem","pluvial","pneu","poda","poeira","poetisa","polegada","policiar","poluente","polvilho","pomar","pomba","ponderar","pontaria","populoso","porta","possuir","postal","pote","poupar","pouso","povoar","praia","prancha","prato","praxe","prece","predador","prefeito","premiar","prensar","preparar","presilha","pretexto","prevenir","prezar","primata","princesa","prisma","privado","processo","produto","profeta","proibido","projeto","prometer","propagar","prosa","protetor","provador","publicar","pudim","pular","pulmonar","pulseira","punhal","punir","pupilo","pureza","puxador","quadra","quantia","quarto","quase","quebrar","queda","queijo","quente","querido","quimono","quina","quiosque","rabanada","rabisco","rachar","racionar","radial","raiar","rainha","raio","raiva","rajada","ralado","ramal","ranger","ranhura","rapadura","rapel","rapidez","raposa","raquete","raridade","rasante","rascunho","rasgar","raspador","rasteira","rasurar","ratazana","ratoeira","realeza","reanimar","reaver","rebaixar","rebelde","rebolar","recado","recente","recheio","recibo","recordar","recrutar","recuar","rede","redimir","redonda","reduzida","reenvio","refinar","refletir","refogar","refresco","refugiar","regalia","regime","regra","reinado","reitor","rejeitar","relativo","remador","remendo","remorso","renovado","reparo","repelir","repleto","repolho","represa","repudiar","requerer","resenha","resfriar","resgatar","residir","resolver","respeito","ressaca","restante","resumir","retalho","reter","retirar","retomada","retratar","revelar","revisor","revolta","riacho","rica","rigidez","rigoroso","rimar","ringue","risada","risco","risonho","robalo","rochedo","rodada","rodeio","rodovia","roedor","roleta","romano","roncar","rosado","roseira","rosto","rota","roteiro","rotina","rotular","rouco","roupa","roxo","rubro","rugido","rugoso","ruivo","rumo","rupestre","russo","sabor","saciar","sacola","sacudir","sadio","safira","saga","sagrada","saibro","salada","saleiro","salgado","saliva","salpicar","salsicha","saltar","salvador","sambar","samurai","sanar","sanfona","sangue","sanidade","sapato","sarda","sargento","sarjeta","saturar","saudade","saxofone","sazonal","secar","secular","seda","sedento","sediado","sedoso","sedutor","segmento","segredo","segundo","seiva","seleto","selvagem","semanal","semente","senador","senhor","sensual","sentado","separado","sereia","seringa","serra","servo","setembro","setor","sigilo","silhueta","silicone","simetria","simpatia","simular","sinal","sincero","singular","sinopse","sintonia","sirene","siri","situado","soberano","sobra","socorro","sogro","soja","solda","soletrar","solteiro","sombrio","sonata","sondar","sonegar","sonhador","sono","soprano","soquete","sorrir","sorteio","sossego","sotaque","soterrar","sovado","sozinho","suavizar","subida","submerso","subsolo","subtrair","sucata","sucesso","suco","sudeste","sufixo","sugador","sugerir","sujeito","sulfato","sumir","suor","superior","suplicar","suposto","suprimir","surdina","surfista","surpresa","surreal","surtir","suspiro","sustento","tabela","tablete","tabuada","tacho","tagarela","talher","talo","talvez","tamanho","tamborim","tampa","tangente","tanto","tapar","tapioca","tardio","tarefa","tarja","tarraxa","tatuagem","taurino","taxativo","taxista","teatral","tecer","tecido","teclado","tedioso","teia","teimar","telefone","telhado","tempero","tenente","tensor","tentar","termal","terno","terreno","tese","tesoura","testado","teto","textura","texugo","tiara","tigela","tijolo","timbrar","timidez","tingido","tinteiro","tiragem","titular","toalha","tocha","tolerar","tolice","tomada","tomilho","tonel","tontura","topete","tora","torcido","torneio","torque","torrada","torto","tostar","touca","toupeira","toxina","trabalho","tracejar","tradutor","trafegar","trajeto","trama","trancar","trapo","traseiro","tratador","travar","treino","tremer","trepidar","trevo","triagem","tribo","triciclo","tridente","trilogia","trindade","triplo","triturar","triunfal","trocar","trombeta","trova","trunfo","truque","tubular","tucano","tudo","tulipa","tupi","turbo","turma","turquesa","tutelar","tutorial","uivar","umbigo","unha","unidade","uniforme","urologia","urso","urtiga","urubu","usado","usina","usufruir","vacina","vadiar","vagaroso","vaidoso","vala","valente","validade","valores","vantagem","vaqueiro","varanda","vareta","varrer","vascular","vasilha","vassoura","vazar","vazio","veado","vedar","vegetar","veicular","veleiro","velhice","veludo","vencedor","vendaval","venerar","ventre","verbal","verdade","vereador","vergonha","vermelho","verniz","versar","vertente","vespa","vestido","vetorial","viaduto","viagem","viajar","viatura","vibrador","videira","vidraria","viela","viga","vigente","vigiar","vigorar","vilarejo","vinco","vinheta","vinil","violeta","virada","virtude","visitar","visto","vitral","viveiro","vizinho","voador","voar","vogal","volante","voleibol","voltagem","volumoso","vontade","vulto","vuvuzela","xadrez","xarope","xeque","xeretar","xerife","xingar","zangado","zarpar","zebu","zelador","zombar","zoologia","zumbido"]')},7408:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.WriterLength = void 0;\n/**\n * Writer implementation which only measures the length of the serialized\n * output but doesn\'t actually store any byte data.\n **/\nclass WriterLength {\n    constructor() {\n        this.length = 0;\n    }\n    /** Write a single byte */\n    putU8(_value) {\n        this.length++;\n    }\n    /** Write a 2-byte little-endian integer (uint16_t) */\n    putU16(_value, _endian) {\n        this.length += 2;\n    }\n    /** Write a 4-byte little-endian integer (uint32_t) */\n    putU32(_value, _endian) {\n        this.length += 4;\n    }\n    /** Write an 8-byte little-endian integer (uint64_t) */\n    putU64(_value, _endian) {\n        this.length += 8;\n    }\n    /** Write the given bytes */\n    putBytes(bytes) {\n        this.length += bytes.length;\n    }\n}\nexports.WriterLength = WriterLength;\n//# sourceMappingURL=writerlength.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvaW8vd3JpdGVybGVuZ3RoLmpzPzE3NmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xcml0ZXJMZW5ndGggPSB2b2lkIDA7XG4vKipcbiAqIFdyaXRlciBpbXBsZW1lbnRhdGlvbiB3aGljaCBvbmx5IG1lYXN1cmVzIHRoZSBsZW5ndGggb2YgdGhlIHNlcmlhbGl6ZWRcbiAqIG91dHB1dCBidXQgZG9lc24ndCBhY3R1YWxseSBzdG9yZSBhbnkgYnl0ZSBkYXRhLlxuICoqL1xuY2xhc3MgV3JpdGVyTGVuZ3RoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICAvKiogV3JpdGUgYSBzaW5nbGUgYnl0ZSAqL1xuICAgIHB1dFU4KF92YWx1ZSkge1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICAvKiogV3JpdGUgYSAyLWJ5dGUgbGl0dGxlLWVuZGlhbiBpbnRlZ2VyICh1aW50MTZfdCkgKi9cbiAgICBwdXRVMTYoX3ZhbHVlLCBfZW5kaWFuKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDI7XG4gICAgfVxuICAgIC8qKiBXcml0ZSBhIDQtYnl0ZSBsaXR0bGUtZW5kaWFuIGludGVnZXIgKHVpbnQzMl90KSAqL1xuICAgIHB1dFUzMihfdmFsdWUsIF9lbmRpYW4pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gNDtcbiAgICB9XG4gICAgLyoqIFdyaXRlIGFuIDgtYnl0ZSBsaXR0bGUtZW5kaWFuIGludGVnZXIgKHVpbnQ2NF90KSAqL1xuICAgIHB1dFU2NChfdmFsdWUsIF9lbmRpYW4pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gODtcbiAgICB9XG4gICAgLyoqIFdyaXRlIHRoZSBnaXZlbiBieXRlcyAqL1xuICAgIHB1dEJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGJ5dGVzLmxlbmd0aDtcbiAgICB9XG59XG5leHBvcnRzLldyaXRlckxlbmd0aCA9IFdyaXRlckxlbmd0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyaXRlcmxlbmd0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7408\n\n}')},7518:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const ECLevel = __webpack_require__(9953)\r\n\r\nconst EC_BLOCKS_TABLE = [\r\n// L  M  Q  H\r\n  1, 1, 1, 1,\r\n  1, 1, 1, 1,\r\n  1, 1, 2, 2,\r\n  1, 2, 2, 4,\r\n  1, 2, 4, 4,\r\n  2, 4, 4, 4,\r\n  2, 4, 6, 5,\r\n  2, 4, 6, 6,\r\n  2, 5, 8, 8,\r\n  4, 5, 8, 8,\r\n  4, 5, 8, 11,\r\n  4, 8, 10, 11,\r\n  4, 9, 12, 16,\r\n  4, 9, 16, 16,\r\n  6, 10, 12, 18,\r\n  6, 10, 17, 16,\r\n  6, 11, 16, 19,\r\n  6, 13, 18, 21,\r\n  7, 14, 21, 25,\r\n  8, 16, 20, 25,\r\n  8, 17, 23, 25,\r\n  9, 17, 23, 34,\r\n  9, 18, 25, 30,\r\n  10, 20, 27, 32,\r\n  12, 21, 29, 35,\r\n  12, 23, 34, 37,\r\n  12, 25, 34, 40,\r\n  13, 26, 35, 42,\r\n  14, 28, 38, 45,\r\n  15, 29, 40, 48,\r\n  16, 31, 43, 51,\r\n  17, 33, 45, 54,\r\n  18, 35, 48, 57,\r\n  19, 37, 51, 60,\r\n  19, 38, 53, 63,\r\n  20, 40, 56, 66,\r\n  21, 43, 59, 70,\r\n  22, 45, 62, 74,\r\n  24, 47, 65, 77,\r\n  25, 49, 68, 81\r\n]\r\n\r\nconst EC_CODEWORDS_TABLE = [\r\n// L  M  Q  H\r\n  7, 10, 13, 17,\r\n  10, 16, 22, 28,\r\n  15, 26, 36, 44,\r\n  20, 36, 52, 64,\r\n  26, 48, 72, 88,\r\n  36, 64, 96, 112,\r\n  40, 72, 108, 130,\r\n  48, 88, 132, 156,\r\n  60, 110, 160, 192,\r\n  72, 130, 192, 224,\r\n  80, 150, 224, 264,\r\n  96, 176, 260, 308,\r\n  104, 198, 288, 352,\r\n  120, 216, 320, 384,\r\n  132, 240, 360, 432,\r\n  144, 280, 408, 480,\r\n  168, 308, 448, 532,\r\n  180, 338, 504, 588,\r\n  196, 364, 546, 650,\r\n  224, 416, 600, 700,\r\n  224, 442, 644, 750,\r\n  252, 476, 690, 816,\r\n  270, 504, 750, 900,\r\n  300, 560, 810, 960,\r\n  312, 588, 870, 1050,\r\n  336, 644, 952, 1110,\r\n  360, 700, 1020, 1200,\r\n  390, 728, 1050, 1260,\r\n  420, 784, 1140, 1350,\r\n  450, 812, 1200, 1440,\r\n  480, 868, 1290, 1530,\r\n  510, 924, 1350, 1620,\r\n  540, 980, 1440, 1710,\r\n  570, 1036, 1530, 1800,\r\n  570, 1064, 1590, 1890,\r\n  600, 1120, 1680, 1980,\r\n  630, 1204, 1770, 2100,\r\n  660, 1260, 1860, 2220,\r\n  720, 1316, 1950, 2310,\r\n  750, 1372, 2040, 2430\r\n]\r\n\r\n/**\r\n * Returns the number of error correction block that the QR Code should contain\r\n * for the specified version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction blocks\r\n */\r\nexports.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the number of error correction codewords to use for the specified\r\n * version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction codewords\r\n */\r\nexports.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSw2QkFBNkI7QUFDekM7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvY29yZS9lcnJvci1jb3JyZWN0aW9uLWNvZGUuanM/MzRmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFQ0xldmVsID0gcmVxdWlyZSgnLi9lcnJvci1jb3JyZWN0aW9uLWxldmVsJylcclxuXHJcbmNvbnN0IEVDX0JMT0NLU19UQUJMRSA9IFtcclxuLy8gTCAgTSAgUSAgSFxyXG4gIDEsIDEsIDEsIDEsXHJcbiAgMSwgMSwgMSwgMSxcclxuICAxLCAxLCAyLCAyLFxyXG4gIDEsIDIsIDIsIDQsXHJcbiAgMSwgMiwgNCwgNCxcclxuICAyLCA0LCA0LCA0LFxyXG4gIDIsIDQsIDYsIDUsXHJcbiAgMiwgNCwgNiwgNixcclxuICAyLCA1LCA4LCA4LFxyXG4gIDQsIDUsIDgsIDgsXHJcbiAgNCwgNSwgOCwgMTEsXHJcbiAgNCwgOCwgMTAsIDExLFxyXG4gIDQsIDksIDEyLCAxNixcclxuICA0LCA5LCAxNiwgMTYsXHJcbiAgNiwgMTAsIDEyLCAxOCxcclxuICA2LCAxMCwgMTcsIDE2LFxyXG4gIDYsIDExLCAxNiwgMTksXHJcbiAgNiwgMTMsIDE4LCAyMSxcclxuICA3LCAxNCwgMjEsIDI1LFxyXG4gIDgsIDE2LCAyMCwgMjUsXHJcbiAgOCwgMTcsIDIzLCAyNSxcclxuICA5LCAxNywgMjMsIDM0LFxyXG4gIDksIDE4LCAyNSwgMzAsXHJcbiAgMTAsIDIwLCAyNywgMzIsXHJcbiAgMTIsIDIxLCAyOSwgMzUsXHJcbiAgMTIsIDIzLCAzNCwgMzcsXHJcbiAgMTIsIDI1LCAzNCwgNDAsXHJcbiAgMTMsIDI2LCAzNSwgNDIsXHJcbiAgMTQsIDI4LCAzOCwgNDUsXHJcbiAgMTUsIDI5LCA0MCwgNDgsXHJcbiAgMTYsIDMxLCA0MywgNTEsXHJcbiAgMTcsIDMzLCA0NSwgNTQsXHJcbiAgMTgsIDM1LCA0OCwgNTcsXHJcbiAgMTksIDM3LCA1MSwgNjAsXHJcbiAgMTksIDM4LCA1MywgNjMsXHJcbiAgMjAsIDQwLCA1NiwgNjYsXHJcbiAgMjEsIDQzLCA1OSwgNzAsXHJcbiAgMjIsIDQ1LCA2MiwgNzQsXHJcbiAgMjQsIDQ3LCA2NSwgNzcsXHJcbiAgMjUsIDQ5LCA2OCwgODFcclxuXVxyXG5cclxuY29uc3QgRUNfQ09ERVdPUkRTX1RBQkxFID0gW1xyXG4vLyBMICBNICBRICBIXHJcbiAgNywgMTAsIDEzLCAxNyxcclxuICAxMCwgMTYsIDIyLCAyOCxcclxuICAxNSwgMjYsIDM2LCA0NCxcclxuICAyMCwgMzYsIDUyLCA2NCxcclxuICAyNiwgNDgsIDcyLCA4OCxcclxuICAzNiwgNjQsIDk2LCAxMTIsXHJcbiAgNDAsIDcyLCAxMDgsIDEzMCxcclxuICA0OCwgODgsIDEzMiwgMTU2LFxyXG4gIDYwLCAxMTAsIDE2MCwgMTkyLFxyXG4gIDcyLCAxMzAsIDE5MiwgMjI0LFxyXG4gIDgwLCAxNTAsIDIyNCwgMjY0LFxyXG4gIDk2LCAxNzYsIDI2MCwgMzA4LFxyXG4gIDEwNCwgMTk4LCAyODgsIDM1MixcclxuICAxMjAsIDIxNiwgMzIwLCAzODQsXHJcbiAgMTMyLCAyNDAsIDM2MCwgNDMyLFxyXG4gIDE0NCwgMjgwLCA0MDgsIDQ4MCxcclxuICAxNjgsIDMwOCwgNDQ4LCA1MzIsXHJcbiAgMTgwLCAzMzgsIDUwNCwgNTg4LFxyXG4gIDE5NiwgMzY0LCA1NDYsIDY1MCxcclxuICAyMjQsIDQxNiwgNjAwLCA3MDAsXHJcbiAgMjI0LCA0NDIsIDY0NCwgNzUwLFxyXG4gIDI1MiwgNDc2LCA2OTAsIDgxNixcclxuICAyNzAsIDUwNCwgNzUwLCA5MDAsXHJcbiAgMzAwLCA1NjAsIDgxMCwgOTYwLFxyXG4gIDMxMiwgNTg4LCA4NzAsIDEwNTAsXHJcbiAgMzM2LCA2NDQsIDk1MiwgMTExMCxcclxuICAzNjAsIDcwMCwgMTAyMCwgMTIwMCxcclxuICAzOTAsIDcyOCwgMTA1MCwgMTI2MCxcclxuICA0MjAsIDc4NCwgMTE0MCwgMTM1MCxcclxuICA0NTAsIDgxMiwgMTIwMCwgMTQ0MCxcclxuICA0ODAsIDg2OCwgMTI5MCwgMTUzMCxcclxuICA1MTAsIDkyNCwgMTM1MCwgMTYyMCxcclxuICA1NDAsIDk4MCwgMTQ0MCwgMTcxMCxcclxuICA1NzAsIDEwMzYsIDE1MzAsIDE4MDAsXHJcbiAgNTcwLCAxMDY0LCAxNTkwLCAxODkwLFxyXG4gIDYwMCwgMTEyMCwgMTY4MCwgMTk4MCxcclxuICA2MzAsIDEyMDQsIDE3NzAsIDIxMDAsXHJcbiAgNjYwLCAxMjYwLCAxODYwLCAyMjIwLFxyXG4gIDcyMCwgMTMxNiwgMTk1MCwgMjMxMCxcclxuICA3NTAsIDEzNzIsIDIwNDAsIDI0MzBcclxuXVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGJsb2NrIHRoYXQgdGhlIFFSIENvZGUgc2hvdWxkIGNvbnRhaW5cclxuICogZm9yIHRoZSBzcGVjaWZpZWQgdmVyc2lvbiBhbmQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbC5cclxuICpcclxuICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cclxuICogQHBhcmFtICB7TnVtYmVyfSBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzXHJcbiAqL1xyXG5leHBvcnRzLmdldEJsb2Nrc0NvdW50ID0gZnVuY3Rpb24gZ2V0QmxvY2tzQ291bnQgKHZlcnNpb24sIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XHJcbiAgc3dpdGNoIChlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xyXG4gICAgY2FzZSBFQ0xldmVsLkw6XHJcbiAgICAgIHJldHVybiBFQ19CTE9DS1NfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAwXVxyXG4gICAgY2FzZSBFQ0xldmVsLk06XHJcbiAgICAgIHJldHVybiBFQ19CTE9DS1NfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAxXVxyXG4gICAgY2FzZSBFQ0xldmVsLlE6XHJcbiAgICAgIHJldHVybiBFQ19CTE9DS1NfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAyXVxyXG4gICAgY2FzZSBFQ0xldmVsLkg6XHJcbiAgICAgIHJldHVybiBFQ19CTE9DS1NfVEFCTEVbKHZlcnNpb24gLSAxKSAqIDQgKyAzXVxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3JkcyB0byB1c2UgZm9yIHRoZSBzcGVjaWZpZWRcclxuICogdmVyc2lvbiBhbmQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbC5cclxuICpcclxuICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uICAgICAgICAgICAgICBRUiBDb2RlIHZlcnNpb25cclxuICogQHBhcmFtICB7TnVtYmVyfSBlcnJvckNvcnJlY3Rpb25MZXZlbCBFcnJvciBjb3JyZWN0aW9uIGxldmVsXHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAgTnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzXHJcbiAqL1xyXG5leHBvcnRzLmdldFRvdGFsQ29kZXdvcmRzQ291bnQgPSBmdW5jdGlvbiBnZXRUb3RhbENvZGV3b3Jkc0NvdW50ICh2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xyXG4gIHN3aXRjaCAoZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcclxuICAgIGNhc2UgRUNMZXZlbC5MOlxyXG4gICAgICByZXR1cm4gRUNfQ09ERVdPUkRTX1RBQkxFWyh2ZXJzaW9uIC0gMSkgKiA0ICsgMF1cclxuICAgIGNhc2UgRUNMZXZlbC5NOlxyXG4gICAgICByZXR1cm4gRUNfQ09ERVdPUkRTX1RBQkxFWyh2ZXJzaW9uIC0gMSkgKiA0ICsgMV1cclxuICAgIGNhc2UgRUNMZXZlbC5ROlxyXG4gICAgICByZXR1cm4gRUNfQ09ERVdPUkRTX1RBQkxFWyh2ZXJzaW9uIC0gMSkgKiA0ICsgMl1cclxuICAgIGNhc2UgRUNMZXZlbC5IOlxyXG4gICAgICByZXR1cm4gRUNfQ09ERVdPUkRTX1RBQkxFWyh2ZXJzaW9uIC0gMSkgKiA0ICsgM11cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWRcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7518\n\n}")},7526:(__unused_webpack_module,exports)=>{"use strict";eval("{\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUyNi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcz8xZmI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7526\n\n}")},7568:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("{/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1354);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/***** General *****/\n\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    background: transparent;\n    color: white;\n    min-height: 100vh;\n}\n\n.container {\n    padding: 0 15px 0px 15px;\n    display: flex;\n    flex-direction: column;\n}\n\n.screen {\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: 1000;\n    display: none;\n    flex-direction: column;\n}\n\n.screen:not(.hidden) {\n    display: flex;\n}\n\n.screen-header {\n    display: flex;\n    align-items: center;\n    padding: 10px 20px;\n    margin-bottom: 10px;\n    background: rgba(0, 0, 0, 0.1);\n    backdrop-filter: blur(10px);\n}\n\n.screen-header h2 {\n    font-size: 1.3em;\n    font-weight: 600;\n    margin-left: 20px;\n}\n\n@media (width > 340px) {\n    .screen-header h2 {\n        font-size: 1.5em;\n    }\n}\n\n.actions {\n    display: flex;\n    justify-content: center;\n    margin-top: 20px;\n}\n\n.btn {\n    padding: 15px 20px;\n    border: none;\n    border-radius: 12px;\n    font-size: 1em;\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.btn:disabled {\n    opacity: 0.6;\n    cursor: not-allowed;\n    transform: none;\n    pointer-events: none;\n}\n\n.btn-primary {\n    background: linear-gradient(45deg, #4CAF50, #45a049);\n    color: white;\n    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);\n}\n\n.btn-secondary {\n    background: rgba(255, 255, 255, 0.2);\n    color: white;\n    border: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);\n}\n\n.btn:active {\n    transform: translateY(0);\n}\n\n/* Hold-to-send button animation */\n.btn-primary.holding {\n    position: relative;\n    overflow: hidden;\n}\n\n.btn-primary.holding::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 0%;\n    background: linear-gradient(90deg, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0.7) 100%);\n    animation: holdProgress 1s linear forwards;\n    z-index: 0;\n    box-shadow: 2px 0 10px rgba(255, 255, 255, 0.5);\n}\n\n.btn-primary.holding span {\n    position: relative;\n    z-index: 1;\n    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);\n}\n\n@keyframes holdProgress {\n    from {\n        width: 0%;\n    }\n    to {\n        width: 100%;\n    }\n}\n\n.hidden {\n    display: none;\n}\n\n.back-arrow-icon {\n    width: 24px;\n    height: 24px;\n}\n\n.back-btn {\n    background: none;\n    border: none;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    transition: all 0.3s ease;\n    margin-right: 15px;\n}\n\n.back-btn:hover {\n    background: rgba(255, 255, 255, 0.1);\n    transform: scale(1.1);\n}\n\n.loading {\n    display: inline-block;\n    width: 20px;\n    height: 20px;\n    border: 3px solid rgba(255,255,255,.3);\n    border-radius: 50%;\n    border-top-color: #fff;\n    animation: spin 1s ease-in-out infinite;\n}\n\n.loading-screen {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 1);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 10000;\n    color: white;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n}\n\n.loading-content {\n    text-align: center;\n}\n\n.loading-spinner {\n    width: 60px;\n    height: 60px;\n    border: 4px solid rgba(255, 255, 255, 0.3);\n    border-radius: 50%;\n    border-top-color: #fff;\n    animation: spin 1s ease-in-out infinite;\n    margin: 0 auto 20px;\n}\n\n.loading-text {\n    font-size: 18px;\n    font-weight: 500;\n}\n\n@keyframes spin {\n    to { transform: rotate(360deg); }\n}\n\n.wallet-info {\n    margin: 20px 0;\n    padding: 20px;\n    background: rgba(0, 0, 0, 0.1);\n    border-radius: 15px;\n}\n\n.info-item {\n    display: flex;\n    justify-content: space-between;\n    padding: 8px 0;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.info-item:last-child {\n    border-bottom: none;\n}\n\n.info-label {\n    opacity: 0.8;\n    font-weight: 500;\n}\n\n.info-value {\n    font-weight: 600;\n    font-family: 'Courier New', monospace;\n}\n\n/***** HEADER *****/\n\n.header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 10px 15px;\n}\n\n.title {\n    display: flex;\n}\n\n#ecash-logo {\n    width: 35px;\n    height: 35px;\n}\n\n.title h1 {\n    font-size: 1.6em;\n    font-weight: 300;\n    text-shadow: 0 2px 4px rgba(0,0,0,0.3);\n    display: flex;\n    align-items: end;\n    margin-left: 10px;\n}\n\n.header-buttons {\n    display: flex;\n}\n\n.history-button, .settings-button {\n    background: none;\n    border: none;\n    width: 36px;\n    height: 36px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n/***** Wallet card *****/\n\n.card {\n    background: rgba(255, 255, 255, 0.1);\n    backdrop-filter: blur(10px);\n    border-radius: 20px;\n    padding: 15px;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\n    border: 1px solid rgba(255, 255, 255, 0.2);\n    text-align: center;\n}\n\n.balance-container {\n    position: relative;\n    padding-bottom: 30px; /* Reserve space for transitional balance */\n}\n\n.card-label {\n    opacity: 0.8;\n    font-size: 1.2em;\n    margin-bottom: 10px;\n}\n\n.balance {\n    font-size: 3em;\n    font-weight: bold;\n    text-shadow: 0 2px 4px rgba(0,0,0,0.3);\n}\n\n.transitional-balance {\n    position: absolute;\n    top: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n    font-size: 1.2em;\n    font-weight: 600;\n    margin-top: -30px;\n}\n\n.transitional-balance.receive {\n    color: #4ade80;\n}\n\n.transitional-balance.spend {\n    color: #f87171;\n}\n\n.transitional-balance.shake {\n    animation: shake 0.5s ease-in-out;\n}\n\n@keyframes shake {\n    0%, 100% { transform: translateX(-50%) translateX(0); }\n    10%, 30%, 50%, 70%, 90% { transform: translateX(-50%) translateX(-2px); }\n    20%, 40%, 60%, 80% { transform: translateX(-50%) translateX(2px); }\n}\n\n.address-label {\n    font-size: 1.2em;\n    margin-bottom: 10px;\n    opacity: 0.9;\n}\n\n.address {\n    font-family: 'Courier New', monospace;\n    font-size: 0.9em;\n    background: rgba(0, 0, 0, 0.2);\n    padding: 15px;\n    border-radius: 15px;\n    word-break: break-all;\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    line-height: 1.4;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.address:hover {\n    background: rgba(0, 0, 0, 0.3);\n    border-color: rgba(255, 255, 255, 0.3);\n    transform: translateY(-1px);\n}\n\n.address:active {\n    transform: translateY(0);\n}\n\n.qr-code {\n    margin-top: 20px;\n}\n\n.qr-code canvas {\n    border-radius: 15px;\n    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);\n}\n\n/***** Scan button *****/\n\n.scan-section {\n    margin: 10px 0;;\n}\n\n.scan-btn {\n    background: none;\n    border: 2px solid rgba(255, 255, 255, 0.3);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 100px;\n    height: 100px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    margin: 0 auto;\n}\n\n.scan-btn:hover {\n    transform: scale(1.1);\n    border-color: rgba(255, 255, 255, 0.6);\n}\n\n.scan-btn:active {\n    transform: scale(0.95);\n}\n\n.scan-btn img {\n    width: 48px;\n    height: 48px;\n}\n\n/***** History screen *****/\n\n.transaction-list {\n    max-height: calc(100vh - 100px);\n    overflow-y: auto;\n    /* Hide scrollbar completely */\n    scrollbar-width: none;\n    flex: 1;\n}\n\n/* Hide scrollbar for webkit browsers */\n.transaction-list::-webkit-scrollbar {\n    display: none;\n}\n\n.transaction-item {\n    display: flex;\n    align-items: center;\n    padding: 15px 0;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n    word-break: break-all;\n}\n\n.transaction-item:last-child {\n    border-bottom: none;\n}\n\n.transaction-info {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    gap: 5px;\n    text-align: left;\n    font-size: 0.9em;\n}\n\n.transaction-txid {\n    font-family: 'Courier New', monospace;\n    cursor: pointer;\n    text-decoration: underline;\n    text-decoration-style: dotted;\n    opacity: 0.9;\n    transition: opacity 0.2s ease;\n}\n\n.transaction-txid:hover {\n    opacity: 1;\n    text-decoration-style: solid;\n}\n\n.transaction-amount {\n    font-weight: bold;\n    font-size: 1.1em;\n    text-align: right;\n    text-shadow: 0 1px 2px rgba(0,0,0,0.3);\n}\n\n.transaction-amount.received {\n    color: #4ade80;\n}\n\n.transaction-amount.sent {\n    color: #f87171;\n}\n\n.loading-transactions {\n    text-align: center;\n    padding: 40px 20px;\n    opacity: 0.8;\n}\n\n.loading-transactions .loading-spinner {\n    width: 40px;\n    height: 40px;\n    border: 3px solid rgba(255, 255, 255, 0.3);\n    border-radius: 50%;\n    border-top-color: #fff;\n    animation: spin 1s ease-in-out infinite;\n    margin: 0 auto 15px;\n}\n\n.no-transactions {\n    text-align: center;\n    padding: 40px 20px;\n    opacity: 0.8;\n}\n\n.no-transactions h3 {\n    margin: 0 0 10px 0;\n}\n\n.loading-more {\n    text-align: center;\n    padding: 20px;\n    opacity: 0.6;\n}\n\n.loading-more .loading-spinner {\n    width: 20px;\n    height: 20px;\n    margin: 0 auto 10px;\n}\n\n/***** Settings screen *****/\n\n.setting-item {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 15px 0;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.setting-item:last-child {\n    border-bottom: none;\n}\n\n.setting-info {\n    text-align: left;\n    margin-right: 10px;\n}\n\n.setting-info h3 {\n    margin-bottom: 5px;\n    font-size: 1.1em;\n    font-weight: 600;\n}\n\n.setting-info p {\n    font-size: 0.9em;\n    opacity: 0.8;\n}\n\n/* Toggle Switch */\n.toggle-switch {\n    position: relative;\n    display: inline-block;\n    width: 56px;\n    height: 30px;\n    flex-shrink: 0;\n}\n\n.toggle-switch input {\n    opacity: 0;\n    width: 0;\n    height: 0;\n}\n\n.toggle-slider {\n    position: absolute;\n    cursor: pointer;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba(255, 255, 255, 0.2);\n    border: 2px solid rgba(255, 255, 255, 0.3);\n    transition: all 0.3s ease;\n    border-radius: 30px;\n}\n\n.toggle-slider:before {\n    position: absolute;\n    content: \"\";\n    height: 22px;\n    width: 22px;\n    left: 2px;\n    bottom: 2px;\n    background-color: white;\n    transition: all 0.3s ease;\n    border-radius: 50%;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n}\n\n.toggle-switch input:checked + .toggle-slider {\n    background-color: #4CAF50;\n    border-color: #4CAF50;\n}\n\n.toggle-switch input:checked + .toggle-slider:before {\n    transform: translateX(26px);\n}\n\n.toggle-switch input:focus + .toggle-slider {\n    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);\n}\n\n.mnemonic-display {\n    margin-top: 15px;\n}\n\n.mnemonic-display textarea {\n    width: 100%;\n    min-height: 80px;\n    padding: 10px;\n    background: rgba(0, 0, 0, 0.3);\n    border: 1px solid rgba(255, 255, 255, 0.3);\n    border-radius: 6px;\n    color: white;\n    font-family: 'Courier New', monospace;\n    font-size: 14px;\n    line-height: 1.4;\n    resize: none;\n    overflow: hidden;\n}\n\n.mnemonic-display textarea:focus {\n    outline: none;\n}\n\n/***** Send screen *****/\n\n.form-group {\n    margin-bottom: 20px;\n}\n\n.form-group label {\n    display: block;\n    font-size: 1.1em;\n    font-weight: 600;\n    margin-bottom: 5px;\n    text-shadow: 0 1px 2px rgba(0,0,0,0.3);\n}\n\n.form-group input {\n    width: 100%;\n    padding: 15px;\n    border: 2px solid rgba(255, 255, 255, 0.2);\n    border-radius: 12px;\n    background: rgba(255, 255, 255, 0.1);\n    color: white;\n    font-size: 1em;\n    font-family: 'Courier New', monospace;\n    transition: all 0.3s ease;\n}\n\n.form-group input::placeholder {\n    color: rgba(255, 255, 255, 0.6);\n}\n\n.form-group input:focus {\n    outline: none;\n    border-color: rgba(255, 255, 255, 0.5);\n    background: rgba(255, 255, 255, 0.15);\n    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.1);\n}\n\n.form-group input[readonly] {\n    background: rgba(0, 0, 0, 0.2);\n    border-color: rgba(255, 255, 255, 0.3);\n    cursor: not-allowed;\n}\n\n.form-group input.invalid {\n    border-color: #f87171;\n    background: rgba(248, 113, 113, 0.1);\n    box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.1);\n}\n\n.form-group input.valid {\n    border-color: #4ade80;\n    background: rgba(74, 222, 128, 0.1);\n    box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);\n}\n\n/* Address field validation styles */\n#recipient-address.valid {\n    border-color: #4CAF50;\n    background-color: rgba(76, 175, 80, 0.1);\n}\n\n#recipient-address.invalid {\n    border-color: #ff6b6b;\n    background-color: rgba(255, 107, 107, 0.1);\n}\n\n#recipient-address.valid:focus {\n    border-color: #4CAF50;\n    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\n}\n\n#recipient-address.invalid:focus {\n    border-color: #ff6b6b;\n    box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.2);\n}\n\n.slider-wrapper {\n    margin-top: 15px;\n    position: relative;\n}\n\n#amount-slider {\n    accent-color: white;\n    padding: 0;\n}\n\n#amount-slider:focus {\n    box-shadow: none;\n}\n\n/*\n * Make the slider thumb bigger for touch application.\n * This doesn't work for Firefox (and maybe others).\n */\n#amount-slider::-webkit-slider-thumb {\n    border-radius: 50%;\n    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);\n    border: 14px solid white;\n}\n\n.slider-labels {\n    display: flex;\n    justify-content: space-between;\n    font-size: 0.85em;\n    opacity: 0.7;\n}\n\n#fee-display {\n    margin: 10px 0;\n    background: rgba(0, 0, 0, 0.1);\n}\n\n#fee-display.error {\n    border: 1px solid #ff6b6b;\n    background: rgba(255, 107, 107, 0.1);\n}\n\n.fee-info {\n    display: flex;\n    flex-direction: column;\n    gap: 8px;\n}\n\n.fee-item {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n}\n\n.fee-item.title {\n    font-weight: bold;\n    font-size: 1.1em;\n}\n\n.fee-item.title.error {\n    color: #ff6b6b;\n}\n\n.fee-item.total {\n    border-top: 1px solid rgba(255, 255, 255, 0.2);\n    padding-top: 10px;\n    font-weight: bold;\n    font-size: 1.1em;\n}\n\n.fee-label {\n    font-size: 0.9em;\n    opacity: 0.8;\n}\n\n.send-actions {\n    display: flex;\n    gap: 15px;\n    margin-top: 10px;\n    padding: 15px;\n    border-top: 1px solid rgba(255, 255, 255, 0.1);\n    float: bottom;\n}\n\n/* Stick the buttons to the bottom of the screen if it fits */\n@media (height > 660px) {\n    .send-actions {\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        right: 0;\n    }\n}\n\n.send-actions .btn {\n    flex: 1;\n    font-size: 1.1em;\n}\n\n/***** Camera Modal *****/\n\n.camera-modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.9);\n    z-index: 1000;\n    display: none;\n    align-items: center;\n    justify-content: center;\n}\n\n.camera-modal:not(.hidden) {\n    display: flex;\n    background: black;\n}\n\n.camera-container {\n    width: 100%;\n    max-width: 500px;\n    margin: 20px;\n    border-radius: 20px;\n    overflow: hidden;\n    display: flex;\n    flex-direction: column;\n}\n\n.camera-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: end;\n    padding: 20px;\n    background: #f8f9fa;\n}\n\n.camera-header h3 {\n    color: #333;\n    font-size: 1.2em;\n}\n\n.close-btn {\n    background: none;\n    border: none;\n    font-size: 36px;\n    color: #666;\n    cursor: pointer;\n    width: 30px;\n    height: 30px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.close-btn:hover {\n    background: #e9ecef;\n    color: #333;\n}\n\n.camera-content {\n    position: relative;\n    width: 100%;\n    aspect-ratio: 4 / 3;\n    background: black;\n    min-height: 300px;\n    max-height: 500px;\n}\n\n#camera-video {\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n}\n\n.scan-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.camera-footer {\n    padding: 15px 20px;\n    background: #f8f9fa;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\n.camera-footer p {\n    margin: 0 0 15px 0;\n    color: #333;\n    font-size: 0.9em;\n}\n\n.manual-entry-btn {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 8px;\n    padding: 10px 20px;\n    background: #6c757d;\n    border: none;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.manual-entry-btn:hover {\n    background: #5a6268;\n    transform: translateY(-1px);\n}\n\n.manual-entry-btn img {\n    width: 24px;\n    height: 24px;\n    filter: brightness(0) invert(1);\n}\n\n/* No camera fallback styles */\n.no-camera-fallback {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: #1a1a1a;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    text-align: center;\n    padding: 40px 20px;\n}\n\n.no-camera-fallback.hidden {\n    display: none !important;\n}\n\n#no-camera-icon {\n    width: 48px;\n    height: 48px;\n    margin-bottom: 20px;\n}\n\n.no-camera-icon {\n    font-size: 64px;\n    margin-bottom: 20px;\n    opacity: 0.6;\n}\n\n.no-camera-fallback h3 {\n    margin: 0 0 10px 0;\n    font-size: 1.5em;\n    font-weight: 600;\n}\n\n.no-camera-fallback p {\n    color: rgba(255, 255, 255, 0.7);\n    margin: 0 0 30px 0;\n    line-height: 1.5;\n}\n\n/***** Mnemonic Edit Modal *****/\n\n.modal-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.8);\n    align-items: center;\n    justify-content: center;\n    z-index: 1000;\n}\n\n.modal-content {\n    background: #1a1a1a;\n    border-radius: 12px;\n    margin: 15px;\n    max-width: 600px;\n    max-height: 90vh;\n    overflow-y: auto;\n    border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.modal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 20px;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.modal-header h3 {\n    font-size: 1.2em;\n}\n\n.modal-body {\n    padding: 20px;\n}\n\n.modal-description {\n    opacity: 0.8;\n    margin: 0 0 10px 0;\n    font-size: 0.9em;\n    line-height: 1.4;\n}\n\n.modal-warning {\n    color: #ff9800;\n    margin: 0 0 15px 0;\n    font-size: 0.9em;\n    line-height: 1.4;\n    display: flex;\n    align-items: center;\n    gap: 8px;\n}\n\n.warning-icon {\n    font-size: 1.1em;\n}\n\n.modal-body textarea {\n    width: 100%;\n    min-height: 120px;\n    padding: 10px;\n    background: rgba(0, 0, 0, 0.3);\n    border: 1px solid rgba(255, 255, 255, 0.3);\n    border-radius: 12px;\n    color: white;\n    font-family: 'Courier New', monospace;\n    font-size: 14px;\n    line-height: 1.4;\n    resize: vertical;\n}\n\n.modal-body textarea:focus {\n    outline: none;\n    border-color: rgba(255, 255, 255, 0.5);\n}\n\n.mnemonic-edit-modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.9);\n    z-index: 1000;\n    display: none;\n    align-items: center;\n    justify-content: center;\n}\n\n.validation-message {\n    margin-top: 10px;\n    padding: 10px;\n    border-radius: 12px;\n    font-size: 0.9em;\n    line-height: 1.4;\n}\n\n.validation-message.error {\n    background: rgba(244, 67, 54, 0.2);\n    color: #f44336;\n    border: 1px solid rgba(244, 67, 54, 0.3);\n}\n\n.validation-message.success {\n    background: rgba(76, 175, 80, 0.2);\n    color: #4CAF50;\n    border: 1px solid rgba(76, 175, 80, 0.3);\n}\n\n.modal-actions {\n    display: flex;\n    gap: 8px;\n    padding: 20px;\n    border-top: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.modal-actions .btn {\n    flex: 1;\n}\n\n/***** Error Modal *****/\n\n.error-modal-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.9);\n    justify-content: center;\n    align-items: center;\n    z-index: 10000;\n}\n\n.error-modal-content {\n    background: #1a1a1a;\n    border: 1px solid rgba(255, 255, 255, 0.2);\n    border-radius: 12px;\n    padding: 20px;\n    max-width: 400px;\n    margin: 15px;\n    text-align: center;\n}\n\n.error-modal-title {\n    margin: 0 0 15px 0;\n    color: #ff6b6b;\n    font-size: 18px;\n    font-weight: 600;\n}\n\n.error-modal-message {\n    margin: 0 0 20px 0;\n    opacity: 0.9;\n    line-height: 1.5;\n}\n\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./src/main.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/***** General *****/\\n\\n* {\\n    margin: 0;\\n    padding: 0;\\n    box-sizing: border-box;\\n}\\n\\nbody {\\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\\n    background: transparent;\\n    color: white;\\n    min-height: 100vh;\\n}\\n\\n.container {\\n    padding: 0 15px 0px 15px;\\n    display: flex;\\n    flex-direction: column;\\n}\\n\\n.screen {\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    z-index: 1000;\\n    display: none;\\n    flex-direction: column;\\n}\\n\\n.screen:not(.hidden) {\\n    display: flex;\\n}\\n\\n.screen-header {\\n    display: flex;\\n    align-items: center;\\n    padding: 10px 20px;\\n    margin-bottom: 10px;\\n    background: rgba(0, 0, 0, 0.1);\\n    backdrop-filter: blur(10px);\\n}\\n\\n.screen-header h2 {\\n    font-size: 1.3em;\\n    font-weight: 600;\\n    margin-left: 20px;\\n}\\n\\n@media (width > 340px) {\\n    .screen-header h2 {\\n        font-size: 1.5em;\\n    }\\n}\\n\\n.actions {\\n    display: flex;\\n    justify-content: center;\\n    margin-top: 20px;\\n}\\n\\n.btn {\\n    padding: 15px 20px;\\n    border: none;\\n    border-radius: 12px;\\n    font-size: 1em;\\n    font-weight: 600;\\n    cursor: pointer;\\n    transition: all 0.3s ease;\\n    text-transform: uppercase;\\n    letter-spacing: 0.5px;\\n}\\n\\n.btn:disabled {\\n    opacity: 0.6;\\n    cursor: not-allowed;\\n    transform: none;\\n    pointer-events: none;\\n}\\n\\n.btn-primary {\\n    background: linear-gradient(45deg, #4CAF50, #45a049);\\n    color: white;\\n    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);\\n}\\n\\n.btn-secondary {\\n    background: rgba(255, 255, 255, 0.2);\\n    color: white;\\n    border: 1px solid rgba(255, 255, 255, 0.3);\\n}\\n\\n.btn:hover {\\n    transform: translateY(-2px);\\n    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);\\n}\\n\\n.btn:active {\\n    transform: translateY(0);\\n}\\n\\n/* Hold-to-send button animation */\\n.btn-primary.holding {\\n    position: relative;\\n    overflow: hidden;\\n}\\n\\n.btn-primary.holding::before {\\n    content: '';\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    height: 100%;\\n    width: 0%;\\n    background: linear-gradient(90deg, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0.7) 100%);\\n    animation: holdProgress 1s linear forwards;\\n    z-index: 0;\\n    box-shadow: 2px 0 10px rgba(255, 255, 255, 0.5);\\n}\\n\\n.btn-primary.holding span {\\n    position: relative;\\n    z-index: 1;\\n    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);\\n}\\n\\n@keyframes holdProgress {\\n    from {\\n        width: 0%;\\n    }\\n    to {\\n        width: 100%;\\n    }\\n}\\n\\n.hidden {\\n    display: none;\\n}\\n\\n.back-arrow-icon {\\n    width: 24px;\\n    height: 24px;\\n}\\n\\n.back-btn {\\n    background: none;\\n    border: none;\\n    cursor: pointer;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    transition: all 0.3s ease;\\n    margin-right: 15px;\\n}\\n\\n.back-btn:hover {\\n    background: rgba(255, 255, 255, 0.1);\\n    transform: scale(1.1);\\n}\\n\\n.loading {\\n    display: inline-block;\\n    width: 20px;\\n    height: 20px;\\n    border: 3px solid rgba(255,255,255,.3);\\n    border-radius: 50%;\\n    border-top-color: #fff;\\n    animation: spin 1s ease-in-out infinite;\\n}\\n\\n.loading-screen {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background: rgba(0, 0, 0, 1);\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    z-index: 10000;\\n    color: white;\\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\\n}\\n\\n.loading-content {\\n    text-align: center;\\n}\\n\\n.loading-spinner {\\n    width: 60px;\\n    height: 60px;\\n    border: 4px solid rgba(255, 255, 255, 0.3);\\n    border-radius: 50%;\\n    border-top-color: #fff;\\n    animation: spin 1s ease-in-out infinite;\\n    margin: 0 auto 20px;\\n}\\n\\n.loading-text {\\n    font-size: 18px;\\n    font-weight: 500;\\n}\\n\\n@keyframes spin {\\n    to { transform: rotate(360deg); }\\n}\\n\\n.wallet-info {\\n    margin: 20px 0;\\n    padding: 20px;\\n    background: rgba(0, 0, 0, 0.1);\\n    border-radius: 15px;\\n}\\n\\n.info-item {\\n    display: flex;\\n    justify-content: space-between;\\n    padding: 8px 0;\\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\\n}\\n\\n.info-item:last-child {\\n    border-bottom: none;\\n}\\n\\n.info-label {\\n    opacity: 0.8;\\n    font-weight: 500;\\n}\\n\\n.info-value {\\n    font-weight: 600;\\n    font-family: 'Courier New', monospace;\\n}\\n\\n/***** HEADER *****/\\n\\n.header {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    padding: 10px 15px;\\n}\\n\\n.title {\\n    display: flex;\\n}\\n\\n#ecash-logo {\\n    width: 35px;\\n    height: 35px;\\n}\\n\\n.title h1 {\\n    font-size: 1.6em;\\n    font-weight: 300;\\n    text-shadow: 0 2px 4px rgba(0,0,0,0.3);\\n    display: flex;\\n    align-items: end;\\n    margin-left: 10px;\\n}\\n\\n.header-buttons {\\n    display: flex;\\n}\\n\\n.history-button, .settings-button {\\n    background: none;\\n    border: none;\\n    width: 36px;\\n    height: 36px;\\n    cursor: pointer;\\n    display: flex;\\n    align-items: center;\\n    justify-content: right;\\n}\\n\\n/***** Wallet card *****/\\n\\n.card {\\n    background: rgba(255, 255, 255, 0.1);\\n    backdrop-filter: blur(10px);\\n    border-radius: 20px;\\n    padding: 15px;\\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);\\n    border: 1px solid rgba(255, 255, 255, 0.2);\\n    text-align: center;\\n}\\n\\n.balance-container {\\n    position: relative;\\n    padding-bottom: 30px; /* Reserve space for transitional balance */\\n}\\n\\n.card-label {\\n    opacity: 0.8;\\n    font-size: 1.2em;\\n    margin-bottom: 10px;\\n}\\n\\n.balance {\\n    font-size: 3em;\\n    font-weight: bold;\\n    text-shadow: 0 2px 4px rgba(0,0,0,0.3);\\n}\\n\\n.transitional-balance {\\n    position: absolute;\\n    top: 100%;\\n    left: 50%;\\n    transform: translateX(-50%);\\n    font-size: 1.2em;\\n    font-weight: 600;\\n    margin-top: -30px;\\n}\\n\\n.transitional-balance.receive {\\n    color: #4ade80;\\n}\\n\\n.transitional-balance.spend {\\n    color: #f87171;\\n}\\n\\n.transitional-balance.shake {\\n    animation: shake 0.5s ease-in-out;\\n}\\n\\n@keyframes shake {\\n    0%, 100% { transform: translateX(-50%) translateX(0); }\\n    10%, 30%, 50%, 70%, 90% { transform: translateX(-50%) translateX(-2px); }\\n    20%, 40%, 60%, 80% { transform: translateX(-50%) translateX(2px); }\\n}\\n\\n.address-label {\\n    font-size: 1.2em;\\n    margin-bottom: 10px;\\n    opacity: 0.9;\\n}\\n\\n.address {\\n    font-family: 'Courier New', monospace;\\n    font-size: 0.9em;\\n    background: rgba(0, 0, 0, 0.2);\\n    padding: 15px;\\n    border-radius: 15px;\\n    word-break: break-all;\\n    border: 1px solid rgba(255, 255, 255, 0.1);\\n    line-height: 1.4;\\n    cursor: pointer;\\n    transition: all 0.3s ease;\\n}\\n\\n.address:hover {\\n    background: rgba(0, 0, 0, 0.3);\\n    border-color: rgba(255, 255, 255, 0.3);\\n    transform: translateY(-1px);\\n}\\n\\n.address:active {\\n    transform: translateY(0);\\n}\\n\\n.qr-code {\\n    margin-top: 20px;\\n}\\n\\n.qr-code canvas {\\n    border-radius: 15px;\\n    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);\\n}\\n\\n/***** Scan button *****/\\n\\n.scan-section {\\n    margin: 10px 0;;\\n}\\n\\n.scan-btn {\\n    background: none;\\n    border: 2px solid rgba(255, 255, 255, 0.3);\\n    border-radius: 50%;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    width: 100px;\\n    height: 100px;\\n    cursor: pointer;\\n    transition: all 0.3s ease;\\n    margin: 0 auto;\\n}\\n\\n.scan-btn:hover {\\n    transform: scale(1.1);\\n    border-color: rgba(255, 255, 255, 0.6);\\n}\\n\\n.scan-btn:active {\\n    transform: scale(0.95);\\n}\\n\\n.scan-btn img {\\n    width: 48px;\\n    height: 48px;\\n}\\n\\n/***** History screen *****/\\n\\n.transaction-list {\\n    max-height: calc(100vh - 100px);\\n    overflow-y: auto;\\n    /* Hide scrollbar completely */\\n    scrollbar-width: none;\\n    flex: 1;\\n}\\n\\n/* Hide scrollbar for webkit browsers */\\n.transaction-list::-webkit-scrollbar {\\n    display: none;\\n}\\n\\n.transaction-item {\\n    display: flex;\\n    align-items: center;\\n    padding: 15px 0;\\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\\n    word-break: break-all;\\n}\\n\\n.transaction-item:last-child {\\n    border-bottom: none;\\n}\\n\\n.transaction-info {\\n    flex: 1;\\n    display: flex;\\n    flex-direction: column;\\n    gap: 5px;\\n    text-align: left;\\n    font-size: 0.9em;\\n}\\n\\n.transaction-txid {\\n    font-family: 'Courier New', monospace;\\n    cursor: pointer;\\n    text-decoration: underline;\\n    text-decoration-style: dotted;\\n    opacity: 0.9;\\n    transition: opacity 0.2s ease;\\n}\\n\\n.transaction-txid:hover {\\n    opacity: 1;\\n    text-decoration-style: solid;\\n}\\n\\n.transaction-amount {\\n    font-weight: bold;\\n    font-size: 1.1em;\\n    text-align: right;\\n    text-shadow: 0 1px 2px rgba(0,0,0,0.3);\\n}\\n\\n.transaction-amount.received {\\n    color: #4ade80;\\n}\\n\\n.transaction-amount.sent {\\n    color: #f87171;\\n}\\n\\n.loading-transactions {\\n    text-align: center;\\n    padding: 40px 20px;\\n    opacity: 0.8;\\n}\\n\\n.loading-transactions .loading-spinner {\\n    width: 40px;\\n    height: 40px;\\n    border: 3px solid rgba(255, 255, 255, 0.3);\\n    border-radius: 50%;\\n    border-top-color: #fff;\\n    animation: spin 1s ease-in-out infinite;\\n    margin: 0 auto 15px;\\n}\\n\\n.no-transactions {\\n    text-align: center;\\n    padding: 40px 20px;\\n    opacity: 0.8;\\n}\\n\\n.no-transactions h3 {\\n    margin: 0 0 10px 0;\\n}\\n\\n.loading-more {\\n    text-align: center;\\n    padding: 20px;\\n    opacity: 0.6;\\n}\\n\\n.loading-more .loading-spinner {\\n    width: 20px;\\n    height: 20px;\\n    margin: 0 auto 10px;\\n}\\n\\n/***** Settings screen *****/\\n\\n.setting-item {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    padding: 15px 0;\\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\\n}\\n\\n.setting-item:last-child {\\n    border-bottom: none;\\n}\\n\\n.setting-info {\\n    text-align: left;\\n    margin-right: 10px;\\n}\\n\\n.setting-info h3 {\\n    margin-bottom: 5px;\\n    font-size: 1.1em;\\n    font-weight: 600;\\n}\\n\\n.setting-info p {\\n    font-size: 0.9em;\\n    opacity: 0.8;\\n}\\n\\n/* Toggle Switch */\\n.toggle-switch {\\n    position: relative;\\n    display: inline-block;\\n    width: 56px;\\n    height: 30px;\\n    flex-shrink: 0;\\n}\\n\\n.toggle-switch input {\\n    opacity: 0;\\n    width: 0;\\n    height: 0;\\n}\\n\\n.toggle-slider {\\n    position: absolute;\\n    cursor: pointer;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    background-color: rgba(255, 255, 255, 0.2);\\n    border: 2px solid rgba(255, 255, 255, 0.3);\\n    transition: all 0.3s ease;\\n    border-radius: 30px;\\n}\\n\\n.toggle-slider:before {\\n    position: absolute;\\n    content: \\\"\\\";\\n    height: 22px;\\n    width: 22px;\\n    left: 2px;\\n    bottom: 2px;\\n    background-color: white;\\n    transition: all 0.3s ease;\\n    border-radius: 50%;\\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\\n}\\n\\n.toggle-switch input:checked + .toggle-slider {\\n    background-color: #4CAF50;\\n    border-color: #4CAF50;\\n}\\n\\n.toggle-switch input:checked + .toggle-slider:before {\\n    transform: translateX(26px);\\n}\\n\\n.toggle-switch input:focus + .toggle-slider {\\n    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);\\n}\\n\\n.mnemonic-display {\\n    margin-top: 15px;\\n}\\n\\n.mnemonic-display textarea {\\n    width: 100%;\\n    min-height: 80px;\\n    padding: 10px;\\n    background: rgba(0, 0, 0, 0.3);\\n    border: 1px solid rgba(255, 255, 255, 0.3);\\n    border-radius: 6px;\\n    color: white;\\n    font-family: 'Courier New', monospace;\\n    font-size: 14px;\\n    line-height: 1.4;\\n    resize: none;\\n    overflow: hidden;\\n}\\n\\n.mnemonic-display textarea:focus {\\n    outline: none;\\n}\\n\\n/***** Send screen *****/\\n\\n.form-group {\\n    margin-bottom: 20px;\\n}\\n\\n.form-group label {\\n    display: block;\\n    font-size: 1.1em;\\n    font-weight: 600;\\n    margin-bottom: 5px;\\n    text-shadow: 0 1px 2px rgba(0,0,0,0.3);\\n}\\n\\n.form-group input {\\n    width: 100%;\\n    padding: 15px;\\n    border: 2px solid rgba(255, 255, 255, 0.2);\\n    border-radius: 12px;\\n    background: rgba(255, 255, 255, 0.1);\\n    color: white;\\n    font-size: 1em;\\n    font-family: 'Courier New', monospace;\\n    transition: all 0.3s ease;\\n}\\n\\n.form-group input::placeholder {\\n    color: rgba(255, 255, 255, 0.6);\\n}\\n\\n.form-group input:focus {\\n    outline: none;\\n    border-color: rgba(255, 255, 255, 0.5);\\n    background: rgba(255, 255, 255, 0.15);\\n    box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.1);\\n}\\n\\n.form-group input[readonly] {\\n    background: rgba(0, 0, 0, 0.2);\\n    border-color: rgba(255, 255, 255, 0.3);\\n    cursor: not-allowed;\\n}\\n\\n.form-group input.invalid {\\n    border-color: #f87171;\\n    background: rgba(248, 113, 113, 0.1);\\n    box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.1);\\n}\\n\\n.form-group input.valid {\\n    border-color: #4ade80;\\n    background: rgba(74, 222, 128, 0.1);\\n    box-shadow: 0 0 0 3px rgba(74, 222, 128, 0.1);\\n}\\n\\n/* Address field validation styles */\\n#recipient-address.valid {\\n    border-color: #4CAF50;\\n    background-color: rgba(76, 175, 80, 0.1);\\n}\\n\\n#recipient-address.invalid {\\n    border-color: #ff6b6b;\\n    background-color: rgba(255, 107, 107, 0.1);\\n}\\n\\n#recipient-address.valid:focus {\\n    border-color: #4CAF50;\\n    box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);\\n}\\n\\n#recipient-address.invalid:focus {\\n    border-color: #ff6b6b;\\n    box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.2);\\n}\\n\\n.slider-wrapper {\\n    margin-top: 15px;\\n    position: relative;\\n}\\n\\n#amount-slider {\\n    accent-color: white;\\n    padding: 0;\\n}\\n\\n#amount-slider:focus {\\n    box-shadow: none;\\n}\\n\\n/*\\n * Make the slider thumb bigger for touch application.\\n * This doesn't work for Firefox (and maybe others).\\n */\\n#amount-slider::-webkit-slider-thumb {\\n    border-radius: 50%;\\n    box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);\\n    border: 14px solid white;\\n}\\n\\n.slider-labels {\\n    display: flex;\\n    justify-content: space-between;\\n    font-size: 0.85em;\\n    opacity: 0.7;\\n}\\n\\n#fee-display {\\n    margin: 10px 0;\\n    background: rgba(0, 0, 0, 0.1);\\n}\\n\\n#fee-display.error {\\n    border: 1px solid #ff6b6b;\\n    background: rgba(255, 107, 107, 0.1);\\n}\\n\\n.fee-info {\\n    display: flex;\\n    flex-direction: column;\\n    gap: 8px;\\n}\\n\\n.fee-item {\\n    display: flex;\\n    justify-content: space-between;\\n    align-items: center;\\n}\\n\\n.fee-item.title {\\n    font-weight: bold;\\n    font-size: 1.1em;\\n}\\n\\n.fee-item.title.error {\\n    color: #ff6b6b;\\n}\\n\\n.fee-item.total {\\n    border-top: 1px solid rgba(255, 255, 255, 0.2);\\n    padding-top: 10px;\\n    font-weight: bold;\\n    font-size: 1.1em;\\n}\\n\\n.fee-label {\\n    font-size: 0.9em;\\n    opacity: 0.8;\\n}\\n\\n.send-actions {\\n    display: flex;\\n    gap: 15px;\\n    margin-top: 10px;\\n    padding: 15px;\\n    border-top: 1px solid rgba(255, 255, 255, 0.1);\\n    float: bottom;\\n}\\n\\n/* Stick the buttons to the bottom of the screen if it fits */\\n@media (height > 660px) {\\n    .send-actions {\\n        position: absolute;\\n        bottom: 0;\\n        left: 0;\\n        right: 0;\\n    }\\n}\\n\\n.send-actions .btn {\\n    flex: 1;\\n    font-size: 1.1em;\\n}\\n\\n/***** Camera Modal *****/\\n\\n.camera-modal {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background: rgba(0, 0, 0, 0.9);\\n    z-index: 1000;\\n    display: none;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n.camera-modal:not(.hidden) {\\n    display: flex;\\n    background: black;\\n}\\n\\n.camera-container {\\n    width: 100%;\\n    max-width: 500px;\\n    margin: 20px;\\n    border-radius: 20px;\\n    overflow: hidden;\\n    display: flex;\\n    flex-direction: column;\\n}\\n\\n.camera-header {\\n    display: flex;\\n    justify-content: space-between;\\n    align-items: end;\\n    padding: 20px;\\n    background: #f8f9fa;\\n}\\n\\n.camera-header h3 {\\n    color: #333;\\n    font-size: 1.2em;\\n}\\n\\n.close-btn {\\n    background: none;\\n    border: none;\\n    font-size: 36px;\\n    color: #666;\\n    cursor: pointer;\\n    width: 30px;\\n    height: 30px;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n.close-btn:hover {\\n    background: #e9ecef;\\n    color: #333;\\n}\\n\\n.camera-content {\\n    position: relative;\\n    width: 100%;\\n    aspect-ratio: 4 / 3;\\n    background: black;\\n    min-height: 300px;\\n    max-height: 500px;\\n}\\n\\n#camera-video {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n}\\n\\n.scan-overlay {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n.camera-footer {\\n    padding: 15px 20px;\\n    background: #f8f9fa;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n}\\n\\n.camera-footer p {\\n    margin: 0 0 15px 0;\\n    color: #333;\\n    font-size: 0.9em;\\n}\\n\\n.manual-entry-btn {\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n    gap: 8px;\\n    padding: 10px 20px;\\n    background: #6c757d;\\n    border: none;\\n    cursor: pointer;\\n    transition: all 0.3s ease;\\n}\\n\\n.manual-entry-btn:hover {\\n    background: #5a6268;\\n    transform: translateY(-1px);\\n}\\n\\n.manual-entry-btn img {\\n    width: 24px;\\n    height: 24px;\\n    filter: brightness(0) invert(1);\\n}\\n\\n/* No camera fallback styles */\\n.no-camera-fallback {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background: #1a1a1a;\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    justify-content: center;\\n    text-align: center;\\n    padding: 40px 20px;\\n}\\n\\n.no-camera-fallback.hidden {\\n    display: none !important;\\n}\\n\\n#no-camera-icon {\\n    width: 48px;\\n    height: 48px;\\n    margin-bottom: 20px;\\n}\\n\\n.no-camera-icon {\\n    font-size: 64px;\\n    margin-bottom: 20px;\\n    opacity: 0.6;\\n}\\n\\n.no-camera-fallback h3 {\\n    margin: 0 0 10px 0;\\n    font-size: 1.5em;\\n    font-weight: 600;\\n}\\n\\n.no-camera-fallback p {\\n    color: rgba(255, 255, 255, 0.7);\\n    margin: 0 0 30px 0;\\n    line-height: 1.5;\\n}\\n\\n/***** Mnemonic Edit Modal *****/\\n\\n.modal-overlay {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    background: rgba(0, 0, 0, 0.8);\\n    align-items: center;\\n    justify-content: center;\\n    z-index: 1000;\\n}\\n\\n.modal-content {\\n    background: #1a1a1a;\\n    border-radius: 12px;\\n    margin: 15px;\\n    max-width: 600px;\\n    max-height: 90vh;\\n    overflow-y: auto;\\n    border: 1px solid rgba(255, 255, 255, 0.2);\\n}\\n\\n.modal-header {\\n    display: flex;\\n    justify-content: space-between;\\n    align-items: center;\\n    padding: 20px;\\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\\n}\\n\\n.modal-header h3 {\\n    font-size: 1.2em;\\n}\\n\\n.modal-body {\\n    padding: 20px;\\n}\\n\\n.modal-description {\\n    opacity: 0.8;\\n    margin: 0 0 10px 0;\\n    font-size: 0.9em;\\n    line-height: 1.4;\\n}\\n\\n.modal-warning {\\n    color: #ff9800;\\n    margin: 0 0 15px 0;\\n    font-size: 0.9em;\\n    line-height: 1.4;\\n    display: flex;\\n    align-items: center;\\n    gap: 8px;\\n}\\n\\n.warning-icon {\\n    font-size: 1.1em;\\n}\\n\\n.modal-body textarea {\\n    width: 100%;\\n    min-height: 120px;\\n    padding: 10px;\\n    background: rgba(0, 0, 0, 0.3);\\n    border: 1px solid rgba(255, 255, 255, 0.3);\\n    border-radius: 12px;\\n    color: white;\\n    font-family: 'Courier New', monospace;\\n    font-size: 14px;\\n    line-height: 1.4;\\n    resize: vertical;\\n}\\n\\n.modal-body textarea:focus {\\n    outline: none;\\n    border-color: rgba(255, 255, 255, 0.5);\\n}\\n\\n.mnemonic-edit-modal {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background: rgba(0, 0, 0, 0.9);\\n    z-index: 1000;\\n    display: none;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n.validation-message {\\n    margin-top: 10px;\\n    padding: 10px;\\n    border-radius: 12px;\\n    font-size: 0.9em;\\n    line-height: 1.4;\\n}\\n\\n.validation-message.error {\\n    background: rgba(244, 67, 54, 0.2);\\n    color: #f44336;\\n    border: 1px solid rgba(244, 67, 54, 0.3);\\n}\\n\\n.validation-message.success {\\n    background: rgba(76, 175, 80, 0.2);\\n    color: #4CAF50;\\n    border: 1px solid rgba(76, 175, 80, 0.3);\\n}\\n\\n.modal-actions {\\n    display: flex;\\n    gap: 8px;\\n    padding: 20px;\\n    border-top: 1px solid rgba(255, 255, 255, 0.1);\\n}\\n\\n.modal-actions .btn {\\n    flex: 1;\\n}\\n\\n/***** Error Modal *****/\\n\\n.error-modal-overlay {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    background: rgba(0, 0, 0, 0.9);\\n    justify-content: center;\\n    align-items: center;\\n    z-index: 10000;\\n}\\n\\n.error-modal-content {\\n    background: #1a1a1a;\\n    border: 1px solid rgba(255, 255, 255, 0.2);\\n    border-radius: 12px;\\n    padding: 20px;\\n    max-width: 400px;\\n    margin: 15px;\\n    text-align: center;\\n}\\n\\n.error-modal-title {\\n    margin: 0 0 15px 0;\\n    color: #ff6b6b;\\n    font-size: 18px;\\n    font-weight: 600;\\n}\\n\\n.error-modal-message {\\n    margin: 0 0 20px 0;\\n    opacity: 0.9;\\n    line-height: 1.5;\\n}\\n\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU2OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDMEc7QUFDakI7QUFDekYsOEJBQThCLG1GQUEyQixDQUFDLDRGQUFxQztBQUMvRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sdUZBQXVGLE1BQU0sVUFBVSxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFlBQVksV0FBVyxZQUFZLE9BQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLEtBQUssWUFBWSxNQUFNLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxXQUFXLFlBQVksV0FBVyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLFlBQVksT0FBTyxLQUFLLFlBQVksV0FBVyxZQUFZLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sWUFBWSxNQUFNLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLFdBQVcsVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFlBQVksT0FBTyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sS0FBSyxVQUFVLE9BQU8sS0FBSyxVQUFVLFVBQVUsT0FBTyxLQUFLLFlBQVksV0FBVyxVQUFVLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxXQUFXLFlBQVksYUFBYSxXQUFXLFVBQVUsWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxzQkFBc0IsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sYUFBYSxNQUFNLFVBQVUsWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsT0FBTyxLQUFLLFVBQVUsVUFBVSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsV0FBVyxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsT0FBTyxLQUFLLFlBQVksV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLGFBQWEsTUFBTSxZQUFZLGFBQWEsYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLHlCQUF5QixPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxzQkFBc0IseUJBQXlCLHlCQUF5QixPQUFPLEtBQUssWUFBWSxhQUFhLFdBQVcsT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLFdBQVcsWUFBWSxhQUFhLGFBQWEsYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxhQUFhLE1BQU0sVUFBVSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLFVBQVUsWUFBWSxXQUFXLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsVUFBVSxPQUFPLGFBQWEsTUFBTSxZQUFZLGFBQWEsYUFBYSxhQUFhLFdBQVcsTUFBTSxZQUFZLE1BQU0sVUFBVSxPQUFPLEtBQUssVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLFVBQVUsWUFBWSxXQUFXLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxXQUFXLFlBQVksYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssWUFBWSxhQUFhLFdBQVcsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxXQUFXLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLFdBQVcsVUFBVSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksT0FBTyxhQUFhLE1BQU0sVUFBVSxZQUFZLGFBQWEsV0FBVyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsT0FBTyxZQUFZLE1BQU0sWUFBWSxhQUFhLFdBQVcsVUFBVSxVQUFVLE9BQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksV0FBVyxZQUFZLGFBQWEsYUFBYSxXQUFXLFlBQVksV0FBVyxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssVUFBVSxPQUFPLGFBQWEsTUFBTSxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxXQUFXLFVBQVUsWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLE9BQU8sWUFBWSxNQUFNLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsTUFBTSxLQUFLLFlBQVksT0FBTyxPQUFPLEtBQUssS0FBSyxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsV0FBVyxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLFdBQVcsWUFBWSxXQUFXLE9BQU8sWUFBWSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxLQUFLLE1BQU0sS0FBSyxVQUFVLFlBQVksT0FBTyxhQUFhLE1BQU0sVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFlBQVksV0FBVyxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksV0FBVyxZQUFZLGFBQWEsV0FBVyxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxXQUFXLE1BQU0sS0FBSyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLFdBQVcsWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksT0FBTyxZQUFZLE1BQU0sWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLFlBQVksV0FBVyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksV0FBVyxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLE9BQU8sYUFBYSxNQUFNLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxZQUFZLGFBQWEsYUFBYSxXQUFXLE9BQU8sS0FBSyxZQUFZLGFBQWEsV0FBVyxZQUFZLGFBQWEsYUFBYSxhQUFhLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxZQUFZLFdBQVcsTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLFlBQVksYUFBYSxhQUFhLFdBQVcsWUFBWSxXQUFXLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksV0FBVyxZQUFZLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLFVBQVUsWUFBWSxPQUFPLEtBQUssVUFBVSxNQUFNLGFBQWEsTUFBTSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFlBQVksc0RBQXNELGdCQUFnQixpQkFBaUIsNkJBQTZCLEdBQUcsVUFBVSxxRkFBcUYsOEJBQThCLG1CQUFtQix3QkFBd0IsR0FBRyxnQkFB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cUJBQXFCLHlCQUF5Qix1QkFBdUIsdUJBQXVCLG9CQUFvQiwwQkFBMEIsZUFBZSxHQUFHLG1CQUFtQix1QkFBdUIsR0FBRywwQkFBMEIsa0JBQWtCLHdCQUF3QixvQkFBb0IscUNBQXFDLGlEQUFpRCwwQkFBMEIsbUJBQW1CLDRDQUE0QyxzQkFBc0IsdUJBQXVCLHVCQUF1QixHQUFHLGdDQUFnQyxvQkFBb0IsNkNBQTZDLEdBQUcsMEJBQTBCLHNCQUFzQixhQUFhLGNBQWMsa0JBQWtCLG1CQUFtQixxQ0FBcUMsb0JBQW9CLG9CQUFvQiwwQkFBMEIsOEJBQThCLEdBQUcseUJBQXlCLHVCQUF1QixvQkFBb0IsMEJBQTBCLHVCQUF1Qix1QkFBdUIsR0FBRywrQkFBK0IseUNBQXlDLHFCQUFxQiwrQ0FBK0MsR0FBRyxpQ0FBaUMseUNBQXlDLHFCQUFxQiwrQ0FBK0MsR0FBRyxvQkFBb0Isb0JBQW9CLGVBQWUsb0JBQW9CLHFEQUFxRCxHQUFHLHlCQUF5QixjQUFjLEdBQUcsdURBQXVELHNCQUFzQixhQUFhLGNBQWMsa0JBQWtCLG1CQUFtQixxQ0FBcUMsOEJBQThCLDBCQUEwQixxQkFBcUIsR0FBRywwQkFBMEIsMEJBQTBCLGlEQUFpRCwwQkFBMEIsb0JBQW9CLHVCQUF1QixtQkFBbUIseUJBQXlCLEdBQUcsd0JBQXdCLHlCQUF5QixxQkFBcUIsc0JBQXNCLHVCQUF1QixHQUFHLDBCQUEwQix5QkFBeUIsbUJBQW1CLHVCQUF1QixHQUFHLHVCQUF1QjtBQUMvejdCO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vc3JjL21haW4uY3NzPzA5OWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC8qKioqKiBHZW5lcmFsICoqKioqL1xuXG4qIHtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xufVxuXG5ib2R5IHtcbiAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sIHNhbnMtc2VyaWY7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xufVxuXG4uY29udGFpbmVyIHtcbiAgICBwYWRkaW5nOiAwIDE1cHggMHB4IDE1cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuXG4uc2NyZWVuIHtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgei1pbmRleDogMTAwMDtcbiAgICBkaXNwbGF5OiBub25lO1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XG5cbi5zY3JlZW46bm90KC5oaWRkZW4pIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xufVxuXG4uc2NyZWVuLWhlYWRlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDEwcHggMjBweDtcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4xKTtcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMTBweCk7XG59XG5cbi5zY3JlZW4taGVhZGVyIGgyIHtcbiAgICBmb250LXNpemU6IDEuM2VtO1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgbWFyZ2luLWxlZnQ6IDIwcHg7XG59XG5cbkBtZWRpYSAod2lkdGggPiAzNDBweCkge1xuICAgIC5zY3JlZW4taGVhZGVyIGgyIHtcbiAgICAgICAgZm9udC1zaXplOiAxLjVlbTtcbiAgICB9XG59XG5cbi5hY3Rpb25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIG1hcmdpbi10b3A6IDIwcHg7XG59XG5cbi5idG4ge1xuICAgIHBhZGRpbmc6IDE1cHggMjBweDtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICBmb250LXNpemU6IDFlbTtcbiAgICBmb250LXdlaWdodDogNjAwO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgbGV0dGVyLXNwYWNpbmc6IDAuNXB4O1xufVxuXG4uYnRuOmRpc2FibGVkIHtcbiAgICBvcGFjaXR5OiAwLjY7XG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgICB0cmFuc2Zvcm06IG5vbmU7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG5cbi5idG4tcHJpbWFyeSB7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAjNENBRjUwLCAjNDVhMDQ5KTtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgYm94LXNoYWRvdzogMCA0cHggMTVweCByZ2JhKDc2LCAxNzUsIDgwLCAwLjMpO1xufVxuXG4uYnRuLXNlY29uZGFyeSB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XG59XG5cbi5idG46aG92ZXIge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMnB4KTtcbiAgICBib3gtc2hhZG93OiAwIDZweCAyMHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbn1cblxuLmJ0bjphY3RpdmUge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcbn1cblxuLyogSG9sZC10by1zZW5kIGJ1dHRvbiBhbmltYXRpb24gKi9cbi5idG4tcHJpbWFyeS5ob2xkaW5nIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuLmJ0bi1wcmltYXJ5LmhvbGRpbmc6OmJlZm9yZSB7XG4gICAgY29udGVudDogJyc7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB3aWR0aDogMCU7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSkgMCUsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSAxMDAlKTtcbiAgICBhbmltYXRpb246IGhvbGRQcm9ncmVzcyAxcyBsaW5lYXIgZm9yd2FyZHM7XG4gICAgei1pbmRleDogMDtcbiAgICBib3gtc2hhZG93OiAycHggMCAxMHB4IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcbn1cblxuLmJ0bi1wcmltYXJ5LmhvbGRpbmcgc3BhbiB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHotaW5kZXg6IDE7XG4gICAgdGV4dC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuNSk7XG59XG5cbkBrZXlmcmFtZXMgaG9sZFByb2dyZXNzIHtcbiAgICBmcm9tIHtcbiAgICAgICAgd2lkdGg6IDAlO1xuICAgIH1cbiAgICB0byB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cbn1cblxuLmhpZGRlbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cblxuLmJhY2stYXJyb3ctaWNvbiB7XG4gICAgd2lkdGg6IDI0cHg7XG4gICAgaGVpZ2h0OiAyNHB4O1xufVxuXG4uYmFjay1idG4ge1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgICBtYXJnaW4tcmlnaHQ6IDE1cHg7XG59XG5cbi5iYWNrLWJ0bjpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xKTtcbn1cblxuLmxvYWRpbmcge1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB3aWR0aDogMjBweDtcbiAgICBoZWlnaHQ6IDIwcHg7XG4gICAgYm9yZGVyOiAzcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwuMyk7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIGJvcmRlci10b3AtY29sb3I6ICNmZmY7XG4gICAgYW5pbWF0aW9uOiBzcGluIDFzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xufVxuXG4ubG9hZGluZy1zY3JlZW4ge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAxKTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgei1pbmRleDogMTAwMDA7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgc2Fucy1zZXJpZjtcbn1cblxuLmxvYWRpbmctY29udGVudCB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG4ubG9hZGluZy1zcGlubmVyIHtcbiAgICB3aWR0aDogNjBweDtcbiAgICBoZWlnaHQ6IDYwcHg7XG4gICAgYm9yZGVyOiA0cHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICBib3JkZXItdG9wLWNvbG9yOiAjZmZmO1xuICAgIGFuaW1hdGlvbjogc3BpbiAxcyBlYXNlLWluLW91dCBpbmZpbml0ZTtcbiAgICBtYXJnaW46IDAgYXV0byAyMHB4O1xufVxuXG4ubG9hZGluZy10ZXh0IHtcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbn1cblxuQGtleWZyYW1lcyBzcGluIHtcbiAgICB0byB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbn1cblxuLndhbGxldC1pbmZvIHtcbiAgICBtYXJnaW46IDIwcHggMDtcbiAgICBwYWRkaW5nOiAyMHB4O1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4xKTtcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xufVxuXG4uaW5mby1pdGVtIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBwYWRkaW5nOiA4cHggMDtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xufVxuXG4uaW5mby1pdGVtOmxhc3QtY2hpbGQge1xuICAgIGJvcmRlci1ib3R0b206IG5vbmU7XG59XG5cbi5pbmZvLWxhYmVsIHtcbiAgICBvcGFjaXR5OiAwLjg7XG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcbn1cblxuLmluZm8tdmFsdWUge1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgZm9udC1mYW1pbHk6ICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcbn1cblxuLyoqKioqIEhFQURFUiAqKioqKi9cblxuLmhlYWRlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBwYWRkaW5nOiAxMHB4IDE1cHg7XG59XG5cbi50aXRsZSB7XG4gICAgZGlzcGxheTogZmxleDtcbn1cblxuI2VjYXNoLWxvZ28ge1xuICAgIHdpZHRoOiAzNXB4O1xuICAgIGhlaWdodDogMzVweDtcbn1cblxuLnRpdGxlIGgxIHtcbiAgICBmb250LXNpemU6IDEuNmVtO1xuICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgdGV4dC1zaGFkb3c6IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMyk7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogZW5kO1xuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xufVxuXG4uaGVhZGVyLWJ1dHRvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG59XG5cbi5oaXN0b3J5LWJ1dHRvbiwgLnNldHRpbmdzLWJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgd2lkdGg6IDM2cHg7XG4gICAgaGVpZ2h0OiAzNnB4O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiByaWdodDtcbn1cblxuLyoqKioqIFdhbGxldCBjYXJkICoqKioqL1xuXG4uY2FyZCB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KTtcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xuICAgIHBhZGRpbmc6IDE1cHg7XG4gICAgYm94LXNoYWRvdzogMCA4cHggMzJweCByZ2JhKDAsIDAsIDAsIDAuMSk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuLmJhbGFuY2UtY29udGFpbmVyIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgcGFkZGluZy1ib3R0b206IDMwcHg7IC8qIFJlc2VydmUgc3BhY2UgZm9yIHRyYW5zaXRpb25hbCBiYWxhbmNlICovXG59XG5cbi5jYXJkLWxhYmVsIHtcbiAgICBvcGFjaXR5OiAwLjg7XG4gICAgZm9udC1zaXplOiAxLjJlbTtcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xufVxuXG4uYmFsYW5jZSB7XG4gICAgZm9udC1zaXplOiAzZW07XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdGV4dC1zaGFkb3c6IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMyk7XG59XG5cbi50cmFuc2l0aW9uYWwtYmFsYW5jZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMTAwJTtcbiAgICBsZWZ0OiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICBtYXJnaW4tdG9wOiAtMzBweDtcbn1cblxuLnRyYW5zaXRpb25hbC1iYWxhbmNlLnJlY2VpdmUge1xuICAgIGNvbG9yOiAjNGFkZTgwO1xufVxuXG4udHJhbnNpdGlvbmFsLWJhbGFuY2Uuc3BlbmQge1xuICAgIGNvbG9yOiAjZjg3MTcxO1xufVxuXG4udHJhbnNpdGlvbmFsLWJhbGFuY2Uuc2hha2Uge1xuICAgIGFuaW1hdGlvbjogc2hha2UgMC41cyBlYXNlLWluLW91dDtcbn1cblxuQGtleWZyYW1lcyBzaGFrZSB7XG4gICAgMCUsIDEwMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWCgwKTsgfVxuICAgIDEwJSwgMzAlLCA1MCUsIDcwJSwgOTAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVgoLTJweCk7IH1cbiAgICAyMCUsIDQwJSwgNjAlLCA4MCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWCgycHgpOyB9XG59XG5cbi5hZGRyZXNzLWxhYmVsIHtcbiAgICBmb250LXNpemU6IDEuMmVtO1xuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgb3BhY2l0eTogMC45O1xufVxuXG4uYWRkcmVzcyB7XG4gICAgZm9udC1mYW1pbHk6ICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcbiAgICBmb250LXNpemU6IDAuOWVtO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICBwYWRkaW5nOiAxNXB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XG4gICAgd29yZC1icmVhazogYnJlYWstYWxsO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcbiAgICBsaW5lLWhlaWdodDogMS40O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xufVxuXG4uYWRkcmVzczpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMXB4KTtcbn1cblxuLmFkZHJlc3M6YWN0aXZlIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XG59XG5cbi5xci1jb2RlIHtcbiAgICBtYXJnaW4tdG9wOiAyMHB4O1xufVxuXG4ucXItY29kZSBjYW52YXMge1xuICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7XG4gICAgYm94LXNoYWRvdzogMCA0cHggMTVweCByZ2JhKDAsIDAsIDAsIDAuMik7XG59XG5cbi8qKioqKiBTY2FuIGJ1dHRvbiAqKioqKi9cblxuLnNjYW4tc2VjdGlvbiB7XG4gICAgbWFyZ2luOiAxMHB4IDA7O1xufVxuXG4uc2Nhbi1idG4ge1xuICAgIGJhY2tncm91bmQ6IG5vbmU7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgd2lkdGg6IDEwMHB4O1xuICAgIGhlaWdodDogMTAwcHg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG4gICAgbWFyZ2luOiAwIGF1dG87XG59XG5cbi5zY2FuLWJ0bjpob3ZlciB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xuICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjYpO1xufVxuXG4uc2Nhbi1idG46YWN0aXZlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTUpO1xufVxuXG4uc2Nhbi1idG4gaW1nIHtcbiAgICB3aWR0aDogNDhweDtcbiAgICBoZWlnaHQ6IDQ4cHg7XG59XG5cbi8qKioqKiBIaXN0b3J5IHNjcmVlbiAqKioqKi9cblxuLnRyYW5zYWN0aW9uLWxpc3Qge1xuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwdmggLSAxMDBweCk7XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgICAvKiBIaWRlIHNjcm9sbGJhciBjb21wbGV0ZWx5ICovXG4gICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xuICAgIGZsZXg6IDE7XG59XG5cbi8qIEhpZGUgc2Nyb2xsYmFyIGZvciB3ZWJraXQgYnJvd3NlcnMgKi9cbi50cmFuc2FjdGlvbi1saXN0Ojotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgZGlzcGxheTogbm9uZTtcbn1cblxuLnRyYW5zYWN0aW9uLWl0ZW0ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nOiAxNXB4IDA7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcbiAgICB3b3JkLWJyZWFrOiBicmVhay1hbGw7XG59XG5cbi50cmFuc2FjdGlvbi1pdGVtOmxhc3QtY2hpbGQge1xuICAgIGJvcmRlci1ib3R0b206IG5vbmU7XG59XG5cbi50cmFuc2FjdGlvbi1pbmZvIHtcbiAgICBmbGV4OiAxO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBnYXA6IDVweDtcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgIGZvbnQtc2l6ZTogMC45ZW07XG59XG5cbi50cmFuc2FjdGlvbi10eGlkIHtcbiAgICBmb250LWZhbWlseTogJ0NvdXJpZXIgTmV3JywgbW9ub3NwYWNlO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICB0ZXh0LWRlY29yYXRpb24tc3R5bGU6IGRvdHRlZDtcbiAgICBvcGFjaXR5OiAwLjk7XG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2U7XG59XG5cbi50cmFuc2FjdGlvbi10eGlkOmhvdmVyIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRleHQtZGVjb3JhdGlvbi1zdHlsZTogc29saWQ7XG59XG5cbi50cmFuc2FjdGlvbi1hbW91bnQge1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIGZvbnQtc2l6ZTogMS4xZW07XG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XG4gICAgdGV4dC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMyk7XG59XG5cbi50cmFuc2FjdGlvbi1hbW91bnQucmVjZWl2ZWQge1xuICAgIGNvbG9yOiAjNGFkZTgwO1xufVxuXG4udHJhbnNhY3Rpb24tYW1vdW50LnNlbnQge1xuICAgIGNvbG9yOiAjZjg3MTcxO1xufVxuXG4ubG9hZGluZy10cmFuc2FjdGlvbnMge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBwYWRkaW5nOiA0MHB4IDIwcHg7XG4gICAgb3BhY2l0eTogMC44O1xufVxuXG4ubG9hZGluZy10cmFuc2FjdGlvbnMgLmxvYWRpbmctc3Bpbm5lciB7XG4gICAgd2lkdGg6IDQwcHg7XG4gICAgaGVpZ2h0OiA0MHB4O1xuICAgIGJvcmRlcjogM3B4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYm9yZGVyLXRvcC1jb2xvcjogI2ZmZjtcbiAgICBhbmltYXRpb246IHNwaW4gMXMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XG4gICAgbWFyZ2luOiAwIGF1dG8gMTVweDtcbn1cblxuLm5vLXRyYW5zYWN0aW9ucyB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHBhZGRpbmc6IDQwcHggMjBweDtcbiAgICBvcGFjaXR5OiAwLjg7XG59XG5cbi5uby10cmFuc2FjdGlvbnMgaDMge1xuICAgIG1hcmdpbjogMCAwIDEwcHggMDtcbn1cblxuLmxvYWRpbmctbW9yZSB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgb3BhY2l0eTogMC42O1xufVxuXG4ubG9hZGluZy1tb3JlIC5sb2FkaW5nLXNwaW5uZXIge1xuICAgIHdpZHRoOiAyMHB4O1xuICAgIGhlaWdodDogMjBweDtcbiAgICBtYXJnaW46IDAgYXV0byAxMHB4O1xufVxuXG4vKioqKiogU2V0dGluZ3Mgc2NyZWVuICoqKioqL1xuXG4uc2V0dGluZy1pdGVtIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHBhZGRpbmc6IDE1cHggMDtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xufVxuXG4uc2V0dGluZy1pdGVtOmxhc3QtY2hpbGQge1xuICAgIGJvcmRlci1ib3R0b206IG5vbmU7XG59XG5cbi5zZXR0aW5nLWluZm8ge1xuICAgIHRleHQtYWxpZ246IGxlZnQ7XG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xufVxuXG4uc2V0dGluZy1pbmZvIGgzIHtcbiAgICBtYXJnaW4tYm90dG9tOiA1cHg7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogNjAwO1xufVxuXG4uc2V0dGluZy1pbmZvIHAge1xuICAgIGZvbnQtc2l6ZTogMC45ZW07XG4gICAgb3BhY2l0eTogMC44O1xufVxuXG4vKiBUb2dnbGUgU3dpdGNoICovXG4udG9nZ2xlLXN3aXRjaCB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICB3aWR0aDogNTZweDtcbiAgICBoZWlnaHQ6IDMwcHg7XG4gICAgZmxleC1zaHJpbms6IDA7XG59XG5cbi50b2dnbGUtc3dpdGNoIGlucHV0IHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHdpZHRoOiAwO1xuICAgIGhlaWdodDogMDtcbn1cblxuLnRvZ2dsZS1zbGlkZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgcmlnaHQ6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcbiAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgICBib3JkZXItcmFkaXVzOiAzMHB4O1xufVxuXG4udG9nZ2xlLXNsaWRlcjpiZWZvcmUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBjb250ZW50OiBcIlwiO1xuICAgIGhlaWdodDogMjJweDtcbiAgICB3aWR0aDogMjJweDtcbiAgICBsZWZ0OiAycHg7XG4gICAgYm90dG9tOiAycHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYm94LXNoYWRvdzogMCAycHggNHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbn1cblxuLnRvZ2dsZS1zd2l0Y2ggaW5wdXQ6Y2hlY2tlZCArIC50b2dnbGUtc2xpZGVyIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNENBRjUwO1xuICAgIGJvcmRlci1jb2xvcjogIzRDQUY1MDtcbn1cblxuLnRvZ2dsZS1zd2l0Y2ggaW5wdXQ6Y2hlY2tlZCArIC50b2dnbGUtc2xpZGVyOmJlZm9yZSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDI2cHgpO1xufVxuXG4udG9nZ2xlLXN3aXRjaCBpbnB1dDpmb2N1cyArIC50b2dnbGUtc2xpZGVyIHtcbiAgICBib3gtc2hhZG93OiAwIDAgMCAzcHggcmdiYSg3NiwgMTc1LCA4MCwgMC4yKTtcbn1cblxuLm1uZW1vbmljLWRpc3BsYXkge1xuICAgIG1hcmdpbi10b3A6IDE1cHg7XG59XG5cbi5tbmVtb25pYy1kaXNwbGF5IHRleHRhcmVhIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBtaW4taGVpZ2h0OiA4MHB4O1xuICAgIHBhZGRpbmc6IDEwcHg7XG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIGZvbnQtZmFtaWx5OiAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxLjQ7XG4gICAgcmVzaXplOiBub25lO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5tbmVtb25pYy1kaXNwbGF5IHRleHRhcmVhOmZvY3VzIHtcbiAgICBvdXRsaW5lOiBub25lO1xufVxuXG4vKioqKiogU2VuZCBzY3JlZW4gKioqKiovXG5cbi5mb3JtLWdyb3VwIHtcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xufVxuXG4uZm9ybS1ncm91cCBsYWJlbCB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbiAgICBmb250LXdlaWdodDogNjAwO1xuICAgIG1hcmdpbi1ib3R0b206IDVweDtcbiAgICB0ZXh0LXNoYWRvdzogMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4zKTtcbn1cblxuLmZvcm0tZ3JvdXAgaW5wdXQge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIHBhZGRpbmc6IDE1cHg7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBmb250LXNpemU6IDFlbTtcbiAgICBmb250LWZhbWlseTogJ0NvdXJpZXIgTmV3JywgbW9ub3NwYWNlO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG59XG5cbi5mb3JtLWdyb3VwIGlucHV0OjpwbGFjZWhvbGRlciB7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC42KTtcbn1cblxuLmZvcm0tZ3JvdXAgaW5wdXQ6Zm9jdXMge1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE1KTtcbiAgICBib3gtc2hhZG93OiAwIDAgMCAzcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xufVxuXG4uZm9ybS1ncm91cCBpbnB1dFtyZWFkb25seV0ge1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICBib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xufVxuXG4uZm9ybS1ncm91cCBpbnB1dC5pbnZhbGlkIHtcbiAgICBib3JkZXItY29sb3I6ICNmODcxNzE7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNDgsIDExMywgMTEzLCAwLjEpO1xuICAgIGJveC1zaGFkb3c6IDAgMCAwIDNweCByZ2JhKDI0OCwgMTEzLCAxMTMsIDAuMSk7XG59XG5cbi5mb3JtLWdyb3VwIGlucHV0LnZhbGlkIHtcbiAgICBib3JkZXItY29sb3I6ICM0YWRlODA7XG4gICAgYmFja2dyb3VuZDogcmdiYSg3NCwgMjIyLCAxMjgsIDAuMSk7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgM3B4IHJnYmEoNzQsIDIyMiwgMTI4LCAwLjEpO1xufVxuXG4vKiBBZGRyZXNzIGZpZWxkIHZhbGlkYXRpb24gc3R5bGVzICovXG4jcmVjaXBpZW50LWFkZHJlc3MudmFsaWQge1xuICAgIGJvcmRlci1jb2xvcjogIzRDQUY1MDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDc2LCAxNzUsIDgwLCAwLjEpO1xufVxuXG4jcmVjaXBpZW50LWFkZHJlc3MuaW52YWxpZCB7XG4gICAgYm9yZGVyLWNvbG9yOiAjZmY2YjZiO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAxMDcsIDEwNywgMC4xKTtcbn1cblxuI3JlY2lwaWVudC1hZGRyZXNzLnZhbGlkOmZvY3VzIHtcbiAgICBib3JkZXItY29sb3I6ICM0Q0FGNTA7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMnB4IHJnYmEoNzYsIDE3NSwgODAsIDAuMik7XG59XG5cbiNyZWNpcGllbnQtYWRkcmVzcy5pbnZhbGlkOmZvY3VzIHtcbiAgICBib3JkZXItY29sb3I6ICNmZjZiNmI7XG4gICAgYm94LXNoYWRvdzogMCAwIDAgMnB4IHJnYmEoMjU1LCAxMDcsIDEwNywgMC4yKTtcbn1cblxuLnNsaWRlci13cmFwcGVyIHtcbiAgICBtYXJnaW4tdG9wOiAxNXB4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuI2Ftb3VudC1zbGlkZXIge1xuICAgIGFjY2VudC1jb2xvcjogd2hpdGU7XG4gICAgcGFkZGluZzogMDtcbn1cblxuI2Ftb3VudC1zbGlkZXI6Zm9jdXMge1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG59XG5cbi8qXG4gKiBNYWtlIHRoZSBzbGlkZXIgdGh1bWIgYmlnZ2VyIGZvciB0b3VjaCBhcHBsaWNhdGlvbi5cbiAqIFRoaXMgZG9lc24ndCB3b3JrIGZvciBGaXJlZm94IChhbmQgbWF5YmUgb3RoZXJzKS5cbiAqL1xuI2Ftb3VudC1zbGlkZXI6Oi13ZWJraXQtc2xpZGVyLXRodW1iIHtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgYm94LXNoYWRvdzogMCAzcHggMTJweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgYm9yZGVyOiAxNHB4IHNvbGlkIHdoaXRlO1xufVxuXG4uc2xpZGVyLWxhYmVscyB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgZm9udC1zaXplOiAwLjg1ZW07XG4gICAgb3BhY2l0eTogMC43O1xufVxuXG4jZmVlLWRpc3BsYXkge1xuICAgIG1hcmdpbjogMTBweCAwO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4xKTtcbn1cblxuI2ZlZS1kaXNwbGF5LmVycm9yIHtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZmY2YjZiO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAxMDcsIDEwNywgMC4xKTtcbn1cblxuLmZlZS1pbmZvIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgZ2FwOiA4cHg7XG59XG5cbi5mZWUtaXRlbSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuLmZlZS1pdGVtLnRpdGxlIHtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBmb250LXNpemU6IDEuMWVtO1xufVxuXG4uZmVlLWl0ZW0udGl0bGUuZXJyb3Ige1xuICAgIGNvbG9yOiAjZmY2YjZiO1xufVxuXG4uZmVlLWl0ZW0udG90YWwge1xuICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gICAgcGFkZGluZy10b3A6IDEwcHg7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbn1cblxuLmZlZS1sYWJlbCB7XG4gICAgZm9udC1zaXplOiAwLjllbTtcbiAgICBvcGFjaXR5OiAwLjg7XG59XG5cbi5zZW5kLWFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiAxNXB4O1xuICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgcGFkZGluZzogMTVweDtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xuICAgIGZsb2F0OiBib3R0b207XG59XG5cbi8qIFN0aWNrIHRoZSBidXR0b25zIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiBpZiBpdCBmaXRzICovXG5AbWVkaWEgKGhlaWdodCA+IDY2MHB4KSB7XG4gICAgLnNlbmQtYWN0aW9ucyB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICB9XG59XG5cbi5zZW5kLWFjdGlvbnMgLmJ0biB7XG4gICAgZmxleDogMTtcbiAgICBmb250LXNpemU6IDEuMWVtO1xufVxuXG4vKioqKiogQ2FtZXJhIE1vZGFsICoqKioqL1xuXG4uY2FtZXJhLW1vZGFsIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC45KTtcbiAgICB6LWluZGV4OiAxMDAwO1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cblxuLmNhbWVyYS1tb2RhbDpub3QoLmhpZGRlbikge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYmFja2dyb3VuZDogYmxhY2s7XG59XG5cbi5jYW1lcmEtY29udGFpbmVyIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBtYXgtd2lkdGg6IDUwMHB4O1xuICAgIG1hcmdpbjogMjBweDtcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuXG4uY2FtZXJhLWhlYWRlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGVuZDtcbiAgICBwYWRkaW5nOiAyMHB4O1xuICAgIGJhY2tncm91bmQ6ICNmOGY5ZmE7XG59XG5cbi5jYW1lcmEtaGVhZGVyIGgzIHtcbiAgICBjb2xvcjogIzMzMztcbiAgICBmb250LXNpemU6IDEuMmVtO1xufVxuXG4uY2xvc2UtYnRuIHtcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBmb250LXNpemU6IDM2cHg7XG4gICAgY29sb3I6ICM2NjY7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHdpZHRoOiAzMHB4O1xuICAgIGhlaWdodDogMzBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5cbi5jbG9zZS1idG46aG92ZXIge1xuICAgIGJhY2tncm91bmQ6ICNlOWVjZWY7XG4gICAgY29sb3I6ICMzMzM7XG59XG5cbi5jYW1lcmEtY29udGVudCB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGFzcGVjdC1yYXRpbzogNCAvIDM7XG4gICAgYmFja2dyb3VuZDogYmxhY2s7XG4gICAgbWluLWhlaWdodDogMzAwcHg7XG4gICAgbWF4LWhlaWdodDogNTAwcHg7XG59XG5cbiNjYW1lcmEtdmlkZW8ge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBvYmplY3QtZml0OiBjb3Zlcjtcbn1cblxuLnNjYW4tb3ZlcmxheSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5cbi5jYW1lcmEtZm9vdGVyIHtcbiAgICBwYWRkaW5nOiAxNXB4IDIwcHg7XG4gICAgYmFja2dyb3VuZDogI2Y4ZjlmYTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cblxuLmNhbWVyYS1mb290ZXIgcCB7XG4gICAgbWFyZ2luOiAwIDAgMTVweCAwO1xuICAgIGNvbG9yOiAjMzMzO1xuICAgIGZvbnQtc2l6ZTogMC45ZW07XG59XG5cbi5tYW51YWwtZW50cnktYnRuIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZ2FwOiA4cHg7XG4gICAgcGFkZGluZzogMTBweCAyMHB4O1xuICAgIGJhY2tncm91bmQ6ICM2Yzc1N2Q7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xufVxuXG4ubWFudWFsLWVudHJ5LWJ0bjpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogIzVhNjI2ODtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTFweCk7XG59XG5cbi5tYW51YWwtZW50cnktYnRuIGltZyB7XG4gICAgd2lkdGg6IDI0cHg7XG4gICAgaGVpZ2h0OiAyNHB4O1xuICAgIGZpbHRlcjogYnJpZ2h0bmVzcygwKSBpbnZlcnQoMSk7XG59XG5cbi8qIE5vIGNhbWVyYSBmYWxsYmFjayBzdHlsZXMgKi9cbi5uby1jYW1lcmEtZmFsbGJhY2sge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgYmFja2dyb3VuZDogIzFhMWExYTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgcGFkZGluZzogNDBweCAyMHB4O1xufVxuXG4ubm8tY2FtZXJhLWZhbGxiYWNrLmhpZGRlbiB7XG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xufVxuXG4jbm8tY2FtZXJhLWljb24ge1xuICAgIHdpZHRoOiA0OHB4O1xuICAgIGhlaWdodDogNDhweDtcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xufVxuXG4ubm8tY2FtZXJhLWljb24ge1xuICAgIGZvbnQtc2l6ZTogNjRweDtcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuICAgIG9wYWNpdHk6IDAuNjtcbn1cblxuLm5vLWNhbWVyYS1mYWxsYmFjayBoMyB7XG4gICAgbWFyZ2luOiAwIDAgMTBweCAwO1xuICAgIGZvbnQtc2l6ZTogMS41ZW07XG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcbn1cblxuLm5vLWNhbWVyYS1mYWxsYmFjayBwIHtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xuICAgIG1hcmdpbjogMCAwIDMwcHggMDtcbiAgICBsaW5lLWhlaWdodDogMS41O1xufVxuXG4vKioqKiogTW5lbW9uaWMgRWRpdCBNb2RhbCAqKioqKi9cblxuLm1vZGFsLW92ZXJsYXkge1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjgpO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgei1pbmRleDogMTAwMDtcbn1cblxuLm1vZGFsLWNvbnRlbnQge1xuICAgIGJhY2tncm91bmQ6ICMxYTFhMWE7XG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICBtYXJnaW46IDE1cHg7XG4gICAgbWF4LXdpZHRoOiA2MDBweDtcbiAgICBtYXgtaGVpZ2h0OiA5MHZoO1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xufVxuXG4ubW9kYWwtaGVhZGVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcbn1cblxuLm1vZGFsLWhlYWRlciBoMyB7XG4gICAgZm9udC1zaXplOiAxLjJlbTtcbn1cblxuLm1vZGFsLWJvZHkge1xuICAgIHBhZGRpbmc6IDIwcHg7XG59XG5cbi5tb2RhbC1kZXNjcmlwdGlvbiB7XG4gICAgb3BhY2l0eTogMC44O1xuICAgIG1hcmdpbjogMCAwIDEwcHggMDtcbiAgICBmb250LXNpemU6IDAuOWVtO1xuICAgIGxpbmUtaGVpZ2h0OiAxLjQ7XG59XG5cbi5tb2RhbC13YXJuaW5nIHtcbiAgICBjb2xvcjogI2ZmOTgwMDtcbiAgICBtYXJnaW46IDAgMCAxNXB4IDA7XG4gICAgZm9udC1zaXplOiAwLjllbTtcbiAgICBsaW5lLWhlaWdodDogMS40O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IDhweDtcbn1cblxuLndhcm5pbmctaWNvbiB7XG4gICAgZm9udC1zaXplOiAxLjFlbTtcbn1cblxuLm1vZGFsLWJvZHkgdGV4dGFyZWEge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG1pbi1oZWlnaHQ6IDEyMHB4O1xuICAgIHBhZGRpbmc6IDEwcHg7XG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcbiAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBmb250LWZhbWlseTogJ0NvdXJpZXIgTmV3JywgbW9ub3NwYWNlO1xuICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICBsaW5lLWhlaWdodDogMS40O1xuICAgIHJlc2l6ZTogdmVydGljYWw7XG59XG5cbi5tb2RhbC1ib2R5IHRleHRhcmVhOmZvY3VzIHtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xufVxuXG4ubW5lbW9uaWMtZWRpdC1tb2RhbCB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOSk7XG4gICAgei1pbmRleDogMTAwMDtcbiAgICBkaXNwbGF5OiBub25lO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG59XG5cbi52YWxpZGF0aW9uLW1lc3NhZ2Uge1xuICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgcGFkZGluZzogMTBweDtcbiAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgIGZvbnQtc2l6ZTogMC45ZW07XG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcbn1cblxuLnZhbGlkYXRpb24tbWVzc2FnZS5lcnJvciB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNDQsIDY3LCA1NCwgMC4yKTtcbiAgICBjb2xvcjogI2Y0NDMzNjtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI0NCwgNjcsIDU0LCAwLjMpO1xufVxuXG4udmFsaWRhdGlvbi1tZXNzYWdlLnN1Y2Nlc3Mge1xuICAgIGJhY2tncm91bmQ6IHJnYmEoNzYsIDE3NSwgODAsIDAuMik7XG4gICAgY29sb3I6ICM0Q0FGNTA7XG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSg3NiwgMTc1LCA4MCwgMC4zKTtcbn1cblxuLm1vZGFsLWFjdGlvbnMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiA4cHg7XG4gICAgcGFkZGluZzogMjBweDtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xufVxuXG4ubW9kYWwtYWN0aW9ucyAuYnRuIHtcbiAgICBmbGV4OiAxO1xufVxuXG4vKioqKiogRXJyb3IgTW9kYWwgKioqKiovXG5cbi5lcnJvci1tb2RhbC1vdmVybGF5IHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC45KTtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHotaW5kZXg6IDEwMDAwO1xufVxuXG4uZXJyb3ItbW9kYWwtY29udGVudCB7XG4gICAgYmFja2dyb3VuZDogIzFhMWExYTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICBwYWRkaW5nOiAyMHB4O1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgbWFyZ2luOiAxNXB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuLmVycm9yLW1vZGFsLXRpdGxlIHtcbiAgICBtYXJnaW46IDAgMCAxNXB4IDA7XG4gICAgY29sb3I6ICNmZjZiNmI7XG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG59XG5cbi5lcnJvci1tb2RhbC1tZXNzYWdlIHtcbiAgICBtYXJnaW46IDAgMCAyMHB4IDA7XG4gICAgb3BhY2l0eTogMC45O1xuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XG59XG5cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL21haW4uY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLG9CQUFvQjs7QUFFcEI7SUFDSSxTQUFTO0lBQ1QsVUFBVTtJQUNWLHNCQUFzQjtBQUMxQjs7QUFFQTtJQUNJLDhFQUE4RTtJQUM5RSx1QkFBdUI7SUFDdkIsWUFBWTtJQUNaLGlC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WTtJQUNaLGtCQUFrQjtBQUN0Qjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixjQUFjO0lBQ2QsZUFBZTtJQUNmLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixZQUFZO0lBQ1osZ0JBQWdCO0FBQ3BCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qKioqKiBHZW5lcmFsICoqKioqL1xcblxcbioge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbmJvZHkge1xcbiAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sIHNhbnMtc2VyaWY7XFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbn1cXG5cXG4uY29udGFpbmVyIHtcXG4gICAgcGFkZGluZzogMCAxNXB4IDBweCAxNXB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cXG4uc2NyZWVuIHtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB6LWluZGV4OiAxMDAwO1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cXG4uc2NyZWVuOm5vdCguaGlkZGVuKSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbi5zY3JlZW4taGVhZGVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZzogMTBweCAyMHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KTtcXG59XFxuXFxuLnNjcmVlbi1oZWFkZXIgaDIge1xcbiAgICBmb250LXNpemU6IDEuM2VtO1xcbiAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICBtYXJnaW4tbGVmdDogMjBweDtcXG59XFxuXFxuQG1lZGlhICh3aWR0aCA+IDM0MHB4KSB7XFxuICAgIC5zY3JlZW4taGVhZGVyIGgyIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMS41ZW07XFxuICAgIH1cXG59XFxuXFxuLmFjdGlvbnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgbWFyZ2luLXRvcDogMjBweDtcXG59XFxuXFxuLmJ0biB7XFxuICAgIHBhZGRpbmc6IDE1cHggMjBweDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xcbiAgICBmb250LXNpemU6IDFlbTtcXG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgICBsZXR0ZXItc3BhY2luZzogMC41cHg7XFxufVxcblxcbi5idG46ZGlzYWJsZWQge1xcbiAgICBvcGFjaXR5OiAwLjY7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICAgIHRyYW5zZm9ybTogbm9uZTtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5idG4tcHJpbWFyeSB7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg0NWRlZywgIzRDQUY1MCwgIzQ1YTA0OSk7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgYm94LXNoYWRvdzogMCA0cHggMTVweCByZ2JhKDc2LCAxNzUsIDgwLCAwLjMpO1xcbn1cXG5cXG4uYnRuLXNlY29uZGFyeSB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gICAgY29sb3I6IHdoaXRlO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxufVxcblxcbi5idG46aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTJweCk7XFxuICAgIGJveC1zaGFkb3c6IDAgNnB4IDIwcHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbn1cXG5cXG4uYnRuOmFjdGl2ZSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG59XFxuXFxuLyogSG9sZC10by1zZW5kIGJ1dHRvbiBhbmltYXRpb24gKi9cXG4uYnRuLXByaW1hcnkuaG9sZGluZyB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLmJ0bi1wcmltYXJ5LmhvbGRpbmc6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB3aWR0aDogMCU7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpIDAlLCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNykgMTAwJSk7XFxuICAgIGFuaW1hdGlvbjogaG9sZFByb2dyZXNzIDFzIGxpbmVhciBmb3J3YXJkcztcXG4gICAgei1pbmRleDogMDtcXG4gICAgYm94LXNoYWRvdzogMnB4IDAgMTBweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxufVxcblxcbi5idG4tcHJpbWFyeS5ob2xkaW5nIHNwYW4ge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHotaW5kZXg6IDE7XFxuICAgIHRleHQtc2hhZG93OiAwIDFweCAzcHggcmdiYSgwLCAwLCAwLCAwLjUpO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIGhvbGRQcm9ncmVzcyB7XFxuICAgIGZyb20ge1xcbiAgICAgICAgd2lkdGg6IDAlO1xcbiAgICB9XFxuICAgIHRvIHtcXG4gICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICB9XFxufVxcblxcbi5oaWRkZW4ge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4uYmFjay1hcnJvdy1pY29uIHtcXG4gICAgd2lkdGg6IDI0cHg7XFxuICAgIGhlaWdodDogMjRweDtcXG59XFxuXFxuLmJhY2stYnRuIHtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDE1cHg7XFxufVxcblxcbi5iYWNrLWJ0bjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbn1cXG5cXG4ubG9hZGluZyB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2lkdGg6IDIwcHg7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgYm9yZGVyOiAzcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwuMyk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogI2ZmZjtcXG4gICAgYW5pbWF0aW9uOiBzcGluIDFzIGVhc2UtaW4tb3V0IGluZmluaXRlO1xcbn1cXG5cXG4ubG9hZGluZy1zY3JlZW4ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAxKTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHotaW5kZXg6IDEwMDAwO1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgc2Fucy1zZXJpZjtcXG59XFxuXFxuLmxvYWRpbmctY29udGVudCB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLmxvYWRpbmctc3Bpbm5lciB7XFxuICAgIHdpZHRoOiA2MHB4O1xcbiAgICBoZWlnaHQ6IDYwcHg7XFxuICAgIGJvcmRlcjogNHB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICBib3JkZXItdG9wLWNvbG9yOiAjZmZmO1xcbiAgICBhbmltYXRpb246IHNwaW4gMXMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XFxuICAgIG1hcmdpbjogMCBhdXRvIDIwcHg7XFxufVxcblxcbi5sb2FkaW5nLXRleHQge1xcbiAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxufVxcblxcbkBrZXlmcmFtZXMgc3BpbiB7XFxuICAgIHRvIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxcbn1cXG5cXG4ud2FsbGV0LWluZm8ge1xcbiAgICBtYXJnaW46IDIwcHggMDtcXG4gICAgcGFkZGluZzogMjBweDtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbn1cXG5cXG4uaW5mby1pdGVtIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBwYWRkaW5nOiA4cHggMDtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcXG59XFxuXFxuLmluZm8taXRlbTpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLWJvdHRvbTogbm9uZTtcXG59XFxuXFxuLmluZm8tbGFiZWwge1xcbiAgICBvcGFjaXR5OiAwLjg7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxufVxcblxcbi5pbmZvLXZhbHVlIHtcXG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgZm9udC1mYW1pbHk6ICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG59XFxuXFxuLyoqKioqIEhFQURFUiAqKioqKi9cXG5cXG4uaGVhZGVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBwYWRkaW5nOiAxMHB4IDE1cHg7XFxufVxcblxcbi50aXRsZSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbiNlY2FzaC1sb2dvIHtcXG4gICAgd2lkdGg6IDM1cHg7XFxuICAgIGhlaWdodDogMzVweDtcXG59XFxuXFxuLnRpdGxlIGgxIHtcXG4gICAgZm9udC1zaXplOiAxLjZlbTtcXG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gICAgdGV4dC1zaGFkb3c6IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMyk7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBlbmQ7XFxuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xcbn1cXG5cXG4uaGVhZGVyLWJ1dHRvbnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbn1cXG5cXG4uaGlzdG9yeS1idXR0b24sIC5zZXR0aW5ncy1idXR0b24ge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIHdpZHRoOiAzNnB4O1xcbiAgICBoZWlnaHQ6IDM2cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiByaWdodDtcXG59XFxuXFxuLyoqKioqIFdhbGxldCBjYXJkICoqKioqL1xcblxcbi5jYXJkIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMTBweCk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICAgIHBhZGRpbmc6IDE1cHg7XFxuICAgIGJveC1zaGFkb3c6IDAgOHB4IDMycHggcmdiYSgwLCAwLCAwLCAwLjEpO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLmJhbGFuY2UtY29udGFpbmVyIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogMzBweDsgLyogUmVzZXJ2ZSBzcGFjZSBmb3IgdHJhbnNpdGlvbmFsIGJhbGFuY2UgKi9cXG59XFxuXFxuLmNhcmQtbGFiZWwge1xcbiAgICBvcGFjaXR5OiAwLjg7XFxuICAgIGZvbnQtc2l6ZTogMS4yZW07XFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxufVxcblxcbi5iYWxhbmNlIHtcXG4gICAgZm9udC1zaXplOiAzZW07XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICB0ZXh0LXNoYWRvdzogMCAycHggNHB4IHJnYmEoMCwwLDAsMC4zKTtcXG59XFxuXFxuLnRyYW5zaXRpb25hbC1iYWxhbmNlIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDEwMCU7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xcbiAgICBmb250LXNpemU6IDEuMmVtO1xcbiAgICBmb250LXdlaWdodDogNjAwO1xcbiAgICBtYXJnaW4tdG9wOiAtMzBweDtcXG59XFxuXFxuLnRyYW5zaXRpb25hbC1iYWxhbmNlLnJlY2VpdmUge1xcbiAgICBjb2xvcjogIzRhZGU4MDtcXG59XFxuXFxuLnRyYW5zaXRpb25hbC1iYWxhbmNlLnNwZW5kIHtcXG4gICAgY29sb3I6ICNmODcxNzE7XFxufVxcblxcbi50cmFuc2l0aW9uYWwtYmFsYW5jZS5zaGFrZSB7XFxuICAgIGFuaW1hdGlvbjogc2hha2UgMC41cyBlYXNlLWluLW91dDtcXG59XFxuXFxuQGtleWZyYW1lcyBzaGFrZSB7XFxuICAgIDAlLCAxMDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVgoMCk7IH1cXG4gICAgMTAlLCAzMCUsIDUwJSwgNzAlLCA5MCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWCgtMnB4KTsgfVxcbiAgICAyMCUsIDQwJSwgNjAlLCA4MCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWCgycHgpOyB9XFxufVxcblxcbi5hZGRyZXNzLWxhYmVsIHtcXG4gICAgZm9udC1zaXplOiAxLjJlbTtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTBweDtcXG4gICAgb3BhY2l0eTogMC45O1xcbn1cXG5cXG4uYWRkcmVzcyB7XFxuICAgIGZvbnQtZmFtaWx5OiAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XFxuICAgIGZvbnQtc2l6ZTogMC45ZW07XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG4gICAgcGFkZGluZzogMTVweDtcXG4gICAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gICAgd29yZC1icmVhazogYnJlYWstYWxsO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjQ7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG59XFxuXFxuLmFkZHJlc3M6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMyk7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTFweCk7XFxufVxcblxcbi5hZGRyZXNzOmFjdGl2ZSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcXG59XFxuXFxuLnFyLWNvZGUge1xcbiAgICBtYXJnaW4tdG9wOiAyMHB4O1xcbn1cXG5cXG4ucXItY29kZSBjYW52YXMge1xcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgICBib3gtc2hhZG93OiAwIDRweCAxNXB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG59XFxuXFxuLyoqKioqIFNjYW4gYnV0dG9uICoqKioqL1xcblxcbi5zY2FuLXNlY3Rpb24ge1xcbiAgICBtYXJnaW46IDEwcHggMDs7XFxufVxcblxcbi5zY2FuLWJ0biB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgd2lkdGg6IDEwMHB4O1xcbiAgICBoZWlnaHQ6IDEwMHB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAgIG1hcmdpbjogMCBhdXRvO1xcbn1cXG5cXG4uc2Nhbi1idG46aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjYpO1xcbn1cXG5cXG4uc2Nhbi1idG46YWN0aXZlIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk1KTtcXG59XFxuXFxuLnNjYW4tYnRuIGltZyB7XFxuICAgIHdpZHRoOiA0OHB4O1xcbiAgICBoZWlnaHQ6IDQ4cHg7XFxufVxcblxcbi8qKioqKiBIaXN0b3J5IHNjcmVlbiAqKioqKi9cXG5cXG4udHJhbnNhY3Rpb24tbGlzdCB7XFxuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwdmggLSAxMDBweCk7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIC8qIEhpZGUgc2Nyb2xsYmFyIGNvbXBsZXRlbHkgKi9cXG4gICAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xcbiAgICBmbGV4OiAxO1xcbn1cXG5cXG4vKiBIaWRlIHNjcm9sbGJhciBmb3Igd2Via2l0IGJyb3dzZXJzICovXFxuLnRyYW5zYWN0aW9uLWxpc3Q6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuLnRyYW5zYWN0aW9uLWl0ZW0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nOiAxNXB4IDA7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XFxuICAgIHdvcmQtYnJlYWs6IGJyZWFrLWFsbDtcXG59XFxuXFxuLnRyYW5zYWN0aW9uLWl0ZW06bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1ib3R0b206IG5vbmU7XFxufVxcblxcbi50cmFuc2FjdGlvbi1pbmZvIHtcXG4gICAgZmxleDogMTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgZ2FwOiA1cHg7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIGZvbnQtc2l6ZTogMC45ZW07XFxufVxcblxcbi50cmFuc2FjdGlvbi10eGlkIHtcXG4gICAgZm9udC1mYW1pbHk6ICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgdGV4dC1kZWNvcmF0aW9uLXN0eWxlOiBkb3R0ZWQ7XFxuICAgIG9wYWNpdHk6IDAuOTtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2U7XFxufVxcblxcbi50cmFuc2FjdGlvbi10eGlkOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdGV4dC1kZWNvcmF0aW9uLXN0eWxlOiBzb2xpZDtcXG59XFxuXFxuLnRyYW5zYWN0aW9uLWFtb3VudCB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmb250LXNpemU6IDEuMWVtO1xcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcXG4gICAgdGV4dC1zaGFkb3c6IDAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMyk7XFxufVxcblxcbi50cmFuc2FjdGlvbi1hbW91bnQucmVjZWl2ZWQge1xcbiAgICBjb2xvcjogIzRhZGU4MDtcXG59XFxuXFxuLnRyYW5zYWN0aW9uLWFtb3VudC5zZW50IHtcXG4gICAgY29sb3I6ICNmODcxNzE7XFxufVxcblxcbi5sb2FkaW5nLXRyYW5zYWN0aW9ucyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgcGFkZGluZzogNDBweCAyMHB4O1xcbiAgICBvcGFjaXR5OiAwLjg7XFxufVxcblxcbi5sb2FkaW5nLXRyYW5zYWN0aW9ucyAubG9hZGluZy1zcGlubmVyIHtcXG4gICAgd2lkdGg6IDQwcHg7XFxuICAgIGhlaWdodDogNDBweDtcXG4gICAgYm9yZGVyOiAzcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIGJvcmRlci10b3AtY29sb3I6ICNmZmY7XFxuICAgIGFuaW1hdGlvbjogc3BpbiAxcyBlYXNlLWluLW91dCBpbmZpbml0ZTtcXG4gICAgbWFyZ2luOiAwIGF1dG8gMTVweDtcXG59XFxuXFxuLm5vLXRyYW5zYWN0aW9ucyB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgcGFkZGluZzogNDBweCAyMHB4O1xcbiAgICBvcGFjaXR5OiAwLjg7XFxufVxcblxcbi5uby10cmFuc2FjdGlvbnMgaDMge1xcbiAgICBtYXJnaW46IDAgMCAxMHB4IDA7XFxufVxcblxcbi5sb2FkaW5nLW1vcmUge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHBhZGRpbmc6IDIwcHg7XFxuICAgIG9wYWNpdHk6IDAuNjtcXG59XFxuXFxuLmxvYWRpbmctbW9yZSAubG9hZGluZy1zcGlubmVyIHtcXG4gICAgd2lkdGg6IDIwcHg7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgbWFyZ2luOiAwIGF1dG8gMTBweDtcXG59XFxuXFxuLyoqKioqIFNldHRpbmdzIHNjcmVlbiAqKioqKi9cXG5cXG4uc2V0dGluZy1pdGVtIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBwYWRkaW5nOiAxNXB4IDA7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XFxufVxcblxcbi5zZXR0aW5nLWl0ZW06bGFzdC1jaGlsZCB7XFxuICAgIGJvcmRlci1ib3R0b206IG5vbmU7XFxufVxcblxcbi5zZXR0aW5nLWluZm8ge1xcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxufVxcblxcbi5zZXR0aW5nLWluZm8gaDMge1xcbiAgICBtYXJnaW4tYm90dG9tOiA1cHg7XFxuICAgIGZvbnQtc2l6ZTogMS4xZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxufVxcblxcbi5zZXR0aW5nLWluZm8gcCB7XFxuICAgIGZvbnQtc2l6ZTogMC45ZW07XFxuICAgIG9wYWNpdHk6IDAuODtcXG59XFxuXFxuLyogVG9nZ2xlIFN3aXRjaCAqL1xcbi50b2dnbGUtc3dpdGNoIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHdpZHRoOiA1NnB4O1xcbiAgICBoZWlnaHQ6IDMwcHg7XFxuICAgIGZsZXgtc2hyaW5rOiAwO1xcbn1cXG5cXG4udG9nZ2xlLXN3aXRjaCBpbnB1dCB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxufVxcblxcbi50b2dnbGUtc2xpZGVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAgIGJvcmRlci1yYWRpdXM6IDMwcHg7XFxufVxcblxcbi50b2dnbGUtc2xpZGVyOmJlZm9yZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGhlaWdodDogMjJweDtcXG4gICAgd2lkdGg6IDIycHg7XFxuICAgIGxlZnQ6IDJweDtcXG4gICAgYm90dG9tOiAycHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxufVxcblxcbi50b2dnbGUtc3dpdGNoIGlucHV0OmNoZWNrZWQgKyAudG9nZ2xlLXNsaWRlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICM0Q0FGNTA7XFxuICAgIGJvcmRlci1jb2xvcjogIzRDQUY1MDtcXG59XFxuXFxuLnRvZ2dsZS1zd2l0Y2ggaW5wdXQ6Y2hlY2tlZCArIC50b2dnbGUtc2xpZGVyOmJlZm9yZSB7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyNnB4KTtcXG59XFxuXFxuLnRvZ2dsZS1zd2l0Y2ggaW5wdXQ6Zm9jdXMgKyAudG9nZ2xlLXNsaWRlciB7XFxuICAgIGJveC1zaGFkb3c6IDAgMCAwIDNweCByZ2JhKDc2LCAxNzUsIDgwLCAwLjIpO1xcbn1cXG5cXG4ubW5lbW9uaWMtZGlzcGxheSB7XFxuICAgIG1hcmdpbi10b3A6IDE1cHg7XFxufVxcblxcbi5tbmVtb25pYy1kaXNwbGF5IHRleHRhcmVhIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1pbi1oZWlnaHQ6IDgwcHg7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4zKTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgZm9udC1mYW1pbHk6ICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBsaW5lLWhlaWdodDogMS40O1xcbiAgICByZXNpemU6IG5vbmU7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5tbmVtb25pYy1kaXNwbGF5IHRleHRhcmVhOmZvY3VzIHtcXG4gICAgb3V0bGluZTogbm9uZTtcXG59XFxuXFxuLyoqKioqIFNlbmQgc2NyZWVuICoqKioqL1xcblxcbi5mb3JtLWdyb3VwIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG59XFxuXFxuLmZvcm0tZ3JvdXAgbGFiZWwge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgZm9udC1zaXplOiAxLjFlbTtcXG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogNXB4O1xcbiAgICB0ZXh0LXNoYWRvdzogMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4zKTtcXG59XFxuXFxuLmZvcm0tZ3JvdXAgaW5wdXQge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgcGFkZGluZzogMTVweDtcXG4gICAgYm9yZGVyOiAycHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgZm9udC1zaXplOiAxZW07XFxuICAgIGZvbnQtZmFtaWx5OiAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxufVxcblxcbi5mb3JtLWdyb3VwIGlucHV0OjpwbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNik7XFxufVxcblxcbi5mb3JtLWdyb3VwIGlucHV0OmZvY3VzIHtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNSk7XFxuICAgIGJveC1zaGFkb3c6IDAgMCAwIDNweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XFxufVxcblxcbi5mb3JtLWdyb3VwIGlucHV0W3JlYWRvbmx5XSB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4yKTtcXG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxufVxcblxcbi5mb3JtLWdyb3VwIGlucHV0LmludmFsaWQge1xcbiAgICBib3JkZXItY29sb3I6ICNmODcxNzE7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjQ4LCAxMTMsIDExMywgMC4xKTtcXG4gICAgYm94LXNoYWRvdzogMCAwIDAgM3B4IHJnYmEoMjQ4LCAxMTMsIDExMywgMC4xKTtcXG59XFxuXFxuLmZvcm0tZ3JvdXAgaW5wdXQudmFsaWQge1xcbiAgICBib3JkZXItY29sb3I6ICM0YWRlODA7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoNzQsIDIyMiwgMTI4LCAwLjEpO1xcbiAgICBib3gtc2hhZG93OiAwIDAgMCAzcHggcmdiYSg3NCwgMjIyLCAxMjgsIDAuMSk7XFxufVxcblxcbi8qIEFkZHJlc3MgZmllbGQgdmFsaWRhdGlvbiBzdHlsZXMgKi9cXG4jcmVjaXBpZW50LWFkZHJlc3MudmFsaWQge1xcbiAgICBib3JkZXItY29sb3I6ICM0Q0FGNTA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNzYsIDE3NSwgODAsIDAuMSk7XFxufVxcblxcbiNyZWNpcGllbnQtYWRkcmVzcy5pbnZhbGlkIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZmY2YjZiO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMTA3LCAxMDcsIDAuMSk7XFxufVxcblxcbiNyZWNpcGllbnQtYWRkcmVzcy52YWxpZDpmb2N1cyB7XFxuICAgIGJvcmRlci1jb2xvcjogIzRDQUY1MDtcXG4gICAgYm94LXNoYWRvdzogMCAwIDAgMnB4IHJnYmEoNzYsIDE3NSwgODAsIDAuMik7XFxufVxcblxcbiNyZWNpcGllbnQtYWRkcmVzcy5pbnZhbGlkOmZvY3VzIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjZmY2YjZiO1xcbiAgICBib3gtc2hhZG93OiAwIDAgMCAycHggcmdiYSgyNTUsIDEwNywgMTA3LCAwLjIpO1xcbn1cXG5cXG4uc2xpZGVyLXdyYXBwZXIge1xcbiAgICBtYXJnaW4tdG9wOiAxNXB4O1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbiNhbW91bnQtc2xpZGVyIHtcXG4gICAgYWNjZW50LWNvbG9yOiB3aGl0ZTtcXG4gICAgcGFkZGluZzogMDtcXG59XFxuXFxuI2Ftb3VudC1zbGlkZXI6Zm9jdXMge1xcbiAgICBib3gtc2hhZG93OiBub25lO1xcbn1cXG5cXG4vKlxcbiAqIE1ha2UgdGhlIHNsaWRlciB0aHVtYiBiaWdnZXIgZm9yIHRvdWNoIGFwcGxpY2F0aW9uLlxcbiAqIFRoaXMgZG9lc24ndCB3b3JrIGZvciBGaXJlZm94IChhbmQgbWF5YmUgb3RoZXJzKS5cXG4gKi9cXG4jYW1vdW50LXNsaWRlcjo6LXdlYmtpdC1zbGlkZXItdGh1bWIge1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgIGJveC1zaGFkb3c6IDAgM3B4IDEycHggcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgICBib3JkZXI6IDE0cHggc29saWQgd2hpdGU7XFxufVxcblxcbi5zbGlkZXItbGFiZWxzIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgICBmb250LXNpemU6IDAuODVlbTtcXG4gICAgb3BhY2l0eTogMC43O1xcbn1cXG5cXG4jZmVlLWRpc3BsYXkge1xcbiAgICBtYXJnaW46IDEwcHggMDtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjEpO1xcbn1cXG5cXG4jZmVlLWRpc3BsYXkuZXJyb3Ige1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZmY2YjZiO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMTA3LCAxMDcsIDAuMSk7XFxufVxcblxcbi5mZWUtaW5mbyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGdhcDogOHB4O1xcbn1cXG5cXG4uZmVlLWl0ZW0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5mZWUtaXRlbS50aXRsZSB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmb250LXNpemU6IDEuMWVtO1xcbn1cXG5cXG4uZmVlLWl0ZW0udGl0bGUuZXJyb3Ige1xcbiAgICBjb2xvcjogI2ZmNmI2YjtcXG59XFxuXFxuLmZlZS1pdGVtLnRvdGFsIHtcXG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gICAgcGFkZGluZy10b3A6IDEwcHg7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmb250LXNpemU6IDEuMWVtO1xcbn1cXG5cXG4uZmVlLWxhYmVsIHtcXG4gICAgZm9udC1zaXplOiAwLjllbTtcXG4gICAgb3BhY2l0eTogMC44O1xcbn1cXG5cXG4uc2VuZC1hY3Rpb25zIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZ2FwOiAxNXB4O1xcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICBwYWRkaW5nOiAxNXB4O1xcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xcbiAgICBmbG9hdDogYm90dG9tO1xcbn1cXG5cXG4vKiBTdGljayB0aGUgYnV0dG9ucyB0byB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gaWYgaXQgZml0cyAqL1xcbkBtZWRpYSAoaGVpZ2h0ID4gNjYwcHgpIHtcXG4gICAgLnNlbmQtYWN0aW9ucyB7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICBib3R0b206IDA7XFxuICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgIH1cXG59XFxuXFxuLnNlbmQtYWN0aW9ucyAuYnRuIHtcXG4gICAgZmxleDogMTtcXG4gICAgZm9udC1zaXplOiAxLjFlbTtcXG59XFxuXFxuLyoqKioqIENhbWVyYSBNb2RhbCAqKioqKi9cXG5cXG4uY2FtZXJhLW1vZGFsIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC45KTtcXG4gICAgei1pbmRleDogMTAwMDtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5jYW1lcmEtbW9kYWw6bm90KC5oaWRkZW4pIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYmFja2dyb3VuZDogYmxhY2s7XFxufVxcblxcbi5jYW1lcmEtY29udGFpbmVyIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1heC13aWR0aDogNTAwcHg7XFxuICAgIG1hcmdpbjogMjBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLmNhbWVyYS1oZWFkZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGFsaWduLWl0ZW1zOiBlbmQ7XFxuICAgIHBhZGRpbmc6IDIwcHg7XFxuICAgIGJhY2tncm91bmQ6ICNmOGY5ZmE7XFxufVxcblxcbi5jYW1lcmEtaGVhZGVyIGgzIHtcXG4gICAgY29sb3I6ICMzMzM7XFxuICAgIGZvbnQtc2l6ZTogMS4yZW07XFxufVxcblxcbi5jbG9zZS1idG4ge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGZvbnQtc2l6ZTogMzZweDtcXG4gICAgY29sb3I6ICM2NjY7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgd2lkdGg6IDMwcHg7XFxuICAgIGhlaWdodDogMzBweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5jbG9zZS1idG46aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjZTllY2VmO1xcbiAgICBjb2xvcjogIzMzMztcXG59XFxuXFxuLmNhbWVyYS1jb250ZW50IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgYXNwZWN0LXJhdGlvOiA0IC8gMztcXG4gICAgYmFja2dyb3VuZDogYmxhY2s7XFxuICAgIG1pbi1oZWlnaHQ6IDMwMHB4O1xcbiAgICBtYXgtaGVpZ2h0OiA1MDBweDtcXG59XFxuXFxuI2NhbWVyYS12aWRlbyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG9iamVjdC1maXQ6IGNvdmVyO1xcbn1cXG5cXG4uc2Nhbi1vdmVybGF5IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4uY2FtZXJhLWZvb3RlciB7XFxuICAgIHBhZGRpbmc6IDE1cHggMjBweDtcXG4gICAgYmFja2dyb3VuZDogI2Y4ZjlmYTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmNhbWVyYS1mb290ZXIgcCB7XFxuICAgIG1hcmdpbjogMCAwIDE1cHggMDtcXG4gICAgY29sb3I6ICMzMzM7XFxuICAgIGZvbnQtc2l6ZTogMC45ZW07XFxufVxcblxcbi5tYW51YWwtZW50cnktYnRuIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGdhcDogOHB4O1xcbiAgICBwYWRkaW5nOiAxMHB4IDIwcHg7XFxuICAgIGJhY2tncm91bmQ6ICM2Yzc1N2Q7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbn1cXG5cXG4ubWFudWFsLWVudHJ5LWJ0bjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQ6ICM1YTYyNjg7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMXB4KTtcXG59XFxuXFxuLm1hbnVhbC1lbnRyeS1idG4gaW1nIHtcXG4gICAgd2lkdGg6IDI0cHg7XFxuICAgIGhlaWdodDogMjRweDtcXG4gICAgZmlsdGVyOiBicmlnaHRuZXNzKDApIGludmVydCgxKTtcXG59XFxuXFxuLyogTm8gY2FtZXJhIGZhbGxiYWNrIHN0eWxlcyAqL1xcbi5uby1jYW1lcmEtZmFsbGJhY2sge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgYmFja2dyb3VuZDogIzFhMWExYTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgcGFkZGluZzogNDBweCAyMHB4O1xcbn1cXG5cXG4ubm8tY2FtZXJhLWZhbGxiYWNrLmhpZGRlbiB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxuI25vLWNhbWVyYS1pY29uIHtcXG4gICAgd2lkdGg6IDQ4cHg7XFxuICAgIGhlaWdodDogNDhweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG59XFxuXFxuLm5vLWNhbWVyYS1pY29uIHtcXG4gICAgZm9udC1zaXplOiA2NHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xcbiAgICBvcGFjaXR5OiAwLjY7XFxufVxcblxcbi5uby1jYW1lcmEtZmFsbGJhY2sgaDMge1xcbiAgICBtYXJnaW46IDAgMCAxMHB4IDA7XFxuICAgIGZvbnQtc2l6ZTogMS41ZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxufVxcblxcbi5uby1jYW1lcmEtZmFsbGJhY2sgcCB7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyk7XFxuICAgIG1hcmdpbjogMCAwIDMwcHggMDtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNTtcXG59XFxuXFxuLyoqKioqIE1uZW1vbmljIEVkaXQgTW9kYWwgKioqKiovXFxuXFxuLm1vZGFsLW92ZXJsYXkge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjgpO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgei1pbmRleDogMTAwMDtcXG59XFxuXFxuLm1vZGFsLWNvbnRlbnQge1xcbiAgICBiYWNrZ3JvdW5kOiAjMWExYTFhO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xcbiAgICBtYXJnaW46IDE1cHg7XFxuICAgIG1heC13aWR0aDogNjAwcHg7XFxuICAgIG1heC1oZWlnaHQ6IDkwdmg7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG59XFxuXFxuLm1vZGFsLWhlYWRlciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZzogMjBweDtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcXG59XFxuXFxuLm1vZGFsLWhlYWRlciBoMyB7XFxuICAgIGZvbnQtc2l6ZTogMS4yZW07XFxufVxcblxcbi5tb2RhbC1ib2R5IHtcXG4gICAgcGFkZGluZzogMjBweDtcXG59XFxuXFxuLm1vZGFsLWRlc2NyaXB0aW9uIHtcXG4gICAgb3BhY2l0eTogMC44O1xcbiAgICBtYXJnaW46IDAgMCAxMHB4IDA7XFxuICAgIGZvbnQtc2l6ZTogMC45ZW07XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjQ7XFxufVxcblxcbi5tb2RhbC13YXJuaW5nIHtcXG4gICAgY29sb3I6ICNmZjk4MDA7XFxuICAgIG1hcmdpbjogMCAwIDE1cHggMDtcXG4gICAgZm9udC1zaXplOiAwLjllbTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZ2FwOiA4cHg7XFxufVxcblxcbi53YXJuaW5nLWljb24ge1xcbiAgICBmb250LXNpemU6IDEuMWVtO1xcbn1cXG5cXG4ubW9kYWwtYm9keSB0ZXh0YXJlYSB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtaW4taGVpZ2h0OiAxMjBweDtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjMpO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgZm9udC1mYW1pbHk6ICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBsaW5lLWhlaWdodDogMS40O1xcbiAgICByZXNpemU6IHZlcnRpY2FsO1xcbn1cXG5cXG4ubW9kYWwtYm9keSB0ZXh0YXJlYTpmb2N1cyB7XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpO1xcbn1cXG5cXG4ubW5lbW9uaWMtZWRpdC1tb2RhbCB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOSk7XFxuICAgIHotaW5kZXg6IDEwMDA7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4udmFsaWRhdGlvbi1tZXNzYWdlIHtcXG4gICAgbWFyZ2luLXRvcDogMTBweDtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcXG4gICAgZm9udC1zaXplOiAwLjllbTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXG59XFxuXFxuLnZhbGlkYXRpb24tbWVzc2FnZS5lcnJvciB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjQ0LCA2NywgNTQsIDAuMik7XFxuICAgIGNvbG9yOiAjZjQ0MzM2O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI0NCwgNjcsIDU0LCAwLjMpO1xcbn1cXG5cXG4udmFsaWRhdGlvbi1tZXNzYWdlLnN1Y2Nlc3Mge1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDc2LCAxNzUsIDgwLCAwLjIpO1xcbiAgICBjb2xvcjogIzRDQUY1MDtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSg3NiwgMTc1LCA4MCwgMC4zKTtcXG59XFxuXFxuLm1vZGFsLWFjdGlvbnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBnYXA6IDhweDtcXG4gICAgcGFkZGluZzogMjBweDtcXG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcXG59XFxuXFxuLm1vZGFsLWFjdGlvbnMgLmJ0biB7XFxuICAgIGZsZXg6IDE7XFxufVxcblxcbi8qKioqKiBFcnJvciBNb2RhbCAqKioqKi9cXG5cXG4uZXJyb3ItbW9kYWwtb3ZlcmxheSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOSk7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICB6LWluZGV4OiAxMDAwMDtcXG59XFxuXFxuLmVycm9yLW1vZGFsLWNvbnRlbnQge1xcbiAgICBiYWNrZ3JvdW5kOiAjMWExYTFhO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7XFxuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XFxuICAgIHBhZGRpbmc6IDIwcHg7XFxuICAgIG1heC13aWR0aDogNDAwcHg7XFxuICAgIG1hcmdpbjogMTVweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uZXJyb3ItbW9kYWwtdGl0bGUge1xcbiAgICBtYXJnaW46IDAgMCAxNXB4IDA7XFxuICAgIGNvbG9yOiAjZmY2YjZiO1xcbiAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxufVxcblxcbi5lcnJvci1tb2RhbC1tZXNzYWdlIHtcXG4gICAgbWFyZ2luOiAwIDAgMjBweCAwO1xcbiAgICBvcGFjaXR5OiAwLjk7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxufVxcblxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7568\n\n}")},7583:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{\nconst canPromise = __webpack_require__(1333)\n\nconst QRCode = __webpack_require__(157)\nconst CanvasRenderer = __webpack_require__(7899)\nconst SvgRenderer = __webpack_require__(6756)\n\nfunction renderCanvas (renderFunc, canvas, text, opts, cb) {\n  const args = [].slice.call(arguments, 1)\n  const argsNum = args.length\n  const isLastArgCb = typeof args[argsNum - 1] === 'function'\n\n  if (!isLastArgCb && !canPromise()) {\n    throw new Error('Callback required as last argument')\n  }\n\n  if (isLastArgCb) {\n    if (argsNum < 2) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 2) {\n      cb = text\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 3) {\n      if (canvas.getContext && typeof cb === 'undefined') {\n        cb = opts\n        opts = undefined\n      } else {\n        cb = opts\n        opts = text\n        text = canvas\n        canvas = undefined\n      }\n    }\n  } else {\n    if (argsNum < 1) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 1) {\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 2 && !canvas.getContext) {\n      opts = text\n      text = canvas\n      canvas = undefined\n    }\n\n    return new Promise(function (resolve, reject) {\n      try {\n        const data = QRCode.create(text, opts)\n        resolve(renderFunc(data, canvas, opts))\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  try {\n    const data = QRCode.create(text, opts)\n    cb(null, renderFunc(data, canvas, opts))\n  } catch (e) {\n    cb(e)\n  }\n}\n\nexports.create = QRCode.create\nexports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render)\nexports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL)\n\n// only svg for now.\nexports.toString = renderCanvas.bind(null, function (data, _, opts) {\n  return SvgRenderer.render(data, opts)\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU4My5qcyIsIm1hcHBpbmdzIjoiO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsSUFBZTs7QUFFMUMsZUFBZSxtQkFBTyxDQUFDLEdBQWU7QUFDdEMsdUJBQXVCLG1CQUFPLENBQUMsSUFBbUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsSUFBdUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsaUJBQWlCOztBQUVqQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvYnJvd3Nlci5qcz9kMDU1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuY29uc3QgY2FuUHJvbWlzZSA9IHJlcXVpcmUoJy4vY2FuLXByb21pc2UnKVxuXG5jb25zdCBRUkNvZGUgPSByZXF1aXJlKCcuL2NvcmUvcXJjb2RlJylcbmNvbnN0IENhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlci9jYW52YXMnKVxuY29uc3QgU3ZnUmVuZGVyZXIgPSByZXF1aXJlKCcuL3JlbmRlcmVyL3N2Zy10YWcuanMnKVxuXG5mdW5jdGlvbiByZW5kZXJDYW52YXMgKHJlbmRlckZ1bmMsIGNhbnZhcywgdGV4dCwgb3B0cywgY2IpIHtcbiAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICBjb25zdCBhcmdzTnVtID0gYXJncy5sZW5ndGhcbiAgY29uc3QgaXNMYXN0QXJnQ2IgPSB0eXBlb2YgYXJnc1thcmdzTnVtIC0gMV0gPT09ICdmdW5jdGlvbidcblxuICBpZiAoIWlzTGFzdEFyZ0NiICYmICFjYW5Qcm9taXNlKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxiYWNrIHJlcXVpcmVkIGFzIGxhc3QgYXJndW1lbnQnKVxuICB9XG5cbiAgaWYgKGlzTGFzdEFyZ0NiKSB7XG4gICAgaWYgKGFyZ3NOdW0gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBmZXcgYXJndW1lbnRzIHByb3ZpZGVkJylcbiAgICB9XG5cbiAgICBpZiAoYXJnc051bSA9PT0gMikge1xuICAgICAgY2IgPSB0ZXh0XG4gICAgICB0ZXh0ID0gY2FudmFzXG4gICAgICBjYW52YXMgPSBvcHRzID0gdW5kZWZpbmVkXG4gICAgfSBlbHNlIGlmIChhcmdzTnVtID09PSAzKSB7XG4gICAgICBpZiAoY2FudmFzLmdldENvbnRleHQgJiYgdHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjYiA9IG9wdHNcbiAgICAgICAgb3B0cyA9IHVuZGVmaW5lZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IgPSBvcHRzXG4gICAgICAgIG9wdHMgPSB0ZXh0XG4gICAgICAgIHRleHQgPSBjYW52YXNcbiAgICAgICAgY2FudmFzID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhcmdzTnVtIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gZmV3IGFyZ3VtZW50cyBwcm92aWRlZCcpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3NOdW0gPT09IDEpIHtcbiAgICAgIHRleHQgPSBjYW52YXNcbiAgICAgIGNhbnZhcyA9IG9wdHMgPSB1bmRlZmluZWRcbiAgICB9IGVsc2UgaWYgKGFyZ3NOdW0gPT09IDIgJiYgIWNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICBvcHRzID0gdGV4dFxuICAgICAgdGV4dCA9IGNhbnZhc1xuICAgICAgY2FudmFzID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBRUkNvZGUuY3JlYXRlKHRleHQsIG9wdHMpXG4gICAgICAgIHJlc29sdmUocmVuZGVyRnVuYyhkYXRhLCBjYW52YXMsIG9wdHMpKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gUVJDb2RlLmNyZWF0ZSh0ZXh0LCBvcHRzKVxuICAgIGNiKG51bGwsIHJlbmRlckZ1bmMoZGF0YSwgY2FudmFzLCBvcHRzKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNiKGUpXG4gIH1cbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBRUkNvZGUuY3JlYXRlXG5leHBvcnRzLnRvQ2FudmFzID0gcmVuZGVyQ2FudmFzLmJpbmQobnVsbCwgQ2FudmFzUmVuZGVyZXIucmVuZGVyKVxuZXhwb3J0cy50b0RhdGFVUkwgPSByZW5kZXJDYW52YXMuYmluZChudWxsLCBDYW52YXNSZW5kZXJlci5yZW5kZXJUb0RhdGFVUkwpXG5cbi8vIG9ubHkgc3ZnIGZvciBub3cuXG5leHBvcnRzLnRvU3RyaW5nID0gcmVuZGVyQ2FudmFzLmJpbmQobnVsbCwgZnVuY3Rpb24gKGRhdGEsIF8sIG9wdHMpIHtcbiAgcmV0dXJuIFN2Z1JlbmRlcmVyLnJlbmRlcihkYXRhLCBvcHRzKVxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7583\n\n}")},7595:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\nmodule.exports = Service;\n\nvar util = __webpack_require__(3610);\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== "function")\n        throw TypeError("rpcImpl must be a function");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError("request must be specified");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error("already ended")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit("error", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);\n                    } catch (err) {\n                        self.emit("error", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit("data", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit("error", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit("end").off();\n    }\n    return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU5NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxJQUFpQjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxzQ0FBc0M7QUFDL0U7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQW1CLGVBQWUscUJBQXFCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLGlDQUFpQztBQUM1QyxhQUFhLHdCQUF3QjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckUsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxpQ0FBaUM7QUFDNUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzPzgwN2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7595\n\n}')},7659:module=>{"use strict";eval('{\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === "undefined") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY1OS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcz9iMjE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7659\n\n}')},7736:g=>{"use strict";g.exports=JSON.parse('["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]')},7756:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const getSymbolSize = (__webpack_require__(6886).getSymbolSize)\nconst FINDER_PATTERN_SIZE = 7\n\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const size = getSymbolSize(version)\n\n  return [\n    // top-left\n    [0, 0],\n    // top-right\n    [size - FINDER_PATTERN_SIZE, 0],\n    // bottom-left\n    [0, size - FINDER_PATTERN_SIZE]\n  ]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IseUNBQWdDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9jb3JlL2ZpbmRlci1wYXR0ZXJuLmpzPzkyNGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZ2V0U3ltYm9sU2l6ZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5nZXRTeW1ib2xTaXplXG5jb25zdCBGSU5ERVJfUEFUVEVSTl9TSVpFID0gN1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgcG9zaXRpb25zIG9mIGVhY2ggZmluZGVyIHBhdHRlcm4uXG4gKiBFYWNoIGFycmF5J3MgZWxlbWVudCByZXByZXNlbnQgdGhlIHRvcC1sZWZ0IHBvaW50IG9mIHRoZSBwYXR0ZXJuIGFzICh4LCB5KSBjb29yZGluYXRlc1xuICpcbiAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBBcnJheSBvZiBjb29yZGluYXRlc1xuICovXG5leHBvcnRzLmdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyAodmVyc2lvbikge1xuICBjb25zdCBzaXplID0gZ2V0U3ltYm9sU2l6ZSh2ZXJzaW9uKVxuXG4gIHJldHVybiBbXG4gICAgLy8gdG9wLWxlZnRcbiAgICBbMCwgMF0sXG4gICAgLy8gdG9wLXJpZ2h0XG4gICAgW3NpemUgLSBGSU5ERVJfUEFUVEVSTl9TSVpFLCAwXSxcbiAgICAvLyBib3R0b20tbGVmdFxuICAgIFswLCBzaXplIC0gRklOREVSX1BBVFRFUk5fU0laRV1cbiAgXVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7756\n\n}")},7825:module=>{"use strict";eval('{\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = "";\n  if (obj.supports) {\n    css += "@supports (".concat(obj.supports, ") {");\n  }\n  if (obj.media) {\n    css += "@media ".concat(obj.media, " {");\n  }\n  var needLayer = typeof obj.layer !== "undefined";\n  if (needLayer) {\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += "}";\n  }\n  if (obj.media) {\n    css += "}";\n  }\n  if (obj.supports) {\n    css += "}";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== "undefined") {\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === "undefined") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzgyNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcz9lNDc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cbiAgY3NzICs9IG9iai5jc3M7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH1cblxuICAvLyBGb3Igb2xkIElFXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7825\n\n}')},7899:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const Utils = __webpack_require__(2726)\n\nfunction clearCanvas (ctx, canvas, size) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n  if (!canvas.style) canvas.style = {}\n  canvas.height = size\n  canvas.width = size\n  canvas.style.height = size + 'px'\n  canvas.style.width = size + 'px'\n}\n\nfunction getCanvasElement () {\n  try {\n    return document.createElement('canvas')\n  } catch (e) {\n    throw new Error('You need to specify a canvas element')\n  }\n}\n\nexports.render = function render (qrData, canvas, options) {\n  let opts = options\n  let canvasEl = canvas\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!canvas) {\n    canvasEl = getCanvasElement()\n  }\n\n  opts = Utils.getOptions(opts)\n  const size = Utils.getImageWidth(qrData.modules.size, opts)\n\n  const ctx = canvasEl.getContext('2d')\n  const image = ctx.createImageData(size, size)\n  Utils.qrToImageData(image.data, qrData, opts)\n\n  clearCanvas(ctx, canvasEl, size)\n  ctx.putImageData(image, 0, 0)\n\n  return canvasEl\n}\n\nexports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {\n  let opts = options\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!opts) opts = {}\n\n  const canvasEl = exports.render(qrData, canvas, opts)\n\n  const type = opts.type || 'image/png'\n  const rendererOpts = opts.rendererOpts || {}\n\n  return canvasEl.toDataURL(type, rendererOpts.quality)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg5OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsSUFBUzs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL3FyY29kZS9saWIvcmVuZGVyZXIvY2FudmFzLmpzPzQxNDYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcblxuZnVuY3Rpb24gY2xlYXJDYW52YXMgKGN0eCwgY2FudmFzLCBzaXplKSB7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gIGlmICghY2FudmFzLnN0eWxlKSBjYW52YXMuc3R5bGUgPSB7fVxuICBjYW52YXMuaGVpZ2h0ID0gc2l6ZVxuICBjYW52YXMud2lkdGggPSBzaXplXG4gIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBzaXplICsgJ3B4J1xuICBjYW52YXMuc3R5bGUud2lkdGggPSBzaXplICsgJ3B4J1xufVxuXG5mdW5jdGlvbiBnZXRDYW52YXNFbGVtZW50ICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gc3BlY2lmeSBhIGNhbnZhcyBlbGVtZW50JylcbiAgfVxufVxuXG5leHBvcnRzLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAocXJEYXRhLCBjYW52YXMsIG9wdGlvbnMpIHtcbiAgbGV0IG9wdHMgPSBvcHRpb25zXG4gIGxldCBjYW52YXNFbCA9IGNhbnZhc1xuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcgJiYgKCFjYW52YXMgfHwgIWNhbnZhcy5nZXRDb250ZXh0KSkge1xuICAgIG9wdHMgPSBjYW52YXNcbiAgICBjYW52YXMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICghY2FudmFzKSB7XG4gICAgY2FudmFzRWwgPSBnZXRDYW52YXNFbGVtZW50KClcbiAgfVxuXG4gIG9wdHMgPSBVdGlscy5nZXRPcHRpb25zKG9wdHMpXG4gIGNvbnN0IHNpemUgPSBVdGlscy5nZXRJbWFnZVdpZHRoKHFyRGF0YS5tb2R1bGVzLnNpemUsIG9wdHMpXG5cbiAgY29uc3QgY3R4ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKVxuICBjb25zdCBpbWFnZSA9IGN0eC5jcmVhdGVJbWFnZURhdGEoc2l6ZSwgc2l6ZSlcbiAgVXRpbHMucXJUb0ltYWdlRGF0YShpbWFnZS5kYXRhLCBxckRhdGEsIG9wdHMpXG5cbiAgY2xlYXJDYW52YXMoY3R4LCBjYW52YXNFbCwgc2l6ZSlcbiAgY3R4LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMClcblxuICByZXR1cm4gY2FudmFzRWxcbn1cblxuZXhwb3J0cy5yZW5kZXJUb0RhdGFVUkwgPSBmdW5jdGlvbiByZW5kZXJUb0RhdGFVUkwgKHFyRGF0YSwgY2FudmFzLCBvcHRpb25zKSB7XG4gIGxldCBvcHRzID0gb3B0aW9uc1xuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3VuZGVmaW5lZCcgJiYgKCFjYW52YXMgfHwgIWNhbnZhcy5nZXRDb250ZXh0KSkge1xuICAgIG9wdHMgPSBjYW52YXNcbiAgICBjYW52YXMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgY29uc3QgY2FudmFzRWwgPSBleHBvcnRzLnJlbmRlcihxckRhdGEsIGNhbnZhcywgb3B0cylcblxuICBjb25zdCB0eXBlID0gb3B0cy50eXBlIHx8ICdpbWFnZS9wbmcnXG4gIGNvbnN0IHJlbmRlcmVyT3B0cyA9IG9wdHMucmVuZGVyZXJPcHRzIHx8IHt9XG5cbiAgcmV0dXJuIGNhbnZhc0VsLnRvRGF0YVVSTCh0eXBlLCByZW5kZXJlck9wdHMucXVhbGl0eSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7899\n\n}")},7967:g=>{"use strict";g.exports=JSON.parse('["あいこくしん","あいさつ","あいだ","あおぞら","あかちゃん","あきる","あけがた","あける","あこがれる","あさい","あさひ","あしあと","あじわう","あずかる","あずき","あそぶ","あたえる","あたためる","あたりまえ","あたる","あつい","あつかう","あっしゅく","あつまり","あつめる","あてな","あてはまる","あひる","あぶら","あぶる","あふれる","あまい","あまど","あまやかす","あまり","あみもの","あめりか","あやまる","あゆむ","あらいぐま","あらし","あらすじ","あらためる","あらゆる","あらわす","ありがとう","あわせる","あわてる","あんい","あんがい","あんこ","あんぜん","あんてい","あんない","あんまり","いいだす","いおん","いがい","いがく","いきおい","いきなり","いきもの","いきる","いくじ","いくぶん","いけばな","いけん","いこう","いこく","いこつ","いさましい","いさん","いしき","いじゅう","いじょう","いじわる","いずみ","いずれ","いせい","いせえび","いせかい","いせき","いぜん","いそうろう","いそがしい","いだい","いだく","いたずら","いたみ","いたりあ","いちおう","いちじ","いちど","いちば","いちぶ","いちりゅう","いつか","いっしゅん","いっせい","いっそう","いったん","いっち","いってい","いっぽう","いてざ","いてん","いどう","いとこ","いない","いなか","いねむり","いのち","いのる","いはつ","いばる","いはん","いびき","いひん","いふく","いへん","いほう","いみん","いもうと","いもたれ","いもり","いやがる","いやす","いよかん","いよく","いらい","いらすと","いりぐち","いりょう","いれい","いれもの","いれる","いろえんぴつ","いわい","いわう","いわかん","いわば","いわゆる","いんげんまめ","いんさつ","いんしょう","いんよう","うえき","うえる","うおざ","うがい","うかぶ","うかべる","うきわ","うくらいな","うくれれ","うけたまわる","うけつけ","うけとる","うけもつ","うける","うごかす","うごく","うこん","うさぎ","うしなう","うしろがみ","うすい","うすぎ","うすぐらい","うすめる","うせつ","うちあわせ","うちがわ","うちき","うちゅう","うっかり","うつくしい","うったえる","うつる","うどん","うなぎ","うなじ","うなずく","うなる","うねる","うのう","うぶげ","うぶごえ","うまれる","うめる","うもう","うやまう","うよく","うらがえす","うらぐち","うらない","うりあげ","うりきれ","うるさい","うれしい","うれゆき","うれる","うろこ","うわき","うわさ","うんこう","うんちん","うんてん","うんどう","えいえん","えいが","えいきょう","えいご","えいせい","えいぶん","えいよう","えいわ","えおり","えがお","えがく","えきたい","えくせる","えしゃく","えすて","えつらん","えのぐ","えほうまき","えほん","えまき","えもじ","えもの","えらい","えらぶ","えりあ","えんえん","えんかい","えんぎ","えんげき","えんしゅう","えんぜつ","えんそく","えんちょう","えんとつ","おいかける","おいこす","おいしい","おいつく","おうえん","おうさま","おうじ","おうせつ","おうたい","おうふく","おうべい","おうよう","おえる","おおい","おおう","おおどおり","おおや","おおよそ","おかえり","おかず","おがむ","おかわり","おぎなう","おきる","おくさま","おくじょう","おくりがな","おくる","おくれる","おこす","おこなう","おこる","おさえる","おさない","おさめる","おしいれ","おしえる","おじぎ","おじさん","おしゃれ","おそらく","おそわる","おたがい","おたく","おだやか","おちつく","おっと","おつり","おでかけ","おとしもの","おとなしい","おどり","おどろかす","おばさん","おまいり","おめでとう","おもいで","おもう","おもたい","おもちゃ","おやつ","おやゆび","およぼす","おらんだ","おろす","おんがく","おんけい","おんしゃ","おんせん","おんだん","おんちゅう","おんどけい","かあつ","かいが","がいき","がいけん","がいこう","かいさつ","かいしゃ","かいすいよく","かいぜん","かいぞうど","かいつう","かいてん","かいとう","かいふく","がいへき","かいほう","かいよう","がいらい","かいわ","かえる","かおり","かかえる","かがく","かがし","かがみ","かくご","かくとく","かざる","がぞう","かたい","かたち","がちょう","がっきゅう","がっこう","がっさん","がっしょう","かなざわし","かのう","がはく","かぶか","かほう","かほご","かまう","かまぼこ","かめれおん","かゆい","かようび","からい","かるい","かろう","かわく","かわら","がんか","かんけい","かんこう","かんしゃ","かんそう","かんたん","かんち","がんばる","きあい","きあつ","きいろ","ぎいん","きうい","きうん","きえる","きおう","きおく","きおち","きおん","きかい","きかく","きかんしゃ","ききて","きくばり","きくらげ","きけんせい","きこう","きこえる","きこく","きさい","きさく","きさま","きさらぎ","ぎじかがく","ぎしき","ぎじたいけん","ぎじにってい","ぎじゅつしゃ","きすう","きせい","きせき","きせつ","きそう","きぞく","きぞん","きたえる","きちょう","きつえん","ぎっちり","きつつき","きつね","きてい","きどう","きどく","きない","きなが","きなこ","きぬごし","きねん","きのう","きのした","きはく","きびしい","きひん","きふく","きぶん","きぼう","きほん","きまる","きみつ","きむずかしい","きめる","きもだめし","きもち","きもの","きゃく","きやく","ぎゅうにく","きよう","きょうりゅう","きらい","きらく","きりん","きれい","きれつ","きろく","ぎろん","きわめる","ぎんいろ","きんかくじ","きんじょ","きんようび","ぐあい","くいず","くうかん","くうき","くうぐん","くうこう","ぐうせい","くうそう","ぐうたら","くうふく","くうぼ","くかん","くきょう","くげん","ぐこう","くさい","くさき","くさばな","くさる","くしゃみ","くしょう","くすのき","くすりゆび","くせげ","くせん","ぐたいてき","くださる","くたびれる","くちこみ","くちさき","くつした","ぐっすり","くつろぐ","くとうてん","くどく","くなん","くねくね","くのう","くふう","くみあわせ","くみたてる","くめる","くやくしょ","くらす","くらべる","くるま","くれる","くろう","くわしい","ぐんかん","ぐんしょく","ぐんたい","ぐんて","けあな","けいかく","けいけん","けいこ","けいさつ","げいじゅつ","けいたい","げいのうじん","けいれき","けいろ","けおとす","けおりもの","げきか","げきげん","げきだん","げきちん","げきとつ","げきは","げきやく","げこう","げこくじょう","げざい","けさき","げざん","けしき","けしごむ","けしょう","げすと","けたば","けちゃっぷ","けちらす","けつあつ","けつい","けつえき","けっこん","けつじょ","けっせき","けってい","けつまつ","げつようび","げつれい","けつろん","げどく","けとばす","けとる","けなげ","けなす","けなみ","けぬき","げねつ","けねん","けはい","げひん","けぶかい","げぼく","けまり","けみかる","けむし","けむり","けもの","けらい","けろけろ","けわしい","けんい","けんえつ","けんお","けんか","げんき","けんげん","けんこう","けんさく","けんしゅう","けんすう","げんそう","けんちく","けんてい","けんとう","けんない","けんにん","げんぶつ","けんま","けんみん","けんめい","けんらん","けんり","こあくま","こいぬ","こいびと","ごうい","こうえん","こうおん","こうかん","ごうきゅう","ごうけい","こうこう","こうさい","こうじ","こうすい","ごうせい","こうそく","こうたい","こうちゃ","こうつう","こうてい","こうどう","こうない","こうはい","ごうほう","ごうまん","こうもく","こうりつ","こえる","こおり","ごかい","ごがつ","ごかん","こくご","こくさい","こくとう","こくない","こくはく","こぐま","こけい","こける","ここのか","こころ","こさめ","こしつ","こすう","こせい","こせき","こぜん","こそだて","こたい","こたえる","こたつ","こちょう","こっか","こつこつ","こつばん","こつぶ","こてい","こてん","ことがら","ことし","ことば","ことり","こなごな","こねこね","このまま","このみ","このよ","ごはん","こひつじ","こふう","こふん","こぼれる","ごまあぶら","こまかい","ごますり","こまつな","こまる","こむぎこ","こもじ","こもち","こもの","こもん","こやく","こやま","こゆう","こゆび","こよい","こよう","こりる","これくしょん","ころっけ","こわもて","こわれる","こんいん","こんかい","こんき","こんしゅう","こんすい","こんだて","こんとん","こんなん","こんびに","こんぽん","こんまけ","こんや","こんれい","こんわく","ざいえき","さいかい","さいきん","ざいげん","ざいこ","さいしょ","さいせい","ざいたく","ざいちゅう","さいてき","ざいりょう","さうな","さかいし","さがす","さかな","さかみち","さがる","さぎょう","さくし","さくひん","さくら","さこく","さこつ","さずかる","ざせき","さたん","さつえい","ざつおん","ざっか","ざつがく","さっきょく","ざっし","さつじん","ざっそう","さつたば","さつまいも","さてい","さといも","さとう","さとおや","さとし","さとる","さのう","さばく","さびしい","さべつ","さほう","さほど","さます","さみしい","さみだれ","さむけ","さめる","さやえんどう","さゆう","さよう","さよく","さらだ","ざるそば","さわやか","さわる","さんいん","さんか","さんきゃく","さんこう","さんさい","ざんしょ","さんすう","さんせい","さんそ","さんち","さんま","さんみ","さんらん","しあい","しあげ","しあさって","しあわせ","しいく","しいん","しうち","しえい","しおけ","しかい","しかく","じかん","しごと","しすう","じだい","したうけ","したぎ","したて","したみ","しちょう","しちりん","しっかり","しつじ","しつもん","してい","してき","してつ","じてん","じどう","しなぎれ","しなもの","しなん","しねま","しねん","しのぐ","しのぶ","しはい","しばかり","しはつ","しはらい","しはん","しひょう","しふく","じぶん","しへい","しほう","しほん","しまう","しまる","しみん","しむける","じむしょ","しめい","しめる","しもん","しゃいん","しゃうん","しゃおん","じゃがいも","しやくしょ","しゃくほう","しゃけん","しゃこ","しゃざい","しゃしん","しゃせん","しゃそう","しゃたい","しゃちょう","しゃっきん","じゃま","しゃりん","しゃれい","じゆう","じゅうしょ","しゅくはく","じゅしん","しゅっせき","しゅみ","しゅらば","じゅんばん","しょうかい","しょくたく","しょっけん","しょどう","しょもつ","しらせる","しらべる","しんか","しんこう","じんじゃ","しんせいじ","しんちく","しんりん","すあげ","すあし","すあな","ずあん","すいえい","すいか","すいとう","ずいぶん","すいようび","すうがく","すうじつ","すうせん","すおどり","すきま","すくう","すくない","すける","すごい","すこし","ずさん","すずしい","すすむ","すすめる","すっかり","ずっしり","ずっと","すてき","すてる","すねる","すのこ","すはだ","すばらしい","ずひょう","ずぶぬれ","すぶり","すふれ","すべて","すべる","ずほう","すぼん","すまい","すめし","すもう","すやき","すらすら","するめ","すれちがう","すろっと","すわる","すんぜん","すんぽう","せあぶら","せいかつ","せいげん","せいじ","せいよう","せおう","せかいかん","せきにん","せきむ","せきゆ","せきらんうん","せけん","せこう","せすじ","せたい","せたけ","せっかく","せっきゃく","ぜっく","せっけん","せっこつ","せっさたくま","せつぞく","せつだん","せつでん","せっぱん","せつび","せつぶん","せつめい","せつりつ","せなか","せのび","せはば","せびろ","せぼね","せまい","せまる","せめる","せもたれ","せりふ","ぜんあく","せんい","せんえい","せんか","せんきょ","せんく","せんげん","ぜんご","せんさい","せんしゅ","せんすい","せんせい","せんぞ","せんたく","せんちょう","せんてい","せんとう","せんぬき","せんねん","せんぱい","ぜんぶ","ぜんぽう","せんむ","せんめんじょ","せんもん","せんやく","せんゆう","せんよう","ぜんら","ぜんりゃく","せんれい","せんろ","そあく","そいとげる","そいね","そうがんきょう","そうき","そうご","そうしん","そうだん","そうなん","そうび","そうめん","そうり","そえもの","そえん","そがい","そげき","そこう","そこそこ","そざい","そしな","そせい","そせん","そそぐ","そだてる","そつう","そつえん","そっかん","そつぎょう","そっけつ","そっこう","そっせん","そっと","そとがわ","そとづら","そなえる","そなた","そふぼ","そぼく","そぼろ","そまつ","そまる","そむく","そむりえ","そめる","そもそも","そよかぜ","そらまめ","そろう","そんかい","そんけい","そんざい","そんしつ","そんぞく","そんちょう","ぞんび","ぞんぶん","そんみん","たあい","たいいん","たいうん","たいえき","たいおう","だいがく","たいき","たいぐう","たいけん","たいこ","たいざい","だいじょうぶ","だいすき","たいせつ","たいそう","だいたい","たいちょう","たいてい","だいどころ","たいない","たいねつ","たいのう","たいはん","だいひょう","たいふう","たいへん","たいほ","たいまつばな","たいみんぐ","たいむ","たいめん","たいやき","たいよう","たいら","たいりょく","たいる","たいわん","たうえ","たえる","たおす","たおる","たおれる","たかい","たかね","たきび","たくさん","たこく","たこやき","たさい","たしざん","だじゃれ","たすける","たずさわる","たそがれ","たたかう","たたく","ただしい","たたみ","たちばな","だっかい","だっきゃく","だっこ","だっしゅつ","だったい","たてる","たとえる","たなばた","たにん","たぬき","たのしみ","たはつ","たぶん","たべる","たぼう","たまご","たまる","だむる","ためいき","ためす","ためる","たもつ","たやすい","たよる","たらす","たりきほんがん","たりょう","たりる","たると","たれる","たれんと","たろっと","たわむれる","だんあつ","たんい","たんおん","たんか","たんき","たんけん","たんご","たんさん","たんじょうび","だんせい","たんそく","たんたい","だんち","たんてい","たんとう","だんな","たんにん","だんねつ","たんのう","たんぴん","だんぼう","たんまつ","たんめい","だんれつ","だんろ","だんわ","ちあい","ちあん","ちいき","ちいさい","ちえん","ちかい","ちから","ちきゅう","ちきん","ちけいず","ちけん","ちこく","ちさい","ちしき","ちしりょう","ちせい","ちそう","ちたい","ちたん","ちちおや","ちつじょ","ちてき","ちてん","ちぬき","ちぬり","ちのう","ちひょう","ちへいせん","ちほう","ちまた","ちみつ","ちみどろ","ちめいど","ちゃんこなべ","ちゅうい","ちゆりょく","ちょうし","ちょさくけん","ちらし","ちらみ","ちりがみ","ちりょう","ちるど","ちわわ","ちんたい","ちんもく","ついか","ついたち","つうか","つうじょう","つうはん","つうわ","つかう","つかれる","つくね","つくる","つけね","つける","つごう","つたえる","つづく","つつじ","つつむ","つとめる","つながる","つなみ","つねづね","つのる","つぶす","つまらない","つまる","つみき","つめたい","つもり","つもる","つよい","つるぼ","つるみく","つわもの","つわり","てあし","てあて","てあみ","ていおん","ていか","ていき","ていけい","ていこく","ていさつ","ていし","ていせい","ていたい","ていど","ていねい","ていひょう","ていへん","ていぼう","てうち","ておくれ","てきとう","てくび","でこぼこ","てさぎょう","てさげ","てすり","てそう","てちがい","てちょう","てつがく","てつづき","でっぱ","てつぼう","てつや","でぬかえ","てぬき","てぬぐい","てのひら","てはい","てぶくろ","てふだ","てほどき","てほん","てまえ","てまきずし","てみじか","てみやげ","てらす","てれび","てわけ","てわたし","でんあつ","てんいん","てんかい","てんき","てんぐ","てんけん","てんごく","てんさい","てんし","てんすう","でんち","てんてき","てんとう","てんない","てんぷら","てんぼうだい","てんめつ","てんらんかい","でんりょく","でんわ","どあい","といれ","どうかん","とうきゅう","どうぐ","とうし","とうむぎ","とおい","とおか","とおく","とおす","とおる","とかい","とかす","ときおり","ときどき","とくい","とくしゅう","とくてん","とくに","とくべつ","とけい","とける","とこや","とさか","としょかん","とそう","とたん","とちゅう","とっきゅう","とっくん","とつぜん","とつにゅう","とどける","ととのえる","とない","となえる","となり","とのさま","とばす","どぶがわ","とほう","とまる","とめる","ともだち","ともる","どようび","とらえる","とんかつ","どんぶり","ないかく","ないこう","ないしょ","ないす","ないせん","ないそう","なおす","ながい","なくす","なげる","なこうど","なさけ","なたでここ","なっとう","なつやすみ","ななおし","なにごと","なにもの","なにわ","なのか","なふだ","なまいき","なまえ","なまみ","なみだ","なめらか","なめる","なやむ","ならう","ならび","ならぶ","なれる","なわとび","なわばり","にあう","にいがた","にうけ","におい","にかい","にがて","にきび","にくしみ","にくまん","にげる","にさんかたんそ","にしき","にせもの","にちじょう","にちようび","にっか","にっき","にっけい","にっこう","にっさん","にっしょく","にっすう","にっせき","にってい","になう","にほん","にまめ","にもつ","にやり","にゅういん","にりんしゃ","にわとり","にんい","にんか","にんき","にんげん","にんしき","にんずう","にんそう","にんたい","にんち","にんてい","にんにく","にんぷ","にんまり","にんむ","にんめい","にんよう","ぬいくぎ","ぬかす","ぬぐいとる","ぬぐう","ぬくもり","ぬすむ","ぬまえび","ぬめり","ぬらす","ぬんちゃく","ねあげ","ねいき","ねいる","ねいろ","ねぐせ","ねくたい","ねくら","ねこぜ","ねこむ","ねさげ","ねすごす","ねそべる","ねだん","ねつい","ねっしん","ねつぞう","ねったいぎょ","ねぶそく","ねふだ","ねぼう","ねほりはほり","ねまき","ねまわし","ねみみ","ねむい","ねむたい","ねもと","ねらう","ねわざ","ねんいり","ねんおし","ねんかん","ねんきん","ねんぐ","ねんざ","ねんし","ねんちゃく","ねんど","ねんぴ","ねんぶつ","ねんまつ","ねんりょう","ねんれい","のいず","のおづま","のがす","のきなみ","のこぎり","のこす","のこる","のせる","のぞく","のぞむ","のたまう","のちほど","のっく","のばす","のはら","のべる","のぼる","のみもの","のやま","のらいぬ","のらねこ","のりもの","のりゆき","のれん","のんき","ばあい","はあく","ばあさん","ばいか","ばいく","はいけん","はいご","はいしん","はいすい","はいせん","はいそう","はいち","ばいばい","はいれつ","はえる","はおる","はかい","ばかり","はかる","はくしゅ","はけん","はこぶ","はさみ","はさん","はしご","ばしょ","はしる","はせる","ぱそこん","はそん","はたん","はちみつ","はつおん","はっかく","はづき","はっきり","はっくつ","はっけん","はっこう","はっさん","はっしん","はったつ","はっちゅう","はってん","はっぴょう","はっぽう","はなす","はなび","はにかむ","はぶらし","はみがき","はむかう","はめつ","はやい","はやし","はらう","はろうぃん","はわい","はんい","はんえい","はんおん","はんかく","はんきょう","ばんぐみ","はんこ","はんしゃ","はんすう","はんだん","ぱんち","ぱんつ","はんてい","はんとし","はんのう","はんぱ","はんぶん","はんぺん","はんぼうき","はんめい","はんらん","はんろん","ひいき","ひうん","ひえる","ひかく","ひかり","ひかる","ひかん","ひくい","ひけつ","ひこうき","ひこく","ひさい","ひさしぶり","ひさん","びじゅつかん","ひしょ","ひそか","ひそむ","ひたむき","ひだり","ひたる","ひつぎ","ひっこし","ひっし","ひつじゅひん","ひっす","ひつぜん","ぴったり","ぴっちり","ひつよう","ひてい","ひとごみ","ひなまつり","ひなん","ひねる","ひはん","ひびく","ひひょう","ひほう","ひまわり","ひまん","ひみつ","ひめい","ひめじし","ひやけ","ひやす","ひよう","びょうき","ひらがな","ひらく","ひりつ","ひりょう","ひるま","ひるやすみ","ひれい","ひろい","ひろう","ひろき","ひろゆき","ひんかく","ひんけつ","ひんこん","ひんしゅ","ひんそう","ぴんち","ひんぱん","びんぼう","ふあん","ふいうち","ふうけい","ふうせん","ぷうたろう","ふうとう","ふうふ","ふえる","ふおん","ふかい","ふきん","ふくざつ","ふくぶくろ","ふこう","ふさい","ふしぎ","ふじみ","ふすま","ふせい","ふせぐ","ふそく","ぶたにく","ふたん","ふちょう","ふつう","ふつか","ふっかつ","ふっき","ふっこく","ぶどう","ふとる","ふとん","ふのう","ふはい","ふひょう","ふへん","ふまん","ふみん","ふめつ","ふめん","ふよう","ふりこ","ふりる","ふるい","ふんいき","ぶんがく","ぶんぐ","ふんしつ","ぶんせき","ふんそう","ぶんぽう","へいあん","へいおん","へいがい","へいき","へいげん","へいこう","へいさ","へいしゃ","へいせつ","へいそ","へいたく","へいてん","へいねつ","へいわ","へきが","へこむ","べにいろ","べにしょうが","へらす","へんかん","べんきょう","べんごし","へんさい","へんたい","べんり","ほあん","ほいく","ぼうぎょ","ほうこく","ほうそう","ほうほう","ほうもん","ほうりつ","ほえる","ほおん","ほかん","ほきょう","ぼきん","ほくろ","ほけつ","ほけん","ほこう","ほこる","ほしい","ほしつ","ほしゅ","ほしょう","ほせい","ほそい","ほそく","ほたて","ほたる","ぽちぶくろ","ほっきょく","ほっさ","ほったん","ほとんど","ほめる","ほんい","ほんき","ほんけ","ほんしつ","ほんやく","まいにち","まかい","まかせる","まがる","まける","まこと","まさつ","まじめ","ますく","まぜる","まつり","まとめ","まなぶ","まぬけ","まねく","まほう","まもる","まゆげ","まよう","まろやか","まわす","まわり","まわる","まんが","まんきつ","まんぞく","まんなか","みいら","みうち","みえる","みがく","みかた","みかん","みけん","みこん","みじかい","みすい","みすえる","みせる","みっか","みつかる","みつける","みてい","みとめる","みなと","みなみかさい","みねらる","みのう","みのがす","みほん","みもと","みやげ","みらい","みりょく","みわく","みんか","みんぞく","むいか","むえき","むえん","むかい","むかう","むかえ","むかし","むぎちゃ","むける","むげん","むさぼる","むしあつい","むしば","むじゅん","むしろ","むすう","むすこ","むすぶ","むすめ","むせる","むせん","むちゅう","むなしい","むのう","むやみ","むよう","むらさき","むりょう","むろん","めいあん","めいうん","めいえん","めいかく","めいきょく","めいさい","めいし","めいそう","めいぶつ","めいれい","めいわく","めぐまれる","めざす","めした","めずらしい","めだつ","めまい","めやす","めんきょ","めんせき","めんどう","もうしあげる","もうどうけん","もえる","もくし","もくてき","もくようび","もちろん","もどる","もらう","もんく","もんだい","やおや","やける","やさい","やさしい","やすい","やすたろう","やすみ","やせる","やそう","やたい","やちん","やっと","やっぱり","やぶる","やめる","ややこしい","やよい","やわらかい","ゆうき","ゆうびんきょく","ゆうべ","ゆうめい","ゆけつ","ゆしゅつ","ゆせん","ゆそう","ゆたか","ゆちゃく","ゆでる","ゆにゅう","ゆびわ","ゆらい","ゆれる","ようい","ようか","ようきゅう","ようじ","ようす","ようちえん","よかぜ","よかん","よきん","よくせい","よくぼう","よけい","よごれる","よさん","よしゅう","よそう","よそく","よっか","よてい","よどがわく","よねつ","よやく","よゆう","よろこぶ","よろしい","らいう","らくがき","らくご","らくさつ","らくだ","らしんばん","らせん","らぞく","らたい","らっか","られつ","りえき","りかい","りきさく","りきせつ","りくぐん","りくつ","りけん","りこう","りせい","りそう","りそく","りてん","りねん","りゆう","りゅうがく","りよう","りょうり","りょかん","りょくちゃ","りょこう","りりく","りれき","りろん","りんご","るいけい","るいさい","るいじ","るいせき","るすばん","るりがわら","れいかん","れいぎ","れいせい","れいぞうこ","れいとう","れいぼう","れきし","れきだい","れんあい","れんけい","れんこん","れんさい","れんしゅう","れんぞく","れんらく","ろうか","ろうご","ろうじん","ろうそく","ろくが","ろこつ","ろじうら","ろしゅつ","ろせん","ろてん","ろめん","ろれつ","ろんぎ","ろんぱ","ろんぶん","ろんり","わかす","わかめ","わかやま","わかれる","わしつ","わじまし","わすれもの","わらう","われる"]')},8045:module=>{"use strict";eval("{\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODA0NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSxVQUFVO0FBQ1YsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsR0FBRztBQUNkLFdBQVcsTUFBTTtBQUNqQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzPzMwNWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gYXNQcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuYXNQcm9taXNlfS5cclxuICogQHR5cGVkZWYgYXNQcm9taXNlQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgQWRkaXRpb25hbCBhcmd1bWVudHNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2UgZnJvbSBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7YXNQcm9taXNlQ2FsbGJhY2t9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHsqfSBjdHggRnVuY3Rpb24gY29udGV4dFxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBGdW5jdGlvbiBhcmd1bWVudHNcclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2lmaWVkIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eC8qLCB2YXJhcmdzICovKSB7XHJcbiAgICB2YXIgcGFyYW1zICA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgb2Zmc2V0ICA9IDAsXHJcbiAgICAgICAgaW5kZXggICA9IDIsXHJcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIvKiwgdmFyYXJncyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8045\n\n}")},8112:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=writer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODExMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvaW8vd3JpdGVyLmpzPzQwZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d3JpdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8112\n\n}')},8161:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.WriterBytes = void 0;\nconst bytes_js_1 = __webpack_require__(1292);\n/**\n * Implementation of `Writer` which writes to an array of pre-allocated size.\n * It\'s intended to be used in unison with `WriterLength`, which first finds\n * out the length of the serialized object and then the actual data is written\n * using this class.\n **/\nclass WriterBytes {\n    /** Create a new WriterBytes with the given pre-allocated size */\n    constructor(length) {\n        this.data = new Uint8Array(length);\n        this.view = new DataView(this.data.buffer, this.data.byteOffset, this.data.byteLength);\n        this.idx = 0;\n    }\n    /** Write a single byte */\n    putU8(value) {\n        if (value < 0 || value > 0xff) {\n            throw new Error(`Cannot fit ${value} into a u8`);\n        }\n        this.ensureSize(1);\n        this.data[this.idx] = Number(value);\n        this.idx++;\n    }\n    /** Write a 2-byte little-endian integer (uint16_t) */\n    putU16(value, endian) {\n        if (value < 0 || value > 0xffff) {\n            throw new Error(`Cannot fit ${value} into a u16`);\n        }\n        this.ensureSize(2);\n        this.view.setUint16(this.idx, Number(value), (0, bytes_js_1.endianToBool)(endian));\n        this.idx += 2;\n    }\n    /** Write a 4-byte little-endian integer (uint32_t) */\n    putU32(value, endian) {\n        if (value < 0 || value > 0xffffffff) {\n            throw new Error(`Cannot fit ${value} into a u32`);\n        }\n        this.ensureSize(4);\n        this.view.setUint32(this.idx, Number(value), (0, bytes_js_1.endianToBool)(endian));\n        this.idx += 4;\n    }\n    /** Write an 8-byte little-endian integer (uint64_t) */\n    putU64(value, endian) {\n        if (value < 0 || value > 0xffffffffffffffffn) {\n            throw new Error(`Cannot fit ${value} into a u64`);\n        }\n        this.ensureSize(8);\n        this.view.setBigUint64(this.idx, BigInt(value), (0, bytes_js_1.endianToBool)(endian));\n        this.idx += 8;\n    }\n    /** Write the given bytes */\n    putBytes(bytes) {\n        this.ensureSize(bytes.length);\n        this.data.set(bytes, this.idx);\n        this.idx += bytes.length;\n    }\n    ensureSize(extraBytes) {\n        if (this.data.length < this.idx + extraBytes) {\n            throw new Error(`Not enough bytes: Tried writing ${extraBytes} byte(s), but ` +\n                `only ${this.data.length - this.idx} byte(s) have been ` +\n                `pre-allocated`);\n        }\n    }\n}\nexports.WriterBytes = WriterBytes;\n//# sourceMappingURL=writerbytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE2MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsbUJBQW1CLG1CQUFPLENBQUMsSUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0Usd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvaW8vd3JpdGVyYnl0ZXMuanM/MzM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldyaXRlckJ5dGVzID0gdm9pZCAwO1xuY29uc3QgYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuL2J5dGVzLmpzXCIpO1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBgV3JpdGVyYCB3aGljaCB3cml0ZXMgdG8gYW4gYXJyYXkgb2YgcHJlLWFsbG9jYXRlZCBzaXplLlxuICogSXQncyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIHVuaXNvbiB3aXRoIGBXcml0ZXJMZW5ndGhgLCB3aGljaCBmaXJzdCBmaW5kc1xuICogb3V0IHRoZSBsZW5ndGggb2YgdGhlIHNlcmlhbGl6ZWQgb2JqZWN0IGFuZCB0aGVuIHRoZSBhY3R1YWwgZGF0YSBpcyB3cml0dGVuXG4gKiB1c2luZyB0aGlzIGNsYXNzLlxuICoqL1xuY2xhc3MgV3JpdGVyQnl0ZXMge1xuICAgIC8qKiBDcmVhdGUgYSBuZXcgV3JpdGVyQnl0ZXMgd2l0aCB0aGUgZ2l2ZW4gcHJlLWFsbG9jYXRlZCBzaXplICovXG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLmRhdGEuYnl0ZU9mZnNldCwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgfVxuICAgIC8qKiBXcml0ZSBhIHNpbmdsZSBieXRlICovXG4gICAgcHV0VTgodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDB4ZmYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpdCAke3ZhbHVlfSBpbnRvIGEgdThgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuc3VyZVNpemUoMSk7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLmlkeF0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICB0aGlzLmlkeCsrO1xuICAgIH1cbiAgICAvKiogV3JpdGUgYSAyLWJ5dGUgbGl0dGxlLWVuZGlhbiBpbnRlZ2VyICh1aW50MTZfdCkgKi9cbiAgICBwdXRVMTYodmFsdWUsIGVuZGlhbikge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMHhmZmZmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaXQgJHt2YWx1ZX0gaW50byBhIHUxNmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5zdXJlU2l6ZSgyKTtcbiAgICAgICAgdGhpcy52aWV3LnNldFVpbnQxNih0aGlzLmlkeCwgTnVtYmVyKHZhbHVlKSwgKDAsIGJ5dGVzX2pzXzEuZW5kaWFuVG9Cb29sKShlbmRpYW4pKTtcbiAgICAgICAgdGhpcy5pZHggKz0gMjtcbiAgICB9XG4gICAgLyoqIFdyaXRlIGEgNC1ieXRlIGxpdHRsZS1lbmRpYW4gaW50ZWdlciAodWludDMyX3QpICovXG4gICAgcHV0VTMyKHZhbHVlLCBlbmRpYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpdCAke3ZhbHVlfSBpbnRvIGEgdTMyYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnN1cmVTaXplKDQpO1xuICAgICAgICB0aGlzLnZpZXcuc2V0VWludDMyKHRoaXMuaWR4LCBOdW1iZXIodmFsdWUpLCAoMCwgYnl0ZXNfanNfMS5lbmRpYW5Ub0Jvb2wpKGVuZGlhbikpO1xuICAgICAgICB0aGlzLmlkeCArPSA0O1xuICAgIH1cbiAgICAvKiogV3JpdGUgYW4gOC1ieXRlIGxpdHRsZS1lbmRpYW4gaW50ZWdlciAodWludDY0X3QpICovXG4gICAgcHV0VTY0KHZhbHVlLCBlbmRpYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDB4ZmZmZmZmZmZmZmZmZmZmZm4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpdCAke3ZhbHVlfSBpbnRvIGEgdTY0YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnN1cmVTaXplKDgpO1xuICAgICAgICB0aGlzLnZpZXcuc2V0QmlnVWludDY0KHRoaXMuaWR4LCBCaWdJbnQodmFsdWUpLCAoMCwgYnl0ZXNfanNfMS5lbmRpYW5Ub0Jvb2wpKGVuZGlhbikpO1xuICAgICAgICB0aGlzLmlkeCArPSA4O1xuICAgIH1cbiAgICAvKiogV3JpdGUgdGhlIGdpdmVuIGJ5dGVzICovXG4gICAgcHV0Qnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVTaXplKGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuZGF0YS5zZXQoYnl0ZXMsIHRoaXMuaWR4KTtcbiAgICAgICAgdGhpcy5pZHggKz0gYnl0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICBlbnN1cmVTaXplKGV4dHJhQnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPCB0aGlzLmlkeCArIGV4dHJhQnl0ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGVub3VnaCBieXRlczogVHJpZWQgd3JpdGluZyAke2V4dHJhQnl0ZXN9IGJ5dGUocyksIGJ1dCBgICtcbiAgICAgICAgICAgICAgICBgb25seSAke3RoaXMuZGF0YS5sZW5ndGggLSB0aGlzLmlkeH0gYnl0ZShzKSBoYXZlIGJlZW4gYCArXG4gICAgICAgICAgICAgICAgYHByZS1hbGxvY2F0ZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuV3JpdGVyQnl0ZXMgPSBXcml0ZXJCeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyaXRlcmJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8161\n\n}')},8287:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(7526)\nconst ieee754 = __webpack_require__(251)\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsSUFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz9iNjM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8287\n\n}")},8331:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PluginGroup = exports.PluginEntry = exports.TokenFailedColoring = exports.TokenFailedParsing = exports.Token = exports.GenesisInfo = exports.TokenEntry = exports.TokenInfo = exports.TokenType = exports.BlockMetadata = exports.TxOutput_PluginsEntry = exports.TxOutput = exports.TxInput_PluginsEntry = exports.TxInput = exports.SpentBy = exports.OutPoint = exports.Utxo_PluginsEntry = exports.Utxo = exports.ScriptUtxo_PluginsEntry = exports.ScriptUtxo = exports.Tx = exports.BlockInfo = exports.ChronikInfo = exports.BlockchainInfo = exports.BlockHeaders = exports.BlockHeader = exports.Blocks = exports.Block = exports.txMsgTypeToJSON = exports.txMsgTypeFromJSON = exports.TxMsgType = exports.txFinalizationReasonTypeToJSON = exports.txFinalizationReasonTypeFromJSON = exports.TxFinalizationReasonType = exports.blockMsgTypeToJSON = exports.blockMsgTypeFromJSON = exports.BlockMsgType = exports.tokenTxTypeToJSON = exports.tokenTxTypeFromJSON = exports.TokenTxType = exports.slpTokenTypeToJSON = exports.slpTokenTypeFromJSON = exports.SlpTokenType = exports.alpTokenTypeToJSON = exports.alpTokenTypeFromJSON = exports.AlpTokenType = exports.tokenStatusToJSON = exports.tokenStatusFromJSON = exports.TokenStatus = exports.protobufPackage = void 0;\nexports.Error = exports.Empty = exports.MsgTx = exports.TxFinalizationReason = exports.MsgBlock = exports.CoinbaseData = exports.WsMsg = exports.WsSubTxId = exports.WsPlugin = exports.WsSubLokadId = exports.WsSubTokenId = exports.WsSubScript = exports.WsSubBlocks = exports.WsSub = exports.RawTx = exports.BroadcastTxsResponse = exports.BroadcastTxsRequest = exports.BroadcastTxResponse = exports.BroadcastTxRequest = exports.Utxos = exports.ScriptUtxos = exports.TxHistoryPage = exports.PluginGroups = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(8570));\nconst minimal_1 = __importDefault(__webpack_require__(6946));\nexports.protobufPackage = 'chronik';\n/** Status of a token tx */\nvar TokenStatus;\n(function (TokenStatus) {\n    /**\n     * TOKEN_STATUS_NON_TOKEN - Tx involves no tokens whatsover, i.e. neither any burns nor any failed\n     * parsing/coloring or any tokens being created / moved.\n     */\n    TokenStatus[TokenStatus[\"TOKEN_STATUS_NON_TOKEN\"] = 0] = \"TOKEN_STATUS_NON_TOKEN\";\n    /** TOKEN_STATUS_NORMAL - Tx involves tokens but no unintentional burns or failed parsings/colorings */\n    TokenStatus[TokenStatus[\"TOKEN_STATUS_NORMAL\"] = 1] = \"TOKEN_STATUS_NORMAL\";\n    /** TOKEN_STATUS_NOT_NORMAL - Tx involves tokens but contains unintentional burns or failed parsings/colorings */\n    TokenStatus[TokenStatus[\"TOKEN_STATUS_NOT_NORMAL\"] = 2] = \"TOKEN_STATUS_NOT_NORMAL\";\n    TokenStatus[TokenStatus[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(TokenStatus = exports.TokenStatus || (exports.TokenStatus = {}));\nfunction tokenStatusFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'TOKEN_STATUS_NON_TOKEN':\n            return TokenStatus.TOKEN_STATUS_NON_TOKEN;\n        case 1:\n        case 'TOKEN_STATUS_NORMAL':\n            return TokenStatus.TOKEN_STATUS_NORMAL;\n        case 2:\n        case 'TOKEN_STATUS_NOT_NORMAL':\n            return TokenStatus.TOKEN_STATUS_NOT_NORMAL;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return TokenStatus.UNRECOGNIZED;\n    }\n}\nexports.tokenStatusFromJSON = tokenStatusFromJSON;\nfunction tokenStatusToJSON(object) {\n    switch (object) {\n        case TokenStatus.TOKEN_STATUS_NON_TOKEN:\n            return 'TOKEN_STATUS_NON_TOKEN';\n        case TokenStatus.TOKEN_STATUS_NORMAL:\n            return 'TOKEN_STATUS_NORMAL';\n        case TokenStatus.TOKEN_STATUS_NOT_NORMAL:\n            return 'TOKEN_STATUS_NOT_NORMAL';\n        case TokenStatus.UNRECOGNIZED:\n        default:\n            return 'UNRECOGNIZED';\n    }\n}\nexports.tokenStatusToJSON = tokenStatusToJSON;\n/** ALP token type */\nvar AlpTokenType;\n(function (AlpTokenType) {\n    /** ALP_TOKEN_TYPE_STANDARD - Standard ALP token type */\n    AlpTokenType[AlpTokenType[\"ALP_TOKEN_TYPE_STANDARD\"] = 0] = \"ALP_TOKEN_TYPE_STANDARD\";\n    AlpTokenType[AlpTokenType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(AlpTokenType = exports.AlpTokenType || (exports.AlpTokenType = {}));\nfunction alpTokenTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'ALP_TOKEN_TYPE_STANDARD':\n            return AlpTokenType.ALP_TOKEN_TYPE_STANDARD;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return AlpTokenType.UNRECOGNIZED;\n    }\n}\nexports.alpTokenTypeFromJSON = alpTokenTypeFromJSON;\nfunction alpTokenTypeToJSON(object) {\n    switch (object) {\n        case AlpTokenType.ALP_TOKEN_TYPE_STANDARD:\n            return 'ALP_TOKEN_TYPE_STANDARD';\n        case AlpTokenType.UNRECOGNIZED:\n        default:\n            return 'UNRECOGNIZED';\n    }\n}\nexports.alpTokenTypeToJSON = alpTokenTypeToJSON;\n/** SLP token type */\nvar SlpTokenType;\n(function (SlpTokenType) {\n    /** SLP_TOKEN_TYPE_NONE - Unknown \"0\" token type */\n    SlpTokenType[SlpTokenType[\"SLP_TOKEN_TYPE_NONE\"] = 0] = \"SLP_TOKEN_TYPE_NONE\";\n    /** SLP_TOKEN_TYPE_FUNGIBLE - SLP V1 token type */\n    SlpTokenType[SlpTokenType[\"SLP_TOKEN_TYPE_FUNGIBLE\"] = 1] = \"SLP_TOKEN_TYPE_FUNGIBLE\";\n    /** SLP_TOKEN_TYPE_MINT_VAULT - SLP V2 mint vault token type */\n    SlpTokenType[SlpTokenType[\"SLP_TOKEN_TYPE_MINT_VAULT\"] = 2] = \"SLP_TOKEN_TYPE_MINT_VAULT\";\n    /** SLP_TOKEN_TYPE_NFT1_GROUP - NFT1 group token type */\n    SlpTokenType[SlpTokenType[\"SLP_TOKEN_TYPE_NFT1_GROUP\"] = 129] = \"SLP_TOKEN_TYPE_NFT1_GROUP\";\n    /** SLP_TOKEN_TYPE_NFT1_CHILD - NFT1 child token type */\n    SlpTokenType[SlpTokenType[\"SLP_TOKEN_TYPE_NFT1_CHILD\"] = 65] = \"SLP_TOKEN_TYPE_NFT1_CHILD\";\n    SlpTokenType[SlpTokenType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SlpTokenType = exports.SlpTokenType || (exports.SlpTokenType = {}));\nfunction slpTokenTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'SLP_TOKEN_TYPE_NONE':\n            return SlpTokenType.SLP_TOKEN_TYPE_NONE;\n        case 1:\n        case 'SLP_TOKEN_TYPE_FUNGIBLE':\n            return SlpTokenType.SLP_TOKEN_TYPE_FUNGIBLE;\n        case 2:\n        case 'SLP_TOKEN_TYPE_MINT_VAULT':\n            return SlpTokenType.SLP_TOKEN_TYPE_MINT_VAULT;\n        case 129:\n        case 'SLP_TOKEN_TYPE_NFT1_GROUP':\n            return SlpTokenType.SLP_TOKEN_TYPE_NFT1_GROUP;\n        case 65:\n        case 'SLP_TOKEN_TYPE_NFT1_CHILD':\n            return SlpTokenType.SLP_TOKEN_TYPE_NFT1_CHILD;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return SlpTokenType.UNRECOGNIZED;\n    }\n}\nexports.slpTokenTypeFromJSON = slpTokenTypeFromJSON;\nfunction slpTokenTypeToJSON(object) {\n    switch (object) {\n        case SlpTokenType.SLP_TOKEN_TYPE_NONE:\n            return 'SLP_TOKEN_TYPE_NONE';\n        case SlpTokenType.SLP_TOKEN_TYPE_FUNGIBLE:\n            return 'SLP_TOKEN_TYPE_FUNGIBLE';\n        case SlpTokenType.SLP_TOKEN_TYPE_MINT_VAULT:\n            return 'SLP_TOKEN_TYPE_MINT_VAULT';\n        case SlpTokenType.SLP_TOKEN_TYPE_NFT1_GROUP:\n            return 'SLP_TOKEN_TYPE_NFT1_GROUP';\n        case SlpTokenType.SLP_TOKEN_TYPE_NFT1_CHILD:\n            return 'SLP_TOKEN_TYPE_NFT1_CHILD';\n        case SlpTokenType.UNRECOGNIZED:\n        default:\n            return 'UNRECOGNIZED';\n    }\n}\nexports.slpTokenTypeToJSON = slpTokenTypeToJSON;\n/** SLP/ALP tx type */\nvar TokenTxType;\n(function (TokenTxType) {\n    /** NONE - No tx type, e.g. when input tokens are burned */\n    TokenTxType[TokenTxType[\"NONE\"] = 0] = \"NONE\";\n    /** UNKNOWN - Unknown tx type, i.e. for unknown token types */\n    TokenTxType[TokenTxType[\"UNKNOWN\"] = 1] = \"UNKNOWN\";\n    /** GENESIS - GENESIS tx */\n    TokenTxType[TokenTxType[\"GENESIS\"] = 2] = \"GENESIS\";\n    /** SEND - SEND tx */\n    TokenTxType[TokenTxType[\"SEND\"] = 3] = \"SEND\";\n    /** MINT - MINT tx */\n    TokenTxType[TokenTxType[\"MINT\"] = 4] = \"MINT\";\n    /** BURN - BURN tx */\n    TokenTxType[TokenTxType[\"BURN\"] = 5] = \"BURN\";\n    TokenTxType[TokenTxType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(TokenTxType = exports.TokenTxType || (exports.TokenTxType = {}));\nfunction tokenTxTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'NONE':\n            return TokenTxType.NONE;\n        case 1:\n        case 'UNKNOWN':\n            return TokenTxType.UNKNOWN;\n        case 2:\n        case 'GENESIS':\n            return TokenTxType.GENESIS;\n        case 3:\n        case 'SEND':\n            return TokenTxType.SEND;\n        case 4:\n        case 'MINT':\n            return TokenTxType.MINT;\n        case 5:\n        case 'BURN':\n            return TokenTxType.BURN;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return TokenTxType.UNRECOGNIZED;\n    }\n}\nexports.tokenTxTypeFromJSON = tokenTxTypeFromJSON;\nfunction tokenTxTypeToJSON(object) {\n    switch (object) {\n        case TokenTxType.NONE:\n            return 'NONE';\n        case TokenTxType.UNKNOWN:\n            return 'UNKNOWN';\n        case TokenTxType.GENESIS:\n            return 'GENESIS';\n        case TokenTxType.SEND:\n            return 'SEND';\n        case TokenTxType.MINT:\n            return 'MINT';\n        case TokenTxType.BURN:\n            return 'BURN';\n        case TokenTxType.UNRECOGNIZED:\n        default:\n            return 'UNRECOGNIZED';\n    }\n}\nexports.tokenTxTypeToJSON = tokenTxTypeToJSON;\n/** Type of message for the block */\nvar BlockMsgType;\n(function (BlockMsgType) {\n    /** BLK_CONNECTED - Block connected to the blockchain */\n    BlockMsgType[BlockMsgType[\"BLK_CONNECTED\"] = 0] = \"BLK_CONNECTED\";\n    /** BLK_DISCONNECTED - Block disconnected from the blockchain */\n    BlockMsgType[BlockMsgType[\"BLK_DISCONNECTED\"] = 1] = \"BLK_DISCONNECTED\";\n    /** BLK_FINALIZED - Block has been finalized by Avalanche */\n    BlockMsgType[BlockMsgType[\"BLK_FINALIZED\"] = 2] = \"BLK_FINALIZED\";\n    /** BLK_INVALIDATED - Block has been invalidated by Avalanche */\n    BlockMsgType[BlockMsgType[\"BLK_INVALIDATED\"] = 3] = \"BLK_INVALIDATED\";\n    BlockMsgType[BlockMsgType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(BlockMsgType = exports.BlockMsgType || (exports.BlockMsgType = {}));\nfunction blockMsgTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'BLK_CONNECTED':\n            return BlockMsgType.BLK_CONNECTED;\n        case 1:\n        case 'BLK_DISCONNECTED':\n            return BlockMsgType.BLK_DISCONNECTED;\n        case 2:\n        case 'BLK_FINALIZED':\n            return BlockMsgType.BLK_FINALIZED;\n        case 3:\n        case 'BLK_INVALIDATED':\n            return BlockMsgType.BLK_INVALIDATED;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return BlockMsgType.UNRECOGNIZED;\n    }\n}\nexports.blockMsgTypeFromJSON = blockMsgTypeFromJSON;\nfunction blockMsgTypeToJSON(object) {\n    switch (object) {\n        case BlockMsgType.BLK_CONNECTED:\n            return 'BLK_CONNECTED';\n        case BlockMsgType.BLK_DISCONNECTED:\n            return 'BLK_DISCONNECTED';\n        case BlockMsgType.BLK_FINALIZED:\n            return 'BLK_FINALIZED';\n        case BlockMsgType.BLK_INVALIDATED:\n            return 'BLK_INVALIDATED';\n        case BlockMsgType.UNRECOGNIZED:\n        default:\n            return 'UNRECOGNIZED';\n    }\n}\nexports.blockMsgTypeToJSON = blockMsgTypeToJSON;\n/** Type of tx finalization */\nvar TxFinalizationReasonType;\n(function (TxFinalizationReasonType) {\n    /** TX_FINALIZATION_REASON_POST_CONSENSUS - The transaction is finalized by post-consensus */\n    TxFinalizationReasonType[TxFinalizationReasonType[\"TX_FINALIZATION_REASON_POST_CONSENSUS\"] = 0] = \"TX_FINALIZATION_REASON_POST_CONSENSUS\";\n    /** TX_FINALIZATION_REASON_PRE_CONSENSUS - The transaction is finalized by pre-consensus */\n    TxFinalizationReasonType[TxFinalizationReasonType[\"TX_FINALIZATION_REASON_PRE_CONSENSUS\"] = 1] = \"TX_FINALIZATION_REASON_PRE_CONSENSUS\";\n    TxFinalizationReasonType[TxFinalizationReasonType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(TxFinalizationReasonType = exports.TxFinalizationReasonType || (exports.TxFinalizationReasonType = {}));\nfunction txFinalizationReasonTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'TX_FINALIZATION_REASON_POST_CONSENSUS':\n            return TxFinalizationReasonType.TX_FINALIZATION_REASON_POST_CONSENSUS;\n        case 1:\n        case 'TX_FINALIZATION_REASON_PRE_CONSENSUS':\n            return TxFinalizationReasonType.TX_FINALIZATION_REASON_PRE_CONSENSUS;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return TxFinalizationReasonType.UNRECOGNIZED;\n    }\n}\nexports.txFinalizationReasonTypeFromJSON = txFinalizationReasonTypeFromJSON;\nfunction txFinalizationReasonTypeToJSON(object) {\n    switch (object) {\n        case TxFinalizationReasonType.TX_FINALIZATION_REASON_POST_CONSENSUS:\n            return 'TX_FINALIZATION_REASON_POST_CONSENSUS';\n        case TxFinalizationReasonType.TX_FINALIZATION_REASON_PRE_CONSENSUS:\n            return 'TX_FINALIZATION_REASON_PRE_CONSENSUS';\n        case TxFinalizationReasonType.UNRECOGNIZED:\n        default:\n            return 'UNRECOGNIZED';\n    }\n}\nexports.txFinalizationReasonTypeToJSON = txFinalizationReasonTypeToJSON;\n/** Type of message for a tx */\nvar TxMsgType;\n(function (TxMsgType) {\n    /** TX_ADDED_TO_MEMPOOL - Tx added to the mempool */\n    TxMsgType[TxMsgType[\"TX_ADDED_TO_MEMPOOL\"] = 0] = \"TX_ADDED_TO_MEMPOOL\";\n    /** TX_REMOVED_FROM_MEMPOOL - Tx removed from the mempool */\n    TxMsgType[TxMsgType[\"TX_REMOVED_FROM_MEMPOOL\"] = 1] = \"TX_REMOVED_FROM_MEMPOOL\";\n    /** TX_CONFIRMED - Tx confirmed in a block */\n    TxMsgType[TxMsgType[\"TX_CONFIRMED\"] = 2] = \"TX_CONFIRMED\";\n    /** TX_FINALIZED - Tx finalized by Avalanche */\n    TxMsgType[TxMsgType[\"TX_FINALIZED\"] = 3] = \"TX_FINALIZED\";\n    /** TX_INVALIDATED - Tx invalidated by Avalanche */\n    TxMsgType[TxMsgType[\"TX_INVALIDATED\"] = 4] = \"TX_INVALIDATED\";\n    TxMsgType[TxMsgType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(TxMsgType = exports.TxMsgType || (exports.TxMsgType = {}));\nfunction txMsgTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'TX_ADDED_TO_MEMPOOL':\n            return TxMsgType.TX_ADDED_TO_MEMPOOL;\n        case 1:\n        case 'TX_REMOVED_FROM_MEMPOOL':\n            return TxMsgType.TX_REMOVED_FROM_MEMPOOL;\n        case 2:\n        case 'TX_CONFIRMED':\n            return TxMsgType.TX_CONFIRMED;\n        case 3:\n        case 'TX_FINALIZED':\n            return TxMsgType.TX_FINALIZED;\n        case 4:\n        case 'TX_INVALIDATED':\n            return TxMsgType.TX_INVALIDATED;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return TxMsgType.UNRECOGNIZED;\n    }\n}\nexports.txMsgTypeFromJSON = txMsgTypeFromJSON;\nfunction txMsgTypeToJSON(object) {\n    switch (object) {\n        case TxMsgType.TX_ADDED_TO_MEMPOOL:\n            return 'TX_ADDED_TO_MEMPOOL';\n        case TxMsgType.TX_REMOVED_FROM_MEMPOOL:\n            return 'TX_REMOVED_FROM_MEMPOOL';\n        case TxMsgType.TX_CONFIRMED:\n            return 'TX_CONFIRMED';\n        case TxMsgType.TX_FINALIZED:\n            return 'TX_FINALIZED';\n        case TxMsgType.TX_INVALIDATED:\n            return 'TX_INVALIDATED';\n        case TxMsgType.UNRECOGNIZED:\n        default:\n            return 'UNRECOGNIZED';\n    }\n}\nexports.txMsgTypeToJSON = txMsgTypeToJSON;\nfunction createBaseBlock() {\n    return { blockInfo: undefined };\n}\nexports.Block = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.blockInfo !== undefined) {\n            exports.BlockInfo.encode(message.blockInfo, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlock();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.blockInfo = exports.BlockInfo.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            blockInfo: isSet(object.blockInfo)\n                ? exports.BlockInfo.fromJSON(object.blockInfo)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.blockInfo !== undefined) {\n            obj.blockInfo = exports.BlockInfo.toJSON(message.blockInfo);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.Block.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBlock();\n        message.blockInfo =\n            object.blockInfo !== undefined && object.blockInfo !== null\n                ? exports.BlockInfo.fromPartial(object.blockInfo)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseBlocks() {\n    return { blocks: [] };\n}\nexports.Blocks = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.blocks) {\n            exports.BlockInfo.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlocks();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.blocks.push(exports.BlockInfo.decode(reader, reader.uint32()));\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            blocks: globalThis.Array.isArray(object?.blocks)\n                ? object.blocks.map((e) => exports.BlockInfo.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.blocks?.length) {\n            obj.blocks = message.blocks.map(e => exports.BlockInfo.toJSON(e));\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.Blocks.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBlocks();\n        message.blocks =\n            object.blocks?.map(e => exports.BlockInfo.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseBlockHeader() {\n    return {\n        rawHeader: new Uint8Array(0),\n        root: new Uint8Array(0),\n        branch: [],\n    };\n}\nexports.BlockHeader = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.rawHeader.length !== 0) {\n            writer.uint32(10).bytes(message.rawHeader);\n        }\n        if (message.root.length !== 0) {\n            writer.uint32(18).bytes(message.root);\n        }\n        for (const v of message.branch) {\n            writer.uint32(26).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlockHeader();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.rawHeader = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.root = reader.bytes();\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.branch.push(reader.bytes());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            rawHeader: isSet(object.rawHeader)\n                ? bytesFromBase64(object.rawHeader)\n                : new Uint8Array(0),\n            root: isSet(object.root)\n                ? bytesFromBase64(object.root)\n                : new Uint8Array(0),\n            branch: globalThis.Array.isArray(object?.branch)\n                ? object.branch.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.rawHeader.length !== 0) {\n            obj.rawHeader = base64FromBytes(message.rawHeader);\n        }\n        if (message.root.length !== 0) {\n            obj.root = base64FromBytes(message.root);\n        }\n        if (message.branch?.length) {\n            obj.branch = message.branch.map(e => base64FromBytes(e));\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BlockHeader.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBlockHeader();\n        message.rawHeader = object.rawHeader ?? new Uint8Array(0);\n        message.root = object.root ?? new Uint8Array(0);\n        message.branch = object.branch?.map(e => e) || [];\n        return message;\n    },\n};\nfunction createBaseBlockHeaders() {\n    return { headers: [] };\n}\nexports.BlockHeaders = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.headers) {\n            exports.BlockHeader.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlockHeaders();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.headers.push(exports.BlockHeader.decode(reader, reader.uint32()));\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            headers: globalThis.Array.isArray(object?.headers)\n                ? object.headers.map((e) => exports.BlockHeader.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.headers?.length) {\n            obj.headers = message.headers.map(e => exports.BlockHeader.toJSON(e));\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BlockHeaders.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBlockHeaders();\n        message.headers =\n            object.headers?.map(e => exports.BlockHeader.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseBlockchainInfo() {\n    return { tipHash: new Uint8Array(0), tipHeight: 0 };\n}\nexports.BlockchainInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.tipHash.length !== 0) {\n            writer.uint32(10).bytes(message.tipHash);\n        }\n        if (message.tipHeight !== 0) {\n            writer.uint32(16).int32(message.tipHeight);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlockchainInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.tipHash = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.tipHeight = reader.int32();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            tipHash: isSet(object.tipHash)\n                ? bytesFromBase64(object.tipHash)\n                : new Uint8Array(0),\n            tipHeight: isSet(object.tipHeight)\n                ? globalThis.Number(object.tipHeight)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.tipHash.length !== 0) {\n            obj.tipHash = base64FromBytes(message.tipHash);\n        }\n        if (message.tipHeight !== 0) {\n            obj.tipHeight = Math.round(message.tipHeight);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BlockchainInfo.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBlockchainInfo();\n        message.tipHash = object.tipHash ?? new Uint8Array(0);\n        message.tipHeight = object.tipHeight ?? 0;\n        return message;\n    },\n};\nfunction createBaseChronikInfo() {\n    return { version: '' };\n}\nexports.ChronikInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.version !== '') {\n            writer.uint32(10).string(message.version);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseChronikInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.version = reader.string();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            version: isSet(object.version)\n                ? globalThis.String(object.version)\n                : '',\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.version !== '') {\n            obj.version = message.version;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.ChronikInfo.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseChronikInfo();\n        message.version = object.version ?? '';\n        return message;\n    },\n};\nfunction createBaseBlockInfo() {\n    return {\n        hash: new Uint8Array(0),\n        prevHash: new Uint8Array(0),\n        height: 0,\n        nBits: 0,\n        timestamp: BigInt('0'),\n        isFinal: false,\n        blockSize: BigInt('0'),\n        numTxs: BigInt('0'),\n        numInputs: BigInt('0'),\n        numOutputs: BigInt('0'),\n        sumInputSats: BigInt('0'),\n        sumCoinbaseOutputSats: BigInt('0'),\n        sumNormalOutputSats: BigInt('0'),\n        sumBurnedSats: BigInt('0'),\n    };\n}\nexports.BlockInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.hash.length !== 0) {\n            writer.uint32(10).bytes(message.hash);\n        }\n        if (message.prevHash.length !== 0) {\n            writer.uint32(18).bytes(message.prevHash);\n        }\n        if (message.height !== 0) {\n            writer.uint32(24).int32(message.height);\n        }\n        if (message.nBits !== 0) {\n            writer.uint32(32).uint32(message.nBits);\n        }\n        if (message.timestamp !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.timestamp) !== message.timestamp) {\n                throw new globalThis.Error('value provided for field message.timestamp of type int64 too large');\n            }\n            writer.uint32(40).int64(message.timestamp.toString());\n        }\n        if (message.isFinal === true) {\n            writer.uint32(112).bool(message.isFinal);\n        }\n        if (message.blockSize !== BigInt('0')) {\n            if (BigInt.asUintN(64, message.blockSize) !== message.blockSize) {\n                throw new globalThis.Error('value provided for field message.blockSize of type uint64 too large');\n            }\n            writer.uint32(48).uint64(message.blockSize.toString());\n        }\n        if (message.numTxs !== BigInt('0')) {\n            if (BigInt.asUintN(64, message.numTxs) !== message.numTxs) {\n                throw new globalThis.Error('value provided for field message.numTxs of type uint64 too large');\n            }\n            writer.uint32(56).uint64(message.numTxs.toString());\n        }\n        if (message.numInputs !== BigInt('0')) {\n            if (BigInt.asUintN(64, message.numInputs) !== message.numInputs) {\n                throw new globalThis.Error('value provided for field message.numInputs of type uint64 too large');\n            }\n            writer.uint32(64).uint64(message.numInputs.toString());\n        }\n        if (message.numOutputs !== BigInt('0')) {\n            if (BigInt.asUintN(64, message.numOutputs) !== message.numOutputs) {\n                throw new globalThis.Error('value provided for field message.numOutputs of type uint64 too large');\n            }\n            writer.uint32(72).uint64(message.numOutputs.toString());\n        }\n        if (message.sumInputSats !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.sumInputSats) !== message.sumInputSats) {\n                throw new globalThis.Error('value provided for field message.sumInputSats of type int64 too large');\n            }\n            writer.uint32(80).int64(message.sumInputSats.toString());\n        }\n        if (message.sumCoinbaseOutputSats !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.sumCoinbaseOutputSats) !==\n                message.sumCoinbaseOutputSats) {\n                throw new globalThis.Error('value provided for field message.sumCoinbaseOutputSats of type int64 too large');\n            }\n            writer.uint32(88).int64(message.sumCoinbaseOutputSats.toString());\n        }\n        if (message.sumNormalOutputSats !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.sumNormalOutputSats) !==\n                message.sumNormalOutputSats) {\n                throw new globalThis.Error('value provided for field message.sumNormalOutputSats of type int64 too large');\n            }\n            writer.uint32(96).int64(message.sumNormalOutputSats.toString());\n        }\n        if (message.sumBurnedSats !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.sumBurnedSats) !==\n                message.sumBurnedSats) {\n                throw new globalThis.Error('value provided for field message.sumBurnedSats of type int64 too large');\n            }\n            writer.uint32(104).int64(message.sumBurnedSats.toString());\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlockInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.hash = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.prevHash = reader.bytes();\n                    continue;\n                case 3:\n                    if (tag !== 24) {\n                        break;\n                    }\n                    message.height = reader.int32();\n                    continue;\n                case 4:\n                    if (tag !== 32) {\n                        break;\n                    }\n                    message.nBits = reader.uint32();\n                    continue;\n                case 5:\n                    if (tag !== 40) {\n                        break;\n                    }\n                    message.timestamp = longToBigint(reader.int64());\n                    continue;\n                case 14:\n                    if (tag !== 112) {\n                        break;\n                    }\n                    message.isFinal = reader.bool();\n                    continue;\n                case 6:\n                    if (tag !== 48) {\n                        break;\n                    }\n                    message.blockSize = longToBigint(reader.uint64());\n                    continue;\n                case 7:\n                    if (tag !== 56) {\n                        break;\n                    }\n                    message.numTxs = longToBigint(reader.uint64());\n                    continue;\n                case 8:\n                    if (tag !== 64) {\n                        break;\n                    }\n                    message.numInputs = longToBigint(reader.uint64());\n                    continue;\n                case 9:\n                    if (tag !== 72) {\n                        break;\n                    }\n                    message.numOutputs = longToBigint(reader.uint64());\n                    continue;\n                case 10:\n                    if (tag !== 80) {\n                        break;\n                    }\n                    message.sumInputSats = longToBigint(reader.int64());\n                    continue;\n                case 11:\n                    if (tag !== 88) {\n                        break;\n                    }\n                    message.sumCoinbaseOutputSats = longToBigint(reader.int64());\n                    continue;\n                case 12:\n                    if (tag !== 96) {\n                        break;\n                    }\n                    message.sumNormalOutputSats = longToBigint(reader.int64());\n                    continue;\n                case 13:\n                    if (tag !== 104) {\n                        break;\n                    }\n                    message.sumBurnedSats = longToBigint(reader.int64());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            hash: isSet(object.hash)\n                ? bytesFromBase64(object.hash)\n                : new Uint8Array(0),\n            prevHash: isSet(object.prevHash)\n                ? bytesFromBase64(object.prevHash)\n                : new Uint8Array(0),\n            height: isSet(object.height) ? globalThis.Number(object.height) : 0,\n            nBits: isSet(object.nBits) ? globalThis.Number(object.nBits) : 0,\n            timestamp: isSet(object.timestamp)\n                ? BigInt(object.timestamp)\n                : BigInt('0'),\n            isFinal: isSet(object.isFinal)\n                ? globalThis.Boolean(object.isFinal)\n                : false,\n            blockSize: isSet(object.blockSize)\n                ? BigInt(object.blockSize)\n                : BigInt('0'),\n            numTxs: isSet(object.numTxs) ? BigInt(object.numTxs) : BigInt('0'),\n            numInputs: isSet(object.numInputs)\n                ? BigInt(object.numInputs)\n                : BigInt('0'),\n            numOutputs: isSet(object.numOutputs)\n                ? BigInt(object.numOutputs)\n                : BigInt('0'),\n            sumInputSats: isSet(object.sumInputSats)\n                ? BigInt(object.sumInputSats)\n                : BigInt('0'),\n            sumCoinbaseOutputSats: isSet(object.sumCoinbaseOutputSats)\n                ? BigInt(object.sumCoinbaseOutputSats)\n                : BigInt('0'),\n            sumNormalOutputSats: isSet(object.sumNormalOutputSats)\n                ? BigInt(object.sumNormalOutputSats)\n                : BigInt('0'),\n            sumBurnedSats: isSet(object.sumBurnedSats)\n                ? BigInt(object.sumBurnedSats)\n                : BigInt('0'),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.hash.length !== 0) {\n            obj.hash = base64FromBytes(message.hash);\n        }\n        if (message.prevHash.length !== 0) {\n            obj.prevHash = base64FromBytes(message.prevHash);\n        }\n        if (message.height !== 0) {\n            obj.height = Math.round(message.height);\n        }\n        if (message.nBits !== 0) {\n            obj.nBits = Math.round(message.nBits);\n        }\n        if (message.timestamp !== BigInt('0')) {\n            obj.timestamp = message.timestamp.toString();\n        }\n        if (message.isFinal === true) {\n            obj.isFinal = message.isFinal;\n        }\n        if (message.blockSize !== BigInt('0')) {\n            obj.blockSize = message.blockSize.toString();\n        }\n        if (message.numTxs !== BigInt('0')) {\n            obj.numTxs = message.numTxs.toString();\n        }\n        if (message.numInputs !== BigInt('0')) {\n            obj.numInputs = message.numInputs.toString();\n        }\n        if (message.numOutputs !== BigInt('0')) {\n            obj.numOutputs = message.numOutputs.toString();\n        }\n        if (message.sumInputSats !== BigInt('0')) {\n            obj.sumInputSats = message.sumInputSats.toString();\n        }\n        if (message.sumCoinbaseOutputSats !== BigInt('0')) {\n            obj.sumCoinbaseOutputSats =\n                message.sumCoinbaseOutputSats.toString();\n        }\n        if (message.sumNormalOutputSats !== BigInt('0')) {\n            obj.sumNormalOutputSats = message.sumNormalOutputSats.toString();\n        }\n        if (message.sumBurnedSats !== BigInt('0')) {\n            obj.sumBurnedSats = message.sumBurnedSats.toString();\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BlockInfo.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBlockInfo();\n        message.hash = object.hash ?? new Uint8Array(0);\n        message.prevHash = object.prevHash ?? new Uint8Array(0);\n        message.height = object.height ?? 0;\n        message.nBits = object.nBits ?? 0;\n        message.timestamp = object.timestamp ?? BigInt('0');\n        message.isFinal = object.isFinal ?? false;\n        message.blockSize = object.blockSize ?? BigInt('0');\n        message.numTxs = object.numTxs ?? BigInt('0');\n        message.numInputs = object.numInputs ?? BigInt('0');\n        message.numOutputs = object.numOutputs ?? BigInt('0');\n        message.sumInputSats = object.sumInputSats ?? BigInt('0');\n        message.sumCoinbaseOutputSats =\n            object.sumCoinbaseOutputSats ?? BigInt('0');\n        message.sumNormalOutputSats = object.sumNormalOutputSats ?? BigInt('0');\n        message.sumBurnedSats = object.sumBurnedSats ?? BigInt('0');\n        return message;\n    },\n};\nfunction createBaseTx() {\n    return {\n        txid: new Uint8Array(0),\n        version: 0,\n        inputs: [],\n        outputs: [],\n        lockTime: 0,\n        block: undefined,\n        timeFirstSeen: BigInt('0'),\n        size: 0,\n        isCoinbase: false,\n        tokenEntries: [],\n        tokenFailedParsings: [],\n        tokenStatus: 0,\n        isFinal: false,\n    };\n}\nexports.Tx = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.txid.length !== 0) {\n            writer.uint32(10).bytes(message.txid);\n        }\n        if (message.version !== 0) {\n            writer.uint32(16).int32(message.version);\n        }\n        for (const v of message.inputs) {\n            exports.TxInput.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        for (const v of message.outputs) {\n            exports.TxOutput.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.lockTime !== 0) {\n            writer.uint32(40).uint32(message.lockTime);\n        }\n        if (message.block !== undefined) {\n            exports.BlockMetadata.encode(message.block, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.timeFirstSeen !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.timeFirstSeen) !==\n                message.timeFirstSeen) {\n                throw new globalThis.Error('value provided for field message.timeFirstSeen of type int64 too large');\n            }\n            writer.uint32(72).int64(message.timeFirstSeen.toString());\n        }\n        if (message.size !== 0) {\n            writer.uint32(88).uint32(message.size);\n        }\n        if (message.isCoinbase === true) {\n            writer.uint32(96).bool(message.isCoinbase);\n        }\n        for (const v of message.tokenEntries) {\n            exports.TokenEntry.encode(v, writer.uint32(106).fork()).ldelim();\n        }\n        for (const v of message.tokenFailedParsings) {\n            exports.TokenFailedParsing.encode(v, writer.uint32(114).fork()).ldelim();\n        }\n        if (message.tokenStatus !== 0) {\n            writer.uint32(120).int32(message.tokenStatus);\n        }\n        if (message.isFinal === true) {\n            writer.uint32(128).bool(message.isFinal);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTx();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.txid = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.version = reader.int32();\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.inputs.push(exports.TxInput.decode(reader, reader.uint32()));\n                    continue;\n                case 4:\n                    if (tag !== 34) {\n                        break;\n                    }\n                    message.outputs.push(exports.TxOutput.decode(reader, reader.uint32()));\n                    continue;\n                case 5:\n                    if (tag !== 40) {\n                        break;\n                    }\n                    message.lockTime = reader.uint32();\n                    continue;\n                case 8:\n                    if (tag !== 66) {\n                        break;\n                    }\n                    message.block = exports.BlockMetadata.decode(reader, reader.uint32());\n                    continue;\n                case 9:\n                    if (tag !== 72) {\n                        break;\n                    }\n                    message.timeFirstSeen = longToBigint(reader.int64());\n                    continue;\n                case 11:\n                    if (tag !== 88) {\n                        break;\n                    }\n                    message.size = reader.uint32();\n                    continue;\n                case 12:\n                    if (tag !== 96) {\n                        break;\n                    }\n                    message.isCoinbase = reader.bool();\n                    continue;\n                case 13:\n                    if (tag !== 106) {\n                        break;\n                    }\n                    message.tokenEntries.push(exports.TokenEntry.decode(reader, reader.uint32()));\n                    continue;\n                case 14:\n                    if (tag !== 114) {\n                        break;\n                    }\n                    message.tokenFailedParsings.push(exports.TokenFailedParsing.decode(reader, reader.uint32()));\n                    continue;\n                case 15:\n                    if (tag !== 120) {\n                        break;\n                    }\n                    message.tokenStatus = reader.int32();\n                    continue;\n                case 16:\n                    if (tag !== 128) {\n                        break;\n                    }\n                    message.isFinal = reader.bool();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            txid: isSet(object.txid)\n                ? bytesFromBase64(object.txid)\n                : new Uint8Array(0),\n            version: isSet(object.version)\n                ? globalThis.Number(object.version)\n                : 0,\n            inputs: globalThis.Array.isArray(object?.inputs)\n                ? object.inputs.map((e) => exports.TxInput.fromJSON(e))\n                : [],\n            outputs: globalThis.Array.isArray(object?.outputs)\n                ? object.outputs.map((e) => exports.TxOutput.fromJSON(e))\n                : [],\n            lockTime: isSet(object.lockTime)\n                ? globalThis.Number(object.lockTime)\n                : 0,\n            block: isSet(object.block)\n                ? exports.BlockMetadata.fromJSON(object.block)\n                : undefined,\n            timeFirstSeen: isSet(object.timeFirstSeen)\n                ? BigInt(object.timeFirstSeen)\n                : BigInt('0'),\n            size: isSet(object.size) ? globalThis.Number(object.size) : 0,\n            isCoinbase: isSet(object.isCoinbase)\n                ? globalThis.Boolean(object.isCoinbase)\n                : false,\n            tokenEntries: globalThis.Array.isArray(object?.tokenEntries)\n                ? object.tokenEntries.map((e) => exports.TokenEntry.fromJSON(e))\n                : [],\n            tokenFailedParsings: globalThis.Array.isArray(object?.tokenFailedParsings)\n                ? object.tokenFailedParsings.map((e) => exports.TokenFailedParsing.fromJSON(e))\n                : [],\n            tokenStatus: isSet(object.tokenStatus)\n                ? tokenStatusFromJSON(object.tokenStatus)\n                : 0,\n            isFinal: isSet(object.isFinal)\n                ? globalThis.Boolean(object.isFinal)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.txid.length !== 0) {\n            obj.txid = base64FromBytes(message.txid);\n        }\n        if (message.version !== 0) {\n            obj.version = Math.round(message.version);\n        }\n        if (message.inputs?.length) {\n            obj.inputs = message.inputs.map(e => exports.TxInput.toJSON(e));\n        }\n        if (message.outputs?.length) {\n            obj.outputs = message.outputs.map(e => exports.TxOutput.toJSON(e));\n        }\n        if (message.lockTime !== 0) {\n            obj.lockTime = Math.round(message.lockTime);\n        }\n        if (message.block !== undefined) {\n            obj.block = exports.BlockMetadata.toJSON(message.block);\n        }\n        if (message.timeFirstSeen !== BigInt('0')) {\n            obj.timeFirstSeen = message.timeFirstSeen.toString();\n        }\n        if (message.size !== 0) {\n            obj.size = Math.round(message.size);\n        }\n        if (message.isCoinbase === true) {\n            obj.isCoinbase = message.isCoinbase;\n        }\n        if (message.tokenEntries?.length) {\n            obj.tokenEntries = message.tokenEntries.map(e => exports.TokenEntry.toJSON(e));\n        }\n        if (message.tokenFailedParsings?.length) {\n            obj.tokenFailedParsings = message.tokenFailedParsings.map(e => exports.TokenFailedParsing.toJSON(e));\n        }\n        if (message.tokenStatus !== 0) {\n            obj.tokenStatus = tokenStatusToJSON(message.tokenStatus);\n        }\n        if (message.isFinal === true) {\n            obj.isFinal = message.isFinal;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.Tx.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTx();\n        message.txid = object.txid ?? new Uint8Array(0);\n        message.version = object.version ?? 0;\n        message.inputs = object.inputs?.map(e => exports.TxInput.fromPartial(e)) || [];\n        message.outputs =\n            object.outputs?.map(e => exports.TxOutput.fromPartial(e)) || [];\n        message.lockTime = object.lockTime ?? 0;\n        message.block =\n            object.block !== undefined && object.block !== null\n                ? exports.BlockMetadata.fromPartial(object.block)\n                : undefined;\n        message.timeFirstSeen = object.timeFirstSeen ?? BigInt('0');\n        message.size = object.size ?? 0;\n        message.isCoinbase = object.isCoinbase ?? false;\n        message.tokenEntries =\n            object.tokenEntries?.map(e => exports.TokenEntry.fromPartial(e)) || [];\n        message.tokenFailedParsings =\n            object.tokenFailedParsings?.map(e => exports.TokenFailedParsing.fromPartial(e)) || [];\n        message.tokenStatus = object.tokenStatus ?? 0;\n        message.isFinal = object.isFinal ?? false;\n        return message;\n    },\n};\nfunction createBaseScriptUtxo() {\n    return {\n        outpoint: undefined,\n        blockHeight: 0,\n        isCoinbase: false,\n        sats: BigInt('0'),\n        isFinal: false,\n        token: undefined,\n        plugins: {},\n    };\n}\nexports.ScriptUtxo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.outpoint !== undefined) {\n            exports.OutPoint.encode(message.outpoint, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.blockHeight !== 0) {\n            writer.uint32(16).int32(message.blockHeight);\n        }\n        if (message.isCoinbase === true) {\n            writer.uint32(24).bool(message.isCoinbase);\n        }\n        if (message.sats !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.sats) !== message.sats) {\n                throw new globalThis.Error('value provided for field message.sats of type int64 too large');\n            }\n            writer.uint32(40).int64(message.sats.toString());\n        }\n        if (message.isFinal === true) {\n            writer.uint32(80).bool(message.isFinal);\n        }\n        if (message.token !== undefined) {\n            exports.Token.encode(message.token, writer.uint32(90).fork()).ldelim();\n        }\n        Object.entries(message.plugins).forEach(([key, value]) => {\n            exports.ScriptUtxo_PluginsEntry.encode({ key: key, value }, writer.uint32(98).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseScriptUtxo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.outpoint = exports.OutPoint.decode(reader, reader.uint32());\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.blockHeight = reader.int32();\n                    continue;\n                case 3:\n                    if (tag !== 24) {\n                        break;\n                    }\n                    message.isCoinbase = reader.bool();\n                    continue;\n                case 5:\n                    if (tag !== 40) {\n                        break;\n                    }\n                    message.sats = longToBigint(reader.int64());\n                    continue;\n                case 10:\n                    if (tag !== 80) {\n                        break;\n                    }\n                    message.isFinal = reader.bool();\n                    continue;\n                case 11:\n                    if (tag !== 90) {\n                        break;\n                    }\n                    message.token = exports.Token.decode(reader, reader.uint32());\n                    continue;\n                case 12:\n                    if (tag !== 98) {\n                        break;\n                    }\n                    const entry12 = exports.ScriptUtxo_PluginsEntry.decode(reader, reader.uint32());\n                    if (entry12.value !== undefined) {\n                        message.plugins[entry12.key] = entry12.value;\n                    }\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            outpoint: isSet(object.outpoint)\n                ? exports.OutPoint.fromJSON(object.outpoint)\n                : undefined,\n            blockHeight: isSet(object.blockHeight)\n                ? globalThis.Number(object.blockHeight)\n                : 0,\n            isCoinbase: isSet(object.isCoinbase)\n                ? globalThis.Boolean(object.isCoinbase)\n                : false,\n            sats: isSet(object.sats) ? BigInt(object.sats) : BigInt('0'),\n            isFinal: isSet(object.isFinal)\n                ? globalThis.Boolean(object.isFinal)\n                : false,\n            token: isSet(object.token)\n                ? exports.Token.fromJSON(object.token)\n                : undefined,\n            plugins: isObject(object.plugins)\n                ? Object.entries(object.plugins).reduce((acc, [key, value]) => {\n                    acc[key] = exports.PluginEntry.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.outpoint !== undefined) {\n            obj.outpoint = exports.OutPoint.toJSON(message.outpoint);\n        }\n        if (message.blockHeight !== 0) {\n            obj.blockHeight = Math.round(message.blockHeight);\n        }\n        if (message.isCoinbase === true) {\n            obj.isCoinbase = message.isCoinbase;\n        }\n        if (message.sats !== BigInt('0')) {\n            obj.sats = message.sats.toString();\n        }\n        if (message.isFinal === true) {\n            obj.isFinal = message.isFinal;\n        }\n        if (message.token !== undefined) {\n            obj.token = exports.Token.toJSON(message.token);\n        }\n        if (message.plugins) {\n            const entries = Object.entries(message.plugins);\n            if (entries.length > 0) {\n                obj.plugins = {};\n                entries.forEach(([k, v]) => {\n                    obj.plugins[k] = exports.PluginEntry.toJSON(v);\n                });\n            }\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.ScriptUtxo.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseScriptUtxo();\n        message.outpoint =\n            object.outpoint !== undefined && object.outpoint !== null\n                ? exports.OutPoint.fromPartial(object.outpoint)\n                : undefined;\n        message.blockHeight = object.blockHeight ?? 0;\n        message.isCoinbase = object.isCoinbase ?? false;\n        message.sats = object.sats ?? BigInt('0');\n        message.isFinal = object.isFinal ?? false;\n        message.token =\n            object.token !== undefined && object.token !== null\n                ? exports.Token.fromPartial(object.token)\n                : undefined;\n        message.plugins = Object.entries(object.plugins ?? {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = exports.PluginEntry.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseScriptUtxo_PluginsEntry() {\n    return { key: '', value: undefined };\n}\nexports.ScriptUtxo_PluginsEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key !== '') {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            exports.PluginEntry.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseScriptUtxo_PluginsEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.key = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.value = exports.PluginEntry.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? globalThis.String(object.key) : '',\n            value: isSet(object.value)\n                ? exports.PluginEntry.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.key !== '') {\n            obj.key = message.key;\n        }\n        if (message.value !== undefined) {\n            obj.value = exports.PluginEntry.toJSON(message.value);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.ScriptUtxo_PluginsEntry.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseScriptUtxo_PluginsEntry();\n        message.key = object.key ?? '';\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? exports.PluginEntry.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseUtxo() {\n    return {\n        outpoint: undefined,\n        blockHeight: 0,\n        isCoinbase: false,\n        sats: BigInt('0'),\n        script: new Uint8Array(0),\n        isFinal: false,\n        token: undefined,\n        plugins: {},\n    };\n}\nexports.Utxo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.outpoint !== undefined) {\n            exports.OutPoint.encode(message.outpoint, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.blockHeight !== 0) {\n            writer.uint32(16).int32(message.blockHeight);\n        }\n        if (message.isCoinbase === true) {\n            writer.uint32(24).bool(message.isCoinbase);\n        }\n        if (message.sats !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.sats) !== message.sats) {\n                throw new globalThis.Error('value provided for field message.sats of type int64 too large');\n            }\n            writer.uint32(32).int64(message.sats.toString());\n        }\n        if (message.script.length !== 0) {\n            writer.uint32(42).bytes(message.script);\n        }\n        if (message.isFinal === true) {\n            writer.uint32(48).bool(message.isFinal);\n        }\n        if (message.token !== undefined) {\n            exports.Token.encode(message.token, writer.uint32(58).fork()).ldelim();\n        }\n        Object.entries(message.plugins).forEach(([key, value]) => {\n            exports.Utxo_PluginsEntry.encode({ key: key, value }, writer.uint32(66).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUtxo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.outpoint = exports.OutPoint.decode(reader, reader.uint32());\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.blockHeight = reader.int32();\n                    continue;\n                case 3:\n                    if (tag !== 24) {\n                        break;\n                    }\n                    message.isCoinbase = reader.bool();\n                    continue;\n                case 4:\n                    if (tag !== 32) {\n                        break;\n                    }\n                    message.sats = longToBigint(reader.int64());\n                    continue;\n                case 5:\n                    if (tag !== 42) {\n                        break;\n                    }\n                    message.script = reader.bytes();\n                    continue;\n                case 6:\n                    if (tag !== 48) {\n                        break;\n                    }\n                    message.isFinal = reader.bool();\n                    continue;\n                case 7:\n                    if (tag !== 58) {\n                        break;\n                    }\n                    message.token = exports.Token.decode(reader, reader.uint32());\n                    continue;\n                case 8:\n                    if (tag !== 66) {\n                        break;\n                    }\n                    const entry8 = exports.Utxo_PluginsEntry.decode(reader, reader.uint32());\n                    if (entry8.value !== undefined) {\n                        message.plugins[entry8.key] = entry8.value;\n                    }\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            outpoint: isSet(object.outpoint)\n                ? exports.OutPoint.fromJSON(object.outpoint)\n                : undefined,\n            blockHeight: isSet(object.blockHeight)\n                ? globalThis.Number(object.blockHeight)\n                : 0,\n            isCoinbase: isSet(object.isCoinbase)\n                ? globalThis.Boolean(object.isCoinbase)\n                : false,\n            sats: isSet(object.sats) ? BigInt(object.sats) : BigInt('0'),\n            script: isSet(object.script)\n                ? bytesFromBase64(object.script)\n                : new Uint8Array(0),\n            isFinal: isSet(object.isFinal)\n                ? globalThis.Boolean(object.isFinal)\n                : false,\n            token: isSet(object.token)\n                ? exports.Token.fromJSON(object.token)\n                : undefined,\n            plugins: isObject(object.plugins)\n                ? Object.entries(object.plugins).reduce((acc, [key, value]) => {\n                    acc[key] = exports.PluginEntry.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.outpoint !== undefined) {\n            obj.outpoint = exports.OutPoint.toJSON(message.outpoint);\n        }\n        if (message.blockHeight !== 0) {\n            obj.blockHeight = Math.round(message.blockHeight);\n        }\n        if (message.isCoinbase === true) {\n            obj.isCoinbase = message.isCoinbase;\n        }\n        if (message.sats !== BigInt('0')) {\n            obj.sats = message.sats.toString();\n        }\n        if (message.script.length !== 0) {\n            obj.script = base64FromBytes(message.script);\n        }\n        if (message.isFinal === true) {\n            obj.isFinal = message.isFinal;\n        }\n        if (message.token !== undefined) {\n            obj.token = exports.Token.toJSON(message.token);\n        }\n        if (message.plugins) {\n            const entries = Object.entries(message.plugins);\n            if (entries.length > 0) {\n                obj.plugins = {};\n                entries.forEach(([k, v]) => {\n                    obj.plugins[k] = exports.PluginEntry.toJSON(v);\n                });\n            }\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.Utxo.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseUtxo();\n        message.outpoint =\n            object.outpoint !== undefined && object.outpoint !== null\n                ? exports.OutPoint.fromPartial(object.outpoint)\n                : undefined;\n        message.blockHeight = object.blockHeight ?? 0;\n        message.isCoinbase = object.isCoinbase ?? false;\n        message.sats = object.sats ?? BigInt('0');\n        message.script = object.script ?? new Uint8Array(0);\n        message.isFinal = object.isFinal ?? false;\n        message.token =\n            object.token !== undefined && object.token !== null\n                ? exports.Token.fromPartial(object.token)\n                : undefined;\n        message.plugins = Object.entries(object.plugins ?? {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = exports.PluginEntry.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseUtxo_PluginsEntry() {\n    return { key: '', value: undefined };\n}\nexports.Utxo_PluginsEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key !== '') {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            exports.PluginEntry.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUtxo_PluginsEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.key = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.value = exports.PluginEntry.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? globalThis.String(object.key) : '',\n            value: isSet(object.value)\n                ? exports.PluginEntry.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.key !== '') {\n            obj.key = message.key;\n        }\n        if (message.value !== undefined) {\n            obj.value = exports.PluginEntry.toJSON(message.value);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.Utxo_PluginsEntry.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseUtxo_PluginsEntry();\n        message.key = object.key ?? '';\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? exports.PluginEntry.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseOutPoint() {\n    return { txid: new Uint8Array(0), outIdx: 0 };\n}\nexports.OutPoint = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.txid.length !== 0) {\n            writer.uint32(10).bytes(message.txid);\n        }\n        if (message.outIdx !== 0) {\n            writer.uint32(16).uint32(message.outIdx);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOutPoint();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.txid = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.outIdx = reader.uint32();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            txid: isSet(object.txid)\n                ? bytesFromBase64(object.txid)\n                : new Uint8Array(0),\n            outIdx: isSet(object.outIdx) ? globalThis.Number(object.outIdx) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.txid.length !== 0) {\n            obj.txid = base64FromBytes(message.txid);\n        }\n        if (message.outIdx !== 0) {\n            obj.outIdx = Math.round(message.outIdx);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.OutPoint.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseOutPoint();\n        message.txid = object.txid ?? new Uint8Array(0);\n        message.outIdx = object.outIdx ?? 0;\n        return message;\n    },\n};\nfunction createBaseSpentBy() {\n    return { txid: new Uint8Array(0), inputIdx: 0 };\n}\nexports.SpentBy = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.txid.length !== 0) {\n            writer.uint32(10).bytes(message.txid);\n        }\n        if (message.inputIdx !== 0) {\n            writer.uint32(16).uint32(message.inputIdx);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSpentBy();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.txid = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.inputIdx = reader.uint32();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            txid: isSet(object.txid)\n                ? bytesFromBase64(object.txid)\n                : new Uint8Array(0),\n            inputIdx: isSet(object.inputIdx)\n                ? globalThis.Number(object.inputIdx)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.txid.length !== 0) {\n            obj.txid = base64FromBytes(message.txid);\n        }\n        if (message.inputIdx !== 0) {\n            obj.inputIdx = Math.round(message.inputIdx);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.SpentBy.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseSpentBy();\n        message.txid = object.txid ?? new Uint8Array(0);\n        message.inputIdx = object.inputIdx ?? 0;\n        return message;\n    },\n};\nfunction createBaseTxInput() {\n    return {\n        prevOut: undefined,\n        inputScript: new Uint8Array(0),\n        outputScript: new Uint8Array(0),\n        sats: BigInt('0'),\n        sequenceNo: 0,\n        token: undefined,\n        plugins: {},\n    };\n}\nexports.TxInput = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.prevOut !== undefined) {\n            exports.OutPoint.encode(message.prevOut, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.inputScript.length !== 0) {\n            writer.uint32(18).bytes(message.inputScript);\n        }\n        if (message.outputScript.length !== 0) {\n            writer.uint32(26).bytes(message.outputScript);\n        }\n        if (message.sats !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.sats) !== message.sats) {\n                throw new globalThis.Error('value provided for field message.sats of type int64 too large');\n            }\n            writer.uint32(32).int64(message.sats.toString());\n        }\n        if (message.sequenceNo !== 0) {\n            writer.uint32(40).uint32(message.sequenceNo);\n        }\n        if (message.token !== undefined) {\n            exports.Token.encode(message.token, writer.uint32(66).fork()).ldelim();\n        }\n        Object.entries(message.plugins).forEach(([key, value]) => {\n            exports.TxInput_PluginsEntry.encode({ key: key, value }, writer.uint32(74).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxInput();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.prevOut = exports.OutPoint.decode(reader, reader.uint32());\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.inputScript = reader.bytes();\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.outputScript = reader.bytes();\n                    continue;\n                case 4:\n                    if (tag !== 32) {\n                        break;\n                    }\n                    message.sats = longToBigint(reader.int64());\n                    continue;\n                case 5:\n                    if (tag !== 40) {\n                        break;\n                    }\n                    message.sequenceNo = reader.uint32();\n                    continue;\n                case 8:\n                    if (tag !== 66) {\n                        break;\n                    }\n                    message.token = exports.Token.decode(reader, reader.uint32());\n                    continue;\n                case 9:\n                    if (tag !== 74) {\n                        break;\n                    }\n                    const entry9 = exports.TxInput_PluginsEntry.decode(reader, reader.uint32());\n                    if (entry9.value !== undefined) {\n                        message.plugins[entry9.key] = entry9.value;\n                    }\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            prevOut: isSet(object.prevOut)\n                ? exports.OutPoint.fromJSON(object.prevOut)\n                : undefined,\n            inputScript: isSet(object.inputScript)\n                ? bytesFromBase64(object.inputScript)\n                : new Uint8Array(0),\n            outputScript: isSet(object.outputScript)\n                ? bytesFromBase64(object.outputScript)\n                : new Uint8Array(0),\n            sats: isSet(object.sats) ? BigInt(object.sats) : BigInt('0'),\n            sequenceNo: isSet(object.sequenceNo)\n                ? globalThis.Number(object.sequenceNo)\n                : 0,\n            token: isSet(object.token)\n                ? exports.Token.fromJSON(object.token)\n                : undefined,\n            plugins: isObject(object.plugins)\n                ? Object.entries(object.plugins).reduce((acc, [key, value]) => {\n                    acc[key] = exports.PluginEntry.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.prevOut !== undefined) {\n            obj.prevOut = exports.OutPoint.toJSON(message.prevOut);\n        }\n        if (message.inputScript.length !== 0) {\n            obj.inputScript = base64FromBytes(message.inputScript);\n        }\n        if (message.outputScript.length !== 0) {\n            obj.outputScript = base64FromBytes(message.outputScript);\n        }\n        if (message.sats !== BigInt('0')) {\n            obj.sats = message.sats.toString();\n        }\n        if (message.sequenceNo !== 0) {\n            obj.sequenceNo = Math.round(message.sequenceNo);\n        }\n        if (message.token !== undefined) {\n            obj.token = exports.Token.toJSON(message.token);\n        }\n        if (message.plugins) {\n            const entries = Object.entries(message.plugins);\n            if (entries.length > 0) {\n                obj.plugins = {};\n                entries.forEach(([k, v]) => {\n                    obj.plugins[k] = exports.PluginEntry.toJSON(v);\n                });\n            }\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TxInput.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTxInput();\n        message.prevOut =\n            object.prevOut !== undefined && object.prevOut !== null\n                ? exports.OutPoint.fromPartial(object.prevOut)\n                : undefined;\n        message.inputScript = object.inputScript ?? new Uint8Array(0);\n        message.outputScript = object.outputScript ?? new Uint8Array(0);\n        message.sats = object.sats ?? BigInt('0');\n        message.sequenceNo = object.sequenceNo ?? 0;\n        message.token =\n            object.token !== undefined && object.token !== null\n                ? exports.Token.fromPartial(object.token)\n                : undefined;\n        message.plugins = Object.entries(object.plugins ?? {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = exports.PluginEntry.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseTxInput_PluginsEntry() {\n    return { key: '', value: undefined };\n}\nexports.TxInput_PluginsEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key !== '') {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            exports.PluginEntry.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxInput_PluginsEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.key = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.value = exports.PluginEntry.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? globalThis.String(object.key) : '',\n            value: isSet(object.value)\n                ? exports.PluginEntry.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.key !== '') {\n            obj.key = message.key;\n        }\n        if (message.value !== undefined) {\n            obj.value = exports.PluginEntry.toJSON(message.value);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TxInput_PluginsEntry.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTxInput_PluginsEntry();\n        message.key = object.key ?? '';\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? exports.PluginEntry.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseTxOutput() {\n    return {\n        sats: BigInt('0'),\n        outputScript: new Uint8Array(0),\n        spentBy: undefined,\n        token: undefined,\n        plugins: {},\n    };\n}\nexports.TxOutput = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.sats !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.sats) !== message.sats) {\n                throw new globalThis.Error('value provided for field message.sats of type int64 too large');\n            }\n            writer.uint32(8).int64(message.sats.toString());\n        }\n        if (message.outputScript.length !== 0) {\n            writer.uint32(18).bytes(message.outputScript);\n        }\n        if (message.spentBy !== undefined) {\n            exports.SpentBy.encode(message.spentBy, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.token !== undefined) {\n            exports.Token.encode(message.token, writer.uint32(42).fork()).ldelim();\n        }\n        Object.entries(message.plugins).forEach(([key, value]) => {\n            exports.TxOutput_PluginsEntry.encode({ key: key, value }, writer.uint32(50).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxOutput();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.sats = longToBigint(reader.int64());\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.outputScript = reader.bytes();\n                    continue;\n                case 4:\n                    if (tag !== 34) {\n                        break;\n                    }\n                    message.spentBy = exports.SpentBy.decode(reader, reader.uint32());\n                    continue;\n                case 5:\n                    if (tag !== 42) {\n                        break;\n                    }\n                    message.token = exports.Token.decode(reader, reader.uint32());\n                    continue;\n                case 6:\n                    if (tag !== 50) {\n                        break;\n                    }\n                    const entry6 = exports.TxOutput_PluginsEntry.decode(reader, reader.uint32());\n                    if (entry6.value !== undefined) {\n                        message.plugins[entry6.key] = entry6.value;\n                    }\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sats: isSet(object.sats) ? BigInt(object.sats) : BigInt('0'),\n            outputScript: isSet(object.outputScript)\n                ? bytesFromBase64(object.outputScript)\n                : new Uint8Array(0),\n            spentBy: isSet(object.spentBy)\n                ? exports.SpentBy.fromJSON(object.spentBy)\n                : undefined,\n            token: isSet(object.token)\n                ? exports.Token.fromJSON(object.token)\n                : undefined,\n            plugins: isObject(object.plugins)\n                ? Object.entries(object.plugins).reduce((acc, [key, value]) => {\n                    acc[key] = exports.PluginEntry.fromJSON(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.sats !== BigInt('0')) {\n            obj.sats = message.sats.toString();\n        }\n        if (message.outputScript.length !== 0) {\n            obj.outputScript = base64FromBytes(message.outputScript);\n        }\n        if (message.spentBy !== undefined) {\n            obj.spentBy = exports.SpentBy.toJSON(message.spentBy);\n        }\n        if (message.token !== undefined) {\n            obj.token = exports.Token.toJSON(message.token);\n        }\n        if (message.plugins) {\n            const entries = Object.entries(message.plugins);\n            if (entries.length > 0) {\n                obj.plugins = {};\n                entries.forEach(([k, v]) => {\n                    obj.plugins[k] = exports.PluginEntry.toJSON(v);\n                });\n            }\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TxOutput.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTxOutput();\n        message.sats = object.sats ?? BigInt('0');\n        message.outputScript = object.outputScript ?? new Uint8Array(0);\n        message.spentBy =\n            object.spentBy !== undefined && object.spentBy !== null\n                ? exports.SpentBy.fromPartial(object.spentBy)\n                : undefined;\n        message.token =\n            object.token !== undefined && object.token !== null\n                ? exports.Token.fromPartial(object.token)\n                : undefined;\n        message.plugins = Object.entries(object.plugins ?? {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = exports.PluginEntry.fromPartial(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseTxOutput_PluginsEntry() {\n    return { key: '', value: undefined };\n}\nexports.TxOutput_PluginsEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key !== '') {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== undefined) {\n            exports.PluginEntry.encode(message.value, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxOutput_PluginsEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.key = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.value = exports.PluginEntry.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? globalThis.String(object.key) : '',\n            value: isSet(object.value)\n                ? exports.PluginEntry.fromJSON(object.value)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.key !== '') {\n            obj.key = message.key;\n        }\n        if (message.value !== undefined) {\n            obj.value = exports.PluginEntry.toJSON(message.value);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TxOutput_PluginsEntry.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTxOutput_PluginsEntry();\n        message.key = object.key ?? '';\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? exports.PluginEntry.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseBlockMetadata() {\n    return {\n        height: 0,\n        hash: new Uint8Array(0),\n        timestamp: BigInt('0'),\n        isFinal: false,\n    };\n}\nexports.BlockMetadata = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.height !== 0) {\n            writer.uint32(8).int32(message.height);\n        }\n        if (message.hash.length !== 0) {\n            writer.uint32(18).bytes(message.hash);\n        }\n        if (message.timestamp !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.timestamp) !== message.timestamp) {\n                throw new globalThis.Error('value provided for field message.timestamp of type int64 too large');\n            }\n            writer.uint32(24).int64(message.timestamp.toString());\n        }\n        if (message.isFinal === true) {\n            writer.uint32(32).bool(message.isFinal);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlockMetadata();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.height = reader.int32();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.hash = reader.bytes();\n                    continue;\n                case 3:\n                    if (tag !== 24) {\n                        break;\n                    }\n                    message.timestamp = longToBigint(reader.int64());\n                    continue;\n                case 4:\n                    if (tag !== 32) {\n                        break;\n                    }\n                    message.isFinal = reader.bool();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            height: isSet(object.height) ? globalThis.Number(object.height) : 0,\n            hash: isSet(object.hash)\n                ? bytesFromBase64(object.hash)\n                : new Uint8Array(0),\n            timestamp: isSet(object.timestamp)\n                ? BigInt(object.timestamp)\n                : BigInt('0'),\n            isFinal: isSet(object.isFinal)\n                ? globalThis.Boolean(object.isFinal)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.height !== 0) {\n            obj.height = Math.round(message.height);\n        }\n        if (message.hash.length !== 0) {\n            obj.hash = base64FromBytes(message.hash);\n        }\n        if (message.timestamp !== BigInt('0')) {\n            obj.timestamp = message.timestamp.toString();\n        }\n        if (message.isFinal === true) {\n            obj.isFinal = message.isFinal;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BlockMetadata.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBlockMetadata();\n        message.height = object.height ?? 0;\n        message.hash = object.hash ?? new Uint8Array(0);\n        message.timestamp = object.timestamp ?? BigInt('0');\n        message.isFinal = object.isFinal ?? false;\n        return message;\n    },\n};\nfunction createBaseTokenType() {\n    return { slp: undefined, alp: undefined };\n}\nexports.TokenType = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.slp !== undefined) {\n            writer.uint32(8).int32(message.slp);\n        }\n        if (message.alp !== undefined) {\n            writer.uint32(16).int32(message.alp);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTokenType();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.slp = reader.int32();\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.alp = reader.int32();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            slp: isSet(object.slp)\n                ? slpTokenTypeFromJSON(object.slp)\n                : undefined,\n            alp: isSet(object.alp)\n                ? alpTokenTypeFromJSON(object.alp)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.slp !== undefined) {\n            obj.slp = slpTokenTypeToJSON(message.slp);\n        }\n        if (message.alp !== undefined) {\n            obj.alp = alpTokenTypeToJSON(message.alp);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TokenType.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTokenType();\n        message.slp = object.slp ?? undefined;\n        message.alp = object.alp ?? undefined;\n        return message;\n    },\n};\nfunction createBaseTokenInfo() {\n    return {\n        tokenId: '',\n        tokenType: undefined,\n        genesisInfo: undefined,\n        block: undefined,\n        timeFirstSeen: BigInt('0'),\n    };\n}\nexports.TokenInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.tokenId !== '') {\n            writer.uint32(10).string(message.tokenId);\n        }\n        if (message.tokenType !== undefined) {\n            exports.TokenType.encode(message.tokenType, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.genesisInfo !== undefined) {\n            exports.GenesisInfo.encode(message.genesisInfo, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.block !== undefined) {\n            exports.BlockMetadata.encode(message.block, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.timeFirstSeen !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.timeFirstSeen) !==\n                message.timeFirstSeen) {\n                throw new globalThis.Error('value provided for field message.timeFirstSeen of type int64 too large');\n            }\n            writer.uint32(40).int64(message.timeFirstSeen.toString());\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTokenInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.tokenId = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.tokenType = exports.TokenType.decode(reader, reader.uint32());\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.genesisInfo = exports.GenesisInfo.decode(reader, reader.uint32());\n                    continue;\n                case 4:\n                    if (tag !== 34) {\n                        break;\n                    }\n                    message.block = exports.BlockMetadata.decode(reader, reader.uint32());\n                    continue;\n                case 5:\n                    if (tag !== 40) {\n                        break;\n                    }\n                    message.timeFirstSeen = longToBigint(reader.int64());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            tokenId: isSet(object.tokenId)\n                ? globalThis.String(object.tokenId)\n                : '',\n            tokenType: isSet(object.tokenType)\n                ? exports.TokenType.fromJSON(object.tokenType)\n                : undefined,\n            genesisInfo: isSet(object.genesisInfo)\n                ? exports.GenesisInfo.fromJSON(object.genesisInfo)\n                : undefined,\n            block: isSet(object.block)\n                ? exports.BlockMetadata.fromJSON(object.block)\n                : undefined,\n            timeFirstSeen: isSet(object.timeFirstSeen)\n                ? BigInt(object.timeFirstSeen)\n                : BigInt('0'),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.tokenId !== '') {\n            obj.tokenId = message.tokenId;\n        }\n        if (message.tokenType !== undefined) {\n            obj.tokenType = exports.TokenType.toJSON(message.tokenType);\n        }\n        if (message.genesisInfo !== undefined) {\n            obj.genesisInfo = exports.GenesisInfo.toJSON(message.genesisInfo);\n        }\n        if (message.block !== undefined) {\n            obj.block = exports.BlockMetadata.toJSON(message.block);\n        }\n        if (message.timeFirstSeen !== BigInt('0')) {\n            obj.timeFirstSeen = message.timeFirstSeen.toString();\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TokenInfo.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTokenInfo();\n        message.tokenId = object.tokenId ?? '';\n        message.tokenType =\n            object.tokenType !== undefined && object.tokenType !== null\n                ? exports.TokenType.fromPartial(object.tokenType)\n                : undefined;\n        message.genesisInfo =\n            object.genesisInfo !== undefined && object.genesisInfo !== null\n                ? exports.GenesisInfo.fromPartial(object.genesisInfo)\n                : undefined;\n        message.block =\n            object.block !== undefined && object.block !== null\n                ? exports.BlockMetadata.fromPartial(object.block)\n                : undefined;\n        message.timeFirstSeen = object.timeFirstSeen ?? BigInt('0');\n        return message;\n    },\n};\nfunction createBaseTokenEntry() {\n    return {\n        tokenId: '',\n        tokenType: undefined,\n        txType: 0,\n        groupTokenId: '',\n        isInvalid: false,\n        burnSummary: '',\n        failedColorings: [],\n        actualBurnAtoms: '',\n        intentionalBurnAtoms: BigInt('0'),\n        burnsMintBatons: false,\n    };\n}\nexports.TokenEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.tokenId !== '') {\n            writer.uint32(10).string(message.tokenId);\n        }\n        if (message.tokenType !== undefined) {\n            exports.TokenType.encode(message.tokenType, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.txType !== 0) {\n            writer.uint32(24).int32(message.txType);\n        }\n        if (message.groupTokenId !== '') {\n            writer.uint32(34).string(message.groupTokenId);\n        }\n        if (message.isInvalid === true) {\n            writer.uint32(40).bool(message.isInvalid);\n        }\n        if (message.burnSummary !== '') {\n            writer.uint32(50).string(message.burnSummary);\n        }\n        for (const v of message.failedColorings) {\n            exports.TokenFailedColoring.encode(v, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.actualBurnAtoms !== '') {\n            writer.uint32(66).string(message.actualBurnAtoms);\n        }\n        if (message.intentionalBurnAtoms !== BigInt('0')) {\n            if (BigInt.asUintN(64, message.intentionalBurnAtoms) !==\n                message.intentionalBurnAtoms) {\n                throw new globalThis.Error('value provided for field message.intentionalBurnAtoms of type uint64 too large');\n            }\n            writer.uint32(72).uint64(message.intentionalBurnAtoms.toString());\n        }\n        if (message.burnsMintBatons === true) {\n            writer.uint32(80).bool(message.burnsMintBatons);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTokenEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.tokenId = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.tokenType = exports.TokenType.decode(reader, reader.uint32());\n                    continue;\n                case 3:\n                    if (tag !== 24) {\n                        break;\n                    }\n                    message.txType = reader.int32();\n                    continue;\n                case 4:\n                    if (tag !== 34) {\n                        break;\n                    }\n                    message.groupTokenId = reader.string();\n                    continue;\n                case 5:\n                    if (tag !== 40) {\n                        break;\n                    }\n                    message.isInvalid = reader.bool();\n                    continue;\n                case 6:\n                    if (tag !== 50) {\n                        break;\n                    }\n                    message.burnSummary = reader.string();\n                    continue;\n                case 7:\n                    if (tag !== 58) {\n                        break;\n                    }\n                    message.failedColorings.push(exports.TokenFailedColoring.decode(reader, reader.uint32()));\n                    continue;\n                case 8:\n                    if (tag !== 66) {\n                        break;\n                    }\n                    message.actualBurnAtoms = reader.string();\n                    continue;\n                case 9:\n                    if (tag !== 72) {\n                        break;\n                    }\n                    message.intentionalBurnAtoms = longToBigint(reader.uint64());\n                    continue;\n                case 10:\n                    if (tag !== 80) {\n                        break;\n                    }\n                    message.burnsMintBatons = reader.bool();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            tokenId: isSet(object.tokenId)\n                ? globalThis.String(object.tokenId)\n                : '',\n            tokenType: isSet(object.tokenType)\n                ? exports.TokenType.fromJSON(object.tokenType)\n                : undefined,\n            txType: isSet(object.txType)\n                ? tokenTxTypeFromJSON(object.txType)\n                : 0,\n            groupTokenId: isSet(object.groupTokenId)\n                ? globalThis.String(object.groupTokenId)\n                : '',\n            isInvalid: isSet(object.isInvalid)\n                ? globalThis.Boolean(object.isInvalid)\n                : false,\n            burnSummary: isSet(object.burnSummary)\n                ? globalThis.String(object.burnSummary)\n                : '',\n            failedColorings: globalThis.Array.isArray(object?.failedColorings)\n                ? object.failedColorings.map((e) => exports.TokenFailedColoring.fromJSON(e))\n                : [],\n            actualBurnAtoms: isSet(object.actualBurnAtoms)\n                ? globalThis.String(object.actualBurnAtoms)\n                : '',\n            intentionalBurnAtoms: isSet(object.intentionalBurnAtoms)\n                ? BigInt(object.intentionalBurnAtoms)\n                : BigInt('0'),\n            burnsMintBatons: isSet(object.burnsMintBatons)\n                ? globalThis.Boolean(object.burnsMintBatons)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.tokenId !== '') {\n            obj.tokenId = message.tokenId;\n        }\n        if (message.tokenType !== undefined) {\n            obj.tokenType = exports.TokenType.toJSON(message.tokenType);\n        }\n        if (message.txType !== 0) {\n            obj.txType = tokenTxTypeToJSON(message.txType);\n        }\n        if (message.groupTokenId !== '') {\n            obj.groupTokenId = message.groupTokenId;\n        }\n        if (message.isInvalid === true) {\n            obj.isInvalid = message.isInvalid;\n        }\n        if (message.burnSummary !== '') {\n            obj.burnSummary = message.burnSummary;\n        }\n        if (message.failedColorings?.length) {\n            obj.failedColorings = message.failedColorings.map(e => exports.TokenFailedColoring.toJSON(e));\n        }\n        if (message.actualBurnAtoms !== '') {\n            obj.actualBurnAtoms = message.actualBurnAtoms;\n        }\n        if (message.intentionalBurnAtoms !== BigInt('0')) {\n            obj.intentionalBurnAtoms = message.intentionalBurnAtoms.toString();\n        }\n        if (message.burnsMintBatons === true) {\n            obj.burnsMintBatons = message.burnsMintBatons;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TokenEntry.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTokenEntry();\n        message.tokenId = object.tokenId ?? '';\n        message.tokenType =\n            object.tokenType !== undefined && object.tokenType !== null\n                ? exports.TokenType.fromPartial(object.tokenType)\n                : undefined;\n        message.txType = object.txType ?? 0;\n        message.groupTokenId = object.groupTokenId ?? '';\n        message.isInvalid = object.isInvalid ?? false;\n        message.burnSummary = object.burnSummary ?? '';\n        message.failedColorings =\n            object.failedColorings?.map(e => exports.TokenFailedColoring.fromPartial(e)) || [];\n        message.actualBurnAtoms = object.actualBurnAtoms ?? '';\n        message.intentionalBurnAtoms =\n            object.intentionalBurnAtoms ?? BigInt('0');\n        message.burnsMintBatons = object.burnsMintBatons ?? false;\n        return message;\n    },\n};\nfunction createBaseGenesisInfo() {\n    return {\n        tokenTicker: new Uint8Array(0),\n        tokenName: new Uint8Array(0),\n        url: new Uint8Array(0),\n        hash: new Uint8Array(0),\n        mintVaultScripthash: new Uint8Array(0),\n        data: new Uint8Array(0),\n        authPubkey: new Uint8Array(0),\n        decimals: 0,\n    };\n}\nexports.GenesisInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.tokenTicker.length !== 0) {\n            writer.uint32(10).bytes(message.tokenTicker);\n        }\n        if (message.tokenName.length !== 0) {\n            writer.uint32(18).bytes(message.tokenName);\n        }\n        if (message.url.length !== 0) {\n            writer.uint32(26).bytes(message.url);\n        }\n        if (message.hash.length !== 0) {\n            writer.uint32(34).bytes(message.hash);\n        }\n        if (message.mintVaultScripthash.length !== 0) {\n            writer.uint32(42).bytes(message.mintVaultScripthash);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(50).bytes(message.data);\n        }\n        if (message.authPubkey.length !== 0) {\n            writer.uint32(58).bytes(message.authPubkey);\n        }\n        if (message.decimals !== 0) {\n            writer.uint32(64).uint32(message.decimals);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGenesisInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.tokenTicker = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.tokenName = reader.bytes();\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.url = reader.bytes();\n                    continue;\n                case 4:\n                    if (tag !== 34) {\n                        break;\n                    }\n                    message.hash = reader.bytes();\n                    continue;\n                case 5:\n                    if (tag !== 42) {\n                        break;\n                    }\n                    message.mintVaultScripthash = reader.bytes();\n                    continue;\n                case 6:\n                    if (tag !== 50) {\n                        break;\n                    }\n                    message.data = reader.bytes();\n                    continue;\n                case 7:\n                    if (tag !== 58) {\n                        break;\n                    }\n                    message.authPubkey = reader.bytes();\n                    continue;\n                case 8:\n                    if (tag !== 64) {\n                        break;\n                    }\n                    message.decimals = reader.uint32();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            tokenTicker: isSet(object.tokenTicker)\n                ? bytesFromBase64(object.tokenTicker)\n                : new Uint8Array(0),\n            tokenName: isSet(object.tokenName)\n                ? bytesFromBase64(object.tokenName)\n                : new Uint8Array(0),\n            url: isSet(object.url)\n                ? bytesFromBase64(object.url)\n                : new Uint8Array(0),\n            hash: isSet(object.hash)\n                ? bytesFromBase64(object.hash)\n                : new Uint8Array(0),\n            mintVaultScripthash: isSet(object.mintVaultScripthash)\n                ? bytesFromBase64(object.mintVaultScripthash)\n                : new Uint8Array(0),\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(0),\n            authPubkey: isSet(object.authPubkey)\n                ? bytesFromBase64(object.authPubkey)\n                : new Uint8Array(0),\n            decimals: isSet(object.decimals)\n                ? globalThis.Number(object.decimals)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.tokenTicker.length !== 0) {\n            obj.tokenTicker = base64FromBytes(message.tokenTicker);\n        }\n        if (message.tokenName.length !== 0) {\n            obj.tokenName = base64FromBytes(message.tokenName);\n        }\n        if (message.url.length !== 0) {\n            obj.url = base64FromBytes(message.url);\n        }\n        if (message.hash.length !== 0) {\n            obj.hash = base64FromBytes(message.hash);\n        }\n        if (message.mintVaultScripthash.length !== 0) {\n            obj.mintVaultScripthash = base64FromBytes(message.mintVaultScripthash);\n        }\n        if (message.data.length !== 0) {\n            obj.data = base64FromBytes(message.data);\n        }\n        if (message.authPubkey.length !== 0) {\n            obj.authPubkey = base64FromBytes(message.authPubkey);\n        }\n        if (message.decimals !== 0) {\n            obj.decimals = Math.round(message.decimals);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.GenesisInfo.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseGenesisInfo();\n        message.tokenTicker = object.tokenTicker ?? new Uint8Array(0);\n        message.tokenName = object.tokenName ?? new Uint8Array(0);\n        message.url = object.url ?? new Uint8Array(0);\n        message.hash = object.hash ?? new Uint8Array(0);\n        message.mintVaultScripthash =\n            object.mintVaultScripthash ?? new Uint8Array(0);\n        message.data = object.data ?? new Uint8Array(0);\n        message.authPubkey = object.authPubkey ?? new Uint8Array(0);\n        message.decimals = object.decimals ?? 0;\n        return message;\n    },\n};\nfunction createBaseToken() {\n    return {\n        tokenId: '',\n        tokenType: undefined,\n        entryIdx: 0,\n        atoms: BigInt('0'),\n        isMintBaton: false,\n    };\n}\nexports.Token = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.tokenId !== '') {\n            writer.uint32(10).string(message.tokenId);\n        }\n        if (message.tokenType !== undefined) {\n            exports.TokenType.encode(message.tokenType, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.entryIdx !== 0) {\n            writer.uint32(24).int32(message.entryIdx);\n        }\n        if (message.atoms !== BigInt('0')) {\n            if (BigInt.asUintN(64, message.atoms) !== message.atoms) {\n                throw new globalThis.Error('value provided for field message.atoms of type uint64 too large');\n            }\n            writer.uint32(32).uint64(message.atoms.toString());\n        }\n        if (message.isMintBaton === true) {\n            writer.uint32(40).bool(message.isMintBaton);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseToken();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.tokenId = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.tokenType = exports.TokenType.decode(reader, reader.uint32());\n                    continue;\n                case 3:\n                    if (tag !== 24) {\n                        break;\n                    }\n                    message.entryIdx = reader.int32();\n                    continue;\n                case 4:\n                    if (tag !== 32) {\n                        break;\n                    }\n                    message.atoms = longToBigint(reader.uint64());\n                    continue;\n                case 5:\n                    if (tag !== 40) {\n                        break;\n                    }\n                    message.isMintBaton = reader.bool();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            tokenId: isSet(object.tokenId)\n                ? globalThis.String(object.tokenId)\n                : '',\n            tokenType: isSet(object.tokenType)\n                ? exports.TokenType.fromJSON(object.tokenType)\n                : undefined,\n            entryIdx: isSet(object.entryIdx)\n                ? globalThis.Number(object.entryIdx)\n                : 0,\n            atoms: isSet(object.atoms) ? BigInt(object.atoms) : BigInt('0'),\n            isMintBaton: isSet(object.isMintBaton)\n                ? globalThis.Boolean(object.isMintBaton)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.tokenId !== '') {\n            obj.tokenId = message.tokenId;\n        }\n        if (message.tokenType !== undefined) {\n            obj.tokenType = exports.TokenType.toJSON(message.tokenType);\n        }\n        if (message.entryIdx !== 0) {\n            obj.entryIdx = Math.round(message.entryIdx);\n        }\n        if (message.atoms !== BigInt('0')) {\n            obj.atoms = message.atoms.toString();\n        }\n        if (message.isMintBaton === true) {\n            obj.isMintBaton = message.isMintBaton;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.Token.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseToken();\n        message.tokenId = object.tokenId ?? '';\n        message.tokenType =\n            object.tokenType !== undefined && object.tokenType !== null\n                ? exports.TokenType.fromPartial(object.tokenType)\n                : undefined;\n        message.entryIdx = object.entryIdx ?? 0;\n        message.atoms = object.atoms ?? BigInt('0');\n        message.isMintBaton = object.isMintBaton ?? false;\n        return message;\n    },\n};\nfunction createBaseTokenFailedParsing() {\n    return { pushdataIdx: 0, bytes: new Uint8Array(0), error: '' };\n}\nexports.TokenFailedParsing = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pushdataIdx !== 0) {\n            writer.uint32(8).int32(message.pushdataIdx);\n        }\n        if (message.bytes.length !== 0) {\n            writer.uint32(18).bytes(message.bytes);\n        }\n        if (message.error !== '') {\n            writer.uint32(26).string(message.error);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTokenFailedParsing();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.pushdataIdx = reader.int32();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.bytes = reader.bytes();\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.error = reader.string();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pushdataIdx: isSet(object.pushdataIdx)\n                ? globalThis.Number(object.pushdataIdx)\n                : 0,\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(0),\n            error: isSet(object.error) ? globalThis.String(object.error) : '',\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.pushdataIdx !== 0) {\n            obj.pushdataIdx = Math.round(message.pushdataIdx);\n        }\n        if (message.bytes.length !== 0) {\n            obj.bytes = base64FromBytes(message.bytes);\n        }\n        if (message.error !== '') {\n            obj.error = message.error;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TokenFailedParsing.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTokenFailedParsing();\n        message.pushdataIdx = object.pushdataIdx ?? 0;\n        message.bytes = object.bytes ?? new Uint8Array(0);\n        message.error = object.error ?? '';\n        return message;\n    },\n};\nfunction createBaseTokenFailedColoring() {\n    return { pushdataIdx: 0, error: '' };\n}\nexports.TokenFailedColoring = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pushdataIdx !== 0) {\n            writer.uint32(8).int32(message.pushdataIdx);\n        }\n        if (message.error !== '') {\n            writer.uint32(26).string(message.error);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTokenFailedColoring();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.pushdataIdx = reader.int32();\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.error = reader.string();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pushdataIdx: isSet(object.pushdataIdx)\n                ? globalThis.Number(object.pushdataIdx)\n                : 0,\n            error: isSet(object.error) ? globalThis.String(object.error) : '',\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.pushdataIdx !== 0) {\n            obj.pushdataIdx = Math.round(message.pushdataIdx);\n        }\n        if (message.error !== '') {\n            obj.error = message.error;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TokenFailedColoring.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTokenFailedColoring();\n        message.pushdataIdx = object.pushdataIdx ?? 0;\n        message.error = object.error ?? '';\n        return message;\n    },\n};\nfunction createBasePluginEntry() {\n    return { groups: [], data: [] };\n}\nexports.PluginEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.groups) {\n            writer.uint32(10).bytes(v);\n        }\n        for (const v of message.data) {\n            writer.uint32(18).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePluginEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.groups.push(reader.bytes());\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.data.push(reader.bytes());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groups: globalThis.Array.isArray(object?.groups)\n                ? object.groups.map((e) => bytesFromBase64(e))\n                : [],\n            data: globalThis.Array.isArray(object?.data)\n                ? object.data.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.groups?.length) {\n            obj.groups = message.groups.map(e => base64FromBytes(e));\n        }\n        if (message.data?.length) {\n            obj.data = message.data.map(e => base64FromBytes(e));\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.PluginEntry.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBasePluginEntry();\n        message.groups = object.groups?.map(e => e) || [];\n        message.data = object.data?.map(e => e) || [];\n        return message;\n    },\n};\nfunction createBasePluginGroup() {\n    return { group: new Uint8Array(0) };\n}\nexports.PluginGroup = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.group.length !== 0) {\n            writer.uint32(10).bytes(message.group);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePluginGroup();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.group = reader.bytes();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            group: isSet(object.group)\n                ? bytesFromBase64(object.group)\n                : new Uint8Array(0),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.group.length !== 0) {\n            obj.group = base64FromBytes(message.group);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.PluginGroup.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBasePluginGroup();\n        message.group = object.group ?? new Uint8Array(0);\n        return message;\n    },\n};\nfunction createBasePluginGroups() {\n    return { groups: [], nextStart: new Uint8Array(0) };\n}\nexports.PluginGroups = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.groups) {\n            exports.PluginGroup.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.nextStart.length !== 0) {\n            writer.uint32(18).bytes(message.nextStart);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePluginGroups();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.groups.push(exports.PluginGroup.decode(reader, reader.uint32()));\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.nextStart = reader.bytes();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            groups: globalThis.Array.isArray(object?.groups)\n                ? object.groups.map((e) => exports.PluginGroup.fromJSON(e))\n                : [],\n            nextStart: isSet(object.nextStart)\n                ? bytesFromBase64(object.nextStart)\n                : new Uint8Array(0),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.groups?.length) {\n            obj.groups = message.groups.map(e => exports.PluginGroup.toJSON(e));\n        }\n        if (message.nextStart.length !== 0) {\n            obj.nextStart = base64FromBytes(message.nextStart);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.PluginGroups.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBasePluginGroups();\n        message.groups =\n            object.groups?.map(e => exports.PluginGroup.fromPartial(e)) || [];\n        message.nextStart = object.nextStart ?? new Uint8Array(0);\n        return message;\n    },\n};\nfunction createBaseTxHistoryPage() {\n    return { txs: [], numPages: 0, numTxs: 0 };\n}\nexports.TxHistoryPage = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.txs) {\n            exports.Tx.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.numPages !== 0) {\n            writer.uint32(16).uint32(message.numPages);\n        }\n        if (message.numTxs !== 0) {\n            writer.uint32(24).uint32(message.numTxs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxHistoryPage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.txs.push(exports.Tx.decode(reader, reader.uint32()));\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.numPages = reader.uint32();\n                    continue;\n                case 3:\n                    if (tag !== 24) {\n                        break;\n                    }\n                    message.numTxs = reader.uint32();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            txs: globalThis.Array.isArray(object?.txs)\n                ? object.txs.map((e) => exports.Tx.fromJSON(e))\n                : [],\n            numPages: isSet(object.numPages)\n                ? globalThis.Number(object.numPages)\n                : 0,\n            numTxs: isSet(object.numTxs) ? globalThis.Number(object.numTxs) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.txs?.length) {\n            obj.txs = message.txs.map(e => exports.Tx.toJSON(e));\n        }\n        if (message.numPages !== 0) {\n            obj.numPages = Math.round(message.numPages);\n        }\n        if (message.numTxs !== 0) {\n            obj.numTxs = Math.round(message.numTxs);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TxHistoryPage.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTxHistoryPage();\n        message.txs = object.txs?.map(e => exports.Tx.fromPartial(e)) || [];\n        message.numPages = object.numPages ?? 0;\n        message.numTxs = object.numTxs ?? 0;\n        return message;\n    },\n};\nfunction createBaseScriptUtxos() {\n    return { script: new Uint8Array(0), utxos: [] };\n}\nexports.ScriptUtxos = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.script.length !== 0) {\n            writer.uint32(10).bytes(message.script);\n        }\n        for (const v of message.utxos) {\n            exports.ScriptUtxo.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseScriptUtxos();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.script = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.utxos.push(exports.ScriptUtxo.decode(reader, reader.uint32()));\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            script: isSet(object.script)\n                ? bytesFromBase64(object.script)\n                : new Uint8Array(0),\n            utxos: globalThis.Array.isArray(object?.utxos)\n                ? object.utxos.map((e) => exports.ScriptUtxo.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.script.length !== 0) {\n            obj.script = base64FromBytes(message.script);\n        }\n        if (message.utxos?.length) {\n            obj.utxos = message.utxos.map(e => exports.ScriptUtxo.toJSON(e));\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.ScriptUtxos.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseScriptUtxos();\n        message.script = object.script ?? new Uint8Array(0);\n        message.utxos = object.utxos?.map(e => exports.ScriptUtxo.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseUtxos() {\n    return { utxos: [] };\n}\nexports.Utxos = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.utxos) {\n            exports.Utxo.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUtxos();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.utxos.push(exports.Utxo.decode(reader, reader.uint32()));\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            utxos: globalThis.Array.isArray(object?.utxos)\n                ? object.utxos.map((e) => exports.Utxo.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.utxos?.length) {\n            obj.utxos = message.utxos.map(e => exports.Utxo.toJSON(e));\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.Utxos.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseUtxos();\n        message.utxos = object.utxos?.map(e => exports.Utxo.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseBroadcastTxRequest() {\n    return { rawTx: new Uint8Array(0), skipTokenChecks: false };\n}\nexports.BroadcastTxRequest = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.rawTx.length !== 0) {\n            writer.uint32(10).bytes(message.rawTx);\n        }\n        if (message.skipTokenChecks === true) {\n            writer.uint32(16).bool(message.skipTokenChecks);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBroadcastTxRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.rawTx = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.skipTokenChecks = reader.bool();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            rawTx: isSet(object.rawTx)\n                ? bytesFromBase64(object.rawTx)\n                : new Uint8Array(0),\n            skipTokenChecks: isSet(object.skipTokenChecks)\n                ? globalThis.Boolean(object.skipTokenChecks)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.rawTx.length !== 0) {\n            obj.rawTx = base64FromBytes(message.rawTx);\n        }\n        if (message.skipTokenChecks === true) {\n            obj.skipTokenChecks = message.skipTokenChecks;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BroadcastTxRequest.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBroadcastTxRequest();\n        message.rawTx = object.rawTx ?? new Uint8Array(0);\n        message.skipTokenChecks = object.skipTokenChecks ?? false;\n        return message;\n    },\n};\nfunction createBaseBroadcastTxResponse() {\n    return { txid: new Uint8Array(0) };\n}\nexports.BroadcastTxResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.txid.length !== 0) {\n            writer.uint32(10).bytes(message.txid);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBroadcastTxResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.txid = reader.bytes();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            txid: isSet(object.txid)\n                ? bytesFromBase64(object.txid)\n                : new Uint8Array(0),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.txid.length !== 0) {\n            obj.txid = base64FromBytes(message.txid);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BroadcastTxResponse.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBroadcastTxResponse();\n        message.txid = object.txid ?? new Uint8Array(0);\n        return message;\n    },\n};\nfunction createBaseBroadcastTxsRequest() {\n    return { rawTxs: [], skipTokenChecks: false };\n}\nexports.BroadcastTxsRequest = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.rawTxs) {\n            writer.uint32(10).bytes(v);\n        }\n        if (message.skipTokenChecks === true) {\n            writer.uint32(16).bool(message.skipTokenChecks);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBroadcastTxsRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.rawTxs.push(reader.bytes());\n                    continue;\n                case 2:\n                    if (tag !== 16) {\n                        break;\n                    }\n                    message.skipTokenChecks = reader.bool();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            rawTxs: globalThis.Array.isArray(object?.rawTxs)\n                ? object.rawTxs.map((e) => bytesFromBase64(e))\n                : [],\n            skipTokenChecks: isSet(object.skipTokenChecks)\n                ? globalThis.Boolean(object.skipTokenChecks)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.rawTxs?.length) {\n            obj.rawTxs = message.rawTxs.map(e => base64FromBytes(e));\n        }\n        if (message.skipTokenChecks === true) {\n            obj.skipTokenChecks = message.skipTokenChecks;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BroadcastTxsRequest.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBroadcastTxsRequest();\n        message.rawTxs = object.rawTxs?.map(e => e) || [];\n        message.skipTokenChecks = object.skipTokenChecks ?? false;\n        return message;\n    },\n};\nfunction createBaseBroadcastTxsResponse() {\n    return { txids: [] };\n}\nexports.BroadcastTxsResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.txids) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBroadcastTxsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.txids.push(reader.bytes());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            txids: globalThis.Array.isArray(object?.txids)\n                ? object.txids.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.txids?.length) {\n            obj.txids = message.txids.map(e => base64FromBytes(e));\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.BroadcastTxsResponse.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseBroadcastTxsResponse();\n        message.txids = object.txids?.map(e => e) || [];\n        return message;\n    },\n};\nfunction createBaseRawTx() {\n    return { rawTx: new Uint8Array(0) };\n}\nexports.RawTx = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.rawTx.length !== 0) {\n            writer.uint32(10).bytes(message.rawTx);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRawTx();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.rawTx = reader.bytes();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            rawTx: isSet(object.rawTx)\n                ? bytesFromBase64(object.rawTx)\n                : new Uint8Array(0),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.rawTx.length !== 0) {\n            obj.rawTx = base64FromBytes(message.rawTx);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.RawTx.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseRawTx();\n        message.rawTx = object.rawTx ?? new Uint8Array(0);\n        return message;\n    },\n};\nfunction createBaseWsSub() {\n    return {\n        isUnsub: false,\n        blocks: undefined,\n        script: undefined,\n        tokenId: undefined,\n        lokadId: undefined,\n        plugin: undefined,\n        txid: undefined,\n    };\n}\nexports.WsSub = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.isUnsub === true) {\n            writer.uint32(8).bool(message.isUnsub);\n        }\n        if (message.blocks !== undefined) {\n            exports.WsSubBlocks.encode(message.blocks, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.script !== undefined) {\n            exports.WsSubScript.encode(message.script, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.tokenId !== undefined) {\n            exports.WsSubTokenId.encode(message.tokenId, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.lokadId !== undefined) {\n            exports.WsSubLokadId.encode(message.lokadId, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.plugin !== undefined) {\n            exports.WsPlugin.encode(message.plugin, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.txid !== undefined) {\n            exports.WsSubTxId.encode(message.txid, writer.uint32(58).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWsSub();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.isUnsub = reader.bool();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.blocks = exports.WsSubBlocks.decode(reader, reader.uint32());\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.script = exports.WsSubScript.decode(reader, reader.uint32());\n                    continue;\n                case 4:\n                    if (tag !== 34) {\n                        break;\n                    }\n                    message.tokenId = exports.WsSubTokenId.decode(reader, reader.uint32());\n                    continue;\n                case 5:\n                    if (tag !== 42) {\n                        break;\n                    }\n                    message.lokadId = exports.WsSubLokadId.decode(reader, reader.uint32());\n                    continue;\n                case 6:\n                    if (tag !== 50) {\n                        break;\n                    }\n                    message.plugin = exports.WsPlugin.decode(reader, reader.uint32());\n                    continue;\n                case 7:\n                    if (tag !== 58) {\n                        break;\n                    }\n                    message.txid = exports.WsSubTxId.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            isUnsub: isSet(object.isUnsub)\n                ? globalThis.Boolean(object.isUnsub)\n                : false,\n            blocks: isSet(object.blocks)\n                ? exports.WsSubBlocks.fromJSON(object.blocks)\n                : undefined,\n            script: isSet(object.script)\n                ? exports.WsSubScript.fromJSON(object.script)\n                : undefined,\n            tokenId: isSet(object.tokenId)\n                ? exports.WsSubTokenId.fromJSON(object.tokenId)\n                : undefined,\n            lokadId: isSet(object.lokadId)\n                ? exports.WsSubLokadId.fromJSON(object.lokadId)\n                : undefined,\n            plugin: isSet(object.plugin)\n                ? exports.WsPlugin.fromJSON(object.plugin)\n                : undefined,\n            txid: isSet(object.txid)\n                ? exports.WsSubTxId.fromJSON(object.txid)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.isUnsub === true) {\n            obj.isUnsub = message.isUnsub;\n        }\n        if (message.blocks !== undefined) {\n            obj.blocks = exports.WsSubBlocks.toJSON(message.blocks);\n        }\n        if (message.script !== undefined) {\n            obj.script = exports.WsSubScript.toJSON(message.script);\n        }\n        if (message.tokenId !== undefined) {\n            obj.tokenId = exports.WsSubTokenId.toJSON(message.tokenId);\n        }\n        if (message.lokadId !== undefined) {\n            obj.lokadId = exports.WsSubLokadId.toJSON(message.lokadId);\n        }\n        if (message.plugin !== undefined) {\n            obj.plugin = exports.WsPlugin.toJSON(message.plugin);\n        }\n        if (message.txid !== undefined) {\n            obj.txid = exports.WsSubTxId.toJSON(message.txid);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.WsSub.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseWsSub();\n        message.isUnsub = object.isUnsub ?? false;\n        message.blocks =\n            object.blocks !== undefined && object.blocks !== null\n                ? exports.WsSubBlocks.fromPartial(object.blocks)\n                : undefined;\n        message.script =\n            object.script !== undefined && object.script !== null\n                ? exports.WsSubScript.fromPartial(object.script)\n                : undefined;\n        message.tokenId =\n            object.tokenId !== undefined && object.tokenId !== null\n                ? exports.WsSubTokenId.fromPartial(object.tokenId)\n                : undefined;\n        message.lokadId =\n            object.lokadId !== undefined && object.lokadId !== null\n                ? exports.WsSubLokadId.fromPartial(object.lokadId)\n                : undefined;\n        message.plugin =\n            object.plugin !== undefined && object.plugin !== null\n                ? exports.WsPlugin.fromPartial(object.plugin)\n                : undefined;\n        message.txid =\n            object.txid !== undefined && object.txid !== null\n                ? exports.WsSubTxId.fromPartial(object.txid)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseWsSubBlocks() {\n    return {};\n}\nexports.WsSubBlocks = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWsSubBlocks();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    create(base) {\n        return exports.WsSubBlocks.fromPartial(base ?? {});\n    },\n    fromPartial(_) {\n        const message = createBaseWsSubBlocks();\n        return message;\n    },\n};\nfunction createBaseWsSubScript() {\n    return { scriptType: '', payload: new Uint8Array(0) };\n}\nexports.WsSubScript = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.scriptType !== '') {\n            writer.uint32(10).string(message.scriptType);\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(18).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWsSubScript();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.scriptType = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.payload = reader.bytes();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            scriptType: isSet(object.scriptType)\n                ? globalThis.String(object.scriptType)\n                : '',\n            payload: isSet(object.payload)\n                ? bytesFromBase64(object.payload)\n                : new Uint8Array(0),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.scriptType !== '') {\n            obj.scriptType = message.scriptType;\n        }\n        if (message.payload.length !== 0) {\n            obj.payload = base64FromBytes(message.payload);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.WsSubScript.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseWsSubScript();\n        message.scriptType = object.scriptType ?? '';\n        message.payload = object.payload ?? new Uint8Array(0);\n        return message;\n    },\n};\nfunction createBaseWsSubTokenId() {\n    return { tokenId: '' };\n}\nexports.WsSubTokenId = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.tokenId !== '') {\n            writer.uint32(10).string(message.tokenId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWsSubTokenId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.tokenId = reader.string();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            tokenId: isSet(object.tokenId)\n                ? globalThis.String(object.tokenId)\n                : '',\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.tokenId !== '') {\n            obj.tokenId = message.tokenId;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.WsSubTokenId.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseWsSubTokenId();\n        message.tokenId = object.tokenId ?? '';\n        return message;\n    },\n};\nfunction createBaseWsSubLokadId() {\n    return { lokadId: new Uint8Array(0) };\n}\nexports.WsSubLokadId = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.lokadId.length !== 0) {\n            writer.uint32(10).bytes(message.lokadId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWsSubLokadId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.lokadId = reader.bytes();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            lokadId: isSet(object.lokadId)\n                ? bytesFromBase64(object.lokadId)\n                : new Uint8Array(0),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.lokadId.length !== 0) {\n            obj.lokadId = base64FromBytes(message.lokadId);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.WsSubLokadId.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseWsSubLokadId();\n        message.lokadId = object.lokadId ?? new Uint8Array(0);\n        return message;\n    },\n};\nfunction createBaseWsPlugin() {\n    return { pluginName: '', group: new Uint8Array(0) };\n}\nexports.WsPlugin = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pluginName !== '') {\n            writer.uint32(10).string(message.pluginName);\n        }\n        if (message.group.length !== 0) {\n            writer.uint32(18).bytes(message.group);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWsPlugin();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.pluginName = reader.string();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.group = reader.bytes();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pluginName: isSet(object.pluginName)\n                ? globalThis.String(object.pluginName)\n                : '',\n            group: isSet(object.group)\n                ? bytesFromBase64(object.group)\n                : new Uint8Array(0),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.pluginName !== '') {\n            obj.pluginName = message.pluginName;\n        }\n        if (message.group.length !== 0) {\n            obj.group = base64FromBytes(message.group);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.WsPlugin.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseWsPlugin();\n        message.pluginName = object.pluginName ?? '';\n        message.group = object.group ?? new Uint8Array(0);\n        return message;\n    },\n};\nfunction createBaseWsSubTxId() {\n    return { txid: '' };\n}\nexports.WsSubTxId = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.txid !== '') {\n            writer.uint32(10).string(message.txid);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWsSubTxId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.txid = reader.string();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            txid: isSet(object.txid) ? globalThis.String(object.txid) : '',\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.txid !== '') {\n            obj.txid = message.txid;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.WsSubTxId.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseWsSubTxId();\n        message.txid = object.txid ?? '';\n        return message;\n    },\n};\nfunction createBaseWsMsg() {\n    return { error: undefined, block: undefined, tx: undefined };\n}\nexports.WsMsg = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.error !== undefined) {\n            exports.Error.encode(message.error, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.block !== undefined) {\n            exports.MsgBlock.encode(message.block, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.tx !== undefined) {\n            exports.MsgTx.encode(message.tx, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWsMsg();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.error = exports.Error.decode(reader, reader.uint32());\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.block = exports.MsgBlock.decode(reader, reader.uint32());\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.tx = exports.MsgTx.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            error: isSet(object.error)\n                ? exports.Error.fromJSON(object.error)\n                : undefined,\n            block: isSet(object.block)\n                ? exports.MsgBlock.fromJSON(object.block)\n                : undefined,\n            tx: isSet(object.tx) ? exports.MsgTx.fromJSON(object.tx) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.error !== undefined) {\n            obj.error = exports.Error.toJSON(message.error);\n        }\n        if (message.block !== undefined) {\n            obj.block = exports.MsgBlock.toJSON(message.block);\n        }\n        if (message.tx !== undefined) {\n            obj.tx = exports.MsgTx.toJSON(message.tx);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.WsMsg.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseWsMsg();\n        message.error =\n            object.error !== undefined && object.error !== null\n                ? exports.Error.fromPartial(object.error)\n                : undefined;\n        message.block =\n            object.block !== undefined && object.block !== null\n                ? exports.MsgBlock.fromPartial(object.block)\n                : undefined;\n        message.tx =\n            object.tx !== undefined && object.tx !== null\n                ? exports.MsgTx.fromPartial(object.tx)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCoinbaseData() {\n    return { coinbaseScriptsig: new Uint8Array(0), coinbaseOutputs: [] };\n}\nexports.CoinbaseData = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.coinbaseScriptsig.length !== 0) {\n            writer.uint32(10).bytes(message.coinbaseScriptsig);\n        }\n        for (const v of message.coinbaseOutputs) {\n            exports.TxOutput.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCoinbaseData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 10) {\n                        break;\n                    }\n                    message.coinbaseScriptsig = reader.bytes();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.coinbaseOutputs.push(exports.TxOutput.decode(reader, reader.uint32()));\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            coinbaseScriptsig: isSet(object.coinbaseScriptsig)\n                ? bytesFromBase64(object.coinbaseScriptsig)\n                : new Uint8Array(0),\n            coinbaseOutputs: globalThis.Array.isArray(object?.coinbaseOutputs)\n                ? object.coinbaseOutputs.map((e) => exports.TxOutput.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.coinbaseScriptsig.length !== 0) {\n            obj.coinbaseScriptsig = base64FromBytes(message.coinbaseScriptsig);\n        }\n        if (message.coinbaseOutputs?.length) {\n            obj.coinbaseOutputs = message.coinbaseOutputs.map(e => exports.TxOutput.toJSON(e));\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.CoinbaseData.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseCoinbaseData();\n        message.coinbaseScriptsig =\n            object.coinbaseScriptsig ?? new Uint8Array(0);\n        message.coinbaseOutputs =\n            object.coinbaseOutputs?.map(e => exports.TxOutput.fromPartial(e)) || [];\n        return message;\n    },\n};\nfunction createBaseMsgBlock() {\n    return {\n        msgType: 0,\n        blockHash: new Uint8Array(0),\n        blockHeight: 0,\n        blockTimestamp: BigInt('0'),\n        coinbaseData: undefined,\n    };\n}\nexports.MsgBlock = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.msgType !== 0) {\n            writer.uint32(8).int32(message.msgType);\n        }\n        if (message.blockHash.length !== 0) {\n            writer.uint32(18).bytes(message.blockHash);\n        }\n        if (message.blockHeight !== 0) {\n            writer.uint32(24).int32(message.blockHeight);\n        }\n        if (message.blockTimestamp !== BigInt('0')) {\n            if (BigInt.asIntN(64, message.blockTimestamp) !==\n                message.blockTimestamp) {\n                throw new globalThis.Error('value provided for field message.blockTimestamp of type int64 too large');\n            }\n            writer.uint32(32).int64(message.blockTimestamp.toString());\n        }\n        if (message.coinbaseData !== undefined) {\n            exports.CoinbaseData.encode(message.coinbaseData, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgBlock();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.msgType = reader.int32();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.blockHash = reader.bytes();\n                    continue;\n                case 3:\n                    if (tag !== 24) {\n                        break;\n                    }\n                    message.blockHeight = reader.int32();\n                    continue;\n                case 4:\n                    if (tag !== 32) {\n                        break;\n                    }\n                    message.blockTimestamp = longToBigint(reader.int64());\n                    continue;\n                case 5:\n                    if (tag !== 42) {\n                        break;\n                    }\n                    message.coinbaseData = exports.CoinbaseData.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            msgType: isSet(object.msgType)\n                ? blockMsgTypeFromJSON(object.msgType)\n                : 0,\n            blockHash: isSet(object.blockHash)\n                ? bytesFromBase64(object.blockHash)\n                : new Uint8Array(0),\n            blockHeight: isSet(object.blockHeight)\n                ? globalThis.Number(object.blockHeight)\n                : 0,\n            blockTimestamp: isSet(object.blockTimestamp)\n                ? BigInt(object.blockTimestamp)\n                : BigInt('0'),\n            coinbaseData: isSet(object.coinbaseData)\n                ? exports.CoinbaseData.fromJSON(object.coinbaseData)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.msgType !== 0) {\n            obj.msgType = blockMsgTypeToJSON(message.msgType);\n        }\n        if (message.blockHash.length !== 0) {\n            obj.blockHash = base64FromBytes(message.blockHash);\n        }\n        if (message.blockHeight !== 0) {\n            obj.blockHeight = Math.round(message.blockHeight);\n        }\n        if (message.blockTimestamp !== BigInt('0')) {\n            obj.blockTimestamp = message.blockTimestamp.toString();\n        }\n        if (message.coinbaseData !== undefined) {\n            obj.coinbaseData = exports.CoinbaseData.toJSON(message.coinbaseData);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.MsgBlock.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseMsgBlock();\n        message.msgType = object.msgType ?? 0;\n        message.blockHash = object.blockHash ?? new Uint8Array(0);\n        message.blockHeight = object.blockHeight ?? 0;\n        message.blockTimestamp = object.blockTimestamp ?? BigInt('0');\n        message.coinbaseData =\n            object.coinbaseData !== undefined && object.coinbaseData !== null\n                ? exports.CoinbaseData.fromPartial(object.coinbaseData)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseTxFinalizationReason() {\n    return { finalizationType: 0 };\n}\nexports.TxFinalizationReason = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.finalizationType !== 0) {\n            writer.uint32(8).int32(message.finalizationType);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxFinalizationReason();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.finalizationType = reader.int32();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            finalizationType: isSet(object.finalizationType)\n                ? txFinalizationReasonTypeFromJSON(object.finalizationType)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.finalizationType !== 0) {\n            obj.finalizationType = txFinalizationReasonTypeToJSON(message.finalizationType);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.TxFinalizationReason.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseTxFinalizationReason();\n        message.finalizationType = object.finalizationType ?? 0;\n        return message;\n    },\n};\nfunction createBaseMsgTx() {\n    return {\n        msgType: 0,\n        txid: new Uint8Array(0),\n        finalizationReason: undefined,\n    };\n}\nexports.MsgTx = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.msgType !== 0) {\n            writer.uint32(8).int32(message.msgType);\n        }\n        if (message.txid.length !== 0) {\n            writer.uint32(18).bytes(message.txid);\n        }\n        if (message.finalizationReason !== undefined) {\n            exports.TxFinalizationReason.encode(message.finalizationReason, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgTx();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (tag !== 8) {\n                        break;\n                    }\n                    message.msgType = reader.int32();\n                    continue;\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.txid = reader.bytes();\n                    continue;\n                case 3:\n                    if (tag !== 26) {\n                        break;\n                    }\n                    message.finalizationReason = exports.TxFinalizationReason.decode(reader, reader.uint32());\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            msgType: isSet(object.msgType)\n                ? txMsgTypeFromJSON(object.msgType)\n                : 0,\n            txid: isSet(object.txid)\n                ? bytesFromBase64(object.txid)\n                : new Uint8Array(0),\n            finalizationReason: isSet(object.finalizationReason)\n                ? exports.TxFinalizationReason.fromJSON(object.finalizationReason)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.msgType !== 0) {\n            obj.msgType = txMsgTypeToJSON(message.msgType);\n        }\n        if (message.txid.length !== 0) {\n            obj.txid = base64FromBytes(message.txid);\n        }\n        if (message.finalizationReason !== undefined) {\n            obj.finalizationReason = exports.TxFinalizationReason.toJSON(message.finalizationReason);\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.MsgTx.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseMsgTx();\n        message.msgType = object.msgType ?? 0;\n        message.txid = object.txid ?? new Uint8Array(0);\n        message.finalizationReason =\n            object.finalizationReason !== undefined &&\n                object.finalizationReason !== null\n                ? exports.TxFinalizationReason.fromPartial(object.finalizationReason)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseEmpty() {\n    return {};\n}\nexports.Empty = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEmpty();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    create(base) {\n        return exports.Empty.fromPartial(base ?? {});\n    },\n    fromPartial(_) {\n        const message = createBaseEmpty();\n        return message;\n    },\n};\nfunction createBaseError() {\n    return { msg: '' };\n}\nexports.Error = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.msg !== '') {\n            writer.uint32(18).string(message.msg);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseError();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    if (tag !== 18) {\n                        break;\n                    }\n                    message.msg = reader.string();\n                    continue;\n            }\n            if ((tag & 7) === 4 || tag === 0) {\n                break;\n            }\n            reader.skipType(tag & 7);\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { msg: isSet(object.msg) ? globalThis.String(object.msg) : '' };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.msg !== '') {\n            obj.msg = message.msg;\n        }\n        return obj;\n    },\n    create(base) {\n        return exports.Error.fromPartial(base ?? {});\n    },\n    fromPartial(object) {\n        const message = createBaseError();\n        message.msg = object.msg ?? '';\n        return message;\n    },\n};\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, 'base64'));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString('base64');\n    }\n    else {\n        const bin = [];\n        arr.forEach(byte => {\n            bin.push(globalThis.String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(''));\n    }\n}\nfunction longToBigint(long) {\n    return BigInt(long.toString());\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=chronik.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0Esb0RBQW9EO0FBQ3BELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5REFBeUQ7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMERBQTBEO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0REFBNEQ7QUFDNUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlEQUF5RDtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RDtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnREFBZ0Q7QUFDaEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckIsb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtEQUErRDtBQUMvRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0Q7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtRUFBbUU7QUFDbkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyREFBMkQ7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1REFBdUQ7QUFDdkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RDtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdEQUF3RDtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseURBQXlEO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1EQUFtRDtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnRUFBZ0U7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpRUFBaUU7QUFDakUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlEQUF5RDtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseURBQXlEO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMERBQTBEO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkRBQTJEO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlEQUF5RDtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbURBQW1EO0FBQ25ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0VBQWdFO0FBQ2hFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpRUFBaUU7QUFDakUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpRUFBaUU7QUFDakUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtFQUFrRTtBQUNsRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1EQUFtRDtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbURBQW1EO0FBQ25ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5REFBeUQ7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseURBQXlEO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwREFBMEQ7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwREFBMEQ7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzREFBc0Q7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdURBQXVEO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtREFBbUQ7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMERBQTBEO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0RBQXNEO0FBQ3RELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrRUFBa0U7QUFDbEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtREFBbUQ7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1EQUFtRDtBQUNuRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtREFBbUQ7QUFDbkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2Nocm9uaWstY2xpZW50L2Rpc3QvcHJvdG8vY2hyb25pay5qcz81YWMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QbHVnaW5Hcm91cCA9IGV4cG9ydHMuUGx1Z2luRW50cnkgPSBleHBvcnRzLlRva2VuRmFpbGVkQ29sb3JpbmcgPSBleHBvcnRzLlRva2VuRmFpbGVkUGFyc2luZyA9IGV4cG9ydHMuVG9rZW4gPSBleHBvcnRzLkdlbmVzaXNJbmZvID0gZXhwb3J0cy5Ub2tlbkVudHJ5ID0gZXhwb3J0cy5Ub2tlbkluZm8gPSBleHBvcnRzLlRva2VuVHlwZSA9IGV4cG9ydHMuQmxvY2tNZXRhZGF0YSA9IGV4cG9ydHMuVHhPdXRwdXRfUGx1Z2luc0VudHJ5ID0gZXhwb3J0cy5UeE91dHB1dCA9IGV4cG9ydHMuVHhJbnB1dF9QbHVnaW5zRW50cnkgPSBleHBvcnRzLlR4SW5wdXQgPSBleHBvcnRzLlNwZW50QnkgPSBleHBvcnRzLk91dFBvaW50ID0gZXhwb3J0cy5VdHhvX1BsdWdpbnNFbnRyeSA9IGV4cG9ydHMuVXR4byA9IGV4cG9ydHMuU2NyaXB0VXR4b19QbHVnaW5zRW50cnkgPSBleHBvcnRzLlNjcmlwdFV0eG8gPSBleHBvcnRzLlR4ID0gZXhwb3J0cy5CbG9ja0luZm8gPSBleHBvcnRzLkNocm9uaWtJbmZvID0gZXhwb3J0cy5CbG9ja2NoYWluSW5mbyA9IGV4cG9ydHMuQmxvY2tIZWFkZXJzID0gZXhwb3J0cy5CbG9ja0hlYWRlciA9IGV4cG9ydHMuQmxvY2tzID0gZXhwb3J0cy5CbG9jayA9IGV4cG9ydHMudHhNc2dUeXBlVG9KU09OID0gZXhwb3J0cy50eE1zZ1R5cGVGcm9tSlNPTiA9IGV4cG9ydHMuVHhNc2dUeXBlID0gZXhwb3J0cy50eEZpbmFsaXphdGlvblJlYXNvblR5cGVUb0pTT04gPSBleHBvcnRzLnR4RmluYWxpemF0aW9uUmVhc29uVHlwZUZyb21KU09OID0gZXhwb3J0cy5UeEZpbmFsaXphdGlvblJlYXNvblR5cGUgPSBleHBvcnRzLmJsb2NrTXNnVHlwZVRvSlNPTiA9IGV4cG9ydHMuYmxvY2tNc2dUeXBlRnJvbUpTT04gPSBleHBvcnRzLkJsb2NrTXNnVHlwZSA9IGV4cG9ydHMudG9rZW5UeFR5cGVUb0pTT04gPSBleHBvcnRzLnRva2VuVHhUeXBlRnJvbUpTT04gPSBleHBvcnRzLlRva2VuVHhUeXBlID0gZXhwb3J0cy5zbHBUb2tlblR5cGVUb0pTT04gPSBleHBvcnRzLnNscFRva2VuVHlwZUZyb21KU09OID0gZXhwb3J0cy5TbHBUb2tlblR5cGUgPSBleHBvcnRzLmFscFRva2VuVHlwZVRvSlNPTiA9IGV4cG9ydHMuYWxwVG9rZW5UeXBlRnJvbUpTT04gPSBleHBvcnRzLkFscFRva2VuVHlwZSA9IGV4cG9ydHMudG9rZW5TdGF0dXNUb0pTT04gPSBleHBvcnRzLnRva2VuU3RhdHVzRnJvbUpTT04gPSBleHBvcnRzLlRva2VuU3RhdHVzID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG5leHBvcnRzLkVycm9yID0gZXhwb3J0cy5FbXB0eSA9IGV4cG9ydHMuTXNnVHggPSBleHBvcnRzLlR4RmluYWxpemF0aW9uUmVhc29uID0gZXhwb3J0cy5Nc2dCbG9jayA9IGV4cG9ydHMuQ29pbmJhc2VEYXRhID0gZXhwb3J0cy5Xc01zZyA9IGV4cG9ydHMuV3NTdWJUeElkID0gZXhwb3J0cy5Xc1BsdWdpbiA9IGV4cG9ydHMuV3NTdWJMb2thZElkID0gZXhwb3J0cy5Xc1N1YlRva2VuSWQgPSBleHBvcnRzLldzU3ViU2NyaXB0ID0gZXhwb3J0cy5Xc1N1YkJsb2NrcyA9IGV4cG9ydHMuV3NTdWIgPSBleHBvcnRzLlJhd1R4ID0gZXhwb3J0cy5Ccm9hZGNhc3RUeHNSZXNwb25zZSA9IGV4cG9ydHMuQnJvYWRjYXN0VHhzUmVxdWVzdCA9IGV4cG9ydHMuQnJvYWRjYXN0VHhSZXNwb25zZSA9IGV4cG9ydHMuQnJvYWRjYXN0VHhSZXF1ZXN0ID0gZXhwb3J0cy5VdHhvcyA9IGV4cG9ydHMuU2NyaXB0VXR4b3MgPSBleHBvcnRzLlR4SGlzdG9yeVBhZ2UgPSBleHBvcnRzLlBsdWdpbkdyb3VwcyA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSAnY2hyb25payc7XG4vKiogU3RhdHVzIG9mIGEgdG9rZW4gdHggKi9cbnZhciBUb2tlblN0YXR1cztcbihmdW5jdGlvbiAoVG9rZW5TdGF0dXMpIHtcbiAgICAvKipcbiAgICAgKiBUT0tFTl9TVEFUVVNfTk9OX1RPS0VOIC0gVHggaW52b2x2ZXMgbm8gdG9rZW5zIHdoYXRzb3ZlciwgaS5lLiBuZWl0aGVyIGFueSBidXJucyBub3IgYW55IGZhaWxlZFxuICAgICAqIHBhcnNpbmcvY29sb3Jpbmcgb3IgYW55IHRva2VucyBiZWluZyBjcmVhdGVkIC8gbW92ZWQuXG4gICAgICovXG4gICAgVG9rZW5TdGF0dXNbVG9rZW5TdGF0dXNbXCJUT0tFTl9TVEFUVVNfTk9OX1RPS0VOXCJdID0gMF0gPSBcIlRPS0VOX1NUQVRVU19OT05fVE9LRU5cIjtcbiAgICAvKiogVE9LRU5fU1RBVFVTX05PUk1BTCAtIFR4IGludm9sdmVzIHRva2VucyBidXQgbm8gdW5pbnRlbnRpb25hbCBidXJucyBvciBmYWlsZWQgcGFyc2luZ3MvY29sb3JpbmdzICovXG4gICAgVG9rZW5TdGF0dXNbVG9rZW5TdGF0dXNbXCJUT0tFTl9TVEFUVVNfTk9STUFMXCJdID0gMV0gPSBcIlRPS0VOX1NUQVRVU19OT1JNQUxcIjtcbiAgICAvKiogVE9LRU5fU1RBVFVTX05PVF9OT1JNQUwgLSBUeCBpbnZvbHZlcyB0b2tlbnMgYnV0IGNvbnRhaW5zIHVuaW50ZW50aW9uYWwgYnVybnMgb3IgZmFpbGVkIHBhcnNpbmdzL2NvbG9yaW5ncyAqL1xuICAgIFRva2VuU3RhdHVzW1Rva2VuU3RhdHVzW1wiVE9LRU5fU1RBVFVTX05PVF9OT1JNQUxcIl0gPSAyXSA9IFwiVE9LRU5fU1RBVFVTX05PVF9OT1JNQUxcIjtcbiAgICBUb2tlblN0YXR1c1tUb2tlblN0YXR1c1tcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShUb2tlblN0YXR1cyA9IGV4cG9ydHMuVG9rZW5TdGF0dXMgfHwgKGV4cG9ydHMuVG9rZW5TdGF0dXMgPSB7fSkpO1xuZnVuY3Rpb24gdG9rZW5TdGF0dXNGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgJ1RPS0VOX1NUQVRVU19OT05fVE9LRU4nOlxuICAgICAgICAgICAgcmV0dXJuIFRva2VuU3RhdHVzLlRPS0VOX1NUQVRVU19OT05fVE9LRU47XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAnVE9LRU5fU1RBVFVTX05PUk1BTCc6XG4gICAgICAgICAgICByZXR1cm4gVG9rZW5TdGF0dXMuVE9LRU5fU1RBVFVTX05PUk1BTDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlICdUT0tFTl9TVEFUVVNfTk9UX05PUk1BTCc6XG4gICAgICAgICAgICByZXR1cm4gVG9rZW5TdGF0dXMuVE9LRU5fU1RBVFVTX05PVF9OT1JNQUw7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgJ1VOUkVDT0dOSVpFRCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gVG9rZW5TdGF0dXMuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydHMudG9rZW5TdGF0dXNGcm9tSlNPTiA9IHRva2VuU3RhdHVzRnJvbUpTT047XG5mdW5jdGlvbiB0b2tlblN0YXR1c1RvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIFRva2VuU3RhdHVzLlRPS0VOX1NUQVRVU19OT05fVE9LRU46XG4gICAgICAgICAgICByZXR1cm4gJ1RPS0VOX1NUQVRVU19OT05fVE9LRU4nO1xuICAgICAgICBjYXNlIFRva2VuU3RhdHVzLlRPS0VOX1NUQVRVU19OT1JNQUw6XG4gICAgICAgICAgICByZXR1cm4gJ1RPS0VOX1NUQVRVU19OT1JNQUwnO1xuICAgICAgICBjYXNlIFRva2VuU3RhdHVzLlRPS0VOX1NUQVRVU19OT1RfTk9STUFMOlxuICAgICAgICAgICAgcmV0dXJuICdUT0tFTl9TVEFUVVNfTk9UX05PUk1BTCc7XG4gICAgICAgIGNhc2UgVG9rZW5TdGF0dXMuVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdVTlJFQ09HTklaRUQnO1xuICAgIH1cbn1cbmV4cG9ydHMudG9rZW5TdGF0dXNUb0pTT04gPSB0b2tlblN0YXR1c1RvSlNPTjtcbi8qKiBBTFAgdG9rZW4gdHlwZSAqL1xudmFyIEFscFRva2VuVHlwZTtcbihmdW5jdGlvbiAoQWxwVG9rZW5UeXBlKSB7XG4gICAgLyoqIEFMUF9UT0tFTl9UWVBFX1NUQU5EQVJEIC0gU3RhbmRhcmQgQUxQIHRva2VuIHR5cGUgKi9cbiAgICBBbHBUb2tlblR5cGVbQWxwVG9rZW5UeXBlW1wiQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkRcIl0gPSAwXSA9IFwiQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkRcIjtcbiAgICBBbHBUb2tlblR5cGVbQWxwVG9rZW5UeXBlW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKEFscFRva2VuVHlwZSA9IGV4cG9ydHMuQWxwVG9rZW5UeXBlIHx8IChleHBvcnRzLkFscFRva2VuVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBhbHBUb2tlblR5cGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgJ0FMUF9UT0tFTl9UWVBFX1NUQU5EQVJEJzpcbiAgICAgICAgICAgIHJldHVybiBBbHBUb2tlblR5cGUuQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkQ7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgJ1VOUkVDT0dOSVpFRCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQWxwVG9rZW5UeXBlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLmFscFRva2VuVHlwZUZyb21KU09OID0gYWxwVG9rZW5UeXBlRnJvbUpTT047XG5mdW5jdGlvbiBhbHBUb2tlblR5cGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBBbHBUb2tlblR5cGUuQUxQX1RPS0VOX1RZUEVfU1RBTkRBUkQ6XG4gICAgICAgICAgICByZXR1cm4gJ0FMUF9UT0tFTl9UWVBFX1NUQU5EQVJEJztcbiAgICAgICAgY2FzZSBBbHBUb2tlblR5cGUuVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdVTlJFQ09HTklaRUQnO1xuICAgIH1cbn1cbmV4cG9ydHMuYWxwVG9rZW5UeXBlVG9KU09OID0gYWxwVG9rZW5UeXBlVG9KU09OO1xuLyoqIFNMUCB0b2tlbiB0eXBlICovXG52YXIgU2xwVG9rZW5UeXBlO1xuKGZ1bmN0aW9uIChTbHBUb2tlblR5cGUpIHtcbiAgICAvKiogU0xQX1RPS0VOX1RZUEVfTk9ORSAtIFVua25vd24gXCIwXCIgdG9rZW4gdHlwZSAqL1xuICAgIFNscFRva2VuVHlwZVtTbHBUb2tlblR5cGVbXCJTTFBfVE9LRU5fVFlQRV9OT05FXCJdID0gMF0gPSBcIlNMUF9UT0tFTl9UWVBFX05PTkVcIjtcbiAgICAvKiogU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEUgLSBTTFAgVjEgdG9rZW4gdHlwZSAqL1xuICAgIFNscFRva2VuVHlwZVtTbHBUb2tlblR5cGVbXCJTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRVwiXSA9IDFdID0gXCJTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRVwiO1xuICAgIC8qKiBTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxUIC0gU0xQIFYyIG1pbnQgdmF1bHQgdG9rZW4gdHlwZSAqL1xuICAgIFNscFRva2VuVHlwZVtTbHBUb2tlblR5cGVbXCJTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxUXCJdID0gMl0gPSBcIlNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFRcIjtcbiAgICAvKiogU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUCAtIE5GVDEgZ3JvdXAgdG9rZW4gdHlwZSAqL1xuICAgIFNscFRva2VuVHlwZVtTbHBUb2tlblR5cGVbXCJTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQXCJdID0gMTI5XSA9IFwiU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUFwiO1xuICAgIC8qKiBTTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEIC0gTkZUMSBjaGlsZCB0b2tlbiB0eXBlICovXG4gICAgU2xwVG9rZW5UeXBlW1NscFRva2VuVHlwZVtcIlNMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTERcIl0gPSA2NV0gPSBcIlNMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTERcIjtcbiAgICBTbHBUb2tlblR5cGVbU2xwVG9rZW5UeXBlW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKFNscFRva2VuVHlwZSA9IGV4cG9ydHMuU2xwVG9rZW5UeXBlIHx8IChleHBvcnRzLlNscFRva2VuVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBzbHBUb2tlblR5cGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgJ1NMUF9UT0tFTl9UWVBFX05PTkUnOlxuICAgICAgICAgICAgcmV0dXJuIFNscFRva2VuVHlwZS5TTFBfVE9LRU5fVFlQRV9OT05FO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgJ1NMUF9UT0tFTl9UWVBFX0ZVTkdJQkxFJzpcbiAgICAgICAgICAgIHJldHVybiBTbHBUb2tlblR5cGUuU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEU7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAnU0xQX1RPS0VOX1RZUEVfTUlOVF9WQVVMVCc6XG4gICAgICAgICAgICByZXR1cm4gU2xwVG9rZW5UeXBlLlNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQ7XG4gICAgICAgIGNhc2UgMTI5OlxuICAgICAgICBjYXNlICdTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQJzpcbiAgICAgICAgICAgIHJldHVybiBTbHBUb2tlblR5cGUuU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUDtcbiAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgY2FzZSAnU0xQX1RPS0VOX1RZUEVfTkZUMV9DSElMRCc6XG4gICAgICAgICAgICByZXR1cm4gU2xwVG9rZW5UeXBlLlNMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTEQ7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgJ1VOUkVDT0dOSVpFRCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gU2xwVG9rZW5UeXBlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLnNscFRva2VuVHlwZUZyb21KU09OID0gc2xwVG9rZW5UeXBlRnJvbUpTT047XG5mdW5jdGlvbiBzbHBUb2tlblR5cGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBTbHBUb2tlblR5cGUuU0xQX1RPS0VOX1RZUEVfTk9ORTpcbiAgICAgICAgICAgIHJldHVybiAnU0xQX1RPS0VOX1RZUEVfTk9ORSc7XG4gICAgICAgIGNhc2UgU2xwVG9rZW5UeXBlLlNMUF9UT0tFTl9UWVBFX0ZVTkdJQkxFOlxuICAgICAgICAgICAgcmV0dXJuICdTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSc7XG4gICAgICAgIGNhc2UgU2xwVG9rZW5UeXBlLlNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQ6XG4gICAgICAgICAgICByZXR1cm4gJ1NMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQnO1xuICAgICAgICBjYXNlIFNscFRva2VuVHlwZS5TTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQOlxuICAgICAgICAgICAgcmV0dXJuICdTTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQJztcbiAgICAgICAgY2FzZSBTbHBUb2tlblR5cGUuU0xQX1RPS0VOX1RZUEVfTkZUMV9DSElMRDpcbiAgICAgICAgICAgIHJldHVybiAnU0xQX1RPS0VOX1RZUEVfTkZUMV9DSElMRCc7XG4gICAgICAgIGNhc2UgU2xwVG9rZW5UeXBlLlVOUkVDT0dOSVpFRDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnVU5SRUNPR05JWkVEJztcbiAgICB9XG59XG5leHBvcnRzLnNscFRva2VuVHlwZVRvSlNPTiA9IHNscFRva2VuVHlwZVRvSlNPTjtcbi8qKiBTTFAvQUxQIHR4IHR5cGUgKi9cbnZhciBUb2tlblR4VHlwZTtcbihmdW5jdGlvbiAoVG9rZW5UeFR5cGUpIHtcbiAgICAvKiogTk9ORSAtIE5vIHR4IHR5cGUsIGUuZy4gd2hlbiBpbnB1dCB0b2tlbnMgYXJlIGJ1cm5lZCAqL1xuICAgIFRva2VuVHhUeXBlW1Rva2VuVHhUeXBlW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgLyoqIFVOS05PV04gLSBVbmtub3duIHR4IHR5cGUsIGkuZS4gZm9yIHVua25vd24gdG9rZW4gdHlwZXMgKi9cbiAgICBUb2tlblR4VHlwZVtUb2tlblR4VHlwZVtcIlVOS05PV05cIl0gPSAxXSA9IFwiVU5LTk9XTlwiO1xuICAgIC8qKiBHRU5FU0lTIC0gR0VORVNJUyB0eCAqL1xuICAgIFRva2VuVHhUeXBlW1Rva2VuVHhUeXBlW1wiR0VORVNJU1wiXSA9IDJdID0gXCJHRU5FU0lTXCI7XG4gICAgLyoqIFNFTkQgLSBTRU5EIHR4ICovXG4gICAgVG9rZW5UeFR5cGVbVG9rZW5UeFR5cGVbXCJTRU5EXCJdID0gM10gPSBcIlNFTkRcIjtcbiAgICAvKiogTUlOVCAtIE1JTlQgdHggKi9cbiAgICBUb2tlblR4VHlwZVtUb2tlblR4VHlwZVtcIk1JTlRcIl0gPSA0XSA9IFwiTUlOVFwiO1xuICAgIC8qKiBCVVJOIC0gQlVSTiB0eCAqL1xuICAgIFRva2VuVHhUeXBlW1Rva2VuVHhUeXBlW1wiQlVSTlwiXSA9IDVdID0gXCJCVVJOXCI7XG4gICAgVG9rZW5UeFR5cGVbVG9rZW5UeFR5cGVbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoVG9rZW5UeFR5cGUgPSBleHBvcnRzLlRva2VuVHhUeXBlIHx8IChleHBvcnRzLlRva2VuVHhUeXBlID0ge30pKTtcbmZ1bmN0aW9uIHRva2VuVHhUeXBlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlICdOT05FJzpcbiAgICAgICAgICAgIHJldHVybiBUb2tlblR4VHlwZS5OT05FO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgICAgICAgcmV0dXJuIFRva2VuVHhUeXBlLlVOS05PV047XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSAnR0VORVNJUyc6XG4gICAgICAgICAgICByZXR1cm4gVG9rZW5UeFR5cGUuR0VORVNJUztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlICdTRU5EJzpcbiAgICAgICAgICAgIHJldHVybiBUb2tlblR4VHlwZS5TRU5EO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgJ01JTlQnOlxuICAgICAgICAgICAgcmV0dXJuIFRva2VuVHhUeXBlLk1JTlQ7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSAnQlVSTic6XG4gICAgICAgICAgICByZXR1cm4gVG9rZW5UeFR5cGUuQlVSTjtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSAnVU5SRUNPR05JWkVEJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBUb2tlblR4VHlwZS5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0cy50b2tlblR4VHlwZUZyb21KU09OID0gdG9rZW5UeFR5cGVGcm9tSlNPTjtcbmZ1bmN0aW9uIHRva2VuVHhUeXBlVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgVG9rZW5UeFR5cGUuTk9ORTpcbiAgICAgICAgICAgIHJldHVybiAnTk9ORSc7XG4gICAgICAgIGNhc2UgVG9rZW5UeFR5cGUuVU5LTk9XTjpcbiAgICAgICAgICAgIHJldHVybiAnVU5LTk9XTic7XG4gICAgICAgIGNhc2UgVG9rZW5UeFR5cGUuR0VORVNJUzpcbiAgICAgICAgICAgIHJldHVybiAnR0VORVNJUyc7XG4gICAgICAgIGNhc2UgVG9rZW5UeFR5cGUuU0VORDpcbiAgICAgICAgICAgIHJldHVybiAnU0VORCc7XG4gICAgICAgIGNhc2UgVG9rZW5UeFR5cGUuTUlOVDpcbiAgICAgICAgICAgIHJldHVybiAnTUlOVCc7XG4gICAgICAgIGNhc2UgVG9rZW5UeFR5cGUuQlVSTjpcbiAgICAgICAgICAgIHJldHVybiAnQlVSTic7XG4gICAgICAgIGNhc2UgVG9rZW5UeFR5cGUuVU5SRUNPR05JWkVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdVTlJFQ09HTklaRUQnO1xuICAgIH1cbn1cbmV4cG9ydHMudG9rZW5UeFR5cGVUb0pTT04gPSB0b2tlblR4VHlwZVRvSlNPTjtcbi8qKiBUeXBlIG9mIG1lc3NhZ2UgZm9yIHRoZSBibG9jayAqL1xudmFyIEJsb2NrTXNnVHlwZTtcbihmdW5jdGlvbiAoQmxvY2tNc2dUeXBlKSB7XG4gICAgLyoqIEJMS19DT05ORUNURUQgLSBCbG9jayBjb25uZWN0ZWQgdG8gdGhlIGJsb2NrY2hhaW4gKi9cbiAgICBCbG9ja01zZ1R5cGVbQmxvY2tNc2dUeXBlW1wiQkxLX0NPTk5FQ1RFRFwiXSA9IDBdID0gXCJCTEtfQ09OTkVDVEVEXCI7XG4gICAgLyoqIEJMS19ESVNDT05ORUNURUQgLSBCbG9jayBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgYmxvY2tjaGFpbiAqL1xuICAgIEJsb2NrTXNnVHlwZVtCbG9ja01zZ1R5cGVbXCJCTEtfRElTQ09OTkVDVEVEXCJdID0gMV0gPSBcIkJMS19ESVNDT05ORUNURURcIjtcbiAgICAvKiogQkxLX0ZJTkFMSVpFRCAtIEJsb2NrIGhhcyBiZWVuIGZpbmFsaXplZCBieSBBdmFsYW5jaGUgKi9cbiAgICBCbG9ja01zZ1R5cGVbQmxvY2tNc2dUeXBlW1wiQkxLX0ZJTkFMSVpFRFwiXSA9IDJdID0gXCJCTEtfRklOQUxJWkVEXCI7XG4gICAgLyoqIEJMS19JTlZBTElEQVRFRCAtIEJsb2NrIGhhcyBiZWVuIGludmFsaWRhdGVkIGJ5IEF2YWxhbmNoZSAqL1xuICAgIEJsb2NrTXNnVHlwZVtCbG9ja01zZ1R5cGVbXCJCTEtfSU5WQUxJREFURURcIl0gPSAzXSA9IFwiQkxLX0lOVkFMSURBVEVEXCI7XG4gICAgQmxvY2tNc2dUeXBlW0Jsb2NrTXNnVHlwZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShCbG9ja01zZ1R5cGUgPSBleHBvcnRzLkJsb2NrTXNnVHlwZSB8fCAoZXhwb3J0cy5CbG9ja01zZ1R5cGUgPSB7fSkpO1xuZnVuY3Rpb24gYmxvY2tNc2dUeXBlRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlICdCTEtfQ09OTkVDVEVEJzpcbiAgICAgICAgICAgIHJldHVybiBCbG9ja01zZ1R5cGUuQkxLX0NPTk5FQ1RFRDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlICdCTEtfRElTQ09OTkVDVEVEJzpcbiAgICAgICAgICAgIHJldHVybiBCbG9ja01zZ1R5cGUuQkxLX0RJU0NPTk5FQ1RFRDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlICdCTEtfRklOQUxJWkVEJzpcbiAgICAgICAgICAgIHJldHVybiBCbG9ja01zZ1R5cGUuQkxLX0ZJTkFMSVpFRDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlICdCTEtfSU5WQUxJREFURUQnOlxuICAgICAgICAgICAgcmV0dXJuIEJsb2NrTXNnVHlwZS5CTEtfSU5WQUxJREFURUQ7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgJ1VOUkVDT0dOSVpFRCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQmxvY2tNc2dUeXBlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLmJsb2NrTXNnVHlwZUZyb21KU09OID0gYmxvY2tNc2dUeXBlRnJvbUpTT047XG5mdW5jdGlvbiBibG9ja01zZ1R5cGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBCbG9ja01zZ1R5cGUuQkxLX0NPTk5FQ1RFRDpcbiAgICAgICAgICAgIHJldHVybiAnQkxLX0NPTk5FQ1RFRCc7XG4gICAgICAgIGNhc2UgQmxvY2tNc2dUeXBlLkJMS19ESVNDT05ORUNURUQ6XG4gICAgICAgICAgICByZXR1cm4gJ0JMS19ESVNDT05ORUNURUQnO1xuICAgICAgICBjYXNlIEJsb2NrTXNnVHlwZS5CTEtfRklOQUxJWkVEOlxuICAgICAgICAgICAgcmV0dXJuICdCTEtfRklOQUxJWkVEJztcbiAgICAgICAgY2FzZSBCbG9ja01zZ1R5cGUuQkxLX0lOVkFMSURBVEVEOlxuICAgICAgICAgICAgcmV0dXJuICdCTEtfSU5WQUxJREFURUQnO1xuICAgICAgICBjYXNlIEJsb2NrTXNnVHlwZS5VTlJFQ09HTklaRUQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ1VOUkVDT0dOSVpFRCc7XG4gICAgfVxufVxuZXhwb3J0cy5ibG9ja01zZ1R5cGVUb0pTT04gPSBibG9ja01zZ1R5cGVUb0pTT047XG4vKiogVHlwZSBvZiB0eCBmaW5hbGl6YXRpb24gKi9cbnZhciBUeEZpbmFsaXphdGlvblJlYXNvblR5cGU7XG4oZnVuY3Rpb24gKFR4RmluYWxpemF0aW9uUmVhc29uVHlwZSkge1xuICAgIC8qKiBUWF9GSU5BTElaQVRJT05fUkVBU09OX1BPU1RfQ09OU0VOU1VTIC0gVGhlIHRyYW5zYWN0aW9uIGlzIGZpbmFsaXplZCBieSBwb3N0LWNvbnNlbnN1cyAqL1xuICAgIFR4RmluYWxpemF0aW9uUmVhc29uVHlwZVtUeEZpbmFsaXphdGlvblJlYXNvblR5cGVbXCJUWF9GSU5BTElaQVRJT05fUkVBU09OX1BPU1RfQ09OU0VOU1VTXCJdID0gMF0gPSBcIlRYX0ZJTkFMSVpBVElPTl9SRUFTT05fUE9TVF9DT05TRU5TVVNcIjtcbiAgICAvKiogVFhfRklOQUxJWkFUSU9OX1JFQVNPTl9QUkVfQ09OU0VOU1VTIC0gVGhlIHRyYW5zYWN0aW9uIGlzIGZpbmFsaXplZCBieSBwcmUtY29uc2Vuc3VzICovXG4gICAgVHhGaW5hbGl6YXRpb25SZWFzb25UeXBlW1R4RmluYWxpemF0aW9uUmVhc29uVHlwZVtcIlRYX0ZJTkFMSVpBVElPTl9SRUFTT05fUFJFX0NPTlNFTlNVU1wiXSA9IDFdID0gXCJUWF9GSU5BTElaQVRJT05fUkVBU09OX1BSRV9DT05TRU5TVVNcIjtcbiAgICBUeEZpbmFsaXphdGlvblJlYXNvblR5cGVbVHhGaW5hbGl6YXRpb25SZWFzb25UeXBlW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKFR4RmluYWxpemF0aW9uUmVhc29uVHlwZSA9IGV4cG9ydHMuVHhGaW5hbGl6YXRpb25SZWFzb25UeXBlIHx8IChleHBvcnRzLlR4RmluYWxpemF0aW9uUmVhc29uVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiB0eEZpbmFsaXphdGlvblJlYXNvblR5cGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgJ1RYX0ZJTkFMSVpBVElPTl9SRUFTT05fUE9TVF9DT05TRU5TVVMnOlxuICAgICAgICAgICAgcmV0dXJuIFR4RmluYWxpemF0aW9uUmVhc29uVHlwZS5UWF9GSU5BTElaQVRJT05fUkVBU09OX1BPU1RfQ09OU0VOU1VTO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgJ1RYX0ZJTkFMSVpBVElPTl9SRUFTT05fUFJFX0NPTlNFTlNVUyc6XG4gICAgICAgICAgICByZXR1cm4gVHhGaW5hbGl6YXRpb25SZWFzb25UeXBlLlRYX0ZJTkFMSVpBVElPTl9SRUFTT05fUFJFX0NPTlNFTlNVUztcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSAnVU5SRUNPR05JWkVEJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBUeEZpbmFsaXphdGlvblJlYXNvblR5cGUuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydHMudHhGaW5hbGl6YXRpb25SZWFzb25UeXBlRnJvbUpTT04gPSB0eEZpbmFsaXphdGlvblJlYXNvblR5cGVGcm9tSlNPTjtcbmZ1bmN0aW9uIHR4RmluYWxpemF0aW9uUmVhc29uVHlwZVRvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIFR4RmluYWxpemF0aW9uUmVhc29uVHlwZS5UWF9GSU5BTElaQVRJT05fUkVBU09OX1BPU1RfQ09OU0VOU1VTOlxuICAgICAgICAgICAgcmV0dXJuICdUWF9GSU5BTElaQVRJT05fUkVBU09OX1BPU1RfQ09OU0VOU1VTJztcbiAgICAgICAgY2FzZSBUeEZpbmFsaXphdGlvblJlYXNvblR5cGUuVFhfRklOQUxJWkFUSU9OX1JFQVNPTl9QUkVfQ09OU0VOU1VTOlxuICAgICAgICAgICAgcmV0dXJuICdUWF9GSU5BTElaQVRJT05fUkVBU09OX1BSRV9DT05TRU5TVVMnO1xuICAgICAgICBjYXNlIFR4RmluYWxpemF0aW9uUmVhc29uVHlwZS5VTlJFQ09HTklaRUQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ1VOUkVDT0dOSVpFRCc7XG4gICAgfVxufVxuZXhwb3J0cy50eEZpbmFsaXphdGlvblJlYXNvblR5cGVUb0pTT04gPSB0eEZpbmFsaXphdGlvblJlYXNvblR5cGVUb0pTT047XG4vKiogVHlwZSBvZiBtZXNzYWdlIGZvciBhIHR4ICovXG52YXIgVHhNc2dUeXBlO1xuKGZ1bmN0aW9uIChUeE1zZ1R5cGUpIHtcbiAgICAvKiogVFhfQURERURfVE9fTUVNUE9PTCAtIFR4IGFkZGVkIHRvIHRoZSBtZW1wb29sICovXG4gICAgVHhNc2dUeXBlW1R4TXNnVHlwZVtcIlRYX0FEREVEX1RPX01FTVBPT0xcIl0gPSAwXSA9IFwiVFhfQURERURfVE9fTUVNUE9PTFwiO1xuICAgIC8qKiBUWF9SRU1PVkVEX0ZST01fTUVNUE9PTCAtIFR4IHJlbW92ZWQgZnJvbSB0aGUgbWVtcG9vbCAqL1xuICAgIFR4TXNnVHlwZVtUeE1zZ1R5cGVbXCJUWF9SRU1PVkVEX0ZST01fTUVNUE9PTFwiXSA9IDFdID0gXCJUWF9SRU1PVkVEX0ZST01fTUVNUE9PTFwiO1xuICAgIC8qKiBUWF9DT05GSVJNRUQgLSBUeCBjb25maXJtZWQgaW4gYSBibG9jayAqL1xuICAgIFR4TXNnVHlwZVtUeE1zZ1R5cGVbXCJUWF9DT05GSVJNRURcIl0gPSAyXSA9IFwiVFhfQ09ORklSTUVEXCI7XG4gICAgLyoqIFRYX0ZJTkFMSVpFRCAtIFR4IGZpbmFsaXplZCBieSBBdmFsYW5jaGUgKi9cbiAgICBUeE1zZ1R5cGVbVHhNc2dUeXBlW1wiVFhfRklOQUxJWkVEXCJdID0gM10gPSBcIlRYX0ZJTkFMSVpFRFwiO1xuICAgIC8qKiBUWF9JTlZBTElEQVRFRCAtIFR4IGludmFsaWRhdGVkIGJ5IEF2YWxhbmNoZSAqL1xuICAgIFR4TXNnVHlwZVtUeE1zZ1R5cGVbXCJUWF9JTlZBTElEQVRFRFwiXSA9IDRdID0gXCJUWF9JTlZBTElEQVRFRFwiO1xuICAgIFR4TXNnVHlwZVtUeE1zZ1R5cGVbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoVHhNc2dUeXBlID0gZXhwb3J0cy5UeE1zZ1R5cGUgfHwgKGV4cG9ydHMuVHhNc2dUeXBlID0ge30pKTtcbmZ1bmN0aW9uIHR4TXNnVHlwZUZyb21KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAnVFhfQURERURfVE9fTUVNUE9PTCc6XG4gICAgICAgICAgICByZXR1cm4gVHhNc2dUeXBlLlRYX0FEREVEX1RPX01FTVBPT0w7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAnVFhfUkVNT1ZFRF9GUk9NX01FTVBPT0wnOlxuICAgICAgICAgICAgcmV0dXJuIFR4TXNnVHlwZS5UWF9SRU1PVkVEX0ZST01fTUVNUE9PTDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlICdUWF9DT05GSVJNRUQnOlxuICAgICAgICAgICAgcmV0dXJuIFR4TXNnVHlwZS5UWF9DT05GSVJNRUQ7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSAnVFhfRklOQUxJWkVEJzpcbiAgICAgICAgICAgIHJldHVybiBUeE1zZ1R5cGUuVFhfRklOQUxJWkVEO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgJ1RYX0lOVkFMSURBVEVEJzpcbiAgICAgICAgICAgIHJldHVybiBUeE1zZ1R5cGUuVFhfSU5WQUxJREFURUQ7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgJ1VOUkVDT0dOSVpFRCc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gVHhNc2dUeXBlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLnR4TXNnVHlwZUZyb21KU09OID0gdHhNc2dUeXBlRnJvbUpTT047XG5mdW5jdGlvbiB0eE1zZ1R5cGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBUeE1zZ1R5cGUuVFhfQURERURfVE9fTUVNUE9PTDpcbiAgICAgICAgICAgIHJldHVybiAnVFhfQURERURfVE9fTUVNUE9PTCc7XG4gICAgICAgIGNhc2UgVHhNc2dUeXBlLlRYX1JFTU9WRURfRlJPTV9NRU1QT09MOlxuICAgICAgICAgICAgcmV0dXJuICdUWF9SRU1PVkVEX0ZST01fTUVNUE9PTCc7XG4gICAgICAgIGNhc2UgVHhNc2dUeXBlLlRYX0NPTkZJUk1FRDpcbiAgICAgICAgICAgIHJldHVybiAnVFhfQ09ORklSTUVEJztcbiAgICAgICAgY2FzZSBUeE1zZ1R5cGUuVFhfRklOQUxJWkVEOlxuICAgICAgICAgICAgcmV0dXJuICdUWF9GSU5BTElaRUQnO1xuICAgICAgICBjYXNlIFR4TXNnVHlwZS5UWF9JTlZBTElEQVRFRDpcbiAgICAgICAgICAgIHJldHVybiAnVFhfSU5WQUxJREFURUQnO1xuICAgICAgICBjYXNlIFR4TXNnVHlwZS5VTlJFQ09HTklaRUQ6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ1VOUkVDT0dOSVpFRCc7XG4gICAgfVxufVxuZXhwb3J0cy50eE1zZ1R5cGVUb0pTT04gPSB0eE1zZ1R5cGVUb0pTT047XG5mdW5jdGlvbiBjcmVhdGVCYXNlQmxvY2soKSB7XG4gICAgcmV0dXJuIHsgYmxvY2tJbmZvOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuQmxvY2sgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja0luZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5CbG9ja0luZm8uZW5jb2RlKG1lc3NhZ2UuYmxvY2tJbmZvLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUJsb2NrKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmxvY2tJbmZvID0gZXhwb3J0cy5CbG9ja0luZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9ja0luZm86IGlzU2V0KG9iamVjdC5ibG9ja0luZm8pXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSW5mby5mcm9tSlNPTihvYmplY3QuYmxvY2tJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmJsb2NrSW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouYmxvY2tJbmZvID0gZXhwb3J0cy5CbG9ja0luZm8udG9KU09OKG1lc3NhZ2UuYmxvY2tJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQmxvY2suZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9jaygpO1xuICAgICAgICBtZXNzYWdlLmJsb2NrSW5mbyA9XG4gICAgICAgICAgICBvYmplY3QuYmxvY2tJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmJsb2NrSW5mbyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5CbG9ja0luZm8uZnJvbVBhcnRpYWwob2JqZWN0LmJsb2NrSW5mbylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQmxvY2tzKCkge1xuICAgIHJldHVybiB7IGJsb2NrczogW10gfTtcbn1cbmV4cG9ydHMuQmxvY2tzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYmxvY2tzKSB7XG4gICAgICAgICAgICBleHBvcnRzLkJsb2NrSW5mby5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9ja3MoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9ja3MucHVzaChleHBvcnRzLkJsb2NrSW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9ja3M6IGdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShvYmplY3Q/LmJsb2NrcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5ibG9ja3MubWFwKChlKSA9PiBleHBvcnRzLkJsb2NrSW5mby5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmJsb2Nrcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmouYmxvY2tzID0gbWVzc2FnZS5ibG9ja3MubWFwKGUgPT4gZXhwb3J0cy5CbG9ja0luZm8udG9KU09OKGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQmxvY2tzLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQmxvY2tzKCk7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2tzID1cbiAgICAgICAgICAgIG9iamVjdC5ibG9ja3M/Lm1hcChlID0+IGV4cG9ydHMuQmxvY2tJbmZvLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQmxvY2tIZWFkZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmF3SGVhZGVyOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgcm9vdDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIGJyYW5jaDogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMuQmxvY2tIZWFkZXIgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5yYXdIZWFkZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnJhd0hlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uucm9vdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2Uucm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYnJhbmNoKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9ja0hlYWRlcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJhd0hlYWRlciA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJvb3QgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5icmFuY2gucHVzaChyZWFkZXIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SGVhZGVyOiBpc1NldChvYmplY3QucmF3SGVhZGVyKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5yYXdIZWFkZXIpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgICAgIHJvb3Q6IGlzU2V0KG9iamVjdC5yb290KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5yb290KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICBicmFuY2g6IGdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShvYmplY3Q/LmJyYW5jaClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5icmFuY2gubWFwKChlKSA9PiBieXRlc0Zyb21CYXNlNjQoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yYXdIZWFkZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoucmF3SGVhZGVyID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucmF3SGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yb290Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnJvb3QgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5yb290KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5icmFuY2g/Lmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqLmJyYW5jaCA9IG1lc3NhZ2UuYnJhbmNoLm1hcChlID0+IGJhc2U2NEZyb21CeXRlcyhlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkJsb2NrSGVhZGVyLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQmxvY2tIZWFkZXIoKTtcbiAgICAgICAgbWVzc2FnZS5yYXdIZWFkZXIgPSBvYmplY3QucmF3SGVhZGVyID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLnJvb3QgPSBvYmplY3Qucm9vdCA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgbWVzc2FnZS5icmFuY2ggPSBvYmplY3QuYnJhbmNoPy5tYXAoZSA9PiBlKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQmxvY2tIZWFkZXJzKCkge1xuICAgIHJldHVybiB7IGhlYWRlcnM6IFtdIH07XG59XG5leHBvcnRzLkJsb2NrSGVhZGVycyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQmxvY2tIZWFkZXIuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQmxvY2tIZWFkZXJzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVycy5wdXNoKGV4cG9ydHMuQmxvY2tIZWFkZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyczogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8uaGVhZGVycylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5oZWFkZXJzLm1hcCgoZSkgPT4gZXhwb3J0cy5CbG9ja0hlYWRlci5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmhlYWRlcnM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqLmhlYWRlcnMgPSBtZXNzYWdlLmhlYWRlcnMubWFwKGUgPT4gZXhwb3J0cy5CbG9ja0hlYWRlci50b0pTT04oZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5CbG9ja0hlYWRlcnMuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9ja0hlYWRlcnMoKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXJzID1cbiAgICAgICAgICAgIG9iamVjdC5oZWFkZXJzPy5tYXAoZSA9PiBleHBvcnRzLkJsb2NrSGVhZGVyLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQmxvY2tjaGFpbkluZm8oKSB7XG4gICAgcmV0dXJuIHsgdGlwSGFzaDogbmV3IFVpbnQ4QXJyYXkoMCksIHRpcEhlaWdodDogMCB9O1xufVxuZXhwb3J0cy5CbG9ja2NoYWluSW5mbyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRpcEhhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnRpcEhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRpcEhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuaW50MzIobWVzc2FnZS50aXBIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUJsb2NrY2hhaW5JbmZvKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGlwSGFzaCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpcEhlaWdodCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpcEhhc2g6IGlzU2V0KG9iamVjdC50aXBIYXNoKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC50aXBIYXNoKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICB0aXBIZWlnaHQ6IGlzU2V0KG9iamVjdC50aXBIZWlnaHQpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLk51bWJlcihvYmplY3QudGlwSGVpZ2h0KVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS50aXBIYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnRpcEhhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS50aXBIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aXBIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIG9iai50aXBIZWlnaHQgPSBNYXRoLnJvdW5kKG1lc3NhZ2UudGlwSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQmxvY2tjaGFpbkluZm8uZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9ja2NoYWluSW5mbygpO1xuICAgICAgICBtZXNzYWdlLnRpcEhhc2ggPSBvYmplY3QudGlwSGFzaCA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgbWVzc2FnZS50aXBIZWlnaHQgPSBvYmplY3QudGlwSGVpZ2h0ID8/IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNocm9uaWtJbmZvKCkge1xuICAgIHJldHVybiB7IHZlcnNpb246ICcnIH07XG59XG5leHBvcnRzLkNocm9uaWtJbmZvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gJycpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNocm9uaWtJbmZvKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBpc1NldChvYmplY3QudmVyc2lvbilcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC52ZXJzaW9uKVxuICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gJycpIHtcbiAgICAgICAgICAgIG9iai52ZXJzaW9uID0gbWVzc2FnZS52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5DaHJvbmlrSW5mby5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNocm9uaWtJbmZvKCk7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IG9iamVjdC52ZXJzaW9uID8/ICcnO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VCbG9ja0luZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIHByZXZIYXNoOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBuQml0czogMCxcbiAgICAgICAgdGltZXN0YW1wOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgaXNGaW5hbDogZmFsc2UsXG4gICAgICAgIGJsb2NrU2l6ZTogQmlnSW50KCcwJyksXG4gICAgICAgIG51bVR4czogQmlnSW50KCcwJyksXG4gICAgICAgIG51bUlucHV0czogQmlnSW50KCcwJyksXG4gICAgICAgIG51bU91dHB1dHM6IEJpZ0ludCgnMCcpLFxuICAgICAgICBzdW1JbnB1dFNhdHM6IEJpZ0ludCgnMCcpLFxuICAgICAgICBzdW1Db2luYmFzZU91dHB1dFNhdHM6IEJpZ0ludCgnMCcpLFxuICAgICAgICBzdW1Ob3JtYWxPdXRwdXRTYXRzOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgc3VtQnVybmVkU2F0czogQmlnSW50KCcwJyksXG4gICAgfTtcbn1cbmV4cG9ydHMuQmxvY2tJbmZvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHJldkhhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLnByZXZIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLmludDMyKG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5uQml0cyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikudWludDMyKG1lc3NhZ2UubkJpdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcCAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIGlmIChCaWdJbnQuYXNJbnROKDY0LCBtZXNzYWdlLnRpbWVzdGFtcCkgIT09IG1lc3NhZ2UudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ3ZhbHVlIHByb3ZpZGVkIGZvciBmaWVsZCBtZXNzYWdlLnRpbWVzdGFtcCBvZiB0eXBlIGludDY0IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkuaW50NjQobWVzc2FnZS50aW1lc3RhbXAudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNGaW5hbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMTIpLmJvb2wobWVzc2FnZS5pc0ZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja1NpemUgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBpZiAoQmlnSW50LmFzVWludE4oNjQsIG1lc3NhZ2UuYmxvY2tTaXplKSAhPT0gbWVzc2FnZS5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndmFsdWUgcHJvdmlkZWQgZm9yIGZpZWxkIG1lc3NhZ2UuYmxvY2tTaXplIG9mIHR5cGUgdWludDY0IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0OCkudWludDY0KG1lc3NhZ2UuYmxvY2tTaXplLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm51bVR4cyAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIGlmIChCaWdJbnQuYXNVaW50Tig2NCwgbWVzc2FnZS5udW1UeHMpICE9PSBtZXNzYWdlLm51bVR4cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCd2YWx1ZSBwcm92aWRlZCBmb3IgZmllbGQgbWVzc2FnZS5udW1UeHMgb2YgdHlwZSB1aW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDU2KS51aW50NjQobWVzc2FnZS5udW1UeHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubnVtSW5wdXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgaWYgKEJpZ0ludC5hc1VpbnROKDY0LCBtZXNzYWdlLm51bUlucHV0cykgIT09IG1lc3NhZ2UubnVtSW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ3ZhbHVlIHByb3ZpZGVkIGZvciBmaWVsZCBtZXNzYWdlLm51bUlucHV0cyBvZiB0eXBlIHVpbnQ2NCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNjQpLnVpbnQ2NChtZXNzYWdlLm51bUlucHV0cy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5udW1PdXRwdXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgaWYgKEJpZ0ludC5hc1VpbnROKDY0LCBtZXNzYWdlLm51bU91dHB1dHMpICE9PSBtZXNzYWdlLm51bU91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndmFsdWUgcHJvdmlkZWQgZm9yIGZpZWxkIG1lc3NhZ2UubnVtT3V0cHV0cyBvZiB0eXBlIHVpbnQ2NCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNzIpLnVpbnQ2NChtZXNzYWdlLm51bU91dHB1dHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3VtSW5wdXRTYXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgaWYgKEJpZ0ludC5hc0ludE4oNjQsIG1lc3NhZ2Uuc3VtSW5wdXRTYXRzKSAhPT0gbWVzc2FnZS5zdW1JbnB1dFNhdHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndmFsdWUgcHJvdmlkZWQgZm9yIGZpZWxkIG1lc3NhZ2Uuc3VtSW5wdXRTYXRzIG9mIHR5cGUgaW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgwKS5pbnQ2NChtZXNzYWdlLnN1bUlucHV0U2F0cy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdW1Db2luYmFzZU91dHB1dFNhdHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBpZiAoQmlnSW50LmFzSW50Tig2NCwgbWVzc2FnZS5zdW1Db2luYmFzZU91dHB1dFNhdHMpICE9PVxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3VtQ29pbmJhc2VPdXRwdXRTYXRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ3ZhbHVlIHByb3ZpZGVkIGZvciBmaWVsZCBtZXNzYWdlLnN1bUNvaW5iYXNlT3V0cHV0U2F0cyBvZiB0eXBlIGludDY0IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4OCkuaW50NjQobWVzc2FnZS5zdW1Db2luYmFzZU91dHB1dFNhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3VtTm9ybWFsT3V0cHV0U2F0cyAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIGlmIChCaWdJbnQuYXNJbnROKDY0LCBtZXNzYWdlLnN1bU5vcm1hbE91dHB1dFNhdHMpICE9PVxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3VtTm9ybWFsT3V0cHV0U2F0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCd2YWx1ZSBwcm92aWRlZCBmb3IgZmllbGQgbWVzc2FnZS5zdW1Ob3JtYWxPdXRwdXRTYXRzIG9mIHR5cGUgaW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDk2KS5pbnQ2NChtZXNzYWdlLnN1bU5vcm1hbE91dHB1dFNhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3VtQnVybmVkU2F0cyAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIGlmIChCaWdJbnQuYXNJbnROKDY0LCBtZXNzYWdlLnN1bUJ1cm5lZFNhdHMpICE9PVxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3VtQnVybmVkU2F0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCd2YWx1ZSBwcm92aWRlZCBmb3IgZmllbGQgbWVzc2FnZS5zdW1CdXJuZWRTYXRzIG9mIHR5cGUgaW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwNCkuaW50NjQobWVzc2FnZS5zdW1CdXJuZWRTYXRzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUJsb2NrSW5mbygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmV2SGFzaCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDI0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5CaXRzID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDQwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IGxvbmdUb0JpZ2ludChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDExMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc0ZpbmFsID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA0OCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9ja1NpemUgPSBsb25nVG9CaWdpbnQocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA1Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1UeHMgPSBsb25nVG9CaWdpbnQocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1JbnB1dHMgPSBsb25nVG9CaWdpbnQocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA3Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1PdXRwdXRzID0gbG9uZ1RvQmlnaW50KHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDgwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1bUlucHV0U2F0cyA9IGxvbmdUb0JpZ2ludChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDg4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1bUNvaW5iYXNlT3V0cHV0U2F0cyA9IGxvbmdUb0JpZ2ludChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1bU5vcm1hbE91dHB1dFNhdHMgPSBsb25nVG9CaWdpbnQocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3VtQnVybmVkU2F0cyA9IGxvbmdUb0JpZ2ludChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFzaDogaXNTZXQob2JqZWN0Lmhhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmhhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgICAgIHByZXZIYXNoOiBpc1NldChvYmplY3QucHJldkhhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnByZXZIYXNoKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICBoZWlnaHQ6IGlzU2V0KG9iamVjdC5oZWlnaHQpID8gZ2xvYmFsVGhpcy5OdW1iZXIob2JqZWN0LmhlaWdodCkgOiAwLFxuICAgICAgICAgICAgbkJpdHM6IGlzU2V0KG9iamVjdC5uQml0cykgPyBnbG9iYWxUaGlzLk51bWJlcihvYmplY3QubkJpdHMpIDogMCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogaXNTZXQob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA/IEJpZ0ludChvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogQmlnSW50KCcwJyksXG4gICAgICAgICAgICBpc0ZpbmFsOiBpc1NldChvYmplY3QuaXNGaW5hbClcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuQm9vbGVhbihvYmplY3QuaXNGaW5hbClcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgYmxvY2tTaXplOiBpc1NldChvYmplY3QuYmxvY2tTaXplKVxuICAgICAgICAgICAgICAgID8gQmlnSW50KG9iamVjdC5ibG9ja1NpemUpXG4gICAgICAgICAgICAgICAgOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgICAgIG51bVR4czogaXNTZXQob2JqZWN0Lm51bVR4cykgPyBCaWdJbnQob2JqZWN0Lm51bVR4cykgOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgICAgIG51bUlucHV0czogaXNTZXQob2JqZWN0Lm51bUlucHV0cylcbiAgICAgICAgICAgICAgICA/IEJpZ0ludChvYmplY3QubnVtSW5wdXRzKVxuICAgICAgICAgICAgICAgIDogQmlnSW50KCcwJyksXG4gICAgICAgICAgICBudW1PdXRwdXRzOiBpc1NldChvYmplY3QubnVtT3V0cHV0cylcbiAgICAgICAgICAgICAgICA/IEJpZ0ludChvYmplY3QubnVtT3V0cHV0cylcbiAgICAgICAgICAgICAgICA6IEJpZ0ludCgnMCcpLFxuICAgICAgICAgICAgc3VtSW5wdXRTYXRzOiBpc1NldChvYmplY3Quc3VtSW5wdXRTYXRzKVxuICAgICAgICAgICAgICAgID8gQmlnSW50KG9iamVjdC5zdW1JbnB1dFNhdHMpXG4gICAgICAgICAgICAgICAgOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgICAgIHN1bUNvaW5iYXNlT3V0cHV0U2F0czogaXNTZXQob2JqZWN0LnN1bUNvaW5iYXNlT3V0cHV0U2F0cylcbiAgICAgICAgICAgICAgICA/IEJpZ0ludChvYmplY3Quc3VtQ29pbmJhc2VPdXRwdXRTYXRzKVxuICAgICAgICAgICAgICAgIDogQmlnSW50KCcwJyksXG4gICAgICAgICAgICBzdW1Ob3JtYWxPdXRwdXRTYXRzOiBpc1NldChvYmplY3Quc3VtTm9ybWFsT3V0cHV0U2F0cylcbiAgICAgICAgICAgICAgICA/IEJpZ0ludChvYmplY3Quc3VtTm9ybWFsT3V0cHV0U2F0cylcbiAgICAgICAgICAgICAgICA6IEJpZ0ludCgnMCcpLFxuICAgICAgICAgICAgc3VtQnVybmVkU2F0czogaXNTZXQob2JqZWN0LnN1bUJ1cm5lZFNhdHMpXG4gICAgICAgICAgICAgICAgPyBCaWdJbnQob2JqZWN0LnN1bUJ1cm5lZFNhdHMpXG4gICAgICAgICAgICAgICAgOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5oYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLmhhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wcmV2SGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5wcmV2SGFzaCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnByZXZIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIG9iai5oZWlnaHQgPSBNYXRoLnJvdW5kKG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5uQml0cyAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLm5CaXRzID0gTWF0aC5yb3VuZChtZXNzYWdlLm5CaXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aW1lc3RhbXAgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmoudGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXAudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc0ZpbmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvYmouaXNGaW5hbCA9IG1lc3NhZ2UuaXNGaW5hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja1NpemUgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmouYmxvY2tTaXplID0gbWVzc2FnZS5ibG9ja1NpemUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5udW1UeHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmoubnVtVHhzID0gbWVzc2FnZS5udW1UeHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5udW1JbnB1dHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmoubnVtSW5wdXRzID0gbWVzc2FnZS5udW1JbnB1dHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5udW1PdXRwdXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgb2JqLm51bU91dHB1dHMgPSBtZXNzYWdlLm51bU91dHB1dHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdW1JbnB1dFNhdHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmouc3VtSW5wdXRTYXRzID0gbWVzc2FnZS5zdW1JbnB1dFNhdHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdW1Db2luYmFzZU91dHB1dFNhdHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmouc3VtQ29pbmJhc2VPdXRwdXRTYXRzID1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN1bUNvaW5iYXNlT3V0cHV0U2F0cy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN1bU5vcm1hbE91dHB1dFNhdHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmouc3VtTm9ybWFsT3V0cHV0U2F0cyA9IG1lc3NhZ2Uuc3VtTm9ybWFsT3V0cHV0U2F0cy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN1bUJ1cm5lZFNhdHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmouc3VtQnVybmVkU2F0cyA9IG1lc3NhZ2Uuc3VtQnVybmVkU2F0cy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5CbG9ja0luZm8uZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9ja0luZm8oKTtcbiAgICAgICAgbWVzc2FnZS5oYXNoID0gb2JqZWN0Lmhhc2ggPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIG1lc3NhZ2UucHJldkhhc2ggPSBvYmplY3QucHJldkhhc2ggPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gb2JqZWN0LmhlaWdodCA/PyAwO1xuICAgICAgICBtZXNzYWdlLm5CaXRzID0gb2JqZWN0Lm5CaXRzID8/IDA7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gb2JqZWN0LnRpbWVzdGFtcCA/PyBCaWdJbnQoJzAnKTtcbiAgICAgICAgbWVzc2FnZS5pc0ZpbmFsID0gb2JqZWN0LmlzRmluYWwgPz8gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2tTaXplID0gb2JqZWN0LmJsb2NrU2l6ZSA/PyBCaWdJbnQoJzAnKTtcbiAgICAgICAgbWVzc2FnZS5udW1UeHMgPSBvYmplY3QubnVtVHhzID8/IEJpZ0ludCgnMCcpO1xuICAgICAgICBtZXNzYWdlLm51bUlucHV0cyA9IG9iamVjdC5udW1JbnB1dHMgPz8gQmlnSW50KCcwJyk7XG4gICAgICAgIG1lc3NhZ2UubnVtT3V0cHV0cyA9IG9iamVjdC5udW1PdXRwdXRzID8/IEJpZ0ludCgnMCcpO1xuICAgICAgICBtZXNzYWdlLnN1bUlucHV0U2F0cyA9IG9iamVjdC5zdW1JbnB1dFNhdHMgPz8gQmlnSW50KCcwJyk7XG4gICAgICAgIG1lc3NhZ2Uuc3VtQ29pbmJhc2VPdXRwdXRTYXRzID1cbiAgICAgICAgICAgIG9iamVjdC5zdW1Db2luYmFzZU91dHB1dFNhdHMgPz8gQmlnSW50KCcwJyk7XG4gICAgICAgIG1lc3NhZ2Uuc3VtTm9ybWFsT3V0cHV0U2F0cyA9IG9iamVjdC5zdW1Ob3JtYWxPdXRwdXRTYXRzID8/IEJpZ0ludCgnMCcpO1xuICAgICAgICBtZXNzYWdlLnN1bUJ1cm5lZFNhdHMgPSBvYmplY3Quc3VtQnVybmVkU2F0cyA/PyBCaWdJbnQoJzAnKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHgoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhpZDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIHZlcnNpb246IDAsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBsb2NrVGltZTogMCxcbiAgICAgICAgYmxvY2s6IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZUZpcnN0U2VlbjogQmlnSW50KCcwJyksXG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIGlzQ29pbmJhc2U6IGZhbHNlLFxuICAgICAgICB0b2tlbkVudHJpZXM6IFtdLFxuICAgICAgICB0b2tlbkZhaWxlZFBhcnNpbmdzOiBbXSxcbiAgICAgICAgdG9rZW5TdGF0dXM6IDAsXG4gICAgICAgIGlzRmluYWw6IGZhbHNlLFxuICAgIH07XG59XG5leHBvcnRzLlR4ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHhpZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UudHhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuaW50MzIobWVzc2FnZS52ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVHhJbnB1dC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICBleHBvcnRzLlR4T3V0cHV0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmxvY2tUaW1lICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQwKS51aW50MzIobWVzc2FnZS5sb2NrVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5CbG9ja01ldGFkYXRhLmVuY29kZShtZXNzYWdlLmJsb2NrLCB3cml0ZXIudWludDMyKDY2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWVGaXJzdFNlZW4gIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBpZiAoQmlnSW50LmFzSW50Tig2NCwgbWVzc2FnZS50aW1lRmlyc3RTZWVuKSAhPT1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVGaXJzdFNlZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndmFsdWUgcHJvdmlkZWQgZm9yIGZpZWxkIG1lc3NhZ2UudGltZUZpcnN0U2VlbiBvZiB0eXBlIGludDY0IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig3MikuaW50NjQobWVzc2FnZS50aW1lRmlyc3RTZWVuLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoODgpLnVpbnQzMihtZXNzYWdlLnNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlzQ29pbmJhc2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOTYpLmJvb2wobWVzc2FnZS5pc0NvaW5iYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS50b2tlbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVG9rZW5FbnRyeS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UudG9rZW5GYWlsZWRQYXJzaW5ncykge1xuICAgICAgICAgICAgZXhwb3J0cy5Ub2tlbkZhaWxlZFBhcnNpbmcuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTE0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuU3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEyMCkuaW50MzIobWVzc2FnZS50b2tlblN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNGaW5hbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMjgpLmJvb2wobWVzc2FnZS5pc0ZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR4aWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXRzLnB1c2goZXhwb3J0cy5UeElucHV0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dHMucHVzaChleHBvcnRzLlR4T3V0cHV0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDQwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxvY2tUaW1lID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJsb2NrID0gZXhwb3J0cy5CbG9ja01ldGFkYXRhLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZUZpcnN0U2VlbiA9IGxvbmdUb0JpZ2ludChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDg4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpemUgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlzQ29pbmJhc2UgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9rZW5FbnRyaWVzLnB1c2goZXhwb3J0cy5Ub2tlbkVudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9rZW5GYWlsZWRQYXJzaW5ncy5wdXNoKGV4cG9ydHMuVG9rZW5GYWlsZWRQYXJzaW5nLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9rZW5TdGF0dXMgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlzRmluYWwgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4aWQ6IGlzU2V0KG9iamVjdC50eGlkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC50eGlkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICB2ZXJzaW9uOiBpc1NldChvYmplY3QudmVyc2lvbilcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuTnVtYmVyKG9iamVjdC52ZXJzaW9uKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGlucHV0czogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8uaW5wdXRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmlucHV0cy5tYXAoKGUpID0+IGV4cG9ydHMuVHhJbnB1dC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgb3V0cHV0czogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8ub3V0cHV0cylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5vdXRwdXRzLm1hcCgoZSkgPT4gZXhwb3J0cy5UeE91dHB1dC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgbG9ja1RpbWU6IGlzU2V0KG9iamVjdC5sb2NrVGltZSlcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuTnVtYmVyKG9iamVjdC5sb2NrVGltZSlcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBibG9jazogaXNTZXQob2JqZWN0LmJsb2NrKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5CbG9ja01ldGFkYXRhLmZyb21KU09OKG9iamVjdC5ibG9jaylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRpbWVGaXJzdFNlZW46IGlzU2V0KG9iamVjdC50aW1lRmlyc3RTZWVuKVxuICAgICAgICAgICAgICAgID8gQmlnSW50KG9iamVjdC50aW1lRmlyc3RTZWVuKVxuICAgICAgICAgICAgICAgIDogQmlnSW50KCcwJyksXG4gICAgICAgICAgICBzaXplOiBpc1NldChvYmplY3Quc2l6ZSkgPyBnbG9iYWxUaGlzLk51bWJlcihvYmplY3Quc2l6ZSkgOiAwLFxuICAgICAgICAgICAgaXNDb2luYmFzZTogaXNTZXQob2JqZWN0LmlzQ29pbmJhc2UpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLkJvb2xlYW4ob2JqZWN0LmlzQ29pbmJhc2UpXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHRva2VuRW50cmllczogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8udG9rZW5FbnRyaWVzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnRva2VuRW50cmllcy5tYXAoKGUpID0+IGV4cG9ydHMuVG9rZW5FbnRyeS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgdG9rZW5GYWlsZWRQYXJzaW5nczogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8udG9rZW5GYWlsZWRQYXJzaW5ncylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC50b2tlbkZhaWxlZFBhcnNpbmdzLm1hcCgoZSkgPT4gZXhwb3J0cy5Ub2tlbkZhaWxlZFBhcnNpbmcuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIHRva2VuU3RhdHVzOiBpc1NldChvYmplY3QudG9rZW5TdGF0dXMpXG4gICAgICAgICAgICAgICAgPyB0b2tlblN0YXR1c0Zyb21KU09OKG9iamVjdC50b2tlblN0YXR1cylcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBpc0ZpbmFsOiBpc1NldChvYmplY3QuaXNGaW5hbClcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuQm9vbGVhbihvYmplY3QuaXNGaW5hbClcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnR4aWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoudHhpZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnR4aWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT09IDApIHtcbiAgICAgICAgICAgIG9iai52ZXJzaW9uID0gTWF0aC5yb3VuZChtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlucHV0cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmouaW5wdXRzID0gbWVzc2FnZS5pbnB1dHMubWFwKGUgPT4gZXhwb3J0cy5UeElucHV0LnRvSlNPTihlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmoub3V0cHV0cyA9IG1lc3NhZ2Uub3V0cHV0cy5tYXAoZSA9PiBleHBvcnRzLlR4T3V0cHV0LnRvSlNPTihlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubG9ja1RpbWUgIT09IDApIHtcbiAgICAgICAgICAgIG9iai5sb2NrVGltZSA9IE1hdGgucm91bmQobWVzc2FnZS5sb2NrVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLmJsb2NrID0gZXhwb3J0cy5CbG9ja01ldGFkYXRhLnRvSlNPTihtZXNzYWdlLmJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aW1lRmlyc3RTZWVuICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgb2JqLnRpbWVGaXJzdFNlZW4gPSBtZXNzYWdlLnRpbWVGaXJzdFNlZW4udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBvYmouc2l6ZSA9IE1hdGgucm91bmQobWVzc2FnZS5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc0NvaW5iYXNlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvYmouaXNDb2luYmFzZSA9IG1lc3NhZ2UuaXNDb2luYmFzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlbkVudHJpZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqLnRva2VuRW50cmllcyA9IG1lc3NhZ2UudG9rZW5FbnRyaWVzLm1hcChlID0+IGV4cG9ydHMuVG9rZW5FbnRyeS50b0pTT04oZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuRmFpbGVkUGFyc2luZ3M/Lmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqLnRva2VuRmFpbGVkUGFyc2luZ3MgPSBtZXNzYWdlLnRva2VuRmFpbGVkUGFyc2luZ3MubWFwKGUgPT4gZXhwb3J0cy5Ub2tlbkZhaWxlZFBhcnNpbmcudG9KU09OKGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlblN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnRva2VuU3RhdHVzID0gdG9rZW5TdGF0dXNUb0pTT04obWVzc2FnZS50b2tlblN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNGaW5hbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb2JqLmlzRmluYWwgPSBtZXNzYWdlLmlzRmluYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR4LmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHgoKTtcbiAgICAgICAgbWVzc2FnZS50eGlkID0gb2JqZWN0LnR4aWQgPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IG9iamVjdC52ZXJzaW9uID8/IDA7XG4gICAgICAgIG1lc3NhZ2UuaW5wdXRzID0gb2JqZWN0LmlucHV0cz8ubWFwKGUgPT4gZXhwb3J0cy5UeElucHV0LmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5vdXRwdXRzID1cbiAgICAgICAgICAgIG9iamVjdC5vdXRwdXRzPy5tYXAoZSA9PiBleHBvcnRzLlR4T3V0cHV0LmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5sb2NrVGltZSA9IG9iamVjdC5sb2NrVGltZSA/PyAwO1xuICAgICAgICBtZXNzYWdlLmJsb2NrID1cbiAgICAgICAgICAgIG9iamVjdC5ibG9jayAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5ibG9jayAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5CbG9ja01ldGFkYXRhLmZyb21QYXJ0aWFsKG9iamVjdC5ibG9jaylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS50aW1lRmlyc3RTZWVuID0gb2JqZWN0LnRpbWVGaXJzdFNlZW4gPz8gQmlnSW50KCcwJyk7XG4gICAgICAgIG1lc3NhZ2Uuc2l6ZSA9IG9iamVjdC5zaXplID8/IDA7XG4gICAgICAgIG1lc3NhZ2UuaXNDb2luYmFzZSA9IG9iamVjdC5pc0NvaW5iYXNlID8/IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLnRva2VuRW50cmllcyA9XG4gICAgICAgICAgICBvYmplY3QudG9rZW5FbnRyaWVzPy5tYXAoZSA9PiBleHBvcnRzLlRva2VuRW50cnkuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLnRva2VuRmFpbGVkUGFyc2luZ3MgPVxuICAgICAgICAgICAgb2JqZWN0LnRva2VuRmFpbGVkUGFyc2luZ3M/Lm1hcChlID0+IGV4cG9ydHMuVG9rZW5GYWlsZWRQYXJzaW5nLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS50b2tlblN0YXR1cyA9IG9iamVjdC50b2tlblN0YXR1cyA/PyAwO1xuICAgICAgICBtZXNzYWdlLmlzRmluYWwgPSBvYmplY3QuaXNGaW5hbCA/PyBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2NyaXB0VXR4bygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvdXRwb2ludDogdW5kZWZpbmVkLFxuICAgICAgICBibG9ja0hlaWdodDogMCxcbiAgICAgICAgaXNDb2luYmFzZTogZmFsc2UsXG4gICAgICAgIHNhdHM6IEJpZ0ludCgnMCcpLFxuICAgICAgICBpc0ZpbmFsOiBmYWxzZSxcbiAgICAgICAgdG9rZW46IHVuZGVmaW5lZCxcbiAgICAgICAgcGx1Z2luczoge30sXG4gICAgfTtcbn1cbmV4cG9ydHMuU2NyaXB0VXR4byA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm91dHBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuT3V0UG9pbnQuZW5jb2RlKG1lc3NhZ2Uub3V0cG9pbnQsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2tIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDMyKG1lc3NhZ2UuYmxvY2tIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlzQ29pbmJhc2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLmJvb2wobWVzc2FnZS5pc0NvaW5iYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zYXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgaWYgKEJpZ0ludC5hc0ludE4oNjQsIG1lc3NhZ2Uuc2F0cykgIT09IG1lc3NhZ2Uuc2F0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCd2YWx1ZSBwcm92aWRlZCBmb3IgZmllbGQgbWVzc2FnZS5zYXRzIG9mIHR5cGUgaW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQwKS5pbnQ2NChtZXNzYWdlLnNhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNGaW5hbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4MCkuYm9vbChtZXNzYWdlLmlzRmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVG9rZW4uZW5jb2RlKG1lc3NhZ2UudG9rZW4sIHdyaXRlci51aW50MzIoOTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5wbHVnaW5zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGV4cG9ydHMuU2NyaXB0VXR4b19QbHVnaW5zRW50cnkuZW5jb2RlKHsga2V5OiBrZXksIHZhbHVlIH0sIHdyaXRlci51aW50MzIoOTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTY3JpcHRVdHhvKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cG9pbnQgPSBleHBvcnRzLk91dFBvaW50LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmxvY2tIZWlnaHQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAyNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc0NvaW5iYXNlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zYXRzID0gbG9uZ1RvQmlnaW50KHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gODApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNGaW5hbCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDkwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRva2VuID0gZXhwb3J0cy5Ub2tlbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA5OCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnkxMiA9IGV4cG9ydHMuU2NyaXB0VXR4b19QbHVnaW5zRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5MTIudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbHVnaW5zW2VudHJ5MTIua2V5XSA9IGVudHJ5MTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvdXRwb2ludDogaXNTZXQob2JqZWN0Lm91dHBvaW50KVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PdXRQb2ludC5mcm9tSlNPTihvYmplY3Qub3V0cG9pbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBibG9ja0hlaWdodDogaXNTZXQob2JqZWN0LmJsb2NrSGVpZ2h0KVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5OdW1iZXIob2JqZWN0LmJsb2NrSGVpZ2h0KVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGlzQ29pbmJhc2U6IGlzU2V0KG9iamVjdC5pc0NvaW5iYXNlKVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5Cb29sZWFuKG9iamVjdC5pc0NvaW5iYXNlKVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBzYXRzOiBpc1NldChvYmplY3Quc2F0cykgPyBCaWdJbnQob2JqZWN0LnNhdHMpIDogQmlnSW50KCcwJyksXG4gICAgICAgICAgICBpc0ZpbmFsOiBpc1NldChvYmplY3QuaXNGaW5hbClcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuQm9vbGVhbihvYmplY3QuaXNGaW5hbClcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdG9rZW46IGlzU2V0KG9iamVjdC50b2tlbilcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVG9rZW4uZnJvbUpTT04ob2JqZWN0LnRva2VuKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGx1Z2luczogaXNPYmplY3Qob2JqZWN0LnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuZW50cmllcyhvYmplY3QucGx1Z2lucykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGV4cG9ydHMuUGx1Z2luRW50cnkuZnJvbUpTT04odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KVxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLm91dHBvaW50ID0gZXhwb3J0cy5PdXRQb2ludC50b0pTT04obWVzc2FnZS5vdXRwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2tIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIG9iai5ibG9ja0hlaWdodCA9IE1hdGgucm91bmQobWVzc2FnZS5ibG9ja0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNDb2luYmFzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb2JqLmlzQ29pbmJhc2UgPSBtZXNzYWdlLmlzQ29pbmJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2F0cyAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIG9iai5zYXRzID0gbWVzc2FnZS5zYXRzLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNGaW5hbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb2JqLmlzRmluYWwgPSBtZXNzYWdlLmlzRmluYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLnRva2VuID0gZXhwb3J0cy5Ub2tlbi50b0pTT04obWVzc2FnZS50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGx1Z2lucykge1xuICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UucGx1Z2lucyk7XG4gICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb2JqLnBsdWdpbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvYmoucGx1Z2luc1trXSA9IGV4cG9ydHMuUGx1Z2luRW50cnkudG9KU09OKHYpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5TY3JpcHRVdHhvLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2NyaXB0VXR4bygpO1xuICAgICAgICBtZXNzYWdlLm91dHBvaW50ID1cbiAgICAgICAgICAgIG9iamVjdC5vdXRwb2ludCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5vdXRwb2ludCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PdXRQb2ludC5mcm9tUGFydGlhbChvYmplY3Qub3V0cG9pbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2tIZWlnaHQgPSBvYmplY3QuYmxvY2tIZWlnaHQgPz8gMDtcbiAgICAgICAgbWVzc2FnZS5pc0NvaW5iYXNlID0gb2JqZWN0LmlzQ29pbmJhc2UgPz8gZmFsc2U7XG4gICAgICAgIG1lc3NhZ2Uuc2F0cyA9IG9iamVjdC5zYXRzID8/IEJpZ0ludCgnMCcpO1xuICAgICAgICBtZXNzYWdlLmlzRmluYWwgPSBvYmplY3QuaXNGaW5hbCA/PyBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS50b2tlbiA9XG4gICAgICAgICAgICBvYmplY3QudG9rZW4gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudG9rZW4gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVG9rZW4uZnJvbVBhcnRpYWwob2JqZWN0LnRva2VuKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnBsdWdpbnMgPSBPYmplY3QuZW50cmllcyhvYmplY3QucGx1Z2lucyA/PyB7fSkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGV4cG9ydHMuUGx1Z2luRW50cnkuZnJvbVBhcnRpYWwodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTY3JpcHRVdHhvX1BsdWdpbnNFbnRyeSgpIHtcbiAgICByZXR1cm4geyBrZXk6ICcnLCB2YWx1ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLlNjcmlwdFV0eG9fUGx1Z2luc0VudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9PSAnJykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlBsdWdpbkVudHJ5LmVuY29kZShtZXNzYWdlLnZhbHVlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNjcmlwdFV0eG9fUGx1Z2luc0VudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gZXhwb3J0cy5QbHVnaW5FbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBnbG9iYWxUaGlzLlN0cmluZyhvYmplY3Qua2V5KSA6ICcnLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuUGx1Z2luRW50cnkuZnJvbUpTT04ob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gJycpIHtcbiAgICAgICAgICAgIG9iai5rZXkgPSBtZXNzYWdlLmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmoudmFsdWUgPSBleHBvcnRzLlBsdWdpbkVudHJ5LnRvSlNPTihtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0VXR4b19QbHVnaW5zRW50cnkuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTY3JpcHRVdHhvX1BsdWdpbnNFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IG9iamVjdC5rZXkgPz8gJyc7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlBsdWdpbkVudHJ5LmZyb21QYXJ0aWFsKG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVXR4bygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvdXRwb2ludDogdW5kZWZpbmVkLFxuICAgICAgICBibG9ja0hlaWdodDogMCxcbiAgICAgICAgaXNDb2luYmFzZTogZmFsc2UsXG4gICAgICAgIHNhdHM6IEJpZ0ludCgnMCcpLFxuICAgICAgICBzY3JpcHQ6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICBpc0ZpbmFsOiBmYWxzZSxcbiAgICAgICAgdG9rZW46IHVuZGVmaW5lZCxcbiAgICAgICAgcGx1Z2luczoge30sXG4gICAgfTtcbn1cbmV4cG9ydHMuVXR4byA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm91dHBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuT3V0UG9pbnQuZW5jb2RlKG1lc3NhZ2Uub3V0cG9pbnQsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2tIZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDMyKG1lc3NhZ2UuYmxvY2tIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlzQ29pbmJhc2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLmJvb2wobWVzc2FnZS5pc0NvaW5iYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zYXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgaWYgKEJpZ0ludC5hc0ludE4oNjQsIG1lc3NhZ2Uuc2F0cykgIT09IG1lc3NhZ2Uuc2F0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCd2YWx1ZSBwcm92aWRlZCBmb3IgZmllbGQgbWVzc2FnZS5zYXRzIG9mIHR5cGUgaW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5pbnQ2NChtZXNzYWdlLnNhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2NyaXB0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MikuYnl0ZXMobWVzc2FnZS5zY3JpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlzRmluYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDgpLmJvb2wobWVzc2FnZS5pc0ZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlRva2VuLmVuY29kZShtZXNzYWdlLnRva2VuLCB3cml0ZXIudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2UucGx1Z2lucykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBleHBvcnRzLlV0eG9fUGx1Z2luc0VudHJ5LmVuY29kZSh7IGtleToga2V5LCB2YWx1ZSB9LCB3cml0ZXIudWludDMyKDY2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVXR4bygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHBvaW50ID0gZXhwb3J0cy5PdXRQb2ludC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJsb2NrSGVpZ2h0ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNDb2luYmFzZSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2F0cyA9IGxvbmdUb0JpZ2ludChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2NyaXB0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNGaW5hbCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9rZW4gPSBleHBvcnRzLlRva2VuLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5OCA9IGV4cG9ydHMuVXR4b19QbHVnaW5zRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5OC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsdWdpbnNbZW50cnk4LmtleV0gPSBlbnRyeTgudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvdXRwb2ludDogaXNTZXQob2JqZWN0Lm91dHBvaW50KVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PdXRQb2ludC5mcm9tSlNPTihvYmplY3Qub3V0cG9pbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBibG9ja0hlaWdodDogaXNTZXQob2JqZWN0LmJsb2NrSGVpZ2h0KVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5OdW1iZXIob2JqZWN0LmJsb2NrSGVpZ2h0KVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGlzQ29pbmJhc2U6IGlzU2V0KG9iamVjdC5pc0NvaW5iYXNlKVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5Cb29sZWFuKG9iamVjdC5pc0NvaW5iYXNlKVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBzYXRzOiBpc1NldChvYmplY3Quc2F0cykgPyBCaWdJbnQob2JqZWN0LnNhdHMpIDogQmlnSW50KCcwJyksXG4gICAgICAgICAgICBzY3JpcHQ6IGlzU2V0KG9iamVjdC5zY3JpcHQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnNjcmlwdClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICAgICAgaXNGaW5hbDogaXNTZXQob2JqZWN0LmlzRmluYWwpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLkJvb2xlYW4ob2JqZWN0LmlzRmluYWwpXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHRva2VuOiBpc1NldChvYmplY3QudG9rZW4pXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlRva2VuLmZyb21KU09OKG9iamVjdC50b2tlbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBsdWdpbnM6IGlzT2JqZWN0KG9iamVjdC5wbHVnaW5zKVxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmVudHJpZXMob2JqZWN0LnBsdWdpbnMpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2tleV0gPSBleHBvcnRzLlBsdWdpbkVudHJ5LmZyb21KU09OKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICB9LCB7fSlcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLm91dHBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai5vdXRwb2ludCA9IGV4cG9ydHMuT3V0UG9pbnQudG9KU09OKG1lc3NhZ2Uub3V0cG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmJsb2NrSGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICBvYmouYmxvY2tIZWlnaHQgPSBNYXRoLnJvdW5kKG1lc3NhZ2UuYmxvY2tIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlzQ29pbmJhc2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9iai5pc0NvaW5iYXNlID0gbWVzc2FnZS5pc0NvaW5iYXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNhdHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmouc2F0cyA9IG1lc3NhZ2Uuc2F0cy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNjcmlwdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5zY3JpcHQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5zY3JpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlzRmluYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9iai5pc0ZpbmFsID0gbWVzc2FnZS5pc0ZpbmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai50b2tlbiA9IGV4cG9ydHMuVG9rZW4udG9KU09OKG1lc3NhZ2UudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhtZXNzYWdlLnBsdWdpbnMpO1xuICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9iai5wbHVnaW5zID0ge307XG4gICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnBsdWdpbnNba10gPSBleHBvcnRzLlBsdWdpbkVudHJ5LnRvSlNPTih2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVXR4by5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVV0eG8oKTtcbiAgICAgICAgbWVzc2FnZS5vdXRwb2ludCA9XG4gICAgICAgICAgICBvYmplY3Qub3V0cG9pbnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Qub3V0cG9pbnQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuT3V0UG9pbnQuZnJvbVBhcnRpYWwob2JqZWN0Lm91dHBvaW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmJsb2NrSGVpZ2h0ID0gb2JqZWN0LmJsb2NrSGVpZ2h0ID8/IDA7XG4gICAgICAgIG1lc3NhZ2UuaXNDb2luYmFzZSA9IG9iamVjdC5pc0NvaW5iYXNlID8/IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLnNhdHMgPSBvYmplY3Quc2F0cyA/PyBCaWdJbnQoJzAnKTtcbiAgICAgICAgbWVzc2FnZS5zY3JpcHQgPSBvYmplY3Quc2NyaXB0ID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLmlzRmluYWwgPSBvYmplY3QuaXNGaW5hbCA/PyBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS50b2tlbiA9XG4gICAgICAgICAgICBvYmplY3QudG9rZW4gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudG9rZW4gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVG9rZW4uZnJvbVBhcnRpYWwob2JqZWN0LnRva2VuKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnBsdWdpbnMgPSBPYmplY3QuZW50cmllcyhvYmplY3QucGx1Z2lucyA/PyB7fSkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IGV4cG9ydHMuUGx1Z2luRW50cnkuZnJvbVBhcnRpYWwodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VVdHhvX1BsdWdpbnNFbnRyeSgpIHtcbiAgICByZXR1cm4geyBrZXk6ICcnLCB2YWx1ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLlV0eG9fUGx1Z2luc0VudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9PSAnJykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlBsdWdpbkVudHJ5LmVuY29kZShtZXNzYWdlLnZhbHVlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVV0eG9fUGx1Z2luc0VudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gZXhwb3J0cy5QbHVnaW5FbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBnbG9iYWxUaGlzLlN0cmluZyhvYmplY3Qua2V5KSA6ICcnLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuUGx1Z2luRW50cnkuZnJvbUpTT04ob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gJycpIHtcbiAgICAgICAgICAgIG9iai5rZXkgPSBtZXNzYWdlLmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmoudmFsdWUgPSBleHBvcnRzLlBsdWdpbkVudHJ5LnRvSlNPTihtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVXR4b19QbHVnaW5zRW50cnkuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVdHhvX1BsdWdpbnNFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmtleSA9IG9iamVjdC5rZXkgPz8gJyc7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnZhbHVlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlBsdWdpbkVudHJ5LmZyb21QYXJ0aWFsKG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlT3V0UG9pbnQoKSB7XG4gICAgcmV0dXJuIHsgdHhpZDogbmV3IFVpbnQ4QXJyYXkoMCksIG91dElkeDogMCB9O1xufVxuZXhwb3J0cy5PdXRQb2ludCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnR4aWQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnR4aWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm91dElkeCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDMyKG1lc3NhZ2Uub3V0SWR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VPdXRQb2ludCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR4aWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRJZHggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhpZDogaXNTZXQob2JqZWN0LnR4aWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnR4aWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgICAgIG91dElkeDogaXNTZXQob2JqZWN0Lm91dElkeCkgPyBnbG9iYWxUaGlzLk51bWJlcihvYmplY3Qub3V0SWR4KSA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHhpZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai50eGlkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UudHhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uub3V0SWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoub3V0SWR4ID0gTWF0aC5yb3VuZChtZXNzYWdlLm91dElkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk91dFBvaW50LmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlT3V0UG9pbnQoKTtcbiAgICAgICAgbWVzc2FnZS50eGlkID0gb2JqZWN0LnR4aWQgPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIG1lc3NhZ2Uub3V0SWR4ID0gb2JqZWN0Lm91dElkeCA/PyAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTcGVudEJ5KCkge1xuICAgIHJldHVybiB7IHR4aWQ6IG5ldyBVaW50OEFycmF5KDApLCBpbnB1dElkeDogMCB9O1xufVxuZXhwb3J0cy5TcGVudEJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHhpZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UudHhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXRJZHggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQzMihtZXNzYWdlLmlucHV0SWR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTcGVudEJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHhpZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0SWR4ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4aWQ6IGlzU2V0KG9iamVjdC50eGlkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC50eGlkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICBpbnB1dElkeDogaXNTZXQob2JqZWN0LmlucHV0SWR4KVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5OdW1iZXIob2JqZWN0LmlucHV0SWR4KVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS50eGlkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnR4aWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS50eGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbnB1dElkeCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLmlucHV0SWR4ID0gTWF0aC5yb3VuZChtZXNzYWdlLmlucHV0SWR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuU3BlbnRCeS5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNwZW50QnkoKTtcbiAgICAgICAgbWVzc2FnZS50eGlkID0gb2JqZWN0LnR4aWQgPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIG1lc3NhZ2UuaW5wdXRJZHggPSBvYmplY3QuaW5wdXRJZHggPz8gMDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHhJbnB1dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmV2T3V0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0U2NyaXB0OiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgb3V0cHV0U2NyaXB0OiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgc2F0czogQmlnSW50KCcwJyksXG4gICAgICAgIHNlcXVlbmNlTm86IDAsXG4gICAgICAgIHRva2VuOiB1bmRlZmluZWQsXG4gICAgICAgIHBsdWdpbnM6IHt9LFxuICAgIH07XG59XG5leHBvcnRzLlR4SW5wdXQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wcmV2T3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuT3V0UG9pbnQuZW5jb2RlKG1lc3NhZ2UucHJldk91dCwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbnB1dFNjcmlwdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuaW5wdXRTY3JpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm91dHB1dFNjcmlwdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLmJ5dGVzKG1lc3NhZ2Uub3V0cHV0U2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zYXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgaWYgKEJpZ0ludC5hc0ludE4oNjQsIG1lc3NhZ2Uuc2F0cykgIT09IG1lc3NhZ2Uuc2F0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBnbG9iYWxUaGlzLkVycm9yKCd2YWx1ZSBwcm92aWRlZCBmb3IgZmllbGQgbWVzc2FnZS5zYXRzIG9mIHR5cGUgaW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5pbnQ2NChtZXNzYWdlLnNhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VObyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkudWludDMyKG1lc3NhZ2Uuc2VxdWVuY2VObyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Ub2tlbi5lbmNvZGUobWVzc2FnZS50b2tlbiwgd3JpdGVyLnVpbnQzMig2NikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZW50cmllcyhtZXNzYWdlLnBsdWdpbnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgZXhwb3J0cy5UeElucHV0X1BsdWdpbnNFbnRyeS5lbmNvZGUoeyBrZXk6IGtleSwgdmFsdWUgfSwgd3JpdGVyLnVpbnQzMig3NCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVR4SW5wdXQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmV2T3V0ID0gZXhwb3J0cy5PdXRQb2ludC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0U2NyaXB0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0U2NyaXB0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2F0cyA9IGxvbmdUb0JpZ2ludChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VxdWVuY2VObyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA2Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b2tlbiA9IGV4cG9ydHMuVG9rZW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA3NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnk5ID0gZXhwb3J0cy5UeElucHV0X1BsdWdpbnNFbnRyeS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnk5LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGx1Z2luc1tlbnRyeTkua2V5XSA9IGVudHJ5OS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXZPdXQ6IGlzU2V0KG9iamVjdC5wcmV2T3V0KVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5PdXRQb2ludC5mcm9tSlNPTihvYmplY3QucHJldk91dClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlucHV0U2NyaXB0OiBpc1NldChvYmplY3QuaW5wdXRTY3JpcHQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmlucHV0U2NyaXB0KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICBvdXRwdXRTY3JpcHQ6IGlzU2V0KG9iamVjdC5vdXRwdXRTY3JpcHQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lm91dHB1dFNjcmlwdClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICAgICAgc2F0czogaXNTZXQob2JqZWN0LnNhdHMpID8gQmlnSW50KG9iamVjdC5zYXRzKSA6IEJpZ0ludCgnMCcpLFxuICAgICAgICAgICAgc2VxdWVuY2VObzogaXNTZXQob2JqZWN0LnNlcXVlbmNlTm8pXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLk51bWJlcihvYmplY3Quc2VxdWVuY2VObylcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICB0b2tlbjogaXNTZXQob2JqZWN0LnRva2VuKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Ub2tlbi5mcm9tSlNPTihvYmplY3QudG9rZW4pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwbHVnaW5zOiBpc09iamVjdChvYmplY3QucGx1Z2lucylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC5wbHVnaW5zKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gZXhwb3J0cy5QbHVnaW5FbnRyeS5mcm9tSlNPTih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5wcmV2T3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai5wcmV2T3V0ID0gZXhwb3J0cy5PdXRQb2ludC50b0pTT04obWVzc2FnZS5wcmV2T3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbnB1dFNjcmlwdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5pbnB1dFNjcmlwdCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmlucHV0U2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXRTY3JpcHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoub3V0cHV0U2NyaXB0ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uub3V0cHV0U2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zYXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgb2JqLnNhdHMgPSBtZXNzYWdlLnNhdHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZXF1ZW5jZU5vICE9PSAwKSB7XG4gICAgICAgICAgICBvYmouc2VxdWVuY2VObyA9IE1hdGgucm91bmQobWVzc2FnZS5zZXF1ZW5jZU5vKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmoudG9rZW4gPSBleHBvcnRzLlRva2VuLnRvSlNPTihtZXNzYWdlLnRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wbHVnaW5zKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobWVzc2FnZS5wbHVnaW5zKTtcbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvYmoucGx1Z2lucyA9IHt9O1xuICAgICAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5wbHVnaW5zW2tdID0gZXhwb3J0cy5QbHVnaW5FbnRyeS50b0pTT04odik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR4SW5wdXQuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeElucHV0KCk7XG4gICAgICAgIG1lc3NhZ2UucHJldk91dCA9XG4gICAgICAgICAgICBvYmplY3QucHJldk91dCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wcmV2T3V0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLk91dFBvaW50LmZyb21QYXJ0aWFsKG9iamVjdC5wcmV2T3V0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmlucHV0U2NyaXB0ID0gb2JqZWN0LmlucHV0U2NyaXB0ID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLm91dHB1dFNjcmlwdCA9IG9iamVjdC5vdXRwdXRTY3JpcHQgPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIG1lc3NhZ2Uuc2F0cyA9IG9iamVjdC5zYXRzID8/IEJpZ0ludCgnMCcpO1xuICAgICAgICBtZXNzYWdlLnNlcXVlbmNlTm8gPSBvYmplY3Quc2VxdWVuY2VObyA/PyAwO1xuICAgICAgICBtZXNzYWdlLnRva2VuID1cbiAgICAgICAgICAgIG9iamVjdC50b2tlbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50b2tlbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Ub2tlbi5mcm9tUGFydGlhbChvYmplY3QudG9rZW4pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucGx1Z2lucyA9IE9iamVjdC5lbnRyaWVzKG9iamVjdC5wbHVnaW5zID8/IHt9KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZXhwb3J0cy5QbHVnaW5FbnRyeS5mcm9tUGFydGlhbCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVR4SW5wdXRfUGx1Z2luc0VudHJ5KCkge1xuICAgIHJldHVybiB7IGtleTogJycsIHZhbHVlOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuVHhJbnB1dF9QbHVnaW5zRW50cnkgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT09ICcnKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuUGx1Z2luRW50cnkuZW5jb2RlKG1lc3NhZ2UudmFsdWUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHhJbnB1dF9QbHVnaW5zRW50cnkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSBleHBvcnRzLlBsdWdpbkVudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC5rZXkpIDogJycsXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5QbHVnaW5FbnRyeS5mcm9tSlNPTihvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9PSAnJykge1xuICAgICAgICAgICAgb2JqLmtleSA9IG1lc3NhZ2Uua2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai52YWx1ZSA9IGV4cG9ydHMuUGx1Z2luRW50cnkudG9KU09OKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeElucHV0X1BsdWdpbnNFbnRyeS5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVR4SW5wdXRfUGx1Z2luc0VudHJ5KCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5ID0gb2JqZWN0LmtleSA/PyAnJztcbiAgICAgICAgbWVzc2FnZS52YWx1ZSA9XG4gICAgICAgICAgICBvYmplY3QudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuUGx1Z2luRW50cnkuZnJvbVBhcnRpYWwob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUeE91dHB1dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzYXRzOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgb3V0cHV0U2NyaXB0OiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgc3BlbnRCeTogdW5kZWZpbmVkLFxuICAgICAgICB0b2tlbjogdW5kZWZpbmVkLFxuICAgICAgICBwbHVnaW5zOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5UeE91dHB1dCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNhdHMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBpZiAoQmlnSW50LmFzSW50Tig2NCwgbWVzc2FnZS5zYXRzKSAhPT0gbWVzc2FnZS5zYXRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ3ZhbHVlIHByb3ZpZGVkIGZvciBmaWVsZCBtZXNzYWdlLnNhdHMgb2YgdHlwZSBpbnQ2NCB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50NjQobWVzc2FnZS5zYXRzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm91dHB1dFNjcmlwdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2Uub3V0cHV0U2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zcGVudEJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU3BlbnRCeS5lbmNvZGUobWVzc2FnZS5zcGVudEJ5LCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVG9rZW4uZW5jb2RlKG1lc3NhZ2UudG9rZW4sIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmVudHJpZXMobWVzc2FnZS5wbHVnaW5zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGV4cG9ydHMuVHhPdXRwdXRfUGx1Z2luc0VudHJ5LmVuY29kZSh7IGtleToga2V5LCB2YWx1ZSB9LCB3cml0ZXIudWludDMyKDUwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHhPdXRwdXQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNhdHMgPSBsb25nVG9CaWdpbnQocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dFNjcmlwdCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwZW50QnkgPSBleHBvcnRzLlNwZW50QnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b2tlbiA9IGV4cG9ydHMuVG9rZW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cnk2ID0gZXhwb3J0cy5UeE91dHB1dF9QbHVnaW5zRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5Ni52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsdWdpbnNbZW50cnk2LmtleV0gPSBlbnRyeTYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzYXRzOiBpc1NldChvYmplY3Quc2F0cykgPyBCaWdJbnQob2JqZWN0LnNhdHMpIDogQmlnSW50KCcwJyksXG4gICAgICAgICAgICBvdXRwdXRTY3JpcHQ6IGlzU2V0KG9iamVjdC5vdXRwdXRTY3JpcHQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lm91dHB1dFNjcmlwdClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICAgICAgc3BlbnRCeTogaXNTZXQob2JqZWN0LnNwZW50QnkpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlNwZW50QnkuZnJvbUpTT04ob2JqZWN0LnNwZW50QnkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0b2tlbjogaXNTZXQob2JqZWN0LnRva2VuKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Ub2tlbi5mcm9tSlNPTihvYmplY3QudG9rZW4pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwbHVnaW5zOiBpc09iamVjdChvYmplY3QucGx1Z2lucylcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKG9iamVjdC5wbHVnaW5zKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gZXhwb3J0cy5QbHVnaW5FbnRyeS5mcm9tSlNPTih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwge30pXG4gICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5zYXRzICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgb2JqLnNhdHMgPSBtZXNzYWdlLnNhdHMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXRTY3JpcHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoub3V0cHV0U2NyaXB0ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uub3V0cHV0U2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zcGVudEJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai5zcGVudEJ5ID0gZXhwb3J0cy5TcGVudEJ5LnRvSlNPTihtZXNzYWdlLnNwZW50QnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai50b2tlbiA9IGV4cG9ydHMuVG9rZW4udG9KU09OKG1lc3NhZ2UudG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhtZXNzYWdlLnBsdWdpbnMpO1xuICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9iai5wbHVnaW5zID0ge307XG4gICAgICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnBsdWdpbnNba10gPSBleHBvcnRzLlBsdWdpbkVudHJ5LnRvSlNPTih2KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHhPdXRwdXQuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeE91dHB1dCgpO1xuICAgICAgICBtZXNzYWdlLnNhdHMgPSBvYmplY3Quc2F0cyA/PyBCaWdJbnQoJzAnKTtcbiAgICAgICAgbWVzc2FnZS5vdXRwdXRTY3JpcHQgPSBvYmplY3Qub3V0cHV0U2NyaXB0ID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLnNwZW50QnkgPVxuICAgICAgICAgICAgb2JqZWN0LnNwZW50QnkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc3BlbnRCeSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TcGVudEJ5LmZyb21QYXJ0aWFsKG9iamVjdC5zcGVudEJ5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnRva2VuID1cbiAgICAgICAgICAgIG9iamVjdC50b2tlbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50b2tlbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Ub2tlbi5mcm9tUGFydGlhbChvYmplY3QudG9rZW4pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucGx1Z2lucyA9IE9iamVjdC5lbnRyaWVzKG9iamVjdC5wbHVnaW5zID8/IHt9KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gZXhwb3J0cy5QbHVnaW5FbnRyeS5mcm9tUGFydGlhbCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVR4T3V0cHV0X1BsdWdpbnNFbnRyeSgpIHtcbiAgICByZXR1cm4geyBrZXk6ICcnLCB2YWx1ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLlR4T3V0cHV0X1BsdWdpbnNFbnRyeSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gJycpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5QbHVnaW5FbnRyeS5lbmNvZGUobWVzc2FnZS52YWx1ZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeE91dHB1dF9QbHVnaW5zRW50cnkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSBleHBvcnRzLlBsdWdpbkVudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC5rZXkpIDogJycsXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5QbHVnaW5FbnRyeS5mcm9tSlNPTihvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9PSAnJykge1xuICAgICAgICAgICAgb2JqLmtleSA9IG1lc3NhZ2Uua2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai52YWx1ZSA9IGV4cG9ydHMuUGx1Z2luRW50cnkudG9KU09OKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeE91dHB1dF9QbHVnaW5zRW50cnkuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeE91dHB1dF9QbHVnaW5zRW50cnkoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSBvYmplY3Qua2V5ID8/ICcnO1xuICAgICAgICBtZXNzYWdlLnZhbHVlID1cbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52YWx1ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5QbHVnaW5FbnRyeS5mcm9tUGFydGlhbChvYmplY3QudmFsdWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUJsb2NrTWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBoYXNoOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgdGltZXN0YW1wOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgaXNGaW5hbDogZmFsc2UsXG4gICAgfTtcbn1cbmV4cG9ydHMuQmxvY2tNZXRhZGF0YSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudGltZXN0YW1wICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgaWYgKEJpZ0ludC5hc0ludE4oNjQsIG1lc3NhZ2UudGltZXN0YW1wKSAhPT0gbWVzc2FnZS50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndmFsdWUgcHJvdmlkZWQgZm9yIGZpZWxkIG1lc3NhZ2UudGltZXN0YW1wIG9mIHR5cGUgaW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5pbnQ2NChtZXNzYWdlLnRpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc0ZpbmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5ib29sKG1lc3NhZ2UuaXNGaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQmxvY2tNZXRhZGF0YSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDI0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IGxvbmdUb0JpZ2ludChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNGaW5hbCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiBpc1NldChvYmplY3QuaGVpZ2h0KSA/IGdsb2JhbFRoaXMuTnVtYmVyKG9iamVjdC5oZWlnaHQpIDogMCxcbiAgICAgICAgICAgIGhhc2g6IGlzU2V0KG9iamVjdC5oYXNoKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5oYXNoKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGlzU2V0KG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgPyBCaWdJbnQob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IEJpZ0ludCgnMCcpLFxuICAgICAgICAgICAgaXNGaW5hbDogaXNTZXQob2JqZWN0LmlzRmluYWwpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLkJvb2xlYW4ob2JqZWN0LmlzRmluYWwpXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5oZWlnaHQgIT09IDApIHtcbiAgICAgICAgICAgIG9iai5oZWlnaHQgPSBNYXRoLnJvdW5kKG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLmhhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aW1lc3RhbXAgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmoudGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXAudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc0ZpbmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvYmouaXNGaW5hbCA9IG1lc3NhZ2UuaXNGaW5hbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQmxvY2tNZXRhZGF0YS5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUJsb2NrTWV0YWRhdGEoKTtcbiAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSBvYmplY3QuaGVpZ2h0ID8/IDA7XG4gICAgICAgIG1lc3NhZ2UuaGFzaCA9IG9iamVjdC5oYXNoID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IG9iamVjdC50aW1lc3RhbXAgPz8gQmlnSW50KCcwJyk7XG4gICAgICAgIG1lc3NhZ2UuaXNGaW5hbCA9IG9iamVjdC5pc0ZpbmFsID8/IGZhbHNlO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUb2tlblR5cGUoKSB7XG4gICAgcmV0dXJuIHsgc2xwOiB1bmRlZmluZWQsIGFscDogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLlRva2VuVHlwZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNscCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2Uuc2xwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hbHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuaW50MzIobWVzc2FnZS5hbHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRva2VuVHlwZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2xwID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWxwID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2xwOiBpc1NldChvYmplY3Quc2xwKVxuICAgICAgICAgICAgICAgID8gc2xwVG9rZW5UeXBlRnJvbUpTT04ob2JqZWN0LnNscClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFscDogaXNTZXQob2JqZWN0LmFscClcbiAgICAgICAgICAgICAgICA/IGFscFRva2VuVHlwZUZyb21KU09OKG9iamVjdC5hbHApXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2xwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai5zbHAgPSBzbHBUb2tlblR5cGVUb0pTT04obWVzc2FnZS5zbHApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFscCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouYWxwID0gYWxwVG9rZW5UeXBlVG9KU09OKG1lc3NhZ2UuYWxwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVG9rZW5UeXBlLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVG9rZW5UeXBlKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2xwID0gb2JqZWN0LnNscCA/PyB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuYWxwID0gb2JqZWN0LmFscCA/PyB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVRva2VuSW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbklkOiAnJyxcbiAgICAgICAgdG9rZW5UeXBlOiB1bmRlZmluZWQsXG4gICAgICAgIGdlbmVzaXNJbmZvOiB1bmRlZmluZWQsXG4gICAgICAgIGJsb2NrOiB1bmRlZmluZWQsXG4gICAgICAgIHRpbWVGaXJzdFNlZW46IEJpZ0ludCgnMCcpLFxuICAgIH07XG59XG5leHBvcnRzLlRva2VuSW5mbyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuSWQgIT09ICcnKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50b2tlbklkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Ub2tlblR5cGUuZW5jb2RlKG1lc3NhZ2UudG9rZW5UeXBlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmdlbmVzaXNJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuR2VuZXNpc0luZm8uZW5jb2RlKG1lc3NhZ2UuZ2VuZXNpc0luZm8sIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5CbG9ja01ldGFkYXRhLmVuY29kZShtZXNzYWdlLmJsb2NrLCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWVGaXJzdFNlZW4gIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBpZiAoQmlnSW50LmFzSW50Tig2NCwgbWVzc2FnZS50aW1lRmlyc3RTZWVuKSAhPT1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVGaXJzdFNlZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndmFsdWUgcHJvdmlkZWQgZm9yIGZpZWxkIG1lc3NhZ2UudGltZUZpcnN0U2VlbiBvZiB0eXBlIGludDY0IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkuaW50NjQobWVzc2FnZS50aW1lRmlyc3RTZWVuLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRva2VuSW5mbygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRva2VuSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9rZW5UeXBlID0gZXhwb3J0cy5Ub2tlblR5cGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nZW5lc2lzSW5mbyA9IGV4cG9ydHMuR2VuZXNpc0luZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9jayA9IGV4cG9ydHMuQmxvY2tNZXRhZGF0YS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDQwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVGaXJzdFNlZW4gPSBsb25nVG9CaWdpbnQocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuSWQ6IGlzU2V0KG9iamVjdC50b2tlbklkKVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5TdHJpbmcob2JqZWN0LnRva2VuSWQpXG4gICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIHRva2VuVHlwZTogaXNTZXQob2JqZWN0LnRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVG9rZW5UeXBlLmZyb21KU09OKG9iamVjdC50b2tlblR5cGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBnZW5lc2lzSW5mbzogaXNTZXQob2JqZWN0LmdlbmVzaXNJbmZvKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5HZW5lc2lzSW5mby5mcm9tSlNPTihvYmplY3QuZ2VuZXNpc0luZm8pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBibG9jazogaXNTZXQob2JqZWN0LmJsb2NrKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5CbG9ja01ldGFkYXRhLmZyb21KU09OKG9iamVjdC5ibG9jaylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRpbWVGaXJzdFNlZW46IGlzU2V0KG9iamVjdC50aW1lRmlyc3RTZWVuKVxuICAgICAgICAgICAgICAgID8gQmlnSW50KG9iamVjdC50aW1lRmlyc3RTZWVuKVxuICAgICAgICAgICAgICAgIDogQmlnSW50KCcwJyksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW5JZCAhPT0gJycpIHtcbiAgICAgICAgICAgIG9iai50b2tlbklkID0gbWVzc2FnZS50b2tlbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmoudG9rZW5UeXBlID0gZXhwb3J0cy5Ub2tlblR5cGUudG9KU09OKG1lc3NhZ2UudG9rZW5UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5nZW5lc2lzSW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouZ2VuZXNpc0luZm8gPSBleHBvcnRzLkdlbmVzaXNJbmZvLnRvSlNPTihtZXNzYWdlLmdlbmVzaXNJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9jayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouYmxvY2sgPSBleHBvcnRzLkJsb2NrTWV0YWRhdGEudG9KU09OKG1lc3NhZ2UuYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWVGaXJzdFNlZW4gIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmoudGltZUZpcnN0U2VlbiA9IG1lc3NhZ2UudGltZUZpcnN0U2Vlbi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5Ub2tlbkluZm8uZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb2tlbkluZm8oKTtcbiAgICAgICAgbWVzc2FnZS50b2tlbklkID0gb2JqZWN0LnRva2VuSWQgPz8gJyc7XG4gICAgICAgIG1lc3NhZ2UudG9rZW5UeXBlID1cbiAgICAgICAgICAgIG9iamVjdC50b2tlblR5cGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudG9rZW5UeXBlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlRva2VuVHlwZS5mcm9tUGFydGlhbChvYmplY3QudG9rZW5UeXBlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmdlbmVzaXNJbmZvID1cbiAgICAgICAgICAgIG9iamVjdC5nZW5lc2lzSW5mbyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5nZW5lc2lzSW5mbyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5HZW5lc2lzSW5mby5mcm9tUGFydGlhbChvYmplY3QuZ2VuZXNpc0luZm8pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2sgPVxuICAgICAgICAgICAgb2JqZWN0LmJsb2NrICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmJsb2NrICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrTWV0YWRhdGEuZnJvbVBhcnRpYWwob2JqZWN0LmJsb2NrKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnRpbWVGaXJzdFNlZW4gPSBvYmplY3QudGltZUZpcnN0U2VlbiA/PyBCaWdJbnQoJzAnKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVG9rZW5FbnRyeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbklkOiAnJyxcbiAgICAgICAgdG9rZW5UeXBlOiB1bmRlZmluZWQsXG4gICAgICAgIHR4VHlwZTogMCxcbiAgICAgICAgZ3JvdXBUb2tlbklkOiAnJyxcbiAgICAgICAgaXNJbnZhbGlkOiBmYWxzZSxcbiAgICAgICAgYnVyblN1bW1hcnk6ICcnLFxuICAgICAgICBmYWlsZWRDb2xvcmluZ3M6IFtdLFxuICAgICAgICBhY3R1YWxCdXJuQXRvbXM6ICcnLFxuICAgICAgICBpbnRlbnRpb25hbEJ1cm5BdG9tczogQmlnSW50KCcwJyksXG4gICAgICAgIGJ1cm5zTWludEJhdG9uczogZmFsc2UsXG4gICAgfTtcbn1cbmV4cG9ydHMuVG9rZW5FbnRyeSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuSWQgIT09ICcnKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50b2tlbklkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Ub2tlblR5cGUuZW5jb2RlKG1lc3NhZ2UudG9rZW5UeXBlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnR4VHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS50eFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmdyb3VwVG9rZW5JZCAhPT0gJycpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLnN0cmluZyhtZXNzYWdlLmdyb3VwVG9rZW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaXNJbnZhbGlkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQwKS5ib29sKG1lc3NhZ2UuaXNJbnZhbGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5idXJuU3VtbWFyeSAhPT0gJycpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTApLnN0cmluZyhtZXNzYWdlLmJ1cm5TdW1tYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5mYWlsZWRDb2xvcmluZ3MpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVG9rZW5GYWlsZWRDb2xvcmluZy5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMig1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hY3R1YWxCdXJuQXRvbXMgIT09ICcnKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDY2KS5zdHJpbmcobWVzc2FnZS5hY3R1YWxCdXJuQXRvbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmludGVudGlvbmFsQnVybkF0b21zICE9PSBCaWdJbnQoJzAnKSkge1xuICAgICAgICAgICAgaWYgKEJpZ0ludC5hc1VpbnROKDY0LCBtZXNzYWdlLmludGVudGlvbmFsQnVybkF0b21zKSAhPT1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLmludGVudGlvbmFsQnVybkF0b21zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ3ZhbHVlIHByb3ZpZGVkIGZvciBmaWVsZCBtZXNzYWdlLmludGVudGlvbmFsQnVybkF0b21zIG9mIHR5cGUgdWludDY0IHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig3MikudWludDY0KG1lc3NhZ2UuaW50ZW50aW9uYWxCdXJuQXRvbXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYnVybnNNaW50QmF0b25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgwKS5ib29sKG1lc3NhZ2UuYnVybnNNaW50QmF0b25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb2tlbkVudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9rZW5JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b2tlblR5cGUgPSBleHBvcnRzLlRva2VuVHlwZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDI0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR4VHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwVG9rZW5JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA0MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pc0ludmFsaWQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJ1cm5TdW1tYXJ5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDU4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZhaWxlZENvbG9yaW5ncy5wdXNoKGV4cG9ydHMuVG9rZW5GYWlsZWRDb2xvcmluZy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA2Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY3R1YWxCdXJuQXRvbXMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50ZW50aW9uYWxCdXJuQXRvbXMgPSBsb25nVG9CaWdpbnQocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gODApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYnVybnNNaW50QmF0b25zID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbklkOiBpc1NldChvYmplY3QudG9rZW5JZClcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC50b2tlbklkKVxuICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICB0b2tlblR5cGU6IGlzU2V0KG9iamVjdC50b2tlblR5cGUpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlRva2VuVHlwZS5mcm9tSlNPTihvYmplY3QudG9rZW5UeXBlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHhUeXBlOiBpc1NldChvYmplY3QudHhUeXBlKVxuICAgICAgICAgICAgICAgID8gdG9rZW5UeFR5cGVGcm9tSlNPTihvYmplY3QudHhUeXBlKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGdyb3VwVG9rZW5JZDogaXNTZXQob2JqZWN0Lmdyb3VwVG9rZW5JZClcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC5ncm91cFRva2VuSWQpXG4gICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIGlzSW52YWxpZDogaXNTZXQob2JqZWN0LmlzSW52YWxpZClcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuQm9vbGVhbihvYmplY3QuaXNJbnZhbGlkKVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBidXJuU3VtbWFyeTogaXNTZXQob2JqZWN0LmJ1cm5TdW1tYXJ5KVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5TdHJpbmcob2JqZWN0LmJ1cm5TdW1tYXJ5KVxuICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICBmYWlsZWRDb2xvcmluZ3M6IGdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShvYmplY3Q/LmZhaWxlZENvbG9yaW5ncylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5mYWlsZWRDb2xvcmluZ3MubWFwKChlKSA9PiBleHBvcnRzLlRva2VuRmFpbGVkQ29sb3JpbmcuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIGFjdHVhbEJ1cm5BdG9tczogaXNTZXQob2JqZWN0LmFjdHVhbEJ1cm5BdG9tcylcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC5hY3R1YWxCdXJuQXRvbXMpXG4gICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIGludGVudGlvbmFsQnVybkF0b21zOiBpc1NldChvYmplY3QuaW50ZW50aW9uYWxCdXJuQXRvbXMpXG4gICAgICAgICAgICAgICAgPyBCaWdJbnQob2JqZWN0LmludGVudGlvbmFsQnVybkF0b21zKVxuICAgICAgICAgICAgICAgIDogQmlnSW50KCcwJyksXG4gICAgICAgICAgICBidXJuc01pbnRCYXRvbnM6IGlzU2V0KG9iamVjdC5idXJuc01pbnRCYXRvbnMpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLkJvb2xlYW4ob2JqZWN0LmJ1cm5zTWludEJhdG9ucylcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuSWQgIT09ICcnKSB7XG4gICAgICAgICAgICBvYmoudG9rZW5JZCA9IG1lc3NhZ2UudG9rZW5JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLnRva2VuVHlwZSA9IGV4cG9ydHMuVG9rZW5UeXBlLnRvSlNPTihtZXNzYWdlLnRva2VuVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHhUeXBlICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoudHhUeXBlID0gdG9rZW5UeFR5cGVUb0pTT04obWVzc2FnZS50eFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmdyb3VwVG9rZW5JZCAhPT0gJycpIHtcbiAgICAgICAgICAgIG9iai5ncm91cFRva2VuSWQgPSBtZXNzYWdlLmdyb3VwVG9rZW5JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc0ludmFsaWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9iai5pc0ludmFsaWQgPSBtZXNzYWdlLmlzSW52YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5idXJuU3VtbWFyeSAhPT0gJycpIHtcbiAgICAgICAgICAgIG9iai5idXJuU3VtbWFyeSA9IG1lc3NhZ2UuYnVyblN1bW1hcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZmFpbGVkQ29sb3JpbmdzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5mYWlsZWRDb2xvcmluZ3MgPSBtZXNzYWdlLmZhaWxlZENvbG9yaW5ncy5tYXAoZSA9PiBleHBvcnRzLlRva2VuRmFpbGVkQ29sb3JpbmcudG9KU09OKGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hY3R1YWxCdXJuQXRvbXMgIT09ICcnKSB7XG4gICAgICAgICAgICBvYmouYWN0dWFsQnVybkF0b21zID0gbWVzc2FnZS5hY3R1YWxCdXJuQXRvbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW50ZW50aW9uYWxCdXJuQXRvbXMgIT09IEJpZ0ludCgnMCcpKSB7XG4gICAgICAgICAgICBvYmouaW50ZW50aW9uYWxCdXJuQXRvbXMgPSBtZXNzYWdlLmludGVudGlvbmFsQnVybkF0b21zLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYnVybnNNaW50QmF0b25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvYmouYnVybnNNaW50QmF0b25zID0gbWVzc2FnZS5idXJuc01pbnRCYXRvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlRva2VuRW50cnkuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb2tlbkVudHJ5KCk7XG4gICAgICAgIG1lc3NhZ2UudG9rZW5JZCA9IG9iamVjdC50b2tlbklkID8/ICcnO1xuICAgICAgICBtZXNzYWdlLnRva2VuVHlwZSA9XG4gICAgICAgICAgICBvYmplY3QudG9rZW5UeXBlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRva2VuVHlwZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Ub2tlblR5cGUuZnJvbVBhcnRpYWwob2JqZWN0LnRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS50eFR5cGUgPSBvYmplY3QudHhUeXBlID8/IDA7XG4gICAgICAgIG1lc3NhZ2UuZ3JvdXBUb2tlbklkID0gb2JqZWN0Lmdyb3VwVG9rZW5JZCA/PyAnJztcbiAgICAgICAgbWVzc2FnZS5pc0ludmFsaWQgPSBvYmplY3QuaXNJbnZhbGlkID8/IGZhbHNlO1xuICAgICAgICBtZXNzYWdlLmJ1cm5TdW1tYXJ5ID0gb2JqZWN0LmJ1cm5TdW1tYXJ5ID8/ICcnO1xuICAgICAgICBtZXNzYWdlLmZhaWxlZENvbG9yaW5ncyA9XG4gICAgICAgICAgICBvYmplY3QuZmFpbGVkQ29sb3JpbmdzPy5tYXAoZSA9PiBleHBvcnRzLlRva2VuRmFpbGVkQ29sb3JpbmcuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLmFjdHVhbEJ1cm5BdG9tcyA9IG9iamVjdC5hY3R1YWxCdXJuQXRvbXMgPz8gJyc7XG4gICAgICAgIG1lc3NhZ2UuaW50ZW50aW9uYWxCdXJuQXRvbXMgPVxuICAgICAgICAgICAgb2JqZWN0LmludGVudGlvbmFsQnVybkF0b21zID8/IEJpZ0ludCgnMCcpO1xuICAgICAgICBtZXNzYWdlLmJ1cm5zTWludEJhdG9ucyA9IG9iamVjdC5idXJuc01pbnRCYXRvbnMgPz8gZmFsc2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdlbmVzaXNJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuVGlja2VyOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgdG9rZW5OYW1lOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgdXJsOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgaGFzaDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIG1pbnRWYXVsdFNjcmlwdGhhc2g6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICBkYXRhOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgYXV0aFB1YmtleTogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIGRlY2ltYWxzOiAwLFxuICAgIH07XG59XG5leHBvcnRzLkdlbmVzaXNJbmZvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW5UaWNrZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnRva2VuVGlja2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlbk5hbWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLnRva2VuTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudXJsLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXMobWVzc2FnZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5ieXRlcyhtZXNzYWdlLmhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1pbnRWYXVsdFNjcmlwdGhhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQyKS5ieXRlcyhtZXNzYWdlLm1pbnRWYXVsdFNjcmlwdGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDUwKS5ieXRlcyhtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhQdWJrZXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDU4KS5ieXRlcyhtZXNzYWdlLmF1dGhQdWJrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRlY2ltYWxzICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDY0KS51aW50MzIobWVzc2FnZS5kZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2VuZXNpc0luZm8oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b2tlblRpY2tlciA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRva2VuTmFtZSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVybCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taW50VmF1bHRTY3JpcHRoYXNoID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDU4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF1dGhQdWJrZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA2NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZWNpbWFscyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlblRpY2tlcjogaXNTZXQob2JqZWN0LnRva2VuVGlja2VyKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC50b2tlblRpY2tlcilcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICAgICAgdG9rZW5OYW1lOiBpc1NldChvYmplY3QudG9rZW5OYW1lKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC50b2tlbk5hbWUpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgICAgIHVybDogaXNTZXQob2JqZWN0LnVybClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QudXJsKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICBoYXNoOiBpc1NldChvYmplY3QuaGFzaClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuaGFzaClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICAgICAgbWludFZhdWx0U2NyaXB0aGFzaDogaXNTZXQob2JqZWN0Lm1pbnRWYXVsdFNjcmlwdGhhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lm1pbnRWYXVsdFNjcmlwdGhhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgICAgIGRhdGE6IGlzU2V0KG9iamVjdC5kYXRhKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5kYXRhKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICBhdXRoUHVia2V5OiBpc1NldChvYmplY3QuYXV0aFB1YmtleSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYXV0aFB1YmtleSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICAgICAgZGVjaW1hbHM6IGlzU2V0KG9iamVjdC5kZWNpbWFscylcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuTnVtYmVyKG9iamVjdC5kZWNpbWFscylcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW5UaWNrZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoudG9rZW5UaWNrZXIgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS50b2tlblRpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW5OYW1lLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnRva2VuTmFtZSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnRva2VuTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudXJsLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnVybCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5oYXNoID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubWludFZhdWx0U2NyaXB0aGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5taW50VmF1bHRTY3JpcHRoYXNoID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UubWludFZhdWx0U2NyaXB0aGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5kYXRhID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYXV0aFB1YmtleS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5hdXRoUHVia2V5ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYXV0aFB1YmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVjaW1hbHMgIT09IDApIHtcbiAgICAgICAgICAgIG9iai5kZWNpbWFscyA9IE1hdGgucm91bmQobWVzc2FnZS5kZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkdlbmVzaXNJbmZvLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlR2VuZXNpc0luZm8oKTtcbiAgICAgICAgbWVzc2FnZS50b2tlblRpY2tlciA9IG9iamVjdC50b2tlblRpY2tlciA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgbWVzc2FnZS50b2tlbk5hbWUgPSBvYmplY3QudG9rZW5OYW1lID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLnVybCA9IG9iamVjdC51cmwgPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIG1lc3NhZ2UuaGFzaCA9IG9iamVjdC5oYXNoID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLm1pbnRWYXVsdFNjcmlwdGhhc2ggPVxuICAgICAgICAgICAgb2JqZWN0Lm1pbnRWYXVsdFNjcmlwdGhhc2ggPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIG1lc3NhZ2UuZGF0YSA9IG9iamVjdC5kYXRhID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLmF1dGhQdWJrZXkgPSBvYmplY3QuYXV0aFB1YmtleSA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgbWVzc2FnZS5kZWNpbWFscyA9IG9iamVjdC5kZWNpbWFscyA/PyAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUb2tlbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbklkOiAnJyxcbiAgICAgICAgdG9rZW5UeXBlOiB1bmRlZmluZWQsXG4gICAgICAgIGVudHJ5SWR4OiAwLFxuICAgICAgICBhdG9tczogQmlnSW50KCcwJyksXG4gICAgICAgIGlzTWludEJhdG9uOiBmYWxzZSxcbiAgICB9O1xufVxuZXhwb3J0cy5Ub2tlbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuSWQgIT09ICcnKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50b2tlbklkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Ub2tlblR5cGUuZW5jb2RlKG1lc3NhZ2UudG9rZW5UeXBlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVudHJ5SWR4ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5pbnQzMihtZXNzYWdlLmVudHJ5SWR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hdG9tcyAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIGlmIChCaWdJbnQuYXNVaW50Tig2NCwgbWVzc2FnZS5hdG9tcykgIT09IG1lc3NhZ2UuYXRvbXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcigndmFsdWUgcHJvdmlkZWQgZm9yIGZpZWxkIG1lc3NhZ2UuYXRvbXMgb2YgdHlwZSB1aW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS51aW50NjQobWVzc2FnZS5hdG9tcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc01pbnRCYXRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MCkuYm9vbChtZXNzYWdlLmlzTWludEJhdG9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb2tlbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRva2VuSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9rZW5UeXBlID0gZXhwb3J0cy5Ub2tlblR5cGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAyNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyeUlkeCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF0b21zID0gbG9uZ1RvQmlnaW50KHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNNaW50QmF0b24gPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuSWQ6IGlzU2V0KG9iamVjdC50b2tlbklkKVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5TdHJpbmcob2JqZWN0LnRva2VuSWQpXG4gICAgICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICAgIHRva2VuVHlwZTogaXNTZXQob2JqZWN0LnRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVG9rZW5UeXBlLmZyb21KU09OKG9iamVjdC50b2tlblR5cGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBlbnRyeUlkeDogaXNTZXQob2JqZWN0LmVudHJ5SWR4KVxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpcy5OdW1iZXIob2JqZWN0LmVudHJ5SWR4KVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGF0b21zOiBpc1NldChvYmplY3QuYXRvbXMpID8gQmlnSW50KG9iamVjdC5hdG9tcykgOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgICAgIGlzTWludEJhdG9uOiBpc1NldChvYmplY3QuaXNNaW50QmF0b24pXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLkJvb2xlYW4ob2JqZWN0LmlzTWludEJhdG9uKVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW5JZCAhPT0gJycpIHtcbiAgICAgICAgICAgIG9iai50b2tlbklkID0gbWVzc2FnZS50b2tlbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmoudG9rZW5UeXBlID0gZXhwb3J0cy5Ub2tlblR5cGUudG9KU09OKG1lc3NhZ2UudG9rZW5UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5lbnRyeUlkeCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLmVudHJ5SWR4ID0gTWF0aC5yb3VuZChtZXNzYWdlLmVudHJ5SWR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hdG9tcyAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIG9iai5hdG9tcyA9IG1lc3NhZ2UuYXRvbXMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pc01pbnRCYXRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb2JqLmlzTWludEJhdG9uID0gbWVzc2FnZS5pc01pbnRCYXRvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVG9rZW4uZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb2tlbigpO1xuICAgICAgICBtZXNzYWdlLnRva2VuSWQgPSBvYmplY3QudG9rZW5JZCA/PyAnJztcbiAgICAgICAgbWVzc2FnZS50b2tlblR5cGUgPVxuICAgICAgICAgICAgb2JqZWN0LnRva2VuVHlwZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50b2tlblR5cGUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVG9rZW5UeXBlLmZyb21QYXJ0aWFsKG9iamVjdC50b2tlblR5cGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuZW50cnlJZHggPSBvYmplY3QuZW50cnlJZHggPz8gMDtcbiAgICAgICAgbWVzc2FnZS5hdG9tcyA9IG9iamVjdC5hdG9tcyA/PyBCaWdJbnQoJzAnKTtcbiAgICAgICAgbWVzc2FnZS5pc01pbnRCYXRvbiA9IG9iamVjdC5pc01pbnRCYXRvbiA/PyBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVG9rZW5GYWlsZWRQYXJzaW5nKCkge1xuICAgIHJldHVybiB7IHB1c2hkYXRhSWR4OiAwLCBieXRlczogbmV3IFVpbnQ4QXJyYXkoMCksIGVycm9yOiAnJyB9O1xufVxuZXhwb3J0cy5Ub2tlbkZhaWxlZFBhcnNpbmcgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wdXNoZGF0YUlkeCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLnB1c2hkYXRhSWR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ieXRlcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSAnJykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRva2VuRmFpbGVkUGFyc2luZygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHVzaGRhdGFJZHggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ieXRlcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1c2hkYXRhSWR4OiBpc1NldChvYmplY3QucHVzaGRhdGFJZHgpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLk51bWJlcihvYmplY3QucHVzaGRhdGFJZHgpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgYnl0ZXM6IGlzU2V0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYnl0ZXMpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgICAgIGVycm9yOiBpc1NldChvYmplY3QuZXJyb3IpID8gZ2xvYmFsVGhpcy5TdHJpbmcob2JqZWN0LmVycm9yKSA6ICcnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnB1c2hkYXRhSWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoucHVzaGRhdGFJZHggPSBNYXRoLnJvdW5kKG1lc3NhZ2UucHVzaGRhdGFJZHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLmJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSAnJykge1xuICAgICAgICAgICAgb2JqLmVycm9yID0gbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVG9rZW5GYWlsZWRQYXJzaW5nLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVG9rZW5GYWlsZWRQYXJzaW5nKCk7XG4gICAgICAgIG1lc3NhZ2UucHVzaGRhdGFJZHggPSBvYmplY3QucHVzaGRhdGFJZHggPz8gMDtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyA9IG9iamVjdC5ieXRlcyA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgbWVzc2FnZS5lcnJvciA9IG9iamVjdC5lcnJvciA/PyAnJztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVG9rZW5GYWlsZWRDb2xvcmluZygpIHtcbiAgICByZXR1cm4geyBwdXNoZGF0YUlkeDogMCwgZXJyb3I6ICcnIH07XG59XG5leHBvcnRzLlRva2VuRmFpbGVkQ29sb3JpbmcgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wdXNoZGF0YUlkeCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLnB1c2hkYXRhSWR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5lcnJvciAhPT0gJycpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUb2tlbkZhaWxlZENvbG9yaW5nKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wdXNoZGF0YUlkeCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1c2hkYXRhSWR4OiBpc1NldChvYmplY3QucHVzaGRhdGFJZHgpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLk51bWJlcihvYmplY3QucHVzaGRhdGFJZHgpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgZXJyb3I6IGlzU2V0KG9iamVjdC5lcnJvcikgPyBnbG9iYWxUaGlzLlN0cmluZyhvYmplY3QuZXJyb3IpIDogJycsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucHVzaGRhdGFJZHggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5wdXNoZGF0YUlkeCA9IE1hdGgucm91bmQobWVzc2FnZS5wdXNoZGF0YUlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgIT09ICcnKSB7XG4gICAgICAgICAgICBvYmouZXJyb3IgPSBtZXNzYWdlLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5Ub2tlbkZhaWxlZENvbG9yaW5nLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVG9rZW5GYWlsZWRDb2xvcmluZygpO1xuICAgICAgICBtZXNzYWdlLnB1c2hkYXRhSWR4ID0gb2JqZWN0LnB1c2hkYXRhSWR4ID8/IDA7XG4gICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBvYmplY3QuZXJyb3IgPz8gJyc7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVBsdWdpbkVudHJ5KCkge1xuICAgIHJldHVybiB7IGdyb3VwczogW10sIGRhdGE6IFtdIH07XG59XG5leHBvcnRzLlBsdWdpbkVudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZ3JvdXBzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5kYXRhKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQbHVnaW5FbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3Vwcy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwczogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8uZ3JvdXBzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lmdyb3Vwcy5tYXAoKGUpID0+IGJ5dGVzRnJvbUJhc2U2NChlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgZGF0YTogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8uZGF0YSlcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5kYXRhLm1hcCgoZSkgPT4gYnl0ZXNGcm9tQmFzZTY0KGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXBzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5ncm91cHMgPSBtZXNzYWdlLmdyb3Vwcy5tYXAoZSA9PiBiYXNlNjRGcm9tQnl0ZXMoZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGE/Lmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqLmRhdGEgPSBtZXNzYWdlLmRhdGEubWFwKGUgPT4gYmFzZTY0RnJvbUJ5dGVzKGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuUGx1Z2luRW50cnkuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQbHVnaW5FbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmdyb3VwcyA9IG9iamVjdC5ncm91cHM/Lm1hcChlID0+IGUpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLmRhdGEgPSBvYmplY3QuZGF0YT8ubWFwKGUgPT4gZSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVBsdWdpbkdyb3VwKCkge1xuICAgIHJldHVybiB7IGdyb3VwOiBuZXcgVWludDhBcnJheSgwKSB9O1xufVxuZXhwb3J0cy5QbHVnaW5Hcm91cCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmdyb3VwLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGx1Z2luR3JvdXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwOiBpc1NldChvYmplY3QuZ3JvdXApXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmdyb3VwKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmouZ3JvdXAgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlBsdWdpbkdyb3VwLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGx1Z2luR3JvdXAoKTtcbiAgICAgICAgbWVzc2FnZS5ncm91cCA9IG9iamVjdC5ncm91cCA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUGx1Z2luR3JvdXBzKCkge1xuICAgIHJldHVybiB7IGdyb3VwczogW10sIG5leHRTdGFydDogbmV3IFVpbnQ4QXJyYXkoMCkgfTtcbn1cbmV4cG9ydHMuUGx1Z2luR3JvdXBzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZ3JvdXBzKSB7XG4gICAgICAgICAgICBleHBvcnRzLlBsdWdpbkdyb3VwLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm5leHRTdGFydC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UubmV4dFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQbHVnaW5Hcm91cHMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cHMucHVzaChleHBvcnRzLlBsdWdpbkdyb3VwLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5leHRTdGFydCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwczogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8uZ3JvdXBzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lmdyb3Vwcy5tYXAoKGUpID0+IGV4cG9ydHMuUGx1Z2luR3JvdXAuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIG5leHRTdGFydDogaXNTZXQob2JqZWN0Lm5leHRTdGFydClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QubmV4dFN0YXJ0KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXBzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5ncm91cHMgPSBtZXNzYWdlLmdyb3Vwcy5tYXAoZSA9PiBleHBvcnRzLlBsdWdpbkdyb3VwLnRvSlNPTihlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmV4dFN0YXJ0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLm5leHRTdGFydCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLm5leHRTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlBsdWdpbkdyb3Vwcy5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBsdWdpbkdyb3VwcygpO1xuICAgICAgICBtZXNzYWdlLmdyb3VwcyA9XG4gICAgICAgICAgICBvYmplY3QuZ3JvdXBzPy5tYXAoZSA9PiBleHBvcnRzLlBsdWdpbkdyb3VwLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5uZXh0U3RhcnQgPSBvYmplY3QubmV4dFN0YXJ0ID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUeEhpc3RvcnlQYWdlKCkge1xuICAgIHJldHVybiB7IHR4czogW10sIG51bVBhZ2VzOiAwLCBudW1UeHM6IDAgfTtcbn1cbmV4cG9ydHMuVHhIaXN0b3J5UGFnZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnR4cykge1xuICAgICAgICAgICAgZXhwb3J0cy5UeC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5udW1QYWdlcyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDMyKG1lc3NhZ2UubnVtUGFnZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm51bVR4cyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDMyKG1lc3NhZ2UubnVtVHhzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeEhpc3RvcnlQYWdlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHhzLnB1c2goZXhwb3J0cy5UeC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1QYWdlcyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAyNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1UeHMgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhzOiBnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkob2JqZWN0Py50eHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudHhzLm1hcCgoZSkgPT4gZXhwb3J0cy5UeC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgbnVtUGFnZXM6IGlzU2V0KG9iamVjdC5udW1QYWdlcylcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuTnVtYmVyKG9iamVjdC5udW1QYWdlcylcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBudW1UeHM6IGlzU2V0KG9iamVjdC5udW1UeHMpID8gZ2xvYmFsVGhpcy5OdW1iZXIob2JqZWN0Lm51bVR4cykgOiAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnR4cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmoudHhzID0gbWVzc2FnZS50eHMubWFwKGUgPT4gZXhwb3J0cy5UeC50b0pTT04oZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm51bVBhZ2VzICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoubnVtUGFnZXMgPSBNYXRoLnJvdW5kKG1lc3NhZ2UubnVtUGFnZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm51bVR4cyAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLm51bVR4cyA9IE1hdGgucm91bmQobWVzc2FnZS5udW1UeHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeEhpc3RvcnlQYWdlLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHhIaXN0b3J5UGFnZSgpO1xuICAgICAgICBtZXNzYWdlLnR4cyA9IG9iamVjdC50eHM/Lm1hcChlID0+IGV4cG9ydHMuVHguZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLm51bVBhZ2VzID0gb2JqZWN0Lm51bVBhZ2VzID8/IDA7XG4gICAgICAgIG1lc3NhZ2UubnVtVHhzID0gb2JqZWN0Lm51bVR4cyA/PyAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTY3JpcHRVdHhvcygpIHtcbiAgICByZXR1cm4geyBzY3JpcHQ6IG5ldyBVaW50OEFycmF5KDApLCB1dHhvczogW10gfTtcbn1cbmV4cG9ydHMuU2NyaXB0VXR4b3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zY3JpcHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnNjcmlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UudXR4b3MpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU2NyaXB0VXR4by5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTY3JpcHRVdHhvcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNjcmlwdCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnV0eG9zLnB1c2goZXhwb3J0cy5TY3JpcHRVdHhvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjcmlwdDogaXNTZXQob2JqZWN0LnNjcmlwdClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Quc2NyaXB0KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICB1dHhvczogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8udXR4b3MpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudXR4b3MubWFwKChlKSA9PiBleHBvcnRzLlNjcmlwdFV0eG8uZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5zY3JpcHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmouc2NyaXB0ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uuc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51dHhvcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmoudXR4b3MgPSBtZXNzYWdlLnV0eG9zLm1hcChlID0+IGV4cG9ydHMuU2NyaXB0VXR4by50b0pTT04oZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5TY3JpcHRVdHhvcy5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNjcmlwdFV0eG9zKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2NyaXB0ID0gb2JqZWN0LnNjcmlwdCA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgbWVzc2FnZS51dHhvcyA9IG9iamVjdC51dHhvcz8ubWFwKGUgPT4gZXhwb3J0cy5TY3JpcHRVdHhvLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVXR4b3MoKSB7XG4gICAgcmV0dXJuIHsgdXR4b3M6IFtdIH07XG59XG5leHBvcnRzLlV0eG9zID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UudXR4b3MpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVXR4by5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVdHhvcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnV0eG9zLnB1c2goZXhwb3J0cy5VdHhvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHV0eG9zOiBnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkob2JqZWN0Py51dHhvcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC51dHhvcy5tYXAoKGUpID0+IGV4cG9ydHMuVXR4by5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnV0eG9zPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai51dHhvcyA9IG1lc3NhZ2UudXR4b3MubWFwKGUgPT4gZXhwb3J0cy5VdHhvLnRvSlNPTihlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlV0eG9zLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVXR4b3MoKTtcbiAgICAgICAgbWVzc2FnZS51dHhvcyA9IG9iamVjdC51dHhvcz8ubWFwKGUgPT4gZXhwb3J0cy5VdHhvLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQnJvYWRjYXN0VHhSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJhd1R4OiBuZXcgVWludDhBcnJheSgwKSwgc2tpcFRva2VuQ2hlY2tzOiBmYWxzZSB9O1xufVxuZXhwb3J0cy5Ccm9hZGNhc3RUeFJlcXVlc3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5yYXdUeC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UucmF3VHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNraXBUb2tlbkNoZWNrcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuYm9vbChtZXNzYWdlLnNraXBUb2tlbkNoZWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQnJvYWRjYXN0VHhSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmF3VHggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5za2lwVG9rZW5DaGVja3MgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd1R4OiBpc1NldChvYmplY3QucmF3VHgpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnJhd1R4KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICBza2lwVG9rZW5DaGVja3M6IGlzU2V0KG9iamVjdC5za2lwVG9rZW5DaGVja3MpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLkJvb2xlYW4ob2JqZWN0LnNraXBUb2tlbkNoZWNrcylcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJhd1R4Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnJhd1R4ID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucmF3VHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNraXBUb2tlbkNoZWNrcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb2JqLnNraXBUb2tlbkNoZWNrcyA9IG1lc3NhZ2Uuc2tpcFRva2VuQ2hlY2tzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5Ccm9hZGNhc3RUeFJlcXVlc3QuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCcm9hZGNhc3RUeFJlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yYXdUeCA9IG9iamVjdC5yYXdUeCA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgbWVzc2FnZS5za2lwVG9rZW5DaGVja3MgPSBvYmplY3Quc2tpcFRva2VuQ2hlY2tzID8/IGZhbHNlO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VCcm9hZGNhc3RUeFJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHR4aWQ6IG5ldyBVaW50OEFycmF5KDApIH07XG59XG5leHBvcnRzLkJyb2FkY2FzdFR4UmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50eGlkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS50eGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCcm9hZGNhc3RUeFJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHhpZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4aWQ6IGlzU2V0KG9iamVjdC50eGlkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC50eGlkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHhpZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai50eGlkID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UudHhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkJyb2FkY2FzdFR4UmVzcG9uc2UuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCcm9hZGNhc3RUeFJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UudHhpZCA9IG9iamVjdC50eGlkID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VCcm9hZGNhc3RUeHNSZXF1ZXN0KCkge1xuICAgIHJldHVybiB7IHJhd1R4czogW10sIHNraXBUb2tlbkNoZWNrczogZmFsc2UgfTtcbn1cbmV4cG9ydHMuQnJvYWRjYXN0VHhzUmVxdWVzdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnJhd1R4cykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXModik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2tpcFRva2VuQ2hlY2tzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5ib29sKG1lc3NhZ2Uuc2tpcFRva2VuQ2hlY2tzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCcm9hZGNhc3RUeHNSZXF1ZXN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmF3VHhzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNraXBUb2tlbkNoZWNrcyA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3VHhzOiBnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkob2JqZWN0Py5yYXdUeHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QucmF3VHhzLm1hcCgoZSkgPT4gYnl0ZXNGcm9tQmFzZTY0KGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBza2lwVG9rZW5DaGVja3M6IGlzU2V0KG9iamVjdC5za2lwVG9rZW5DaGVja3MpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLkJvb2xlYW4ob2JqZWN0LnNraXBUb2tlbkNoZWNrcylcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnJhd1R4cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmoucmF3VHhzID0gbWVzc2FnZS5yYXdUeHMubWFwKGUgPT4gYmFzZTY0RnJvbUJ5dGVzKGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5za2lwVG9rZW5DaGVja3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9iai5za2lwVG9rZW5DaGVja3MgPSBtZXNzYWdlLnNraXBUb2tlbkNoZWNrcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQnJvYWRjYXN0VHhzUmVxdWVzdC5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUJyb2FkY2FzdFR4c1JlcXVlc3QoKTtcbiAgICAgICAgbWVzc2FnZS5yYXdUeHMgPSBvYmplY3QucmF3VHhzPy5tYXAoZSA9PiBlKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5za2lwVG9rZW5DaGVja3MgPSBvYmplY3Quc2tpcFRva2VuQ2hlY2tzID8/IGZhbHNlO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VCcm9hZGNhc3RUeHNSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyB0eGlkczogW10gfTtcbn1cbmV4cG9ydHMuQnJvYWRjYXN0VHhzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS50eGlkcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXModik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQnJvYWRjYXN0VHhzUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eGlkcy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eGlkczogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8udHhpZHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudHhpZHMubWFwKChlKSA9PiBieXRlc0Zyb21CYXNlNjQoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS50eGlkcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmoudHhpZHMgPSBtZXNzYWdlLnR4aWRzLm1hcChlID0+IGJhc2U2NEZyb21CeXRlcyhlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkJyb2FkY2FzdFR4c1Jlc3BvbnNlLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQnJvYWRjYXN0VHhzUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS50eGlkcyA9IG9iamVjdC50eGlkcz8ubWFwKGUgPT4gZSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVJhd1R4KCkge1xuICAgIHJldHVybiB7IHJhd1R4OiBuZXcgVWludDhBcnJheSgwKSB9O1xufVxuZXhwb3J0cy5SYXdUeCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJhd1R4Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5yYXdUeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmF3VHgoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yYXdUeCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd1R4OiBpc1NldChvYmplY3QucmF3VHgpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnJhd1R4KVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucmF3VHgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmoucmF3VHggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5yYXdUeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlJhd1R4LmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmF3VHgoKTtcbiAgICAgICAgbWVzc2FnZS5yYXdUeCA9IG9iamVjdC5yYXdUeCA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlV3NTdWIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNVbnN1YjogZmFsc2UsXG4gICAgICAgIGJsb2NrczogdW5kZWZpbmVkLFxuICAgICAgICBzY3JpcHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgdG9rZW5JZDogdW5kZWZpbmVkLFxuICAgICAgICBsb2thZElkOiB1bmRlZmluZWQsXG4gICAgICAgIHBsdWdpbjogdW5kZWZpbmVkLFxuICAgICAgICB0eGlkOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuV3NTdWIgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5pc1Vuc3ViID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmJvb2wobWVzc2FnZS5pc1Vuc3ViKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Xc1N1YkJsb2Nrcy5lbmNvZGUobWVzc2FnZS5ibG9ja3MsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2NyaXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuV3NTdWJTY3JpcHQuZW5jb2RlKG1lc3NhZ2Uuc2NyaXB0LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Xc1N1YlRva2VuSWQuZW5jb2RlKG1lc3NhZ2UudG9rZW5JZCwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5sb2thZElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuV3NTdWJMb2thZElkLmVuY29kZShtZXNzYWdlLmxva2FkSWQsIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGx1Z2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuV3NQbHVnaW4uZW5jb2RlKG1lc3NhZ2UucGx1Z2luLCB3cml0ZXIudWludDMyKDUwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnR4aWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Xc1N1YlR4SWQuZW5jb2RlKG1lc3NhZ2UudHhpZCwgd3JpdGVyLnVpbnQzMig1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXc1N1YigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNVbnN1YiA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmxvY2tzID0gZXhwb3J0cy5Xc1N1YkJsb2Nrcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNjcmlwdCA9IGV4cG9ydHMuV3NTdWJTY3JpcHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b2tlbklkID0gZXhwb3J0cy5Xc1N1YlRva2VuSWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sb2thZElkID0gZXhwb3J0cy5Xc1N1Ykxva2FkSWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbHVnaW4gPSBleHBvcnRzLldzUGx1Z2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gNTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHhpZCA9IGV4cG9ydHMuV3NTdWJUeElkLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNVbnN1YjogaXNTZXQob2JqZWN0LmlzVW5zdWIpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLkJvb2xlYW4ob2JqZWN0LmlzVW5zdWIpXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGJsb2NrczogaXNTZXQob2JqZWN0LmJsb2NrcylcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuV3NTdWJCbG9ja3MuZnJvbUpTT04ob2JqZWN0LmJsb2NrcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNjcmlwdDogaXNTZXQob2JqZWN0LnNjcmlwdClcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuV3NTdWJTY3JpcHQuZnJvbUpTT04ob2JqZWN0LnNjcmlwdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRva2VuSWQ6IGlzU2V0KG9iamVjdC50b2tlbklkKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Xc1N1YlRva2VuSWQuZnJvbUpTT04ob2JqZWN0LnRva2VuSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBsb2thZElkOiBpc1NldChvYmplY3QubG9rYWRJZClcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuV3NTdWJMb2thZElkLmZyb21KU09OKG9iamVjdC5sb2thZElkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGx1Z2luOiBpc1NldChvYmplY3QucGx1Z2luKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Xc1BsdWdpbi5mcm9tSlNPTihvYmplY3QucGx1Z2luKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHhpZDogaXNTZXQob2JqZWN0LnR4aWQpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLldzU3ViVHhJZC5mcm9tSlNPTihvYmplY3QudHhpZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5pc1Vuc3ViID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvYmouaXNVbnN1YiA9IG1lc3NhZ2UuaXNVbnN1YjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLmJsb2NrcyA9IGV4cG9ydHMuV3NTdWJCbG9ja3MudG9KU09OKG1lc3NhZ2UuYmxvY2tzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zY3JpcHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLnNjcmlwdCA9IGV4cG9ydHMuV3NTdWJTY3JpcHQudG9KU09OKG1lc3NhZ2Uuc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b2tlbklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai50b2tlbklkID0gZXhwb3J0cy5Xc1N1YlRva2VuSWQudG9KU09OKG1lc3NhZ2UudG9rZW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubG9rYWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmoubG9rYWRJZCA9IGV4cG9ydHMuV3NTdWJMb2thZElkLnRvSlNPTihtZXNzYWdlLmxva2FkSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnBsdWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmoucGx1Z2luID0gZXhwb3J0cy5Xc1BsdWdpbi50b0pTT04obWVzc2FnZS5wbHVnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnR4aWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLnR4aWQgPSBleHBvcnRzLldzU3ViVHhJZC50b0pTT04obWVzc2FnZS50eGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuV3NTdWIuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXc1N1YigpO1xuICAgICAgICBtZXNzYWdlLmlzVW5zdWIgPSBvYmplY3QuaXNVbnN1YiA/PyBmYWxzZTtcbiAgICAgICAgbWVzc2FnZS5ibG9ja3MgPVxuICAgICAgICAgICAgb2JqZWN0LmJsb2NrcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5ibG9ja3MgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuV3NTdWJCbG9ja3MuZnJvbVBhcnRpYWwob2JqZWN0LmJsb2NrcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zY3JpcHQgPVxuICAgICAgICAgICAgb2JqZWN0LnNjcmlwdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zY3JpcHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuV3NTdWJTY3JpcHQuZnJvbVBhcnRpYWwob2JqZWN0LnNjcmlwdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS50b2tlbklkID1cbiAgICAgICAgICAgIG9iamVjdC50b2tlbklkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnRva2VuSWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuV3NTdWJUb2tlbklkLmZyb21QYXJ0aWFsKG9iamVjdC50b2tlbklkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmxva2FkSWQgPVxuICAgICAgICAgICAgb2JqZWN0Lmxva2FkSWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubG9rYWRJZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Xc1N1Ykxva2FkSWQuZnJvbVBhcnRpYWwob2JqZWN0Lmxva2FkSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UucGx1Z2luID1cbiAgICAgICAgICAgIG9iamVjdC5wbHVnaW4gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGx1Z2luICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLldzUGx1Z2luLmZyb21QYXJ0aWFsKG9iamVjdC5wbHVnaW4pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UudHhpZCA9XG4gICAgICAgICAgICBvYmplY3QudHhpZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC50eGlkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLldzU3ViVHhJZC5mcm9tUGFydGlhbChvYmplY3QudHhpZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlV3NTdWJCbG9ja3MoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0cy5Xc1N1YkJsb2NrcyA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVdzU3ViQmxvY2tzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5Xc1N1YkJsb2Nrcy5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXc1N1YkJsb2NrcygpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VXc1N1YlNjcmlwdCgpIHtcbiAgICByZXR1cm4geyBzY3JpcHRUeXBlOiAnJywgcGF5bG9hZDogbmV3IFVpbnQ4QXJyYXkoMCkgfTtcbn1cbmV4cG9ydHMuV3NTdWJTY3JpcHQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zY3JpcHRUeXBlICE9PSAnJykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uuc2NyaXB0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGF5bG9hZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV3NTdWJTY3JpcHQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zY3JpcHRUeXBlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWxvYWQgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY3JpcHRUeXBlOiBpc1NldChvYmplY3Quc2NyaXB0VHlwZSlcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC5zY3JpcHRUeXBlKVxuICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgICBwYXlsb2FkOiBpc1NldChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucGF5bG9hZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KDApLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnNjcmlwdFR5cGUgIT09ICcnKSB7XG4gICAgICAgICAgICBvYmouc2NyaXB0VHlwZSA9IG1lc3NhZ2Uuc2NyaXB0VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wYXlsb2FkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnBheWxvYWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuV3NTdWJTY3JpcHQuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXc1N1YlNjcmlwdCgpO1xuICAgICAgICBtZXNzYWdlLnNjcmlwdFR5cGUgPSBvYmplY3Quc2NyaXB0VHlwZSA/PyAnJztcbiAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gb2JqZWN0LnBheWxvYWQgPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVdzU3ViVG9rZW5JZCgpIHtcbiAgICByZXR1cm4geyB0b2tlbklkOiAnJyB9O1xufVxuZXhwb3J0cy5Xc1N1YlRva2VuSWQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50b2tlbklkICE9PSAnJykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UudG9rZW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV3NTdWJUb2tlbklkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG9rZW5JZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbklkOiBpc1NldChvYmplY3QudG9rZW5JZClcbiAgICAgICAgICAgICAgICA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC50b2tlbklkKVxuICAgICAgICAgICAgICAgIDogJycsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW5JZCAhPT0gJycpIHtcbiAgICAgICAgICAgIG9iai50b2tlbklkID0gbWVzc2FnZS50b2tlbklkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBjcmVhdGUoYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5Xc1N1YlRva2VuSWQuZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXc1N1YlRva2VuSWQoKTtcbiAgICAgICAgbWVzc2FnZS50b2tlbklkID0gb2JqZWN0LnRva2VuSWQgPz8gJyc7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVdzU3ViTG9rYWRJZCgpIHtcbiAgICByZXR1cm4geyBsb2thZElkOiBuZXcgVWludDhBcnJheSgwKSB9O1xufVxuZXhwb3J0cy5Xc1N1Ykxva2FkSWQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5sb2thZElkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5sb2thZElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXc1N1Ykxva2FkSWQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sb2thZElkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9rYWRJZDogaXNTZXQob2JqZWN0Lmxva2FkSWQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmxva2FkSWQpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5sb2thZElkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLmxva2FkSWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5sb2thZElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuV3NTdWJMb2thZElkLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV3NTdWJMb2thZElkKCk7XG4gICAgICAgIG1lc3NhZ2UubG9rYWRJZCA9IG9iamVjdC5sb2thZElkID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VXc1BsdWdpbigpIHtcbiAgICByZXR1cm4geyBwbHVnaW5OYW1lOiAnJywgZ3JvdXA6IG5ldyBVaW50OEFycmF5KDApIH07XG59XG5leHBvcnRzLldzUGx1Z2luID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGx1Z2luTmFtZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnBsdWdpbk5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmdyb3VwLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5ncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV3NQbHVnaW4oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbHVnaW5OYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGx1Z2luTmFtZTogaXNTZXQob2JqZWN0LnBsdWdpbk5hbWUpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLlN0cmluZyhvYmplY3QucGx1Z2luTmFtZSlcbiAgICAgICAgICAgICAgICA6ICcnLFxuICAgICAgICAgICAgZ3JvdXA6IGlzU2V0KG9iamVjdC5ncm91cClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZ3JvdXApXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5wbHVnaW5OYW1lICE9PSAnJykge1xuICAgICAgICAgICAgb2JqLnBsdWdpbk5hbWUgPSBtZXNzYWdlLnBsdWdpbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmouZ3JvdXAgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLldzUGx1Z2luLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV3NQbHVnaW4oKTtcbiAgICAgICAgbWVzc2FnZS5wbHVnaW5OYW1lID0gb2JqZWN0LnBsdWdpbk5hbWUgPz8gJyc7XG4gICAgICAgIG1lc3NhZ2UuZ3JvdXAgPSBvYmplY3QuZ3JvdXAgPz8gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVdzU3ViVHhJZCgpIHtcbiAgICByZXR1cm4geyB0eGlkOiAnJyB9O1xufVxuZXhwb3J0cy5Xc1N1YlR4SWQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50eGlkICE9PSAnJykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UudHhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV3NTdWJUeElkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHhpZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eGlkOiBpc1NldChvYmplY3QudHhpZCkgPyBnbG9iYWxUaGlzLlN0cmluZyhvYmplY3QudHhpZCkgOiAnJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS50eGlkICE9PSAnJykge1xuICAgICAgICAgICAgb2JqLnR4aWQgPSBtZXNzYWdlLnR4aWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLldzU3ViVHhJZC5mcm9tUGFydGlhbChiYXNlID8/IHt9KTtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVdzU3ViVHhJZCgpO1xuICAgICAgICBtZXNzYWdlLnR4aWQgPSBvYmplY3QudHhpZCA/PyAnJztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlV3NNc2coKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHVuZGVmaW5lZCwgYmxvY2s6IHVuZGVmaW5lZCwgdHg6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0cy5Xc01zZyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuRXJyb3IuZW5jb2RlKG1lc3NhZ2UuZXJyb3IsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Nc2dCbG9jay5lbmNvZGUobWVzc2FnZS5ibG9jaywgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLk1zZ1R4LmVuY29kZShtZXNzYWdlLnR4LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVdzTXNnKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBleHBvcnRzLkVycm9yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmxvY2sgPSBleHBvcnRzLk1zZ0Jsb2NrLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHggPSBleHBvcnRzLk1zZ1R4LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3I6IGlzU2V0KG9iamVjdC5lcnJvcilcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuRXJyb3IuZnJvbUpTT04ob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmxvY2s6IGlzU2V0KG9iamVjdC5ibG9jaylcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuTXNnQmxvY2suZnJvbUpTT04ob2JqZWN0LmJsb2NrKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHg6IGlzU2V0KG9iamVjdC50eCkgPyBleHBvcnRzLk1zZ1R4LmZyb21KU09OKG9iamVjdC50eCkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLmVycm9yID0gZXhwb3J0cy5FcnJvci50b0pTT04obWVzc2FnZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLmJsb2NrID0gZXhwb3J0cy5Nc2dCbG9jay50b0pTT04obWVzc2FnZS5ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLnR4ID0gZXhwb3J0cy5Nc2dUeC50b0pTT04obWVzc2FnZS50eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLldzTXNnLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV3NNc2coKTtcbiAgICAgICAgbWVzc2FnZS5lcnJvciA9XG4gICAgICAgICAgICBvYmplY3QuZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZXJyb3IgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuRXJyb3IuZnJvbVBhcnRpYWwob2JqZWN0LmVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmJsb2NrID1cbiAgICAgICAgICAgIG9iamVjdC5ibG9jayAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5ibG9jayAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Nc2dCbG9jay5mcm9tUGFydGlhbChvYmplY3QuYmxvY2spXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UudHggPVxuICAgICAgICAgICAgb2JqZWN0LnR4ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnR4ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLk1zZ1R4LmZyb21QYXJ0aWFsKG9iamVjdC50eClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29pbmJhc2VEYXRhKCkge1xuICAgIHJldHVybiB7IGNvaW5iYXNlU2NyaXB0c2lnOiBuZXcgVWludDhBcnJheSgwKSwgY29pbmJhc2VPdXRwdXRzOiBbXSB9O1xufVxuZXhwb3J0cy5Db2luYmFzZURhdGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jb2luYmFzZVNjcmlwdHNpZy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuY29pbmJhc2VTY3JpcHRzaWcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmNvaW5iYXNlT3V0cHV0cykge1xuICAgICAgICAgICAgZXhwb3J0cy5UeE91dHB1dC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlci5jcmVhdGUoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb2luYmFzZURhdGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2luYmFzZVNjcmlwdHNpZyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvaW5iYXNlT3V0cHV0cy5wdXNoKGV4cG9ydHMuVHhPdXRwdXQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29pbmJhc2VTY3JpcHRzaWc6IGlzU2V0KG9iamVjdC5jb2luYmFzZVNjcmlwdHNpZylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuY29pbmJhc2VTY3JpcHRzaWcpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgICAgIGNvaW5iYXNlT3V0cHV0czogZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KG9iamVjdD8uY29pbmJhc2VPdXRwdXRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmNvaW5iYXNlT3V0cHV0cy5tYXAoKGUpID0+IGV4cG9ydHMuVHhPdXRwdXQuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5jb2luYmFzZVNjcmlwdHNpZy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIG9iai5jb2luYmFzZVNjcmlwdHNpZyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmNvaW5iYXNlU2NyaXB0c2lnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb2luYmFzZU91dHB1dHM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqLmNvaW5iYXNlT3V0cHV0cyA9IG1lc3NhZ2UuY29pbmJhc2VPdXRwdXRzLm1hcChlID0+IGV4cG9ydHMuVHhPdXRwdXQudG9KU09OKGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQ29pbmJhc2VEYXRhLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29pbmJhc2VEYXRhKCk7XG4gICAgICAgIG1lc3NhZ2UuY29pbmJhc2VTY3JpcHRzaWcgPVxuICAgICAgICAgICAgb2JqZWN0LmNvaW5iYXNlU2NyaXB0c2lnID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLmNvaW5iYXNlT3V0cHV0cyA9XG4gICAgICAgICAgICBvYmplY3QuY29pbmJhc2VPdXRwdXRzPy5tYXAoZSA9PiBleHBvcnRzLlR4T3V0cHV0LmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnQmxvY2soKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbXNnVHlwZTogMCxcbiAgICAgICAgYmxvY2tIYXNoOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgYmxvY2tIZWlnaHQ6IDAsXG4gICAgICAgIGJsb2NrVGltZXN0YW1wOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgY29pbmJhc2VEYXRhOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuTXNnQmxvY2sgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tc2dUeXBlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UubXNnVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2tIYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5ibG9ja0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmJsb2NrSGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5pbnQzMihtZXNzYWdlLmJsb2NrSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja1RpbWVzdGFtcCAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIGlmIChCaWdJbnQuYXNJbnROKDY0LCBtZXNzYWdlLmJsb2NrVGltZXN0YW1wKSAhPT1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLmJsb2NrVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ3ZhbHVlIHByb3ZpZGVkIGZvciBmaWVsZCBtZXNzYWdlLmJsb2NrVGltZXN0YW1wIG9mIHR5cGUgaW50NjQgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5pbnQ2NChtZXNzYWdlLmJsb2NrVGltZXN0YW1wLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvaW5iYXNlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkNvaW5iYXNlRGF0YS5lbmNvZGUobWVzc2FnZS5jb2luYmFzZURhdGEsIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnQmxvY2soKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1zZ1R5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAxOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9ja0hhc2ggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSAyNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9ja0hlaWdodCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJsb2NrVGltZXN0YW1wID0gbG9uZ1RvQmlnaW50KHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnICE9PSA0Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2luYmFzZURhdGEgPSBleHBvcnRzLkNvaW5iYXNlRGF0YS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ1R5cGU6IGlzU2V0KG9iamVjdC5tc2dUeXBlKVxuICAgICAgICAgICAgICAgID8gYmxvY2tNc2dUeXBlRnJvbUpTT04ob2JqZWN0Lm1zZ1R5cGUpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBpc1NldChvYmplY3QuYmxvY2tIYXNoKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ibG9ja0hhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgICAgIGJsb2NrSGVpZ2h0OiBpc1NldChvYmplY3QuYmxvY2tIZWlnaHQpXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzLk51bWJlcihvYmplY3QuYmxvY2tIZWlnaHQpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgYmxvY2tUaW1lc3RhbXA6IGlzU2V0KG9iamVjdC5ibG9ja1RpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA/IEJpZ0ludChvYmplY3QuYmxvY2tUaW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiBCaWdJbnQoJzAnKSxcbiAgICAgICAgICAgIGNvaW5iYXNlRGF0YTogaXNTZXQob2JqZWN0LmNvaW5iYXNlRGF0YSlcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQ29pbmJhc2VEYXRhLmZyb21KU09OKG9iamVjdC5jb2luYmFzZURhdGEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubXNnVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLm1zZ1R5cGUgPSBibG9ja01zZ1R5cGVUb0pTT04obWVzc2FnZS5tc2dUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja0hhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBvYmouYmxvY2tIYXNoID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYmxvY2tIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja0hlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLmJsb2NrSGVpZ2h0ID0gTWF0aC5yb3VuZChtZXNzYWdlLmJsb2NrSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja1RpbWVzdGFtcCAhPT0gQmlnSW50KCcwJykpIHtcbiAgICAgICAgICAgIG9iai5ibG9ja1RpbWVzdGFtcCA9IG1lc3NhZ2UuYmxvY2tUaW1lc3RhbXAudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb2luYmFzZURhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLmNvaW5iYXNlRGF0YSA9IGV4cG9ydHMuQ29pbmJhc2VEYXRhLnRvSlNPTihtZXNzYWdlLmNvaW5iYXNlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk1zZ0Jsb2NrLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnQmxvY2soKTtcbiAgICAgICAgbWVzc2FnZS5tc2dUeXBlID0gb2JqZWN0Lm1zZ1R5cGUgPz8gMDtcbiAgICAgICAgbWVzc2FnZS5ibG9ja0hhc2ggPSBvYmplY3QuYmxvY2tIYXNoID8/IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICBtZXNzYWdlLmJsb2NrSGVpZ2h0ID0gb2JqZWN0LmJsb2NrSGVpZ2h0ID8/IDA7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2tUaW1lc3RhbXAgPSBvYmplY3QuYmxvY2tUaW1lc3RhbXAgPz8gQmlnSW50KCcwJyk7XG4gICAgICAgIG1lc3NhZ2UuY29pbmJhc2VEYXRhID1cbiAgICAgICAgICAgIG9iamVjdC5jb2luYmFzZURhdGEgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29pbmJhc2VEYXRhICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkNvaW5iYXNlRGF0YS5mcm9tUGFydGlhbChvYmplY3QuY29pbmJhc2VEYXRhKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUeEZpbmFsaXphdGlvblJlYXNvbigpIHtcbiAgICByZXR1cm4geyBmaW5hbGl6YXRpb25UeXBlOiAwIH07XG59XG5leHBvcnRzLlR4RmluYWxpemF0aW9uUmVhc29uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZmluYWxpemF0aW9uVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLmZpbmFsaXphdGlvblR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVR4RmluYWxpemF0aW9uUmVhc29uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5maW5hbGl6YXRpb25UeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gNCB8fCB0YWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmluYWxpemF0aW9uVHlwZTogaXNTZXQob2JqZWN0LmZpbmFsaXphdGlvblR5cGUpXG4gICAgICAgICAgICAgICAgPyB0eEZpbmFsaXphdGlvblJlYXNvblR5cGVGcm9tSlNPTihvYmplY3QuZmluYWxpemF0aW9uVHlwZSlcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZmluYWxpemF0aW9uVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLmZpbmFsaXphdGlvblR5cGUgPSB0eEZpbmFsaXphdGlvblJlYXNvblR5cGVUb0pTT04obWVzc2FnZS5maW5hbGl6YXRpb25UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHhGaW5hbGl6YXRpb25SZWFzb24uZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeEZpbmFsaXphdGlvblJlYXNvbigpO1xuICAgICAgICBtZXNzYWdlLmZpbmFsaXphdGlvblR5cGUgPSBvYmplY3QuZmluYWxpemF0aW9uVHlwZSA/PyAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dUeCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtc2dUeXBlOiAwLFxuICAgICAgICB0eGlkOiBuZXcgVWludDhBcnJheSgwKSxcbiAgICAgICAgZmluYWxpemF0aW9uUmVhc29uOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuTXNnVHggPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tc2dUeXBlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UubXNnVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudHhpZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UudHhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZmluYWxpemF0aW9uUmVhc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVHhGaW5hbGl6YXRpb25SZWFzb24uZW5jb2RlKG1lc3NhZ2UuZmluYWxpemF0aW9uUmVhc29uLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1R4KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tc2dUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHhpZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IDI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZpbmFsaXphdGlvblJlYXNvbiA9IGV4cG9ydHMuVHhGaW5hbGl6YXRpb25SZWFzb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dUeXBlOiBpc1NldChvYmplY3QubXNnVHlwZSlcbiAgICAgICAgICAgICAgICA/IHR4TXNnVHlwZUZyb21KU09OKG9iamVjdC5tc2dUeXBlKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHR4aWQ6IGlzU2V0KG9iamVjdC50eGlkKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC50eGlkKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoMCksXG4gICAgICAgICAgICBmaW5hbGl6YXRpb25SZWFzb246IGlzU2V0KG9iamVjdC5maW5hbGl6YXRpb25SZWFzb24pXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlR4RmluYWxpemF0aW9uUmVhc29uLmZyb21KU09OKG9iamVjdC5maW5hbGl6YXRpb25SZWFzb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubXNnVHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLm1zZ1R5cGUgPSB0eE1zZ1R5cGVUb0pTT04obWVzc2FnZS5tc2dUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50eGlkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgb2JqLnR4aWQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS50eGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5maW5hbGl6YXRpb25SZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLmZpbmFsaXphdGlvblJlYXNvbiA9IGV4cG9ydHMuVHhGaW5hbGl6YXRpb25SZWFzb24udG9KU09OKG1lc3NhZ2UuZmluYWxpemF0aW9uUmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgY3JlYXRlKGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTXNnVHguZnJvbVBhcnRpYWwoYmFzZSA/PyB7fSk7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dUeCgpO1xuICAgICAgICBtZXNzYWdlLm1zZ1R5cGUgPSBvYmplY3QubXNnVHlwZSA/PyAwO1xuICAgICAgICBtZXNzYWdlLnR4aWQgPSBvYmplY3QudHhpZCA/PyBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgbWVzc2FnZS5maW5hbGl6YXRpb25SZWFzb24gPVxuICAgICAgICAgICAgb2JqZWN0LmZpbmFsaXphdGlvblJlYXNvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LmZpbmFsaXphdGlvblJlYXNvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5UeEZpbmFsaXphdGlvblJlYXNvbi5mcm9tUGFydGlhbChvYmplY3QuZmluYWxpemF0aW9uUmVhc29uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFbXB0eSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLkVtcHR5ID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIuY3JlYXRlKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRW1wdHkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSA0IHx8IHRhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkVtcHR5LmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwoXykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVtcHR5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVycm9yKCkge1xuICAgIHJldHVybiB7IG1zZzogJycgfTtcbn1cbmV4cG9ydHMuRXJyb3IgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tc2cgIT09ICcnKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5tc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyLmNyZWF0ZShpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUVycm9yKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gMTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXNnID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDQgfHwgdGFnID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHsgbXNnOiBpc1NldChvYmplY3QubXNnKSA/IGdsb2JhbFRoaXMuU3RyaW5nKG9iamVjdC5tc2cpIDogJycgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5tc2cgIT09ICcnKSB7XG4gICAgICAgICAgICBvYmoubXNnID0gbWVzc2FnZS5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGNyZWF0ZShiYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkVycm9yLmZyb21QYXJ0aWFsKGJhc2UgPz8ge30pO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRXJyb3IoKTtcbiAgICAgICAgbWVzc2FnZS5tc2cgPSBvYmplY3QubXNnID8/ICcnO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5CdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgJ2Jhc2U2NCcpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGdsb2JhbFRoaXMuYXRvYihiNjQpO1xuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGlmIChnbG9iYWxUaGlzLkJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShhcnIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgICAgICBhcnIuZm9yRWFjaChieXRlID0+IHtcbiAgICAgICAgICAgIGJpbi5wdXNoKGdsb2JhbFRoaXMuU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGJpbi5qb2luKCcnKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9uZ1RvQmlnaW50KGxvbmcpIHtcbiAgICByZXR1cm4gQmlnSW50KGxvbmcudG9TdHJpbmcoKSk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHJvbmlrLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8331\n\n}")},8393:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("{\n// EXTERNAL MODULE: ./node_modules/ecash-wallet/dist/index.js\nvar dist = __webpack_require__(5436);\n// EXTERNAL MODULE: ./node_modules/chronik-client/dist/index.js\nvar chronik_client_dist = __webpack_require__(1904);\n// EXTERNAL MODULE: ./node_modules/ecash-lib/dist/indexBrowser.js\nvar indexBrowser = __webpack_require__(8816);\n// EXTERNAL MODULE: ./node_modules/pulltorefreshjs/dist/index.umd.js\nvar index_umd = __webpack_require__(3678);\nvar index_umd_default = /*#__PURE__*/__webpack_require__.n(index_umd);\n;// ./src/common.ts\n// Check if we are running in a React Native WebView. This makes it possible to\n// use a degraded but functional web version of the app.\nfunction isReactNativeWebView() {\n    return !!window.ReactNativeWebView;\n}\n// Send a message to the backend app if we are running in a React Native\n// WebView. This is how we communicate back and forth to escape the WebView and\n// access the platform native features.\nfunction sendMessageToBackend(type, data) {\n    if (isReactNativeWebView()) {\n        window.ReactNativeWebView.postMessage(JSON.stringify({\n            type,\n            data,\n        }));\n        return true;\n    }\n    return false;\n}\nfunction webViewLog(...messages) {\n    const catMessages = messages.join(' ');\n    console.log(catMessages);\n    sendMessageToBackend('LOG', catMessages);\n}\nfunction webViewError(...messages) {\n    webViewLog('Error:', ...messages);\n}\n\n;// ./src/amount.ts\n\n\n\n// Conversion function for display\nfunction satsToXec(sats) {\n    return Math.round(sats) / 100; // Round to avoid floating-point errors\n}\n// Calculate transaction amount for our address\nasync function calculateTransactionAmountSats(wallet, chronik, txid) {\n    try {\n        // Get transaction details from Chronik\n        const tx = await chronik.tx(txid);\n        if (!tx) {\n            webViewError('Transaction not found:', txid);\n            return 0;\n        }\n        // Get our address hash160 for comparison\n        const ecc = new indexBrowser.Ecc();\n        const pk = ecc.derivePubkey(wallet.sk);\n        const pkh = (0,indexBrowser.shaRmd160)(pk);\n        const ourHash160 = Array.from(pkh).map(byte => byte.toString(16).padStart(2, '0')).join('');\n        let totalAmount = 0;\n        // Check outputs (receives) - amounts sent TO our address\n        for (let i = 0; i < tx.outputs.length; i++) {\n            const output = tx.outputs[i];\n            if (output.outputScript && output.sats) {\n                try {\n                    // Handle both hex string and Uint8Array formats\n                    let outputScript;\n                    if (typeof output.outputScript === 'string') {\n                        // Convert hex string to Uint8Array\n                        const hex = output.outputScript;\n                        outputScript = new Uint8Array(hex.length / 2);\n                        for (let j = 0; j < hex.length; j += 2) {\n                            outputScript[j / 2] = parseInt(hex.substr(j, 2), 16);\n                        }\n                    }\n                    else {\n                        outputScript = output.outputScript;\n                    }\n                    // We only support P2PKH scripts\n                    if (outputScript && outputScript.length === 25 &&\n                        outputScript[0] === 0x76 && outputScript[1] === 0xa9 && outputScript[2] === 0x14) {\n                        // Extract hash160 from P2PKH script\n                        const scriptHash160 = outputScript.slice(3, 23);\n                        const scriptHash160Hex = Array.from(scriptHash160).map(byte => byte.toString(16).padStart(2, '0')).join('');\n                        if (scriptHash160Hex === ourHash160) {\n                            const amountSats = Number(output.sats);\n                            totalAmount += amountSats;\n                        }\n                    }\n                }\n                catch (error) {\n                    webViewError(`Could not parse output script from txid ${txid} index ${i}:`, error);\n                }\n            }\n        }\n        // Check inputs (spends) - amounts sent FROM our address\n        for (let i = 0; i < tx.inputs.length; i++) {\n            const input = tx.inputs[i];\n            if (input.outputScript && input.sats) {\n                try {\n                    // Handle both hex string and Uint8Array formats\n                    let inputScript;\n                    if (typeof input.outputScript === 'string') {\n                        // Convert hex string to Uint8Array\n                        const hex = input.outputScript;\n                        inputScript = new Uint8Array(hex.length / 2);\n                        for (let j = 0; j < hex.length; j += 2) {\n                            inputScript[j / 2] = parseInt(hex.substr(j, 2), 16);\n                        }\n                    }\n                    else {\n                        inputScript = input.outputScript;\n                    }\n                    // We only support P2PKH scripts\n                    if (inputScript && inputScript.length === 25 &&\n                        inputScript[0] === 0x76 && inputScript[1] === 0xa9 && inputScript[2] === 0x14) {\n                        // Extract hash160 from P2PKH script\n                        const scriptHash160 = inputScript.slice(3, 23);\n                        const scriptHash160Hex = Array.from(scriptHash160).map(byte => byte.toString(16).padStart(2, '0')).join('');\n                        if (scriptHash160Hex === ourHash160) {\n                            const amountSats = Number(input.sats);\n                            totalAmount -= amountSats;\n                        }\n                    }\n                }\n                catch (error) {\n                    webViewError(`Could not parse input script from txid ${txid} index ${i}:`, error);\n                }\n            }\n        }\n        return totalAmount;\n    }\n    catch (error) {\n        webViewError('Failed calculating transaction amount:', error);\n        return 0;\n    }\n}\n// Calculate maximum spendable amount\nfunction calculateMaxSpendableAmount(wallet) {\n    // Select all spendable utxos and calculate the size of a transaction that\n    // sends them all to a single p2pkh output + change output\n    const spendableUtxos = wallet.spendableUtxos();\n    const balanceSats = dist.Wallet.sumUtxosSats(spendableUtxos);\n    const inputs = spendableUtxos.map(utxo => wallet.p2pkhUtxoToBuilderInput(utxo));\n    const txBuilder = new indexBrowser.TxBuilder({\n        inputs,\n        // No leftover in this case, send all to self\n        outputs: [\n            wallet.script,\n        ],\n    });\n    const thisTx = txBuilder.sign({\n        feePerKb: indexBrowser.DEFAULT_FEE_SATS_PER_KB,\n        dustSats: indexBrowser.DEFAULT_DUST_SATS,\n    });\n    const txSize = thisTx.serSize();\n    const txFee = (0,indexBrowser.calcTxFee)(txSize, indexBrowser.DEFAULT_FEE_SATS_PER_KB);\n    return satsToXec(Number(balanceSats - txFee));\n}\n// Estimate transaction fee\nfunction estimateTransactionFee(wallet, recipientAddress, amountXEC) {\n    try {\n        // Convert XEC to satoshis (1 XEC = 100 satoshis)\n        const amountSatoshis = Math.round(amountXEC * 100);\n        // Create the action with outputs\n        const action = wallet.action({\n            outputs: [\n                {\n                    address: recipientAddress,\n                    sats: BigInt(amountSatoshis)\n                }\n            ]\n        });\n        // Build the transaction to get fee estimate\n        const builtTx = action.build();\n        // Get fee in satoshis and convert to XEC\n        const feeSatoshis = Number(builtTx.fee());\n        const feeXEC = satsToXec(feeSatoshis);\n        const totalXEC = amountXEC + feeXEC;\n        return { feeXEC, totalXEC };\n    }\n    catch (error) {\n        webViewError('Failed estimating transaction fee:', error);\n        return null;\n    }\n}\n\n;// ./src/config.ts\n/**\n * Configuration for the Marlin Wallet\n */\nconst config = {\n    /**\n     * Chronik API endpoints\n     * Multiple endpoints can be provided for failover\n     */\n    chronikUrls: [\n        'https://chronik-native1.fabien.cash',\n        'https://chronik-native2.fabien.cash',\n        'https://chronik-native3.fabien.cash',\n    ],\n    /**\n     * Address prefix for the network\n     * 'ecash' for mainnet, 'ectest' for testnet\n     */\n    addressPrefix: 'ecash',\n    /**\n     * Block explorer base URL\n     * Transaction IDs will be appended to this URL\n     */\n    explorerUrl: 'https://explorer.e.cash/tx/',\n    /**\n     * Currency ticker symbol\n     */\n    ticker: 'XEC',\n    /**\n     * BIP21 prefix\n     */\n    bip21Prefix: 'ecash:',\n};\n\n;// ./src/wallet.ts\n\n\n// Return the eCash address string for this wallet\nfunction getAddress(wallet) {\n    if (!wallet || !wallet.address) {\n        return null;\n    }\n    return indexBrowser.Address.parse(wallet.address).withPrefix(config.addressPrefix).toString();\n}\n// Send a transaction\nasync function sendTransaction(wallet, recipientAddress, sats) {\n    // Create the action with outputs\n    const action = wallet.action({\n        outputs: [\n            {\n                address: recipientAddress,\n                sats: BigInt(sats)\n            }\n        ]\n    });\n    const builtTx = action.build();\n    await builtTx.broadcast();\n}\n\n;// ./src/transaction-history.ts\n\n\n\n\n// ============================================================================\n// TRANSACTION HISTORY MANAGER\n// ============================================================================\n// Transaction History Manager\nclass TransactionHistoryManager {\n    constructor(wallet, chronik) {\n        this.currentPage = 0;\n        this.totalPages = 0;\n        this.hasMoreTransactions = true;\n        this.isLoadingTransactions = false;\n        this.allTransactions = [];\n        this.wallet = wallet;\n        this.chronik = chronik;\n        this.address = getAddress(this.wallet);\n    }\n    // Getters\n    get isCurrentlyLoading() {\n        return this.isLoadingTransactions;\n    }\n    get hasMoreToLoad() {\n        return this.hasMoreTransactions;\n    }\n    get transactions() {\n        return this.allTransactions;\n    }\n    // Reset state for new history load\n    reset() {\n        this.currentPage = 0;\n        this.totalPages = 0;\n        this.hasMoreTransactions = true;\n        this.isLoadingTransactions = false;\n        this.allTransactions = [];\n    }\n    // Load more transactions\n    async loadMore() {\n        if (!this.hasMoreToLoad || this.isCurrentlyLoading) {\n            return;\n        }\n        await this.loadTransactionHistory(this.chronik, this.address, false);\n    }\n    // Main transaction loading function\n    async loadTransactionHistory(chronik, address, reset = true) {\n        const transactionList = document.getElementById('transaction-list');\n        if (!transactionList)\n            return;\n        if (this.isLoadingTransactions) {\n            return; // Prevent multiple simultaneous requests\n        }\n        if (reset) {\n            this.reset();\n            // Show loading state only on reset\n            transactionList.innerHTML = `\n                <div class=\"loading-transactions\">\n                    <div class=\"loading-spinner\"></div>\n                    <p>Loading transactions...</p>\n                </div>\n            `;\n        }\n        if (!this.hasMoreTransactions) {\n            return; // No more transactions to load\n        }\n        this.isLoadingTransactions = true;\n        // Show loading indicator immediately if not resetting\n        if (!reset) {\n            this.displayTransactions(this.allTransactions);\n        }\n        try {\n            // Get transaction history from Chronik with pagination\n            const txHistoryResponse = await this.chronik.address(this.address).history(this.currentPage, 25);\n            const txHistory = txHistoryResponse.txs;\n            // Update pagination metadata\n            this.totalPages = txHistoryResponse.numPages;\n            if (!txHistory || txHistory.length === 0) {\n                this.hasMoreTransactions = false;\n                if (this.allTransactions.length === 0) {\n                    this.showNoTransactions();\n                }\n                return;\n            }\n            // Add new transactions to existing list\n            if (reset) {\n                this.allTransactions = txHistory;\n            }\n            else {\n                this.allTransactions = [...this.allTransactions, ...txHistory];\n            }\n            // Check if we've reached the last page\n            if (this.currentPage >= this.totalPages - 1) {\n                this.hasMoreTransactions = false;\n            }\n            else {\n                this.currentPage++;\n            }\n            // Process and display all transactions\n            this.displayTransactions(this.allTransactions);\n        }\n        catch (error) {\n            webViewError('Failed to load transaction history:', error);\n            this.showTransactionError();\n        }\n        finally {\n            this.isLoadingTransactions = false;\n            // Update display one more time to remove loading indicator\n            if (!reset) {\n                this.displayTransactions(this.allTransactions);\n            }\n        }\n    }\n    // Display transactions in the UI\n    async displayTransactions(transactions) {\n        const transactionList = document.getElementById('transaction-list');\n        if (!transactionList)\n            return;\n        if (transactions.length === 0) {\n            this.showNoTransactions();\n            return;\n        }\n        // Process transactions in parallel for better performance\n        const transactionHTML = await Promise.all(transactions.map(async (tx) => {\n            // Use timeFirstSeen field from Chronik, fallback to block timestamp if zero\n            let time;\n            if (tx.timeFirstSeen && tx.timeFirstSeen > 0) {\n                time = new Date(tx.timeFirstSeen * 1000).toLocaleString();\n            }\n            else if (tx.block && tx.block.timestamp) {\n                time = new Date(tx.block.timestamp * 1000).toLocaleString();\n            }\n            else {\n                time = 'Unknown Date';\n            }\n            const txid = String(tx.txid);\n            const shortTxid = txid.length > 12 ? `${txid.substring(0, 6)}...${txid.substring(txid.length - 6)}` : txid;\n            // Calculate real transaction amount\n            const amountSats = await calculateTransactionAmountSats(this.wallet, this.chronik, txid);\n            const amountXEC = satsToXec(amountSats);\n            const isReceived = amountXEC > 0;\n            const amountClass = isReceived ? 'received' : 'sent';\n            const amountPrefix = isReceived ? '+' : '-';\n            const amountValue = Math.abs(amountXEC).toFixed(2);\n            return `\n                <div class=\"transaction-item\">\n                    <div class=\"transaction-info\">\n                        <div class=\"transaction-time\">${String(time)}</div>\n                        <div class=\"transaction-txid\" data-txid=\"${String(txid)}\">${String(shortTxid)}</div>\n                    </div>\n                    <div class=\"transaction-amount ${String(amountClass)}\">\n                        ${String(amountPrefix)}${String(amountValue)} ${config.ticker}\n                    </div>\n                </div>\n            `;\n        }));\n        // Add loading indicator at bottom if currently loading more transactions\n        let loadingIndicator = '';\n        if (this.isLoadingTransactions) {\n            loadingIndicator = `\n                <div class=\"loading-more\">\n                    <div class=\"loading-spinner\"></div>\n                    <p>Loading more transactions...</p>\n                </div>\n            `;\n        }\n        transactionList.innerHTML = transactionHTML.join('') + loadingIndicator;\n    }\n    // Show no transactions message\n    showNoTransactions() {\n        const transactionList = document.getElementById('transaction-list');\n        if (!transactionList) {\n            return;\n        }\n        transactionList.innerHTML = `\n            <div class=\"no-transactions\">\n                <h3>No Transactions</h3>\n                <p>You haven't made any transactions yet.</p>\n            </div>\n        `;\n    }\n    // Show transaction error\n    showTransactionError() {\n        const transactionList = document.getElementById('transaction-list');\n        if (!transactionList) {\n            return;\n        }\n        transactionList.innerHTML = `\n            <div class=\"no-transactions\">\n                <h3>Error Loading Transactions</h3>\n                <p>Failed to load transaction history. Please try again later.</p>\n            </div>\n        `;\n    }\n    // Handle scroll events for infinite loading\n    handleScroll() {\n        const transactionList = document.getElementById('transaction-list');\n        if (!transactionList)\n            return;\n        // Check if user has scrolled near the bottom\n        const scrollTop = transactionList.scrollTop;\n        const scrollHeight = transactionList.scrollHeight;\n        const clientHeight = transactionList.clientHeight;\n        const isNearBottom = scrollTop + clientHeight >= scrollHeight - 100;\n        // Load more transactions if near bottom, more pages available, and not currently loading\n        if (isNearBottom && this.hasMoreToLoad && !this.isCurrentlyLoading) {\n            webViewLog('Near bottom detected, loading more transactions...');\n            this.loadMore();\n        }\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/bip39/src/index.js\nvar src = __webpack_require__(749);\n// EXTERNAL MODULE: ./node_modules/randombytes/browser.js\nvar browser = __webpack_require__(3209);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n;// ./src/mnemonic.ts\n\n\n\n/**\n * Generate a mnemonic using the bip39 library. Use to create a new wallet.\n */\nfunction generateMnemonic() {\n    const mnemonic = src/* generateMnemonic */.we(128, (browser_default()), src/* wordlists */.Yu['english']);\n    return mnemonic;\n}\n/*\n * Get the mnemonic from the wallet data object.\n * TODO: Switch to be a proper HD wallet. This means that the seed should be\n * stored in ecash-wallet and then we can retrieve the mnemonic from there.\n */\nfunction getMnemonic(walletData) {\n    if (!walletData || !walletData.mnemonic) {\n        return null;\n    }\n    return walletData.mnemonic;\n}\n// Check the mnemonic is valid\nfunction validateMnemonic(mnemonic) {\n    try {\n        // Check if it's a valid BIP39 mnemonic\n        return src/* validateMnemonic */.JB(mnemonic.trim());\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Request to store mnemonic in secure storage, fallback to localStorage for\n * web.\n */\nfunction storeMnemonic(mnemonic) {\n    if (!sendMessageToBackend('STORE_MNEMONIC', mnemonic)) {\n        // Fallback to localStorage for web\n        localStorage.setItem('ecash_wallet_mnemonic', mnemonic);\n    }\n}\n/**\n * Request to load mnemonic from secure storage, fallback to localStorage for\n * web.\n */\nfunction loadMnemonic() {\n    return new Promise((resolve, reject) => {\n        if (isReactNativeWebView()) {\n            webViewLog('Loading mnemonic from secure storage');\n            const handleResponse = (event) => {\n                try {\n                    const message = JSON.parse(event.data);\n                    if (message.type === 'MNEMONIC_RESPONSE') {\n                        document.removeEventListener('message', handleResponse);\n                        window.removeEventListener('message', handleResponse);\n                        resolve(message.data);\n                    }\n                }\n                catch (error) {\n                    webViewError('Error parsing mnemonic response:', error);\n                }\n            };\n            document.addEventListener('message', handleResponse);\n            window.addEventListener('message', handleResponse);\n            sendMessageToBackend('LOAD_MNEMONIC', undefined);\n            // Timeout after 30 seconds\n            setTimeout(() => {\n                document.removeEventListener('message', handleResponse);\n                window.removeEventListener('message', handleResponse);\n                reject(new Error('Timeout loading mnemonic'));\n            }, 30000);\n        }\n        else {\n            webViewLog('Loading mnemonic from local storage');\n            // Fallback to localStorage for web\n            const mnemonic = localStorage.getItem('ecash_wallet_mnemonic');\n            resolve(mnemonic);\n        }\n    });\n}\n\n;// ./src/address.ts\n\n\n\n// Check the address string is a valid eCash address\nfunction isValidECashAddress(address) {\n    try {\n        // Use Address.parse() to validate the address\n        // This will throw an error if the address is invalid\n        indexBrowser.Address.parse(address);\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n// Copy address to clipboard\nasync function copyAddress(wallet) {\n    const address = getAddress(wallet);\n    if (!address) {\n        return;\n    }\n    try {\n        await navigator.clipboard.writeText(address);\n        // Address copied silently - no status message\n    }\n    catch (error) {\n        webViewError('Failed to copy address:', error);\n    }\n}\n\n;// ./node_modules/qr-scanner/qr-scanner.min.js\nclass e{constructor(a,b,c,d,f){this._legacyCanvasSize=e.DEFAULT_CANVAS_SIZE;this._preferredCamera=\"environment\";this._maxScansPerSecond=25;this._lastScanTimestamp=-1;this._destroyed=this._flashOn=this._paused=this._active=!1;this.$video=a;this.$canvas=document.createElement(\"canvas\");c&&\"object\"===typeof c?this._onDecode=b:(c||d||f?console.warn(\"You're using a deprecated version of the QrScanner constructor which will be removed in the future\"):console.warn(\"Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\"),\nthis._legacyOnDecode=b);b=\"object\"===typeof c?c:{};this._onDecodeError=b.onDecodeError||(\"function\"===typeof c?c:this._onDecodeError);this._calculateScanRegion=b.calculateScanRegion||(\"function\"===typeof d?d:this._calculateScanRegion);this._preferredCamera=b.preferredCamera||f||this._preferredCamera;this._legacyCanvasSize=\"number\"===typeof c?c:\"number\"===typeof d?d:this._legacyCanvasSize;this._maxScansPerSecond=b.maxScansPerSecond||this._maxScansPerSecond;this._onPlay=this._onPlay.bind(this);this._onLoadedMetaData=\nthis._onLoadedMetaData.bind(this);this._onVisibilityChange=this._onVisibilityChange.bind(this);this._updateOverlay=this._updateOverlay.bind(this);a.disablePictureInPicture=!0;a.playsInline=!0;a.muted=!0;let h=!1;a.hidden&&(a.hidden=!1,h=!0);document.body.contains(a)||(document.body.appendChild(a),h=!0);c=a.parentElement;if(b.highlightScanRegion||b.highlightCodeOutline){d=!!b.overlay;this.$overlay=b.overlay||document.createElement(\"div\");f=this.$overlay.style;f.position=\"absolute\";f.display=\"none\";\nf.pointerEvents=\"none\";this.$overlay.classList.add(\"scan-region-highlight\");if(!d&&b.highlightScanRegion){this.$overlay.innerHTML='<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\"><path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21\"/></svg>';try{this.$overlay.firstElementChild.animate({transform:[\"scale(.98)\",\n\"scale(1.01)\"]},{duration:400,iterations:Infinity,direction:\"alternate\",easing:\"ease-in-out\"})}catch(m){}c.insertBefore(this.$overlay,this.$video.nextSibling)}b.highlightCodeOutline&&(this.$overlay.insertAdjacentHTML(\"beforeend\",'<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>'),this.$codeOutlineHighlight=this.$overlay.lastElementChild)}this._scanRegion=\nthis._calculateScanRegion(a);requestAnimationFrame(()=>{let m=window.getComputedStyle(a);\"none\"===m.display&&(a.style.setProperty(\"display\",\"block\",\"important\"),h=!0);\"visible\"!==m.visibility&&(a.style.setProperty(\"visibility\",\"visible\",\"important\"),h=!0);h&&(console.warn(\"QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.\"),a.style.opacity=\"0\",a.style.width=\"0\",a.style.height=\"0\",this.$overlay&&this.$overlay.parentElement&&this.$overlay.parentElement.removeChild(this.$overlay),\ndelete this.$overlay,delete this.$codeOutlineHighlight);this.$overlay&&this._updateOverlay()});a.addEventListener(\"play\",this._onPlay);a.addEventListener(\"loadedmetadata\",this._onLoadedMetaData);document.addEventListener(\"visibilitychange\",this._onVisibilityChange);window.addEventListener(\"resize\",this._updateOverlay);this._qrEnginePromise=e.createQrEngine()}static set WORKER_PATH(a){console.warn(\"Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.\")}static async hasCamera(){try{return!!(await e.listCameras(!1)).length}catch(a){return!1}}static async listCameras(a=\n!1){if(!navigator.mediaDevices)return[];let b=async()=>(await navigator.mediaDevices.enumerateDevices()).filter(d=>\"videoinput\"===d.kind),c;try{a&&(await b()).every(d=>!d.label)&&(c=await navigator.mediaDevices.getUserMedia({audio:!1,video:!0}))}catch(d){}try{return(await b()).map((d,f)=>({id:d.deviceId,label:d.label||(0===f?\"Default Camera\":`Camera ${f+1}`)}))}finally{c&&(console.warn(\"Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream\"),e._stopVideoStream(c))}}async hasFlash(){let a;\ntry{if(this.$video.srcObject){if(!(this.$video.srcObject instanceof MediaStream))return!1;a=this.$video.srcObject}else a=(await this._getCameraStream()).stream;return\"torch\"in a.getVideoTracks()[0].getSettings()}catch(b){return!1}finally{a&&a!==this.$video.srcObject&&(console.warn(\"Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream\"),e._stopVideoStream(a))}}isFlashOn(){return this._flashOn}async toggleFlash(){this._flashOn?await this.turnFlashOff():await this.turnFlashOn()}async turnFlashOn(){if(!this._flashOn&&\n!this._destroyed&&(this._flashOn=!0,this._active&&!this._paused))try{if(!await this.hasFlash())throw\"No flash available\";await this.$video.srcObject.getVideoTracks()[0].applyConstraints({advanced:[{torch:!0}]})}catch(a){throw this._flashOn=!1,a;}}async turnFlashOff(){this._flashOn&&(this._flashOn=!1,await this._restartVideoStream())}destroy(){this.$video.removeEventListener(\"loadedmetadata\",this._onLoadedMetaData);this.$video.removeEventListener(\"play\",this._onPlay);document.removeEventListener(\"visibilitychange\",\nthis._onVisibilityChange);window.removeEventListener(\"resize\",this._updateOverlay);this._destroyed=!0;this._flashOn=!1;this.stop();e._postWorkerMessage(this._qrEnginePromise,\"close\")}async start(){if(this._destroyed)throw Error(\"The QR scanner can not be started as it had been destroyed.\");if(!this._active||this._paused)if(\"https:\"!==window.location.protocol&&console.warn(\"The camera stream is only accessible if the page is transferred via https.\"),this._active=!0,!document.hidden)if(this._paused=\n!1,this.$video.srcObject)await this.$video.play();else try{let {stream:a,facingMode:b}=await this._getCameraStream();!this._active||this._paused?e._stopVideoStream(a):(this._setVideoMirror(b),this.$video.srcObject=a,await this.$video.play(),this._flashOn&&(this._flashOn=!1,this.turnFlashOn().catch(()=>{})))}catch(a){if(!this._paused)throw this._active=!1,a;}}stop(){this.pause();this._active=!1}async pause(a=!1){this._paused=!0;if(!this._active)return!0;this.$video.pause();this.$overlay&&(this.$overlay.style.display=\n\"none\");let b=()=>{this.$video.srcObject instanceof MediaStream&&(e._stopVideoStream(this.$video.srcObject),this.$video.srcObject=null)};if(a)return b(),!0;await new Promise(c=>setTimeout(c,300));if(!this._paused)return!1;b();return!0}async setCamera(a){a!==this._preferredCamera&&(this._preferredCamera=a,await this._restartVideoStream())}static async scanImage(a,b,c,d,f=!1,h=!1){let m,n=!1;b&&(\"scanRegion\"in b||\"qrEngine\"in b||\"canvas\"in b||\"disallowCanvasResizing\"in b||\"alsoTryWithoutScanRegion\"in\nb||\"returnDetailedScanResult\"in b)?(m=b.scanRegion,c=b.qrEngine,d=b.canvas,f=b.disallowCanvasResizing||!1,h=b.alsoTryWithoutScanRegion||!1,n=!0):b||c||d||f||h?console.warn(\"You're using a deprecated api for scanImage which will be removed in the future.\"):console.warn(\"Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\");b=!!c;try{let p,k;[c,p]=await Promise.all([c||e.createQrEngine(),e._loadImage(a)]);\n[d,k]=e._drawToCanvas(p,m,d,f);let q;if(c instanceof Worker){let g=c;b||e._postWorkerMessageSync(g,\"inversionMode\",\"both\");q=await new Promise((l,v)=>{let w,u,r,y=-1;u=t=>{t.data.id===y&&(g.removeEventListener(\"message\",u),g.removeEventListener(\"error\",r),clearTimeout(w),null!==t.data.data?l({data:t.data.data,cornerPoints:e._convertPoints(t.data.cornerPoints,m)}):v(e.NO_QR_CODE_FOUND))};r=t=>{g.removeEventListener(\"message\",u);g.removeEventListener(\"error\",r);clearTimeout(w);v(\"Scanner error: \"+(t?\nt.message||t:\"Unknown Error\"))};g.addEventListener(\"message\",u);g.addEventListener(\"error\",r);w=setTimeout(()=>r(\"timeout\"),1E4);let x=k.getImageData(0,0,d.width,d.height);y=e._postWorkerMessageSync(g,\"decode\",x,[x.data.buffer])})}else q=await Promise.race([new Promise((g,l)=>window.setTimeout(()=>l(\"Scanner error: timeout\"),1E4)),(async()=>{try{var [g]=await c.detect(d);if(!g)throw e.NO_QR_CODE_FOUND;return{data:g.rawValue,cornerPoints:e._convertPoints(g.cornerPoints,m)}}catch(l){g=l.message||l;\nif(/not implemented|service unavailable/.test(g))return e._disableBarcodeDetector=!0,e.scanImage(a,{scanRegion:m,canvas:d,disallowCanvasResizing:f,alsoTryWithoutScanRegion:h});throw`Scanner error: ${g}`;}})()]);return n?q:q.data}catch(p){if(!m||!h)throw p;let k=await e.scanImage(a,{qrEngine:c,canvas:d,disallowCanvasResizing:f});return n?k:k.data}finally{b||e._postWorkerMessage(c,\"close\")}}setGrayscaleWeights(a,b,c,d=!0){e._postWorkerMessage(this._qrEnginePromise,\"grayscaleWeights\",{red:a,green:b,\nblue:c,useIntegerApproximation:d})}setInversionMode(a){e._postWorkerMessage(this._qrEnginePromise,\"inversionMode\",a)}static async createQrEngine(a){a&&console.warn(\"Specifying a worker path is not required and not supported anymore.\");a=()=>__webpack_require__.e(/* import() */ 170).then(__webpack_require__.bind(__webpack_require__, 8170)).then(c=>c.createWorker());if(!(!e._disableBarcodeDetector&&\"BarcodeDetector\"in window&&BarcodeDetector.getSupportedFormats&&(await BarcodeDetector.getSupportedFormats()).includes(\"qr_code\")))return a();let b=navigator.userAgentData;\nreturn b&&b.brands.some(({brand:c})=>/Chromium/i.test(c))&&/mac ?OS/i.test(b.platform)&&await b.getHighEntropyValues([\"architecture\",\"platformVersion\"]).then(({architecture:c,platformVersion:d})=>/arm/i.test(c||\"arm\")&&13<=parseInt(d||\"13\")).catch(()=>!0)?a():new BarcodeDetector({formats:[\"qr_code\"]})}_onPlay(){this._scanRegion=this._calculateScanRegion(this.$video);this._updateOverlay();this.$overlay&&(this.$overlay.style.display=\"\");this._scanFrame()}_onLoadedMetaData(){this._scanRegion=this._calculateScanRegion(this.$video);\nthis._updateOverlay()}_onVisibilityChange(){document.hidden?this.pause():this._active&&this.start()}_calculateScanRegion(a){let b=Math.round(2/3*Math.min(a.videoWidth,a.videoHeight));return{x:Math.round((a.videoWidth-b)/2),y:Math.round((a.videoHeight-b)/2),width:b,height:b,downScaledWidth:this._legacyCanvasSize,downScaledHeight:this._legacyCanvasSize}}_updateOverlay(){requestAnimationFrame(()=>{if(this.$overlay){var a=this.$video,b=a.videoWidth,c=a.videoHeight,d=a.offsetWidth,f=a.offsetHeight,h=a.offsetLeft,\nm=a.offsetTop,n=window.getComputedStyle(a),p=n.objectFit,k=b/c,q=d/f;switch(p){case \"none\":var g=b;var l=c;break;case \"fill\":g=d;l=f;break;default:(\"cover\"===p?k>q:k<q)?(l=f,g=l*k):(g=d,l=g/k),\"scale-down\"===p&&(g=Math.min(g,b),l=Math.min(l,c))}var [v,w]=n.objectPosition.split(\" \").map((r,y)=>{const x=parseFloat(r);return r.endsWith(\"%\")?(y?f-l:d-g)*x/100:x});n=this._scanRegion.width||b;q=this._scanRegion.height||c;p=this._scanRegion.x||0;var u=this._scanRegion.y||0;k=this.$overlay.style;k.width=\n`${n/b*g}px`;k.height=`${q/c*l}px`;k.top=`${m+w+u/c*l}px`;c=/scaleX\\(-1\\)/.test(a.style.transform);k.left=`${h+(c?d-v-g:v)+(c?b-p-n:p)/b*g}px`;k.transform=a.style.transform}})}static _convertPoints(a,b){if(!b)return a;let c=b.x||0,d=b.y||0,f=b.width&&b.downScaledWidth?b.width/b.downScaledWidth:1;b=b.height&&b.downScaledHeight?b.height/b.downScaledHeight:1;for(let h of a)h.x=h.x*f+c,h.y=h.y*b+d;return a}_scanFrame(){!this._active||this.$video.paused||this.$video.ended||(\"requestVideoFrameCallback\"in\nthis.$video?this.$video.requestVideoFrameCallback.bind(this.$video):requestAnimationFrame)(async()=>{if(!(1>=this.$video.readyState)){var a=Date.now()-this._lastScanTimestamp,b=1E3/this._maxScansPerSecond;a<b&&await new Promise(d=>setTimeout(d,b-a));this._lastScanTimestamp=Date.now();try{var c=await e.scanImage(this.$video,{scanRegion:this._scanRegion,qrEngine:this._qrEnginePromise,canvas:this.$canvas})}catch(d){if(!this._active)return;this._onDecodeError(d)}!e._disableBarcodeDetector||await this._qrEnginePromise instanceof\nWorker||(this._qrEnginePromise=e.createQrEngine());c?(this._onDecode?this._onDecode(c):this._legacyOnDecode&&this._legacyOnDecode(c.data),this.$codeOutlineHighlight&&(clearTimeout(this._codeOutlineHighlightRemovalTimeout),this._codeOutlineHighlightRemovalTimeout=void 0,this.$codeOutlineHighlight.setAttribute(\"viewBox\",`${this._scanRegion.x||0} `+`${this._scanRegion.y||0} `+`${this._scanRegion.width||this.$video.videoWidth} `+`${this._scanRegion.height||this.$video.videoHeight}`),this.$codeOutlineHighlight.firstElementChild.setAttribute(\"points\",\nc.cornerPoints.map(({x:d,y:f})=>`${d},${f}`).join(\" \")),this.$codeOutlineHighlight.style.display=\"\")):this.$codeOutlineHighlight&&!this._codeOutlineHighlightRemovalTimeout&&(this._codeOutlineHighlightRemovalTimeout=setTimeout(()=>this.$codeOutlineHighlight.style.display=\"none\",100))}this._scanFrame()})}_onDecodeError(a){a!==e.NO_QR_CODE_FOUND&&console.log(a)}async _getCameraStream(){if(!navigator.mediaDevices)throw\"Camera not found.\";let a=/^(environment|user)$/.test(this._preferredCamera)?\"facingMode\":\n\"deviceId\",b=[{width:{min:1024}},{width:{min:768}},{}],c=b.map(d=>Object.assign({},d,{[a]:{exact:this._preferredCamera}}));for(let d of[...c,...b])try{let f=await navigator.mediaDevices.getUserMedia({video:d,audio:!1}),h=this._getFacingMode(f)||(d.facingMode?this._preferredCamera:\"environment\"===this._preferredCamera?\"user\":\"environment\");return{stream:f,facingMode:h}}catch(f){}throw\"Camera not found.\";}async _restartVideoStream(){let a=this._paused;await this.pause(!0)&&!a&&this._active&&await this.start()}static _stopVideoStream(a){for(let b of a.getTracks())b.stop(),\na.removeTrack(b)}_setVideoMirror(a){this.$video.style.transform=\"scaleX(\"+(\"user\"===a?-1:1)+\")\"}_getFacingMode(a){return(a=a.getVideoTracks()[0])?/rear|back|environment/i.test(a.label)?\"environment\":/front|user|face/i.test(a.label)?\"user\":null:null}static _drawToCanvas(a,b,c,d=!1){c=c||document.createElement(\"canvas\");let f=b&&b.x?b.x:0,h=b&&b.y?b.y:0,m=b&&b.width?b.width:a.videoWidth||a.width,n=b&&b.height?b.height:a.videoHeight||a.height;d||(d=b&&b.downScaledWidth?b.downScaledWidth:m,b=b&&b.downScaledHeight?\nb.downScaledHeight:n,c.width!==d&&(c.width=d),c.height!==b&&(c.height=b));b=c.getContext(\"2d\",{alpha:!1});b.imageSmoothingEnabled=!1;b.drawImage(a,f,h,m,n,0,0,c.width,c.height);return[c,b]}static async _loadImage(a){if(a instanceof Image)return await e._awaitImageLoad(a),a;if(a instanceof HTMLVideoElement||a instanceof HTMLCanvasElement||a instanceof SVGImageElement||\"OffscreenCanvas\"in window&&a instanceof OffscreenCanvas||\"ImageBitmap\"in window&&a instanceof ImageBitmap)return a;if(a instanceof\nFile||a instanceof Blob||a instanceof URL||\"string\"===typeof a){let b=new Image;b.src=a instanceof File||a instanceof Blob?URL.createObjectURL(a):a.toString();try{return await e._awaitImageLoad(b),b}finally{(a instanceof File||a instanceof Blob)&&URL.revokeObjectURL(b.src)}}else throw\"Unsupported image type.\";}static async _awaitImageLoad(a){a.complete&&0!==a.naturalWidth||await new Promise((b,c)=>{let d=f=>{a.removeEventListener(\"load\",d);a.removeEventListener(\"error\",d);f instanceof ErrorEvent?\nc(\"Image load error\"):b()};a.addEventListener(\"load\",d);a.addEventListener(\"error\",d)})}static async _postWorkerMessage(a,b,c,d){return e._postWorkerMessageSync(await a,b,c,d)}static _postWorkerMessageSync(a,b,c,d){if(!(a instanceof Worker))return-1;let f=e._workerMessageId++;a.postMessage({id:f,type:b,data:c},d);return f}}e.DEFAULT_CANVAS_SIZE=400;e.NO_QR_CODE_FOUND=\"No QR code found\";e._disableBarcodeDetector=!1;e._workerMessageId=0;/* harmony default export */ const qr_scanner_min = (e);\n//# sourceMappingURL=qr-scanner.min.js.map\n\n// EXTERNAL MODULE: ./node_modules/qrcode/lib/browser.js\nvar lib_browser = __webpack_require__(7583);\n;// ./src/qrcode.ts\n\n\n\nlet qrScanner = null;\n// Start the QR Scanner\nasync function startQRScanner(scanResultHandler) {\n    const video = document.getElementById('camera-video');\n    const modal = document.getElementById('camera-modal');\n    if (!video || !modal) {\n        webViewError('Camera elements not found');\n        return;\n    }\n    // Show modal first\n    modal.classList.remove('hidden');\n    // Check initial state of fallback UI\n    const fallback = document.getElementById('no-camera-fallback');\n    if (fallback && !fallback.classList.contains('hidden')) {\n        hideNoCameraFallback();\n    }\n    try {\n        // Create QR scanner - this will fail if no camera is available\n        qrScanner = new qr_scanner_min(video, (result) => {\n            scanResultHandler(result.data);\n        }, {\n            onDecodeError: (error) => {\n                // Silently handle decode errors (normal during scanning)\n            }\n        });\n        await qrScanner.start();\n    }\n    catch (error) {\n        webViewError('Error starting QR scanner:', error);\n        showNoCameraFallback();\n    }\n}\n// Stop the QR scanner\nfunction stopQRScanner(forceClose = false) {\n    const modal = document.getElementById('camera-modal');\n    const fallback = document.getElementById('no-camera-fallback');\n    const video = document.getElementById('camera-video');\n    if (qrScanner) {\n        qrScanner.stop();\n        qrScanner.destroy();\n        qrScanner = null;\n    }\n    // Properly clean up the video element to prevent media player overlay\n    if (video) {\n        // Stop all video tracks\n        if (video.srcObject) {\n            const stream = video.srcObject;\n            if (stream && stream.getTracks) {\n                stream.getTracks().forEach(track => {\n                    track.stop();\n                });\n            }\n        }\n        // Clear the video source\n        video.srcObject = null;\n        video.src = '';\n        video.load(); // Reset the video element\n        // Pause the video\n        video.pause();\n    }\n    // Close modal if forceClose is true OR if fallback is not visible\n    if (modal && (forceClose || !fallback || fallback.classList.contains('hidden'))) {\n        modal.classList.add('hidden');\n    }\n}\n// Show no camera fallback UI\nfunction showNoCameraFallback() {\n    const fallback = document.getElementById('no-camera-fallback');\n    const video = document.getElementById('camera-video');\n    const scanOverlay = document.querySelector('.scan-overlay');\n    if (fallback) {\n        // Hide video and scan overlay\n        if (video) {\n            video.style.display = 'none';\n        }\n        if (scanOverlay) {\n            scanOverlay.style.display = 'none';\n        }\n        // Show fallback UI\n        fallback.classList.remove('hidden');\n    }\n}\n// Hide no camera fallback UI\nfunction hideNoCameraFallback() {\n    const fallback = document.getElementById('no-camera-fallback');\n    const video = document.getElementById('camera-video');\n    const scanOverlay = document.querySelector('.scan-overlay');\n    if (fallback) {\n        // Hide fallback UI\n        fallback.classList.add('hidden');\n        // Restore video and scan overlay\n        if (video) {\n            video.style.display = 'block';\n        }\n        if (scanOverlay) {\n            scanOverlay.style.display = 'block';\n        }\n    }\n}\n// Render the QR code for an address\nfunction generateQRCode(address) {\n    const qrCodeEl = document.getElementById('qr-code');\n    qrCodeEl.innerHTML = '';\n    const canvas = document.createElement('canvas');\n    qrCodeEl.appendChild(canvas);\n    lib_browser.toCanvas(canvas, address, {\n        width: 200,\n        color: {\n            dark: '#000000',\n            light: '#FFFFFF'\n        }\n    }, (error) => {\n        if (error) {\n            webViewError('Failed to generate QR code:', error);\n            qrCodeEl.innerHTML = '<p style=\"color: #ff6b6b;\">QR Code generation failed</p>';\n        }\n    });\n}\n\n;// ./src/bip21.ts\n\n\n\n/**\n * Create a BIP21 URI from an address and optional amount\n *\n * @param address - The eCash address (may include network prefix like \"ectest:\" or \"ecash:\")\n * @param amountSats - Optional amount in satoshis (will be converted to XEC in the URI)\n * @returns A BIP21 URI string (e.g., \"ecash:address\" or \"ecash:address?amount=100.00\")\n */\nfunction createBip21Uri(address, amountSats) {\n    // Strip any existing prefix to get the raw address\n    const rawAddress = address.includes(':') ? address.split(':')[1] : address;\n    // Build BIP21 URI with config prefix\n    let bip21Uri = config.bip21Prefix + rawAddress;\n    // Add amount parameter if provided and positive\n    if (amountSats && amountSats > 0) {\n        // Convert satoshis to XEC using the standard conversion function\n        const amountXec = satsToXec(amountSats);\n        // Format with 2 decimal places\n        bip21Uri += `?amount=${amountXec.toFixed(2)}`;\n    }\n    return bip21Uri;\n}\n/**\n * Parse a BIP21 URI string\n *\n * Supports simplified BIP21 format for eCash:\n * - always starts with ecash: even for other prefixed addresses\n * - Optional amount parameter (e.g., ?amount=100.42)\n * - All other query parameters are ignored\n *\n * @param uri - The URI string to parse (e.g., \"ecash:prfhcnyqnl5cgrnmlfmms675w93ld7mvvqd0y8lz07?amount=100.42\")\n * @returns Parsed result with address and optional amount, or null if invalid\n */\nfunction parseBip21Uri(uri) {\n    try {\n        // Parse the URI using URL API\n        const url = new URL(uri);\n        // Validate that the protocol matches the expected BIP21 prefix\n        if (url.protocol !== config.bip21Prefix) {\n            return null;\n        }\n        // Check if the pathname already has the expected prefix (e.g., \"ectest:address\")\n        // If not, add the configured prefix\n        let addressPart = url.pathname;\n        if (!addressPart.startsWith(config.addressPrefix + ':')) {\n            addressPart = config.addressPrefix + ':' + addressPart;\n        }\n        // Validate the address (this will catch invalid formats like ecash://address with leading slash)\n        if (!isValidECashAddress(addressPart)) {\n            return null;\n        }\n        const result = {\n            address: addressPart,\n        };\n        // Parse the amount parameter if present. This is the only parameter supported by this wallet.\n        // Amount in BIP21 is specified in XEC, we convert to satoshis (1 XEC = 100 sats)\n        const amountParam = url.searchParams.get('amount');\n        if (amountParam) {\n            // Parse as floating point number (XEC)\n            const amountXec = parseFloat(amountParam);\n            // Validate that it's a valid number and positive\n            if (!isNaN(amountXec) && amountXec > 0) {\n                // Convert XEC to satoshis (1 XEC = 100 sats) and ensure it's an integer\n                result.sats = Math.round(amountXec * 100);\n            }\n        }\n        return result;\n    }\n    catch (error) {\n        return null;\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\nvar injectStylesIntoStyleTag = __webpack_require__(5072);\nvar injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js\nvar styleDomAPI = __webpack_require__(7825);\nvar styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js\nvar insertBySelector = __webpack_require__(7659);\nvar insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\nvar setAttributesWithoutAttributes = __webpack_require__(5056);\nvar setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js\nvar insertStyleElement = __webpack_require__(540);\nvar insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js\nvar styleTagTransform = __webpack_require__(1113);\nvar styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);\n// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./src/main.css\nvar main = __webpack_require__(7568);\n;// ./src/main.css\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (styleTagTransform_default());\noptions.setAttributes = (setAttributesWithoutAttributes_default());\noptions.insert = insertBySelector_default().bind(null, \"head\");\noptions.domAPI = (styleDomAPI_default());\noptions.insertStyleElement = (insertStyleElement_default());\n\nvar update = injectStylesIntoStyleTag_default()(main/* default */.A, options);\n\n\n\n\n       /* harmony default export */ const src_main = (main/* default */.A && main/* default */.A.locals ? main/* default */.A.locals : undefined);\n\n;// ./src/back-arrow.svg\nconst back_arrow_namespaceObject = __webpack_require__.p + \"e3cf713d589cae4b463f.svg\";\n;// ./src/ecash.svg\nconst ecash_namespaceObject = __webpack_require__.p + \"b3d68f75b37ec470cd9f.svg\";\n;// ./src/edit.svg\nconst edit_namespaceObject = __webpack_require__.p + \"ca4a5ac3225f6ca7e4ab.svg\";\n;// ./src/history.svg\nconst history_namespaceObject = __webpack_require__.p + \"cb1417ad58fd60de45de.svg\";\n;// ./src/camera.svg\nconst camera_namespaceObject = __webpack_require__.p + \"2351ef21fd2ca4d6114c.svg\";\n;// ./src/qrcode.svg\nconst src_qrcode_namespaceObject = __webpack_require__.p + \"ee38a1e6a47e10fff448.svg\";\n;// ./src/settings.svg\nconst settings_namespaceObject = __webpack_require__.p + \"0e5e27fe67d8fc159302.svg\";\n;// ./src/index.ts\n// ============================================================================\n// IMPORTS\n// ============================================================================\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Styles\n\n// Icons\n\n\n\n\n\n\n\n// Get DOM elements\nconst mainScreen = document.getElementById('main-screen');\nconst sendScreen = document.getElementById('send-screen');\nconst settingsScreen = document.getElementById('settings-screen');\nconst historyScreen = document.getElementById('history-screen');\n// Wallet state\nlet wallet = null;\nlet ecashWallet = null;\nlet wsEndpoint = null;\nlet chronik;\n// Balance state - separate available and transitional (not finalized yet) \n// balances (in satoshis)\nlet availableBalanceSats = 0; // Only finalized amounts in satoshis\nlet transitionalBalanceSats = 0; // Only non finalized amounts in satoshis\n// Pending transactions - transactions that are not yet finalized\nlet pendingAmounts = {};\n// Create global instance of TransactionHistoryManager\nlet transactionHistory = null;\n// Settings state\nlet requireHoldToSend = true;\n// ============================================================================\n// SETTINGS PERSISTENCE\n// ============================================================================\n// Only used for settings that don't require any security or encryption\nconst SETTINGS_STORAGE_KEY = 'ecashwallet.settings.1';\n// Load settings from localStorage\nfunction loadSettings() {\n    try {\n        const stored = localStorage.getItem(SETTINGS_STORAGE_KEY);\n        if (stored) {\n            const settings = JSON.parse(stored);\n            return settings;\n        }\n    }\n    catch (error) {\n        webViewError('Failed to load settings from localStorage:', error);\n    }\n    // Return defaults if no settings found\n    return {\n        requireHoldToSend: true,\n    };\n}\n// Save settings to localStorage\nfunction saveSettings(settings) {\n    try {\n        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));\n        webViewLog('Settings saved to localStorage');\n    }\n    catch (error) {\n        webViewError('Failed to save settings to localStorage:', error);\n    }\n}\n// ============================================================================\n// GENERAL UTILITY FUNCTIONS\n// ============================================================================\n// Show error modal with proper title\nfunction showErrorModal(title, message) {\n    const errorModalOverlay = document.getElementById('error-modal-overlay');\n    const errorModalTitle = document.querySelector('.error-modal-title');\n    const errorModalMessage = document.querySelector('.error-modal-message');\n    const errorModalClose = document.getElementById('error-modal-close');\n    errorModalTitle.textContent = title;\n    errorModalMessage.textContent = message;\n    errorModalClose.addEventListener('click', () => {\n        errorModalOverlay.style.display = 'none';\n    });\n    errorModalOverlay.style.display = 'flex';\n}\nfunction showLoadingScreen(message) {\n    const loadingEl = document.getElementById('loading');\n    if (loadingEl) {\n        loadingEl.style.display = 'flex';\n        const loadingText = loadingEl.querySelector('.loading-text');\n        if (loadingText) {\n            loadingText.textContent = message;\n        }\n    }\n}\nfunction hideLoadingScreen() {\n    const loadingEl = document.getElementById('loading');\n    if (loadingEl) {\n        loadingEl.style.display = 'none';\n    }\n}\n// ============================================================================\n// NAVIGATION FUNCTIONS\n// ============================================================================\nfunction showMainScreen() {\n    if (mainScreen) {\n        mainScreen.classList.remove('hidden');\n    }\n    if (sendScreen) {\n        sendScreen.classList.add('hidden');\n    }\n    if (settingsScreen) {\n        settingsScreen.classList.add('hidden');\n    }\n    if (historyScreen) {\n        historyScreen.classList.add('hidden');\n    }\n    // Reset the recipient address field to readonly for QR scans\n    const recipientAddressInput = document.getElementById('recipient-address');\n    if (recipientAddressInput) {\n        recipientAddressInput.setAttribute('readonly', 'readonly');\n    }\n}\nasync function showSendScreen() {\n    // Always refresh the available utxos before showing the send screen\n    await syncWallet();\n    if (mainScreen) {\n        mainScreen.classList.add('hidden');\n    }\n    if (sendScreen) {\n        sendScreen.classList.remove('hidden');\n    }\n    // Reset all form fields and validation states\n    const recipientInput = document.getElementById('recipient-address');\n    const sendAmountInput = document.getElementById('send-amount');\n    const amountSlider = document.getElementById('amount-slider');\n    const feeDisplay = document.getElementById('fee-display');\n    // Clear recipient address field and validation states\n    if (recipientInput) {\n        recipientInput.value = '';\n        recipientInput.classList.remove('valid', 'invalid');\n        recipientInput.removeAttribute('readonly'); // Allow editing for manual entry\n    }\n    // Reset amount field and validation states\n    if (sendAmountInput) {\n        sendAmountInput.value = '5.46'; // Prefill with minimum valid amount\n        sendAmountInput.classList.remove('valid', 'invalid');\n    }\n    // Reset slider\n    if (amountSlider) {\n        amountSlider.value = '5.46';\n    }\n    // Hide fee display\n    if (feeDisplay) {\n        feeDisplay.style.display = 'none';\n    }\n    // Re-setup send button behavior based on current setting\n    const confirmSendBtn = document.getElementById('confirm-send');\n    if (confirmSendBtn) {\n        // Remove all existing event listeners by cloning and replacing\n        const newButton = confirmSendBtn.cloneNode(true);\n        confirmSendBtn.parentNode?.replaceChild(newButton, confirmSendBtn);\n        // Setup with current behavior\n        setupHoldToSend(newButton);\n    }\n    // Update send screen limits based on current wallet state\n    updateSendScreenLimits();\n    // Validate amount field after reset\n    validateAmountField();\n    // Initialize slider and marks\n    updateSliderFromInput();\n    const maxSpendable = calculateMaxSpendableAmount(ecashWallet);\n    updateSliderMarks(5.46, maxSpendable);\n}\nasync function openSendScreenWithAddress(address, sats) {\n    // First show the send screen (this will reset everything)\n    await showSendScreen();\n    // Then set the address and make it readonly\n    const recipientAddressInput = document.getElementById('recipient-address');\n    if (recipientAddressInput) {\n        recipientAddressInput.value = address;\n        recipientAddressInput.setAttribute('readonly', 'readonly');\n        // Validate the address after setting it\n        validateAddressField();\n    }\n    // If an amount was provided (in satoshis), convert to XEC and set it\n    if (sats !== undefined && sats > 0) {\n        const sendAmountInput = document.getElementById('send-amount');\n        const amountSlider = document.getElementById('amount-slider');\n        // Convert satoshis to XEC for display\n        const amountXec = satsToXec(sats);\n        if (sendAmountInput) {\n            // Format to 2 decimal places\n            sendAmountInput.value = amountXec.toFixed(2);\n            // Validate the amount\n            validateAmountField();\n        }\n        if (amountSlider) {\n            amountSlider.value = amountXec.toString();\n        }\n    }\n    // Trigger fee calculation since address is now valid\n    updateFeeDisplay();\n}\nasync function openSendScreenForManualEntry() {\n    stopQRScanner(true); // Force close the modal\n    hideNoCameraFallback();\n    // First show the send screen (this will reset everything)\n    await showSendScreen();\n    // The form is already reset by showSendScreen(), no additional action needed\n    // The address field is already cleared and editable\n}\n// Open transaction in block explorer\nfunction openTransactionInExplorer(txid) {\n    const explorerUrl = config.explorerUrl + txid;\n    // On mobile (iOS/Android WebView), send message to native layer to open in system browser\n    // On web, use window.open\n    if (!sendMessageToBackend('OPEN_URL', explorerUrl)) {\n        window.open(explorerUrl, '_blank');\n    }\n}\n// History screen functions\nfunction showHistoryScreen() {\n    if (mainScreen) {\n        mainScreen.classList.add('hidden');\n    }\n    if (sendScreen) {\n        sendScreen.classList.add('hidden');\n    }\n    if (settingsScreen) {\n        settingsScreen.classList.add('hidden');\n    }\n    if (historyScreen) {\n        historyScreen.classList.remove('hidden');\n    }\n    // Load transaction history when showing the screen (reset to first page)\n    const address = getAddress(ecashWallet);\n    if (address) {\n        transactionHistory.loadTransactionHistory(chronik, address, true);\n    }\n    // Setup scroll detection for infinite loading and click handlers for transaction IDs\n    setTimeout(() => {\n        const transactionList = document.getElementById('transaction-list');\n        if (transactionList) {\n            transactionList.addEventListener('scroll', () => transactionHistory.handleScroll());\n            // Event delegation for transaction ID clicks\n            transactionList.addEventListener('click', (e) => {\n                const target = e.target;\n                if (target.classList.contains('transaction-txid')) {\n                    const txid = target.getAttribute('data-txid');\n                    if (txid) {\n                        openTransactionInExplorer(txid);\n                    }\n                }\n            });\n        }\n    }, 100); // Small delay to ensure DOM is ready\n}\n// Settings screen functions\nfunction showSettingsScreen() {\n    if (mainScreen) {\n        mainScreen.classList.add('hidden');\n    }\n    if (sendScreen) {\n        sendScreen.classList.add('hidden');\n    }\n    if (settingsScreen) {\n        settingsScreen.classList.remove('hidden');\n    }\n    if (historyScreen) {\n        historyScreen.classList.add('hidden');\n    }\n    // Always update the mnemonic display when showing settings\n    updateMnemonicDisplay();\n}\n// These are required for the webview html button bindings\nwindow.openHistory = showHistoryScreen;\nwindow.openSettings = showSettingsScreen;\n// ============================================================================\n// SEND SCREEN FUNCTIONS\n// ============================================================================\n// Validate address field and update UI\nfunction validateAddressField() {\n    const recipientInput = document.getElementById('recipient-address');\n    if (!recipientInput) {\n        return;\n    }\n    const address = recipientInput.value.trim();\n    // Clear previous validation states\n    recipientInput.classList.remove('invalid');\n    recipientInput.classList.remove('valid');\n    if (address === '') {\n        // Empty field - no validation state\n        return;\n    }\n    if (isValidECashAddress(address)) {\n        recipientInput.classList.add('valid');\n    }\n    else {\n        recipientInput.classList.add('invalid');\n    }\n}\n// Update send screen with maximum spendable amount\nfunction updateSendScreenLimits() {\n    const maxSpendable = calculateMaxSpendableAmount(ecashWallet);\n    // Update amount input max attribute\n    const amountInput = document.getElementById('send-amount');\n    if (amountInput) {\n        amountInput.max = maxSpendable.toString();\n    }\n    // Update slider max value and label\n    const amountSlider = document.getElementById('amount-slider');\n    if (amountSlider) {\n        amountSlider.max = maxSpendable.toString();\n    }\n    // Update slider max label\n    const sliderMaxLabel = document.getElementById('slider-max-label');\n    if (sliderMaxLabel) {\n        sliderMaxLabel.textContent = `${maxSpendable.toFixed(2)} ${config.ticker}`;\n    }\n}\n// Update fee display\nfunction updateFeeDisplay() {\n    const recipientInput = document.getElementById('recipient-address');\n    const amountInput = document.getElementById('send-amount');\n    const feeDisplay = document.getElementById('fee-display');\n    if (!recipientInput || !amountInput || !feeDisplay) {\n        return;\n    }\n    const recipientAddress = recipientInput.value.trim();\n    let amount = parseFloat(amountInput.value);\n    // Hide if address or amount is invalid\n    if (!recipientAddress || !isValidECashAddress(recipientAddress) || isNaN(amount) || amount <= 0) {\n        feeDisplay.style.display = 'none';\n        return;\n    }\n    let errorMessage = null;\n    // Check for dust threshold\n    const dustXEC = satsToXec(Number(indexBrowser.DEFAULT_DUST_SATS));\n    if (amount < dustXEC) {\n        errorMessage = `Amount is too small`;\n    }\n    // Try to estimate fee for the requested amount\n    let feeEstimate = estimateTransactionFee(ecashWallet, recipientAddress, amount);\n    // Insufficient balance - calculate for max spendable amount\n    if (!feeEstimate) {\n        amount = calculateMaxSpendableAmount(ecashWallet);\n        feeEstimate = estimateTransactionFee(ecashWallet, recipientAddress, amount);\n        errorMessage = `Insufficient balance`;\n    }\n    // Build the html fee block heading depending on the error condition\n    let feeBlockHeading = 'Transaction Details';\n    let feeBlockHeadingClasses = 'title';\n    if (errorMessage) {\n        feeDisplay.classList.add('error');\n        feeBlockHeading = errorMessage;\n        feeBlockHeadingClasses += ' error';\n    }\n    else {\n        feeDisplay.classList.remove('error');\n    }\n    // Build the HTML with conditional styling\n    let html = `<div class=\"fee-info\">\n            <div class=\"fee-item ${feeBlockHeadingClasses}\">\n                ${feeBlockHeading}\n            </div>\n            <div class=\"fee-item\">\n                <span class=\"fee-label\">Amount:</span>\n                <span class=\"fee-value\">${amount.toFixed(2)} ${config.ticker}</span>\n            </div>\n            <div class=\"fee-item\">\n                <span class=\"fee-label\">Network Fee:</span>\n                <span class=\"fee-value\">${feeEstimate?.feeXEC.toFixed(2)} ${config.ticker}</span>\n            </div>\n            <div class=\"fee-item total\">\n                <span class=\"fee-label\">Total:</span>\n                <span class=\"fee-value\">${feeEstimate?.totalXEC.toFixed(2)} ${config.ticker}</span>\n            </div>\n        </div>\n    `;\n    feeDisplay.innerHTML = html;\n    feeDisplay.style.display = 'block';\n}\n// Amount input handling to prevent more than 2 decimals\nfunction handleAmountInput(event) {\n    const input = event.target;\n    const value = input.value;\n    // Allow only numbers and one decimal point\n    const cleanValue = value.replace(/[^0-9.]/g, '');\n    // Prevent multiple decimal points\n    const parts = cleanValue.split('.');\n    if (parts.length > 2) {\n        input.value = parts[0] + '.' + parts.slice(1).join('');\n        return;\n    }\n    // If there's a decimal point, limit to 2 decimal places\n    if (parts.length === 2 && parts[1].length > 2) {\n        input.value = parts[0] + '.' + parts[1].substring(0, 2);\n        return;\n    }\n    // Update the input value if it was cleaned\n    if (cleanValue !== value) {\n        input.value = cleanValue;\n    }\n    // Update slider to match input value\n    updateSliderFromInput();\n    // Run validation after input is processed\n    validateAmountField();\n}\n// Handle slider input\nfunction handleSliderInput(event) {\n    const slider = event.target;\n    const value = parseFloat(slider.value);\n    // Update the amount input field immediately for visual feedback\n    const sendAmountInput = document.getElementById('send-amount');\n    if (sendAmountInput) {\n        sendAmountInput.value = value.toFixed(2);\n    }\n    // Validate immediately without throttling\n    validateAmountField();\n}\n// Update slider from input field\nfunction updateSliderFromInput() {\n    const sendAmountInput = document.getElementById('send-amount');\n    const amountSlider = document.getElementById('amount-slider');\n    if (!sendAmountInput || !amountSlider) {\n        return;\n    }\n    const value = parseFloat(sendAmountInput.value);\n    const minAmount = 5.46;\n    const maxAmount = calculateMaxSpendableAmount(ecashWallet);\n    // Clamp value to slider range\n    const clampedValue = Math.max(minAmount, Math.min(value, maxAmount));\n    // Update slider value\n    amountSlider.value = clampedValue.toString();\n    // Update slider max if balance changed\n    if (maxAmount !== parseFloat(amountSlider.max)) {\n        amountSlider.max = maxAmount.toString();\n        const sliderMaxLabel = document.getElementById('slider-max-label');\n        if (sliderMaxLabel) {\n            sliderMaxLabel.textContent = `${maxAmount.toFixed(2)} ${config.ticker}`;\n        }\n        // Update slider marks for new range\n        updateSliderMarks(minAmount, maxAmount);\n    }\n}\n// Update slider marks based on current range\nfunction updateSliderMarks(minAmount, maxAmount) {\n    const marks = document.querySelectorAll('.mark');\n    const range = maxAmount - minAmount;\n    marks.forEach((mark, index) => {\n        const percentage = ((index + 1) * 10); // 10%, 20%, 30%, etc. (skipping 0% and 100%)\n        const actualValue = minAmount + (range * percentage / 100);\n        const displayValue = actualValue.toFixed(2);\n        // Update the mark's data attribute for reference\n        mark.setAttribute('data-value', displayValue);\n        // Add a subtle tooltip effect on hover\n        mark.title = `${displayValue} ${config.ticker}`;\n    });\n}\n// Amount validation functions\nfunction validateAmountField() {\n    const sendAmountInput = document.getElementById('send-amount');\n    const confirmSendBtn = document.getElementById('confirm-send');\n    if (!sendAmountInput || !confirmSendBtn) {\n        return;\n    }\n    const amount = parseFloat(sendAmountInput.value);\n    const minAmount = 5.46;\n    const maxAmount = calculateMaxSpendableAmount(ecashWallet);\n    // Clear previous validation states\n    sendAmountInput.classList.remove('invalid');\n    sendAmountInput.classList.remove('valid');\n    // Check if amount is valid\n    if (isNaN(amount) || amount <= 0) {\n        sendAmountInput.classList.add('invalid');\n        confirmSendBtn.disabled = true;\n        const btnSpan = confirmSendBtn.querySelector('span');\n        if (btnSpan) {\n            btnSpan.textContent = 'Enter Amount';\n        }\n        return;\n    }\n    if (amount < minAmount) {\n        sendAmountInput.classList.add('invalid');\n        confirmSendBtn.disabled = true;\n        const btnSpan = confirmSendBtn.querySelector('span');\n        if (btnSpan) {\n            btnSpan.textContent = `Min: ${minAmount} ${config.ticker}`;\n        }\n        return;\n    }\n    if (amount > maxAmount) {\n        sendAmountInput.classList.add('invalid');\n        confirmSendBtn.disabled = true;\n        const btnSpan = confirmSendBtn.querySelector('span');\n        if (btnSpan) {\n            btnSpan.textContent = `Max: ${maxAmount.toFixed(2)} ${config.ticker}`;\n        }\n        return;\n    }\n    // Amount is valid\n    sendAmountInput.classList.add('valid');\n    confirmSendBtn.disabled = false;\n    const btnSpan = confirmSendBtn.querySelector('span');\n    if (btnSpan) {\n        btnSpan.textContent = requireHoldToSend ? 'Hold to send' : 'Send';\n    }\n}\n// Send button setup - either hold-to-send or simple click based on settings\nfunction setupHoldToSend(button) {\n    // If hold-to-send is disabled, use simple click behavior\n    if (!requireHoldToSend) {\n        button.addEventListener('click', async () => {\n            await validateAndSend();\n        });\n        return;\n    }\n    // Hold-to-send behavior with progressive haptic feedback\n    let holdTimer = null;\n    let hapticInterval = null;\n    let startTime = 0;\n    const HOLD_DURATION = 1000; // 1 second\n    const HAPTIC_INTERVAL = 50; // Haptic every 50ms for smoother continuous feel\n    // Progressive haptic feedback based on elapsed time\n    const triggerProgressiveHaptic = () => {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / HOLD_DURATION, 1);\n        // Use selection haptic for smoother rapid feedback, transitioning to impacts\n        let hapticType = 'selection';\n        if (progress > 0.8) {\n            hapticType = 'impactHeavy';\n        }\n        else if (progress > 0.5) {\n            hapticType = 'impactMedium';\n        }\n        else if (progress > 0.2) {\n            hapticType = 'impactLight';\n        }\n        sendMessageToBackend('HAPTIC_FEEDBACK', hapticType);\n    };\n    const startHold = (e) => {\n        e.preventDefault();\n        // Check if button is disabled\n        if (button.disabled) {\n            return;\n        }\n        // Validate before starting the hold animation\n        const sendAmountInput = document.getElementById('send-amount');\n        const recipientAddressInput = document.getElementById('recipient-address');\n        if (!sendAmountInput || !recipientAddressInput) {\n            return;\n        }\n        const amount = parseFloat(sendAmountInput.value);\n        const address = recipientAddressInput.value.trim();\n        // Validate address\n        if (!address || !isValidECashAddress(address)) {\n            // Play warning haptic immediately\n            sendMessageToBackend('HAPTIC_FEEDBACK', 'notificationWarning');\n            recipientAddressInput.focus();\n            return;\n        }\n        // Validate amount\n        if (isNaN(amount) || amount <= 0) {\n            // Play warning haptic immediately\n            sendMessageToBackend('HAPTIC_FEEDBACK', 'notificationWarning');\n            return;\n        }\n        startTime = Date.now();\n        button.classList.add('holding');\n        // Trigger initial haptic\n        triggerProgressiveHaptic();\n        // Set up continuous haptic feedback during hold\n        hapticInterval = window.setInterval(() => {\n            triggerProgressiveHaptic();\n        }, HAPTIC_INTERVAL);\n        // Set timer for successful hold\n        holdTimer = window.setTimeout(async () => {\n            // Success haptic\n            sendMessageToBackend('HAPTIC_FEEDBACK', 'notificationSuccess');\n            await validateAndSend();\n            cleanup();\n        }, HOLD_DURATION);\n    };\n    const cancelHold = () => {\n        if (holdTimer === null) {\n            return;\n        }\n        cleanup();\n        // Give feedback that hold was cancelled\n        const holdDuration = Date.now() - startTime;\n        if (holdDuration > 300) {\n            // User held for a bit but released early - give warning haptic\n            sendMessageToBackend('HAPTIC_FEEDBACK', 'notificationWarning');\n        }\n    };\n    const cleanup = () => {\n        if (holdTimer !== null) {\n            clearTimeout(holdTimer);\n            holdTimer = null;\n        }\n        // Clear haptic interval\n        if (hapticInterval !== null) {\n            clearInterval(hapticInterval);\n            hapticInterval = null;\n        }\n        button.classList.remove('holding');\n    };\n    // Mouse events\n    button.addEventListener('mousedown', startHold);\n    button.addEventListener('mouseup', cancelHold);\n    button.addEventListener('mouseleave', cancelHold);\n    // Touch events for mobile\n    button.addEventListener('touchstart', startHold, { passive: false });\n    button.addEventListener('touchend', cancelHold);\n    button.addEventListener('touchcancel', cancelHold);\n}\nasync function validateAndSend() {\n    const sendAmountInput = document.getElementById('send-amount');\n    const recipientAddressInput = document.getElementById('recipient-address');\n    if (!sendAmountInput || !recipientAddressInput) {\n        return;\n    }\n    const amount = parseFloat(sendAmountInput.value);\n    const address = recipientAddressInput.value.trim();\n    // Validate address\n    if (!address || !isValidECashAddress(address)) {\n        recipientAddressInput.focus();\n        return;\n    }\n    // Validate amount\n    validateAmountField();\n    const confirmSendBtn = document.getElementById('confirm-send');\n    if (confirmSendBtn.disabled) {\n        return; // Amount validation failed\n    }\n    // All validations passed, proceed with sending\n    try {\n        // Convert XEC to satoshis (1 XEC = 100 satoshis)\n        const sats = Math.round(amount * 100);\n        await sendTransaction(ecashWallet, address, sats);\n        webViewLog(`Sent ${amount} ${config.ticker} to ${address}`);\n    }\n    catch (error) {\n        webViewError('Failed to send transaction:', error);\n    }\n    finally {\n        // Return to main screen\n        showMainScreen();\n    }\n}\n// ============================================================================\n// SETTINGS SCREEN FUNCTIONS\n// ============================================================================\n// Mnemonic management functions\nfunction updateMnemonicDisplay() {\n    const mnemonicText = document.getElementById('mnemonic-text');\n    const walletMnemonic = getMnemonic(wallet);\n    if (mnemonicText && walletMnemonic) {\n        // mnemonicText.value = wallet.mnemonic;\n        mnemonicText.value = walletMnemonic;\n    }\n}\nfunction showMnemonicEditModal() {\n    const modal = document.getElementById('mnemonic-edit-modal');\n    if (modal) {\n        const editText = document.getElementById('mnemonic-edit-text');\n        const validation = document.getElementById('mnemonic-validation');\n        if (editText) {\n            const walletMnemonic = getMnemonic(wallet);\n            editText.value = walletMnemonic ? walletMnemonic : '';\n        }\n        if (validation) {\n            validation.style.display = 'none';\n        }\n        modal.style.display = 'flex';\n        modal.classList.remove('hidden');\n    }\n}\nfunction hideMnemonicEditModal() {\n    const modal = document.getElementById('mnemonic-edit-modal');\n    if (modal) {\n        modal.style.display = 'none';\n        modal.classList.add('hidden');\n    }\n}\nfunction showValidationMessage(message, isError = true) {\n    const validation = document.getElementById('mnemonic-validation');\n    if (validation) {\n        validation.textContent = message;\n        validation.className = `validation-message ${isError ? 'error' : 'success'}`;\n        validation.style.display = 'block';\n    }\n}\nfunction hideValidationMessage() {\n    const validation = document.getElementById('mnemonic-validation');\n    if (validation) {\n        validation.style.display = 'none';\n    }\n}\nasync function saveMnemonic(newMnemonic) {\n    try {\n        // Validate the mnemonic\n        if (!validateMnemonic(newMnemonic)) {\n            showValidationMessage('Invalid mnemonic. Please enter a valid 12-word recovery phrase.');\n            return false;\n        }\n        // Store the new mnemonic\n        await storeMnemonic(newMnemonic.trim());\n        // Update the wallet with the new mnemonic\n        if (wallet) {\n            wallet.mnemonic = newMnemonic.trim();\n        }\n        // Reload the wallet with the new mnemonic\n        webViewLog('Reloading wallet with new mnemonic...');\n        await loadWalletFromMnemonic(wallet.mnemonic);\n        // Ensure main screen is visible and wallet is displayed\n        showMainScreen();\n        // Update the display\n        updateMnemonicDisplay();\n        // Show success message\n        showValidationMessage('Mnemonic updated successfully! Wallet reloaded.', false);\n        // Disable the save button\n        const saveMnemonicEditBtn = document.getElementById('save-mnemonic-edit');\n        if (saveMnemonicEditBtn) {\n            saveMnemonicEditBtn.disabled = true;\n        }\n        // Hide modal after a short delay\n        setTimeout(() => {\n            hideMnemonicEditModal();\n            hideValidationMessage();\n            // Re-enable the save button\n            if (saveMnemonicEditBtn) {\n                saveMnemonicEditBtn.disabled = false;\n            }\n        }, 2000);\n        return true;\n    }\n    catch (error) {\n        webViewError('Error saving mnemonic:', error);\n        showValidationMessage('Failed to save mnemonic. Please try again.');\n        return false;\n    }\n}\n// ============================================================================\n// WALLET MANAGEMENT FUNCTIONS\n// ============================================================================\n// Update NFC address for tag emulation (BIP21 URI)\n// amountSats is optional - if provided, it will be included in the BIP21 URI\nfunction updateNfcAddress(amountSats) {\n    if (!ecashWallet) {\n        return;\n    }\n    const address = getAddress(ecashWallet);\n    if (!address) {\n        return;\n    }\n    // Create BIP21 URI using the bip21 module\n    const bip21Uri = createBip21Uri(address, amountSats);\n    // Send the complete BIP21 URI to native app for NFC HCE\n    sendMessageToBackend('SET_NFC_URI', bip21Uri);\n}\n// Load existing wallet from stored mnemonic\nasync function loadWalletFromMnemonic(mnemonic) {\n    // Create wallet using ecash-wallet library\n    ecashWallet = dist.Wallet.fromMnemonic(mnemonic, chronik);\n    const address = getAddress(ecashWallet);\n    if (!address) {\n        // This should never happen\n        webViewError('Cannot get address from wallet');\n        return;\n    }\n    await syncWallet();\n    // Create wallet data object - balance in satoshis\n    wallet = {\n        mnemonic: mnemonic,\n    };\n    // Update displays\n    updateWalletDisplay();\n    updateTransitionalBalance();\n    generateQRCode(address);\n    subscribeToAddress(address);\n    transactionHistory = new TransactionHistoryManager(ecashWallet, chronik);\n    // Update NFC address for tag emulation\n    updateNfcAddress();\n    // Send address and BIP21 prefix to watch\n    sendMessageToBackend('SEND_ADDRESS_TO_WATCH', {\n        address: address,\n        bip21Prefix: config.bip21Prefix\n    });\n    // Notify React Native that wallet is ready (for pending NFC payments)\n    sendMessageToBackend('WALLET_READY', true);\n}\n// Load the wallet. Use the mnemonic from storage if it exists, otherwise create\n// a new wallet.\nasync function loadWallet(forceReload = false) {\n    // Prevent duplicate wallet creation unless force reload is requested\n    if (ecashWallet && !forceReload) {\n        return;\n    }\n    // If force reloading, reset the existing wallet\n    if (forceReload && ecashWallet) {\n        ecashWallet = null;\n    }\n    webViewLog('Loading the wallet...');\n    let mnemonic = null;\n    try {\n        // Load existing mnemonic from storage\n        mnemonic = await loadMnemonic();\n    }\n    catch (error) {\n        // We failed to load the mnemonic, most likely because the user did not\n        // complete the authentication. Close the app.\n        webViewLog('Failed to load existing wallet:', error);\n        sendMessageToBackend('CLOSE_APP', undefined);\n        return;\n    }\n    // Loading the mnemonic succeeded, but the mnemonic is null. This means that\n    // the user does not have a wallet yet. Create a new wallet.\n    if (!mnemonic) {\n        try {\n            webViewLog('Starting wallet creation (first run)...');\n            // Generate and store a new mnemonic for first run\n            mnemonic = generateMnemonic();\n            storeMnemonic(mnemonic);\n        }\n        catch (error) {\n            webViewError('Failed to create mnemonic:', error);\n            return;\n        }\n    }\n    await loadWalletFromMnemonic(mnemonic);\n}\n// Update wallet display (address and balance)\nfunction updateWalletDisplay() {\n    if (!wallet) {\n        webViewError('No wallet data, cannnot update the display');\n        return;\n    }\n    const address = getAddress(ecashWallet);\n    if (!address) {\n        webViewError('No address, cannot update the display');\n        return;\n    }\n    const addressEl = document.getElementById('address');\n    if (addressEl) {\n        addressEl.textContent = address;\n    }\n    else {\n        webViewError('addressEl not found, cannot update address display');\n    }\n    // Update balance display, no animation\n    updateAvailableBalanceDisplay(false);\n}\n// ============================================================================\n// BALANCE AND TRANSACTION MANAGEMENT FUNCTIONS\n// ============================================================================\n// Add pending transaction amount\nasync function addPendingAmount(txid, state) {\n    if (pendingAmounts[txid]) {\n        webViewLog(`Transaction ${txid} already exists in pending amounts, ignoring duplicate`);\n        return false;\n    }\n    const txAmountSats = await calculateTransactionAmountSats(ecashWallet, chronik, txid);\n    if (txAmountSats == 0) {\n        webViewLog(`Transaction ${txid} has no amount, ignoring`);\n        return false;\n    }\n    pendingAmounts[txid] = {\n        amountSats: txAmountSats,\n        state,\n    };\n    webViewLog(`Added pending transaction ${txid}: ${satsToXec(txAmountSats)} ${config.ticker} (${txAmountSats} sats, state: ${state})`);\n    return pendingAmounts[txid];\n}\nfunction finalizeTransaction(amountSats) {\n    availableBalanceSats += amountSats;\n    updateTransitionalBalance();\n    updateAvailableBalanceDisplay(true); // Animate when finalizing transactions\n    triggerShakeAnimation();\n    // Trigger haptic feedback for transaction finalization\n    sendMessageToBackend('TX_FINALIZED', undefined);\n}\nasync function finalizePreConsensus(txid) {\n    let tx;\n    if (pendingAmounts[txid]) {\n        // We already have the transaction in our pending amounts, so we can\n        // just update the state\n        tx = pendingAmounts[txid];\n        tx.state = 'finalized';\n    }\n    else {\n        const pending_tx = await addPendingAmount(txid, 'finalized');\n        if (!pending_tx) {\n            return;\n        }\n        tx = pending_tx;\n    }\n    finalizeTransaction(tx.amountSats);\n    webViewLog(`Pre-consensus finalized transaction ${txid}: ${satsToXec(tx.amountSats)} ${config.ticker} moved to available balance, state set to finalized`);\n}\nasync function finalizePostConsensus(txid) {\n    if (!pendingAmounts[txid]) {\n        // We're lost, just resync\n        webViewLog(`Post-consensus finalized transaction ${txid} but it's not pending, resyncing`);\n        await syncWallet();\n        return;\n    }\n    const tx = pendingAmounts[txid];\n    if (tx.state === 'pending_finalization') {\n        finalizeTransaction(tx.amountSats);\n        webViewLog(`Post-consensus finalized transaction ${txid} which is pending finalization, moving to available balance`);\n    }\n    // We won't get any message for this transaction anymore\n    delete pendingAmounts[txid];\n}\n// Update transitional balance display\nfunction updateTransitionalBalance() {\n    // Calculate total pending amounts\n    transitionalBalanceSats = 0;\n    for (const tx of Object.values(pendingAmounts).filter(tx => tx.state === 'pending_finalization')) {\n        // Amount sign determines type: positive = receive, negative = send, 0 = receive\n        transitionalBalanceSats += tx.amountSats;\n    }\n    webViewLog('Updated transitional balance:', satsToXec(transitionalBalanceSats), config.ticker, '(', transitionalBalanceSats, 'sats)');\n    // Update transitional balance display\n    const transitionalBalanceEl = document.getElementById('transitional-balance');\n    if (transitionalBalanceEl) {\n        if (transitionalBalanceSats !== 0) {\n            const sign = transitionalBalanceSats > 0 ? '+' : '';\n            const type = transitionalBalanceSats > 0 ? 'receive' : 'spend';\n            const displayText = `${sign}${satsToXec(transitionalBalanceSats).toFixed(2)} ${config.ticker}`;\n            transitionalBalanceEl.textContent = displayText;\n            transitionalBalanceEl.className = `transitional-balance ${type}`;\n            transitionalBalanceEl.classList.remove('hidden');\n        }\n        else {\n            transitionalBalanceEl.classList.add('hidden');\n        }\n    }\n    else {\n        webViewError('transitionalBalanceEl not found, cannot update transitional balance display');\n    }\n}\n// Update available balance display with optional animation\nfunction updateAvailableBalanceDisplay(animate = true) {\n    const balanceEl = document.getElementById('balance');\n    if (balanceEl) {\n        const balanceXec = satsToXec(availableBalanceSats);\n        if (animate) {\n            animateBalanceChange(balanceEl, balanceXec);\n        }\n        else {\n            balanceEl.textContent = `${balanceXec.toFixed(2)} ${config.ticker}`;\n        }\n        webViewLog('Available balance updated:', balanceXec, config.ticker, '(', availableBalanceSats, 'sats)');\n    }\n    else {\n        webViewError('balanceEl not found, cannot update available balance display');\n    }\n}\n// Animate balance change with counting effect\nfunction animateBalanceChange(balanceEl, targetBalance) {\n    const startBalance = parseFloat(balanceEl.textContent?.replace(` ${config.ticker}`, '') || '0');\n    const difference = targetBalance - startBalance;\n    const duration = 1000; // 1 second animation\n    const startTime = Date.now();\n    // Add highlight effect for balance changes\n    if (Math.abs(difference) > 0.01) { // Only highlight if there's a meaningful change\n        balanceEl.style.transition = 'all 0.3s ease';\n        balanceEl.style.transform = 'scale(1.05)';\n        balanceEl.style.color = difference > 0 ? '#4ade80' : '#f87171'; // Green for increase, red for decrease\n        setTimeout(() => {\n            balanceEl.style.transform = 'scale(1)';\n            balanceEl.style.color = '';\n        }, 300);\n    }\n    function updateBalance() {\n        const elapsed = Date.now() - startTime;\n        const progress = Math.min(elapsed / duration, 1);\n        // Use easing function for smooth animation\n        const easeOutCubic = 1 - Math.pow(1 - progress, 3);\n        const currentBalance = startBalance + (difference * easeOutCubic);\n        balanceEl.textContent = `${currentBalance.toFixed(2)} ${config.ticker}`;\n        if (progress < 1) {\n            requestAnimationFrame(updateBalance);\n        }\n        else {\n            // Reset color after animation completes\n            setTimeout(() => {\n                balanceEl.style.color = '';\n            }, 200);\n        }\n    }\n    requestAnimationFrame(updateBalance);\n}\n// Trigger shake animation\nfunction triggerShakeAnimation() {\n    const transitionalBalanceEl = document.getElementById('transitional-balance');\n    if (transitionalBalanceEl) {\n        transitionalBalanceEl.classList.add('shake');\n        setTimeout(() => {\n            transitionalBalanceEl.classList.remove('shake');\n        }, 500);\n    }\n    else {\n        webViewError('transitionalBalanceEl not found, cannot trigger shake animation');\n    }\n}\n// Helper function to check if main screen is visible\nfunction isMainScreenVisible() {\n    const sendScreen = document.getElementById('send-screen');\n    const settingsScreen = document.getElementById('settings-screen');\n    // Main screen is visible if both send and settings screens are hidden\n    return (!sendScreen || sendScreen.classList.contains('hidden')) &&\n        (!settingsScreen || settingsScreen.classList.contains('hidden'));\n}\n// ============================================================================\n// PULL-TO-REFRESH FUNCTIONS\n// ============================================================================\n// Pull-to-refresh functions using PullToRefresh.js library\nfunction initPullToRefresh() {\n    index_umd_default().init({\n        mainElement: '.container',\n        onRefresh: async () => {\n            try {\n                await syncWallet();\n            }\n            catch (error) {\n                webViewError('Failed pull-to-refresh sync:', error);\n                throw error;\n            }\n        },\n        shouldPullToRefresh: () => {\n            // Only allow pull-to-refresh on the main screen\n            return isMainScreenVisible();\n        }\n    });\n}\n// ============================================================================\n// QR SCANNER FUNCTIONS\n// ============================================================================\nfunction handleScanButtonClick() {\n    stopQRScanner();\n    startQRScanner(handleQRScanResult);\n}\nfunction handleCloseCamera() {\n    stopQRScanner(true); // Force close the modal\n    hideNoCameraFallback();\n}\nasync function handleQRScanResult(result) {\n    // First, try to parse as BIP21 URI\n    const bip21Result = parseBip21Uri(result);\n    if (bip21Result) {\n        webViewLog('BIP21 URI scanned:', result);\n        stopQRScanner();\n        await openSendScreenWithAddress(bip21Result.address, bip21Result.sats);\n        return;\n    }\n    // Fallback: validate if the scanned data is a plain valid eCash address\n    if (isValidECashAddress(result)) {\n        webViewLog('eCash address scanned:', result);\n        stopQRScanner();\n        await openSendScreenWithAddress(result);\n    }\n}\n// ============================================================================\n// SYNC AND SUBSCRIPTION FUNCTIONS\n// ============================================================================\n// Subscribe to address notifications via Chronik WebSocket.\n// This is where the main wallet update logic happens.\nasync function subscribeToAddress(address) {\n    try {\n        // Close existing connection if any\n        unsubscribeFromAddress();\n        // Create WebSocket connection using chronik-client\n        wsEndpoint = chronik.ws({\n            onConnect: () => {\n                webViewLog('Chronik WebSocket connected');\n            },\n            onReconnect: (e) => {\n                webViewLog('Chronik WebSocket reconnecting:', e);\n            },\n            onMessage: async (msg) => {\n                if (!('msgType' in msg) || !('txid' in msg)) {\n                    webViewError('No msgType, skipping websocket message:', msg);\n                    return;\n                }\n                if (!('txid' in msg)) {\n                    webViewError('No txid, skipping websocket message:', msg);\n                    return;\n                }\n                const txid = msg.txid;\n                try {\n                    switch (msg.msgType) {\n                        case 'TX_ADDED_TO_MEMPOOL':\n                            // The transaction is not finalized yet, show it\n                            // in the transitional balance\n                            const tx = await addPendingAmount(txid, 'pending_finalization');\n                            if (!tx) {\n                                webViewError(`Failed to add pending mempool transaction: ${txid}`);\n                                break;\n                            }\n                            updateTransitionalBalance();\n                            triggerShakeAnimation();\n                            webViewLog(`Added pending transaction: ${satsToXec(tx.amountSats)} ${config.ticker} for tx ${txid}`);\n                            break;\n                        case 'TX_CONFIRMED':\n                            if (pendingAmounts[txid]) {\n                                // This is the most common scenario\n                                webViewLog(`Confirmed transaction ${txid} is already pending with state ${pendingAmounts[txid].state}, skipping`);\n                            }\n                            else {\n                                // If the pending transaction doesn't exist, we\n                                // need to figure out if it's been finalized by\n                                // pre-consensus or not.\n                                // If it's final we have no way to know whether\n                                // it's already been accounted for or not (e.g.\n                                // we just opened the wallet).\n                                // In this case we do nothing and wait for the\n                                // block to eventually finalize to resync the\n                                // wallet.\n                                const chronik_tx = await chronik.tx(txid);\n                                if (!chronik_tx.isFinal) {\n                                    const tx = await addPendingAmount(txid, 'pending_finalization');\n                                    if (!tx) {\n                                        webViewError(`Failed to add pending confirmed transaction: ${txid}`);\n                                        break;\n                                    }\n                                    updateTransitionalBalance();\n                                    triggerShakeAnimation();\n                                    webViewLog(`Added pending confirmed transaction: ${satsToXec(tx.amountSats)} ${config.ticker} for tx ${txid}`);\n                                }\n                            }\n                            break;\n                        case 'TX_FINALIZED':\n                            switch (msg.finalizationReasonType) {\n                                case 'TX_FINALIZATION_REASON_PRE_CONSENSUS':\n                                    finalizePreConsensus(txid);\n                                    break;\n                                case 'TX_FINALIZATION_REASON_POST_CONSENSUS':\n                                    finalizePostConsensus(txid);\n                                    break;\n                                default:\n                                    webViewError(`Unknown finalization reason for ${txid}: `, msg.finalizationReasonType);\n                                    break;\n                            }\n                            break;\n                        case 'TX_REMOVED_FROM_MEMPOOL':\n                        case 'TX_INVALIDATED':\n                            delete pendingAmounts[txid];\n                            updateTransitionalBalance();\n                            triggerShakeAnimation();\n                            webViewLog(`Removed pending transaction: ${txid}, reason: ${msg.msgType}`);\n                            break;\n                        default:\n                            webViewError(`Unknown message type: ${msg.msgType}`);\n                            break;\n                    }\n                }\n                catch (error) {\n                    webViewError('Failed processing WebSocket message:', error);\n                }\n            }\n        });\n        // Wait for WebSocket to be connected\n        await wsEndpoint.waitForOpen();\n        wsEndpoint.subscribeToAddress(address);\n        webViewLog('Subscribed to address notifications for:', address);\n    }\n    catch (error) {\n        webViewError('Failed to subscribe to address notifications:', error);\n    }\n}\n// Unsubscribe from address notifications\nfunction unsubscribeFromAddress() {\n    // Actually unsubscribe from all\n    if (wsEndpoint) {\n        wsEndpoint.close();\n        wsEndpoint = null;\n        webViewLog('Unsubscribed from address notifications');\n    }\n}\n// Sync wallet (with finalization for manual sync)\nasync function syncWallet() {\n    webViewLog('Syncing wallet...');\n    try {\n        // Add timeout to prevent hanging\n        const syncPromise = ecashWallet.sync();\n        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Network timeout - please check your internet connection')), 30000));\n        await Promise.race([syncPromise, timeoutPromise]);\n        const spendableUtxos = ecashWallet.spendableSatsOnlyUtxos();\n        const finalUtxos = spendableUtxos.filter(utxo => utxo.isFinal);\n        availableBalanceSats = Number(finalUtxos.reduce((sum, utxo) => sum + utxo.sats, 0n));\n        // Clear all pending transactions. They will be re-added as needed if we\n        // get a message for them.\n        pendingAmounts = {};\n        transitionalBalanceSats = 0;\n        // Update the display\n        updateAvailableBalanceDisplay(false);\n    }\n    catch (error) {\n        webViewError('Failed to sync wallet:', error);\n        // Show user-friendly error message\n        if (error.message.includes('timeout') || error.message.includes('Network')) {\n            webViewError('No internet connection - please check your network and try again');\n            showErrorModal('Network Error', 'No internet connection - please check your network and try again');\n        }\n        else if (error.message.includes('fetch') || error.message.includes('network')) {\n            webViewError('Network error - unable to connect to eCash network');\n            showErrorModal('Connection Error', 'Network error - unable to connect to eCash network');\n        }\n        else {\n            webViewError('Failed to sync wallet - please try again');\n            showErrorModal('Sync Error', 'Failed to sync wallet - please try again');\n        }\n    }\n}\n// ============================================================================\n// INITIALIZATION FUNCTIONS\n// ============================================================================\n// Initialize the app when DOM is ready\nasync function initializeApp() {\n    webViewLog('Initializing app...');\n    // Load saved settings\n    const settings = loadSettings();\n    requireHoldToSend = settings.requireHoldToSend;\n    // Initialize ticker symbols in HTML\n    const tickerElements = [\n        'ticker-balance',\n        'ticker-label',\n        'ticker-slider-min',\n        'ticker-slider-max'\n    ];\n    for (const elementId of tickerElements) {\n        const el = document.getElementById(elementId);\n        if (el) {\n            el.textContent = config.ticker;\n        }\n    }\n    // Set the back arrow icons\n    for (const iconEl of document.querySelectorAll('.back-arrow-icon')) {\n        iconEl.src = back_arrow_namespaceObject;\n    }\n    // Set the eCash logo source\n    const logoEl = document.getElementById('ecash-logo');\n    if (logoEl) {\n        logoEl.src = ecash_namespaceObject;\n    }\n    // Set the edit icon source\n    const editIconEl = document.getElementById('edit-icon');\n    if (editIconEl) {\n        editIconEl.src = edit_namespaceObject;\n    }\n    // Set the history icon source\n    const historyIconEl = document.getElementById('history-icon');\n    if (historyIconEl) {\n        historyIconEl.src = history_namespaceObject;\n    }\n    // Set the no camera icon source\n    const noCameraIconEl = document.getElementById('no-camera-icon');\n    if (noCameraIconEl) {\n        noCameraIconEl.src = camera_namespaceObject;\n    }\n    // Set the QR code icon source\n    const qrIconEl = document.getElementById('qr-icon');\n    if (qrIconEl) {\n        qrIconEl.src = src_qrcode_namespaceObject;\n    }\n    // Set the settings icon source\n    const settingsIconEl = document.getElementById('settings-icon');\n    if (settingsIconEl) {\n        settingsIconEl.src = settings_namespaceObject;\n    }\n    // Initialize pull-to-refresh\n    initPullToRefresh();\n    // Always require authentication on app launch (for security)\n    // Show loading screen with an opaque background for better privacy: we want\n    // to avoid anybody seeing the content of the wallet before the\n    // authentication is complete.\n    showLoadingScreen('Authentication required');\n    chronik = new chronik_client_dist.ChronikClient(config.chronikUrls);\n    try {\n        await loadWallet();\n    }\n    catch (error) {\n        webViewError('Failed to load the wallet:', error);\n        sendMessageToBackend('CLOSE_APP', undefined);\n        return;\n    }\n    // Hide loading screen on success\n    hideLoadingScreen();\n    // Add click listener to address element for copying\n    const addressEl = document.getElementById('address');\n    if (addressEl) {\n        addressEl.addEventListener('click', () => copyAddress(ecashWallet));\n    }\n    else {\n        webViewLog('Error: addressEl not found, cannot add click listener for copying address');\n    }\n    // Add click listeners for QR scanner\n    const scanBtn = document.getElementById('scan-btn');\n    const closeCameraBtn = document.getElementById('close-camera');\n    if (scanBtn) {\n        scanBtn.addEventListener('click', handleScanButtonClick);\n    }\n    if (closeCameraBtn) {\n        closeCameraBtn.addEventListener('click', handleCloseCamera);\n    }\n    // Add click listener for manual entry button\n    const manualEntryBtn = document.getElementById('manual-entry-btn');\n    if (manualEntryBtn) {\n        manualEntryBtn.addEventListener('click', async () => { await openSendScreenForManualEntry(); });\n    }\n    // Add click listeners for Send screen\n    const backBtn = document.getElementById('back-btn');\n    const cancelSendBtn = document.getElementById('cancel-send');\n    const confirmSendBtn = document.getElementById('confirm-send');\n    if (backBtn) {\n        backBtn.addEventListener('click', showMainScreen);\n    }\n    if (cancelSendBtn) {\n        cancelSendBtn.addEventListener('click', showMainScreen);\n    }\n    if (confirmSendBtn) {\n        setupHoldToSend(confirmSendBtn);\n    }\n    // Add click listeners for History screen\n    const historyBackBtn = document.getElementById('history-back-btn');\n    if (historyBackBtn) {\n        historyBackBtn.addEventListener('click', showMainScreen);\n    }\n    // Add click listeners for Settings screen\n    const settingsBackBtn = document.getElementById('settings-back-btn');\n    const editMnemonicBtn = document.getElementById('edit-mnemonic-btn');\n    const cancelMnemonicEditBtn = document.getElementById('cancel-mnemonic-edit');\n    const saveMnemonicEditBtn = document.getElementById('save-mnemonic-edit');\n    const closeMnemonicModalBtn = document.getElementById('close-mnemonic-modal');\n    if (settingsBackBtn) {\n        settingsBackBtn.addEventListener('click', showMainScreen);\n    }\n    // Setup hold-to-send toggle and apply saved setting\n    const holdToSendToggle = document.getElementById('hold-to-send-toggle');\n    if (holdToSendToggle) {\n        // Apply saved setting to toggle UI\n        holdToSendToggle.checked = requireHoldToSend;\n        // Add change listener\n        holdToSendToggle.addEventListener('change', () => {\n            requireHoldToSend = holdToSendToggle.checked;\n            webViewLog(`Hold to send ${requireHoldToSend ? 'enabled' : 'disabled'}`);\n            // Save settings to localStorage\n            saveSettings({\n                requireHoldToSend: requireHoldToSend,\n            });\n        });\n    }\n    if (editMnemonicBtn) {\n        editMnemonicBtn.addEventListener('click', showMnemonicEditModal);\n    }\n    if (cancelMnemonicEditBtn) {\n        cancelMnemonicEditBtn.addEventListener('click', () => {\n            hideMnemonicEditModal();\n            hideValidationMessage();\n        });\n    }\n    if (closeMnemonicModalBtn) {\n        closeMnemonicModalBtn.addEventListener('click', () => {\n            hideMnemonicEditModal();\n            hideValidationMessage();\n        });\n    }\n    if (saveMnemonicEditBtn) {\n        saveMnemonicEditBtn.addEventListener('click', async () => {\n            const editText = document.getElementById('mnemonic-edit-text');\n            if (editText) {\n                await saveMnemonic(editText.value);\n            }\n        });\n    }\n    // Add validation to amount input\n    const sendAmountInput = document.getElementById('send-amount');\n    if (sendAmountInput) {\n        sendAmountInput.addEventListener('input', (event) => {\n            handleAmountInput(event);\n            updateFeeDisplay();\n        });\n        sendAmountInput.addEventListener('blur', validateAmountField);\n    }\n    // Add slider functionality\n    const amountSlider = document.getElementById('amount-slider');\n    if (amountSlider) {\n        amountSlider.addEventListener('input', (event) => {\n            handleSliderInput(event);\n            updateFeeDisplay();\n        });\n    }\n    // Add recipient address input listener for fee updates and validation\n    const recipientAddressInput = document.getElementById('recipient-address');\n    if (recipientAddressInput) {\n        recipientAddressInput.addEventListener('input', () => {\n            validateAddressField();\n            updateFeeDisplay();\n        });\n    }\n    // Ensure camera modal starts hidden\n    const cameraModal = document.getElementById('camera-modal');\n    if (cameraModal) {\n        cameraModal.classList.add('hidden');\n        webViewLog('Camera modal initialized as hidden');\n    }\n}\n// Listen for payment requests from React Native\nfunction handlePaymentRequest(event) {\n    try {\n        const message = JSON.parse(event.data);\n        if (message.type === 'PAYMENT_REQUEST') {\n            const bip21Uri = message.data;\n            // Parse the BIP21 URI\n            const parsed = parseBip21Uri(bip21Uri);\n            if (parsed) {\n                // Open send screen with prefilled address and amount\n                openSendScreenWithAddress(parsed.address, parsed.sats);\n            }\n            else {\n                webViewError('Invalid BIP21 URI:', bip21Uri);\n            }\n        }\n    }\n    catch (error) {\n        // Ignore parse errors from non-JSON messages\n    }\n}\ndocument.addEventListener('message', handlePaymentRequest);\nwindow.addEventListener('message', handlePaymentRequest);\n// Add click listener to address element\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initializeApp);\n}\nelse {\n    // DOM is already ready\n    initializeApp();\n}\n// Cleanup WebSocket connection when page is unloaded\nwindow.addEventListener('beforeunload', () => {\n    unsubscribeFromAddress();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBLFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxhQUFhLFFBQVE7QUFDekIsSUFBSSxvQkFBb0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFZLFVBQVUsaUJBQWlCLDJDQUEyQztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL3NyYy9jb21tb24udHM/YmJhYiIsIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vc3JjL2Ftb3VudC50cz8zMzJmIiwid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9zcmMvY29uZmlnLnRzPzRhMGQiLCJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL3NyYy93YWxsZXQudHM/ZWUwMCIsIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vc3JjL3RyYW5zYWN0aW9uLWhpc3RvcnkudHM/ZmUwOCIsIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vc3JjL21uZW1vbmljLnRzP2Y0YmUiLCJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL3NyYy9hZGRyZXNzLnRzP2Y2ZDYiLCJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xci1zY2FubmVyL3FyLXNjYW5uZXIubWluLmpzPzE2MzQiLCJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL3NyYy9xcmNvZGUudHM/YzJkMSIsIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vc3JjL2JpcDIxLnRzPzc4MzkiLCJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL3NyYy9tYWluLmNzcz9kZGQzIiwid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9zcmMvaW5kZXgudHM/ZTk0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBhIFJlYWN0IE5hdGl2ZSBXZWJWaWV3LiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvXG4vLyB1c2UgYSBkZWdyYWRlZCBidXQgZnVuY3Rpb25hbCB3ZWIgdmVyc2lvbiBvZiB0aGUgYXBwLlxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmVXZWJWaWV3KCkge1xuICAgIHJldHVybiAhIXdpbmRvdy5SZWFjdE5hdGl2ZVdlYlZpZXc7XG59XG4vLyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgYmFja2VuZCBhcHAgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gYSBSZWFjdCBOYXRpdmVcbi8vIFdlYlZpZXcuIFRoaXMgaXMgaG93IHdlIGNvbW11bmljYXRlIGJhY2sgYW5kIGZvcnRoIHRvIGVzY2FwZSB0aGUgV2ViVmlldyBhbmRcbi8vIGFjY2VzcyB0aGUgcGxhdGZvcm0gbmF0aXZlIGZlYXR1cmVzLlxuZXhwb3J0IGZ1bmN0aW9uIHNlbmRNZXNzYWdlVG9CYWNrZW5kKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoaXNSZWFjdE5hdGl2ZVdlYlZpZXcoKSkge1xuICAgICAgICB3aW5kb3cuUmVhY3ROYXRpdmVXZWJWaWV3LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gd2ViVmlld0xvZyguLi5tZXNzYWdlcykge1xuICAgIGNvbnN0IGNhdE1lc3NhZ2VzID0gbWVzc2FnZXMuam9pbignICcpO1xuICAgIGNvbnNvbGUubG9nKGNhdE1lc3NhZ2VzKTtcbiAgICBzZW5kTWVzc2FnZVRvQmFja2VuZCgnTE9HJywgY2F0TWVzc2FnZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlYlZpZXdFcnJvciguLi5tZXNzYWdlcykge1xuICAgIHdlYlZpZXdMb2coJ0Vycm9yOicsIC4uLm1lc3NhZ2VzKTtcbn1cbiIsImltcG9ydCB7IHdlYlZpZXdFcnJvciB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IEVjYywgc2hhUm1kMTYwLCBUeEJ1aWxkZXIsIERFRkFVTFRfRFVTVF9TQVRTLCBERUZBVUxUX0ZFRV9TQVRTX1BFUl9LQiwgY2FsY1R4RmVlIH0gZnJvbSAnZWNhc2gtbGliJztcbmltcG9ydCB7IFdhbGxldCB9IGZyb20gJ2VjYXNoLXdhbGxldCc7XG4vLyBDb252ZXJzaW9uIGZ1bmN0aW9uIGZvciBkaXNwbGF5XG5leHBvcnQgZnVuY3Rpb24gc2F0c1RvWGVjKHNhdHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChzYXRzKSAvIDEwMDsgLy8gUm91bmQgdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgZXJyb3JzXG59XG4vLyBDYWxjdWxhdGUgdHJhbnNhY3Rpb24gYW1vdW50IGZvciBvdXIgYWRkcmVzc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZVRyYW5zYWN0aW9uQW1vdW50U2F0cyh3YWxsZXQsIGNocm9uaWssIHR4aWQpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBHZXQgdHJhbnNhY3Rpb24gZGV0YWlscyBmcm9tIENocm9uaWtcbiAgICAgICAgY29uc3QgdHggPSBhd2FpdCBjaHJvbmlrLnR4KHR4aWQpO1xuICAgICAgICBpZiAoIXR4KSB7XG4gICAgICAgICAgICB3ZWJWaWV3RXJyb3IoJ1RyYW5zYWN0aW9uIG5vdCBmb3VuZDonLCB0eGlkKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBvdXIgYWRkcmVzcyBoYXNoMTYwIGZvciBjb21wYXJpc29uXG4gICAgICAgIGNvbnN0IGVjYyA9IG5ldyBFY2MoKTtcbiAgICAgICAgY29uc3QgcGsgPSBlY2MuZGVyaXZlUHVia2V5KHdhbGxldC5zayk7XG4gICAgICAgIGNvbnN0IHBraCA9IHNoYVJtZDE2MChwayk7XG4gICAgICAgIGNvbnN0IG91ckhhc2gxNjAgPSBBcnJheS5mcm9tKHBraCkubWFwKGJ5dGUgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG4gICAgICAgIGxldCB0b3RhbEFtb3VudCA9IDA7XG4gICAgICAgIC8vIENoZWNrIG91dHB1dHMgKHJlY2VpdmVzKSAtIGFtb3VudHMgc2VudCBUTyBvdXIgYWRkcmVzc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4Lm91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IHR4Lm91dHB1dHNbaV07XG4gICAgICAgICAgICBpZiAob3V0cHV0Lm91dHB1dFNjcmlwdCAmJiBvdXRwdXQuc2F0cykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBib3RoIGhleCBzdHJpbmcgYW5kIFVpbnQ4QXJyYXkgZm9ybWF0c1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0U2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG91dHB1dC5vdXRwdXRTY3JpcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGhleCBzdHJpbmcgdG8gVWludDhBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGV4ID0gb3V0cHV0Lm91dHB1dFNjcmlwdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFNjcmlwdCA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGV4Lmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2NyaXB0W2ogLyAyXSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaiwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFNjcmlwdCA9IG91dHB1dC5vdXRwdXRTY3JpcHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IFAyUEtIIHNjcmlwdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dFNjcmlwdCAmJiBvdXRwdXRTY3JpcHQubGVuZ3RoID09PSAyNSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0U2NyaXB0WzBdID09PSAweDc2ICYmIG91dHB1dFNjcmlwdFsxXSA9PT0gMHhhOSAmJiBvdXRwdXRTY3JpcHRbMl0gPT09IDB4MTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgaGFzaDE2MCBmcm9tIFAyUEtIIHNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0SGFzaDE2MCA9IG91dHB1dFNjcmlwdC5zbGljZSgzLCAyMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHRIYXNoMTYwSGV4ID0gQXJyYXkuZnJvbShzY3JpcHRIYXNoMTYwKS5tYXAoYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JpcHRIYXNoMTYwSGV4ID09PSBvdXJIYXNoMTYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW1vdW50U2F0cyA9IE51bWJlcihvdXRwdXQuc2F0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxBbW91bnQgKz0gYW1vdW50U2F0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgd2ViVmlld0Vycm9yKGBDb3VsZCBub3QgcGFyc2Ugb3V0cHV0IHNjcmlwdCBmcm9tIHR4aWQgJHt0eGlkfSBpbmRleCAke2l9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaW5wdXRzIChzcGVuZHMpIC0gYW1vdW50cyBzZW50IEZST00gb3VyIGFkZHJlc3NcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eC5pbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdHguaW5wdXRzW2ldO1xuICAgICAgICAgICAgaWYgKGlucHV0Lm91dHB1dFNjcmlwdCAmJiBpbnB1dC5zYXRzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGJvdGggaGV4IHN0cmluZyBhbmQgVWludDhBcnJheSBmb3JtYXRzXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dFNjcmlwdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5vdXRwdXRTY3JpcHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGhleCBzdHJpbmcgdG8gVWludDhBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGV4ID0gaW5wdXQub3V0cHV0U2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRTY3JpcHQgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhleC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U2NyaXB0W2ogLyAyXSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaiwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U2NyaXB0ID0gaW5wdXQub3V0cHV0U2NyaXB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCBQMlBLSCBzY3JpcHRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjcmlwdCAmJiBpbnB1dFNjcmlwdC5sZW5ndGggPT09IDI1ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjcmlwdFswXSA9PT0gMHg3NiAmJiBpbnB1dFNjcmlwdFsxXSA9PT0gMHhhOSAmJiBpbnB1dFNjcmlwdFsyXSA9PT0gMHgxNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBoYXNoMTYwIGZyb20gUDJQS0ggc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHRIYXNoMTYwID0gaW5wdXRTY3JpcHQuc2xpY2UoMywgMjMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0SGFzaDE2MEhleCA9IEFycmF5LmZyb20oc2NyaXB0SGFzaDE2MCkubWFwKGJ5dGUgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NyaXB0SGFzaDE2MEhleCA9PT0gb3VySGFzaDE2MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFtb3VudFNhdHMgPSBOdW1iZXIoaW5wdXQuc2F0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxBbW91bnQgLT0gYW1vdW50U2F0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgd2ViVmlld0Vycm9yKGBDb3VsZCBub3QgcGFyc2UgaW5wdXQgc2NyaXB0IGZyb20gdHhpZCAke3R4aWR9IGluZGV4ICR7aX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxBbW91bnQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB3ZWJWaWV3RXJyb3IoJ0ZhaWxlZCBjYWxjdWxhdGluZyB0cmFuc2FjdGlvbiBhbW91bnQ6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4vLyBDYWxjdWxhdGUgbWF4aW11bSBzcGVuZGFibGUgYW1vdW50XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTWF4U3BlbmRhYmxlQW1vdW50KHdhbGxldCkge1xuICAgIC8vIFNlbGVjdCBhbGwgc3BlbmRhYmxlIHV0eG9zIGFuZCBjYWxjdWxhdGUgdGhlIHNpemUgb2YgYSB0cmFuc2FjdGlvbiB0aGF0XG4gICAgLy8gc2VuZHMgdGhlbSBhbGwgdG8gYSBzaW5nbGUgcDJwa2ggb3V0cHV0ICsgY2hhbmdlIG91dHB1dFxuICAgIGNvbnN0IHNwZW5kYWJsZVV0eG9zID0gd2FsbGV0LnNwZW5kYWJsZVV0eG9zKCk7XG4gICAgY29uc3QgYmFsYW5jZVNhdHMgPSBXYWxsZXQuc3VtVXR4b3NTYXRzKHNwZW5kYWJsZVV0eG9zKTtcbiAgICBjb25zdCBpbnB1dHMgPSBzcGVuZGFibGVVdHhvcy5tYXAodXR4byA9PiB3YWxsZXQucDJwa2hVdHhvVG9CdWlsZGVySW5wdXQodXR4bykpO1xuICAgIGNvbnN0IHR4QnVpbGRlciA9IG5ldyBUeEJ1aWxkZXIoe1xuICAgICAgICBpbnB1dHMsXG4gICAgICAgIC8vIE5vIGxlZnRvdmVyIGluIHRoaXMgY2FzZSwgc2VuZCBhbGwgdG8gc2VsZlxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB3YWxsZXQuc2NyaXB0LFxuICAgICAgICBdLFxuICAgIH0pO1xuICAgIGNvbnN0IHRoaXNUeCA9IHR4QnVpbGRlci5zaWduKHtcbiAgICAgICAgZmVlUGVyS2I6IERFRkFVTFRfRkVFX1NBVFNfUEVSX0tCLFxuICAgICAgICBkdXN0U2F0czogREVGQVVMVF9EVVNUX1NBVFMsXG4gICAgfSk7XG4gICAgY29uc3QgdHhTaXplID0gdGhpc1R4LnNlclNpemUoKTtcbiAgICBjb25zdCB0eEZlZSA9IGNhbGNUeEZlZSh0eFNpemUsIERFRkFVTFRfRkVFX1NBVFNfUEVSX0tCKTtcbiAgICByZXR1cm4gc2F0c1RvWGVjKE51bWJlcihiYWxhbmNlU2F0cyAtIHR4RmVlKSk7XG59XG4vLyBFc3RpbWF0ZSB0cmFuc2FjdGlvbiBmZWVcbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVRyYW5zYWN0aW9uRmVlKHdhbGxldCwgcmVjaXBpZW50QWRkcmVzcywgYW1vdW50WEVDKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ29udmVydCBYRUMgdG8gc2F0b3NoaXMgKDEgWEVDID0gMTAwIHNhdG9zaGlzKVxuICAgICAgICBjb25zdCBhbW91bnRTYXRvc2hpcyA9IE1hdGgucm91bmQoYW1vdW50WEVDICogMTAwKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBhY3Rpb24gd2l0aCBvdXRwdXRzXG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHdhbGxldC5hY3Rpb24oe1xuICAgICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcmVjaXBpZW50QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgc2F0czogQmlnSW50KGFtb3VudFNhdG9zaGlzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSB0cmFuc2FjdGlvbiB0byBnZXQgZmVlIGVzdGltYXRlXG4gICAgICAgIGNvbnN0IGJ1aWx0VHggPSBhY3Rpb24uYnVpbGQoKTtcbiAgICAgICAgLy8gR2V0IGZlZSBpbiBzYXRvc2hpcyBhbmQgY29udmVydCB0byBYRUNcbiAgICAgICAgY29uc3QgZmVlU2F0b3NoaXMgPSBOdW1iZXIoYnVpbHRUeC5mZWUoKSk7XG4gICAgICAgIGNvbnN0IGZlZVhFQyA9IHNhdHNUb1hlYyhmZWVTYXRvc2hpcyk7XG4gICAgICAgIGNvbnN0IHRvdGFsWEVDID0gYW1vdW50WEVDICsgZmVlWEVDO1xuICAgICAgICByZXR1cm4geyBmZWVYRUMsIHRvdGFsWEVDIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB3ZWJWaWV3RXJyb3IoJ0ZhaWxlZCBlc3RpbWF0aW5nIHRyYW5zYWN0aW9uIGZlZTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIE1hcmxpbiBXYWxsZXRcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcbiAgICAvKipcbiAgICAgKiBDaHJvbmlrIEFQSSBlbmRwb2ludHNcbiAgICAgKiBNdWx0aXBsZSBlbmRwb2ludHMgY2FuIGJlIHByb3ZpZGVkIGZvciBmYWlsb3ZlclxuICAgICAqL1xuICAgIGNocm9uaWtVcmxzOiBbXG4gICAgICAgICdodHRwczovL2Nocm9uaWstbmF0aXZlMS5mYWJpZW4uY2FzaCcsXG4gICAgICAgICdodHRwczovL2Nocm9uaWstbmF0aXZlMi5mYWJpZW4uY2FzaCcsXG4gICAgICAgICdodHRwczovL2Nocm9uaWstbmF0aXZlMy5mYWJpZW4uY2FzaCcsXG4gICAgXSxcbiAgICAvKipcbiAgICAgKiBBZGRyZXNzIHByZWZpeCBmb3IgdGhlIG5ldHdvcmtcbiAgICAgKiAnZWNhc2gnIGZvciBtYWlubmV0LCAnZWN0ZXN0JyBmb3IgdGVzdG5ldFxuICAgICAqL1xuICAgIGFkZHJlc3NQcmVmaXg6ICdlY2FzaCcsXG4gICAgLyoqXG4gICAgICogQmxvY2sgZXhwbG9yZXIgYmFzZSBVUkxcbiAgICAgKiBUcmFuc2FjdGlvbiBJRHMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIFVSTFxuICAgICAqL1xuICAgIGV4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5lLmNhc2gvdHgvJyxcbiAgICAvKipcbiAgICAgKiBDdXJyZW5jeSB0aWNrZXIgc3ltYm9sXG4gICAgICovXG4gICAgdGlja2VyOiAnWEVDJyxcbiAgICAvKipcbiAgICAgKiBCSVAyMSBwcmVmaXhcbiAgICAgKi9cbiAgICBiaXAyMVByZWZpeDogJ2VjYXNoOicsXG59O1xuIiwiaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ2VjYXNoLWxpYic7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG4vLyBSZXR1cm4gdGhlIGVDYXNoIGFkZHJlc3Mgc3RyaW5nIGZvciB0aGlzIHdhbGxldFxuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3Mod2FsbGV0KSB7XG4gICAgaWYgKCF3YWxsZXQgfHwgIXdhbGxldC5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQWRkcmVzcy5wYXJzZSh3YWxsZXQuYWRkcmVzcykud2l0aFByZWZpeChjb25maWcuYWRkcmVzc1ByZWZpeCkudG9TdHJpbmcoKTtcbn1cbi8vIFNlbmQgYSB0cmFuc2FjdGlvblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRUcmFuc2FjdGlvbih3YWxsZXQsIHJlY2lwaWVudEFkZHJlc3MsIHNhdHMpIHtcbiAgICAvLyBDcmVhdGUgdGhlIGFjdGlvbiB3aXRoIG91dHB1dHNcbiAgICBjb25zdCBhY3Rpb24gPSB3YWxsZXQuYWN0aW9uKHtcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHJlY2lwaWVudEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc2F0czogQmlnSW50KHNhdHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9KTtcbiAgICBjb25zdCBidWlsdFR4ID0gYWN0aW9uLmJ1aWxkKCk7XG4gICAgYXdhaXQgYnVpbHRUeC5icm9hZGNhc3QoKTtcbn1cbiIsImltcG9ydCB7IHdlYlZpZXdMb2csIHdlYlZpZXdFcnJvciB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IGNhbGN1bGF0ZVRyYW5zYWN0aW9uQW1vdW50U2F0cywgc2F0c1RvWGVjIH0gZnJvbSAnLi9hbW91bnQnO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRSQU5TQUNUSU9OIEhJU1RPUlkgTUFOQUdFUlxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVHJhbnNhY3Rpb24gSGlzdG9yeSBNYW5hZ2VyXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25IaXN0b3J5TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3Iod2FsbGV0LCBjaHJvbmlrKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsUGFnZXMgPSAwO1xuICAgICAgICB0aGlzLmhhc01vcmVUcmFuc2FjdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTG9hZGluZ1RyYW5zYWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbFRyYW5zYWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLndhbGxldCA9IHdhbGxldDtcbiAgICAgICAgdGhpcy5jaHJvbmlrID0gY2hyb25paztcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gZ2V0QWRkcmVzcyh0aGlzLndhbGxldCk7XG4gICAgfVxuICAgIC8vIEdldHRlcnNcbiAgICBnZXQgaXNDdXJyZW50bHlMb2FkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0xvYWRpbmdUcmFuc2FjdGlvbnM7XG4gICAgfVxuICAgIGdldCBoYXNNb3JlVG9Mb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNb3JlVHJhbnNhY3Rpb25zO1xuICAgIH1cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxUcmFuc2FjdGlvbnM7XG4gICAgfVxuICAgIC8vIFJlc2V0IHN0YXRlIGZvciBuZXcgaGlzdG9yeSBsb2FkXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsUGFnZXMgPSAwO1xuICAgICAgICB0aGlzLmhhc01vcmVUcmFuc2FjdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzTG9hZGluZ1RyYW5zYWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbFRyYW5zYWN0aW9ucyA9IFtdO1xuICAgIH1cbiAgICAvLyBMb2FkIG1vcmUgdHJhbnNhY3Rpb25zXG4gICAgYXN5bmMgbG9hZE1vcmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNNb3JlVG9Mb2FkIHx8IHRoaXMuaXNDdXJyZW50bHlMb2FkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkVHJhbnNhY3Rpb25IaXN0b3J5KHRoaXMuY2hyb25paywgdGhpcy5hZGRyZXNzLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIE1haW4gdHJhbnNhY3Rpb24gbG9hZGluZyBmdW5jdGlvblxuICAgIGFzeW5jIGxvYWRUcmFuc2FjdGlvbkhpc3RvcnkoY2hyb25paywgYWRkcmVzcywgcmVzZXQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFuc2FjdGlvbi1saXN0Jyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb25MaXN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBzaW11bHRhbmVvdXMgcmVxdWVzdHNcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIC8vIFNob3cgbG9hZGluZyBzdGF0ZSBvbmx5IG9uIHJlc2V0XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkxpc3QuaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2FkaW5nLXRyYW5zYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibG9hZGluZy1zcGlubmVyXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxwPkxvYWRpbmcgdHJhbnNhY3Rpb25zLi4uPC9wPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFzTW9yZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBObyBtb3JlIHRyYW5zYWN0aW9ucyB0byBsb2FkXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0xvYWRpbmdUcmFuc2FjdGlvbnMgPSB0cnVlO1xuICAgICAgICAvLyBTaG93IGxvYWRpbmcgaW5kaWNhdG9yIGltbWVkaWF0ZWx5IGlmIG5vdCByZXNldHRpbmdcbiAgICAgICAgaWYgKCFyZXNldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VHJhbnNhY3Rpb25zKHRoaXMuYWxsVHJhbnNhY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IHRyYW5zYWN0aW9uIGhpc3RvcnkgZnJvbSBDaHJvbmlrIHdpdGggcGFnaW5hdGlvblxuICAgICAgICAgICAgY29uc3QgdHhIaXN0b3J5UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNocm9uaWsuYWRkcmVzcyh0aGlzLmFkZHJlc3MpLmhpc3RvcnkodGhpcy5jdXJyZW50UGFnZSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgdHhIaXN0b3J5ID0gdHhIaXN0b3J5UmVzcG9uc2UudHhzO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBhZ2luYXRpb24gbWV0YWRhdGFcbiAgICAgICAgICAgIHRoaXMudG90YWxQYWdlcyA9IHR4SGlzdG9yeVJlc3BvbnNlLm51bVBhZ2VzO1xuICAgICAgICAgICAgaWYgKCF0eEhpc3RvcnkgfHwgdHhIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzTW9yZVRyYW5zYWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbFRyYW5zYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93Tm9UcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIG5ldyB0cmFuc2FjdGlvbnMgdG8gZXhpc3RpbmcgbGlzdFxuICAgICAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxUcmFuc2FjdGlvbnMgPSB0eEhpc3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbFRyYW5zYWN0aW9ucyA9IFsuLi50aGlzLmFsbFRyYW5zYWN0aW9ucywgLi4udHhIaXN0b3J5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIGxhc3QgcGFnZVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2UgPj0gdGhpcy50b3RhbFBhZ2VzIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzTW9yZVRyYW5zYWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFnZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvY2VzcyBhbmQgZGlzcGxheSBhbGwgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlUcmFuc2FjdGlvbnModGhpcy5hbGxUcmFuc2FjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgd2ViVmlld0Vycm9yKCdGYWlsZWQgdG8gbG9hZCB0cmFuc2FjdGlvbiBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1RyYW5zYWN0aW9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nVHJhbnNhY3Rpb25zID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZGlzcGxheSBvbmUgbW9yZSB0aW1lIHRvIHJlbW92ZSBsb2FkaW5nIGluZGljYXRvclxuICAgICAgICAgICAgaWYgKCFyZXNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVRyYW5zYWN0aW9ucyh0aGlzLmFsbFRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGlzcGxheSB0cmFuc2FjdGlvbnMgaW4gdGhlIFVJXG4gICAgYXN5bmMgZGlzcGxheVRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25MaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zYWN0aW9uLWxpc3QnKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbkxpc3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dOb1RyYW5zYWN0aW9ucygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3MgdHJhbnNhY3Rpb25zIGluIHBhcmFsbGVsIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25IVE1MID0gYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcChhc3luYyAodHgpID0+IHtcbiAgICAgICAgICAgIC8vIFVzZSB0aW1lRmlyc3RTZWVuIGZpZWxkIGZyb20gQ2hyb25paywgZmFsbGJhY2sgdG8gYmxvY2sgdGltZXN0YW1wIGlmIHplcm9cbiAgICAgICAgICAgIGxldCB0aW1lO1xuICAgICAgICAgICAgaWYgKHR4LnRpbWVGaXJzdFNlZW4gJiYgdHgudGltZUZpcnN0U2VlbiA+IDApIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gbmV3IERhdGUodHgudGltZUZpcnN0U2VlbiAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eC5ibG9jayAmJiB0eC5ibG9jay50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gbmV3IERhdGUodHguYmxvY2sudGltZXN0YW1wICogMTAwMCkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWUgPSAnVW5rbm93biBEYXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4aWQgPSBTdHJpbmcodHgudHhpZCk7XG4gICAgICAgICAgICBjb25zdCBzaG9ydFR4aWQgPSB0eGlkLmxlbmd0aCA+IDEyID8gYCR7dHhpZC5zdWJzdHJpbmcoMCwgNil9Li4uJHt0eGlkLnN1YnN0cmluZyh0eGlkLmxlbmd0aCAtIDYpfWAgOiB0eGlkO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJlYWwgdHJhbnNhY3Rpb24gYW1vdW50XG4gICAgICAgICAgICBjb25zdCBhbW91bnRTYXRzID0gYXdhaXQgY2FsY3VsYXRlVHJhbnNhY3Rpb25BbW91bnRTYXRzKHRoaXMud2FsbGV0LCB0aGlzLmNocm9uaWssIHR4aWQpO1xuICAgICAgICAgICAgY29uc3QgYW1vdW50WEVDID0gc2F0c1RvWGVjKGFtb3VudFNhdHMpO1xuICAgICAgICAgICAgY29uc3QgaXNSZWNlaXZlZCA9IGFtb3VudFhFQyA+IDA7XG4gICAgICAgICAgICBjb25zdCBhbW91bnRDbGFzcyA9IGlzUmVjZWl2ZWQgPyAncmVjZWl2ZWQnIDogJ3NlbnQnO1xuICAgICAgICAgICAgY29uc3QgYW1vdW50UHJlZml4ID0gaXNSZWNlaXZlZCA/ICcrJyA6ICctJztcbiAgICAgICAgICAgIGNvbnN0IGFtb3VudFZhbHVlID0gTWF0aC5hYnMoYW1vdW50WEVDKS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHJhbnNhY3Rpb24taXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidHJhbnNhY3Rpb24taW5mb1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRyYW5zYWN0aW9uLXRpbWVcIj4ke1N0cmluZyh0aW1lKX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cmFuc2FjdGlvbi10eGlkXCIgZGF0YS10eGlkPVwiJHtTdHJpbmcodHhpZCl9XCI+JHtTdHJpbmcoc2hvcnRUeGlkKX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0cmFuc2FjdGlvbi1hbW91bnQgJHtTdHJpbmcoYW1vdW50Q2xhc3MpfVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgJHtTdHJpbmcoYW1vdW50UHJlZml4KX0ke1N0cmluZyhhbW91bnRWYWx1ZSl9ICR7Y29uZmlnLnRpY2tlcn1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBgO1xuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEFkZCBsb2FkaW5nIGluZGljYXRvciBhdCBib3R0b20gaWYgY3VycmVudGx5IGxvYWRpbmcgbW9yZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgbGV0IGxvYWRpbmdJbmRpY2F0b3IgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBsb2FkaW5nSW5kaWNhdG9yID0gYFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsb2FkaW5nLW1vcmVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxvYWRpbmctc3Bpbm5lclwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8cD5Mb2FkaW5nIG1vcmUgdHJhbnNhY3Rpb25zLi4uPC9wPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgYDtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbkxpc3QuaW5uZXJIVE1MID0gdHJhbnNhY3Rpb25IVE1MLmpvaW4oJycpICsgbG9hZGluZ0luZGljYXRvcjtcbiAgICB9XG4gICAgLy8gU2hvdyBubyB0cmFuc2FjdGlvbnMgbWVzc2FnZVxuICAgIHNob3dOb1RyYW5zYWN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25MaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zYWN0aW9uLWxpc3QnKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbkxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbkxpc3QuaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5vLXRyYW5zYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgIDxoMz5ObyBUcmFuc2FjdGlvbnM8L2gzPlxuICAgICAgICAgICAgICAgIDxwPllvdSBoYXZlbid0IG1hZGUgYW55IHRyYW5zYWN0aW9ucyB5ZXQuPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gICAgfVxuICAgIC8vIFNob3cgdHJhbnNhY3Rpb24gZXJyb3JcbiAgICBzaG93VHJhbnNhY3Rpb25FcnJvcigpIHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25MaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYW5zYWN0aW9uLWxpc3QnKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbkxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbkxpc3QuaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5vLXRyYW5zYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgIDxoMz5FcnJvciBMb2FkaW5nIFRyYW5zYWN0aW9uczwvaDM+XG4gICAgICAgICAgICAgICAgPHA+RmFpbGVkIHRvIGxvYWQgdHJhbnNhY3Rpb24gaGlzdG9yeS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci48L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHNjcm9sbCBldmVudHMgZm9yIGluZmluaXRlIGxvYWRpbmdcbiAgICBoYW5kbGVTY3JvbGwoKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFuc2FjdGlvbi1saXN0Jyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb25MaXN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGhhcyBzY3JvbGxlZCBuZWFyIHRoZSBib3R0b21cbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdHJhbnNhY3Rpb25MaXN0LnNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gdHJhbnNhY3Rpb25MaXN0LnNjcm9sbEhlaWdodDtcbiAgICAgICAgY29uc3QgY2xpZW50SGVpZ2h0ID0gdHJhbnNhY3Rpb25MaXN0LmNsaWVudEhlaWdodDtcbiAgICAgICAgY29uc3QgaXNOZWFyQm90dG9tID0gc2Nyb2xsVG9wICsgY2xpZW50SGVpZ2h0ID49IHNjcm9sbEhlaWdodCAtIDEwMDtcbiAgICAgICAgLy8gTG9hZCBtb3JlIHRyYW5zYWN0aW9ucyBpZiBuZWFyIGJvdHRvbSwgbW9yZSBwYWdlcyBhdmFpbGFibGUsIGFuZCBub3QgY3VycmVudGx5IGxvYWRpbmdcbiAgICAgICAgaWYgKGlzTmVhckJvdHRvbSAmJiB0aGlzLmhhc01vcmVUb0xvYWQgJiYgIXRoaXMuaXNDdXJyZW50bHlMb2FkaW5nKSB7XG4gICAgICAgICAgICB3ZWJWaWV3TG9nKCdOZWFyIGJvdHRvbSBkZXRlY3RlZCwgbG9hZGluZyBtb3JlIHRyYW5zYWN0aW9ucy4uLicpO1xuICAgICAgICAgICAgdGhpcy5sb2FkTW9yZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgYmlwMzkgZnJvbSAnYmlwMzknO1xuaW1wb3J0IHJhbmRvbUJ5dGVzIGZyb20gJ3JhbmRvbWJ5dGVzJztcbmltcG9ydCB7IGlzUmVhY3ROYXRpdmVXZWJWaWV3LCBzZW5kTWVzc2FnZVRvQmFja2VuZCwgd2ViVmlld0xvZywgd2ViVmlld0Vycm9yIH0gZnJvbSAnLi9jb21tb24nO1xuLyoqXG4gKiBHZW5lcmF0ZSBhIG1uZW1vbmljIHVzaW5nIHRoZSBiaXAzOSBsaWJyYXJ5LiBVc2UgdG8gY3JlYXRlIGEgbmV3IHdhbGxldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTW5lbW9uaWMoKSB7XG4gICAgY29uc3QgbW5lbW9uaWMgPSBiaXAzOS5nZW5lcmF0ZU1uZW1vbmljKDEyOCwgcmFuZG9tQnl0ZXMsIGJpcDM5LndvcmRsaXN0c1snZW5nbGlzaCddKTtcbiAgICByZXR1cm4gbW5lbW9uaWM7XG59XG4vKlxuICogR2V0IHRoZSBtbmVtb25pYyBmcm9tIHRoZSB3YWxsZXQgZGF0YSBvYmplY3QuXG4gKiBUT0RPOiBTd2l0Y2ggdG8gYmUgYSBwcm9wZXIgSEQgd2FsbGV0LiBUaGlzIG1lYW5zIHRoYXQgdGhlIHNlZWQgc2hvdWxkIGJlXG4gKiBzdG9yZWQgaW4gZWNhc2gtd2FsbGV0IGFuZCB0aGVuIHdlIGNhbiByZXRyaWV2ZSB0aGUgbW5lbW9uaWMgZnJvbSB0aGVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1uZW1vbmljKHdhbGxldERhdGEpIHtcbiAgICBpZiAoIXdhbGxldERhdGEgfHwgIXdhbGxldERhdGEubW5lbW9uaWMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXREYXRhLm1uZW1vbmljO1xufVxuLy8gQ2hlY2sgdGhlIG1uZW1vbmljIGlzIHZhbGlkXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNbmVtb25pYyhtbmVtb25pYykge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSB2YWxpZCBCSVAzOSBtbmVtb25pY1xuICAgICAgICByZXR1cm4gYmlwMzkudmFsaWRhdGVNbmVtb25pYyhtbmVtb25pYy50cmltKCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogUmVxdWVzdCB0byBzdG9yZSBtbmVtb25pYyBpbiBzZWN1cmUgc3RvcmFnZSwgZmFsbGJhY2sgdG8gbG9jYWxTdG9yYWdlIGZvclxuICogd2ViLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVNbmVtb25pYyhtbmVtb25pYykge1xuICAgIGlmICghc2VuZE1lc3NhZ2VUb0JhY2tlbmQoJ1NUT1JFX01ORU1PTklDJywgbW5lbW9uaWMpKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGxvY2FsU3RvcmFnZSBmb3Igd2ViXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdlY2FzaF93YWxsZXRfbW5lbW9uaWMnLCBtbmVtb25pYyk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXF1ZXN0IHRvIGxvYWQgbW5lbW9uaWMgZnJvbSBzZWN1cmUgc3RvcmFnZSwgZmFsbGJhY2sgdG8gbG9jYWxTdG9yYWdlIGZvclxuICogd2ViLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZE1uZW1vbmljKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlV2ViVmlldygpKSB7XG4gICAgICAgICAgICB3ZWJWaWV3TG9nKCdMb2FkaW5nIG1uZW1vbmljIGZyb20gc2VjdXJlIHN0b3JhZ2UnKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdNTkVNT05JQ19SRVNQT05TRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgd2ViVmlld0Vycm9yKCdFcnJvciBwYXJzaW5nIG1uZW1vbmljIHJlc3BvbnNlOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVJlc3BvbnNlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlUmVzcG9uc2UpO1xuICAgICAgICAgICAgc2VuZE1lc3NhZ2VUb0JhY2tlbmQoJ0xPQURfTU5FTU9OSUMnLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgLy8gVGltZW91dCBhZnRlciAzMCBzZWNvbmRzXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQgbG9hZGluZyBtbmVtb25pYycpKTtcbiAgICAgICAgICAgIH0sIDMwMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdlYlZpZXdMb2coJ0xvYWRpbmcgbW5lbW9uaWMgZnJvbSBsb2NhbCBzdG9yYWdlJyk7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBsb2NhbFN0b3JhZ2UgZm9yIHdlYlxuICAgICAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZWNhc2hfd2FsbGV0X21uZW1vbmljJyk7XG4gICAgICAgICAgICByZXNvbHZlKG1uZW1vbmljKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwiaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ2VjYXNoLWxpYic7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSAnLi93YWxsZXQnO1xuaW1wb3J0IHsgd2ViVmlld0Vycm9yIH0gZnJvbSAnLi9jb21tb24nO1xuLy8gQ2hlY2sgdGhlIGFkZHJlc3Mgc3RyaW5nIGlzIGEgdmFsaWQgZUNhc2ggYWRkcmVzc1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRFQ2FzaEFkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBBZGRyZXNzLnBhcnNlKCkgdG8gdmFsaWRhdGUgdGhlIGFkZHJlc3NcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhZGRyZXNzIGlzIGludmFsaWRcbiAgICAgICAgQWRkcmVzcy5wYXJzZShhZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8gQ29weSBhZGRyZXNzIHRvIGNsaXBib2FyZFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvcHlBZGRyZXNzKHdhbGxldCkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKHdhbGxldCk7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoYWRkcmVzcyk7XG4gICAgICAgIC8vIEFkZHJlc3MgY29waWVkIHNpbGVudGx5IC0gbm8gc3RhdHVzIG1lc3NhZ2VcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdlYlZpZXdFcnJvcignRmFpbGVkIHRvIGNvcHkgYWRkcmVzczonLCBlcnJvcik7XG4gICAgfVxufVxuIiwiY2xhc3MgZXtjb25zdHJ1Y3RvcihhLGIsYyxkLGYpe3RoaXMuX2xlZ2FjeUNhbnZhc1NpemU9ZS5ERUZBVUxUX0NBTlZBU19TSVpFO3RoaXMuX3ByZWZlcnJlZENhbWVyYT1cImVudmlyb25tZW50XCI7dGhpcy5fbWF4U2NhbnNQZXJTZWNvbmQ9MjU7dGhpcy5fbGFzdFNjYW5UaW1lc3RhbXA9LTE7dGhpcy5fZGVzdHJveWVkPXRoaXMuX2ZsYXNoT249dGhpcy5fcGF1c2VkPXRoaXMuX2FjdGl2ZT0hMTt0aGlzLiR2aWRlbz1hO3RoaXMuJGNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2MmJlwib2JqZWN0XCI9PT10eXBlb2YgYz90aGlzLl9vbkRlY29kZT1iOihjfHxkfHxmP2NvbnNvbGUud2FybihcIllvdSdyZSB1c2luZyBhIGRlcHJlY2F0ZWQgdmVyc2lvbiBvZiB0aGUgUXJTY2FubmVyIGNvbnN0cnVjdG9yIHdoaWNoIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXCIpOmNvbnNvbGUud2FybihcIk5vdGUgdGhhdCB0aGUgdHlwZSBvZiB0aGUgc2NhbiByZXN1bHQgcGFzc2VkIHRvIG9uRGVjb2RlIHdpbGwgY2hhbmdlIGluIHRoZSBmdXR1cmUuIFRvIGFscmVhZHkgc3dpdGNoIHRvIHRoZSBuZXcgYXBpIHRvZGF5LCB5b3UgY2FuIHBhc3MgcmV0dXJuRGV0YWlsZWRTY2FuUmVzdWx0OiB0cnVlLlwiKSxcbnRoaXMuX2xlZ2FjeU9uRGVjb2RlPWIpO2I9XCJvYmplY3RcIj09PXR5cGVvZiBjP2M6e307dGhpcy5fb25EZWNvZGVFcnJvcj1iLm9uRGVjb2RlRXJyb3J8fChcImZ1bmN0aW9uXCI9PT10eXBlb2YgYz9jOnRoaXMuX29uRGVjb2RlRXJyb3IpO3RoaXMuX2NhbGN1bGF0ZVNjYW5SZWdpb249Yi5jYWxjdWxhdGVTY2FuUmVnaW9ufHwoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQ/ZDp0aGlzLl9jYWxjdWxhdGVTY2FuUmVnaW9uKTt0aGlzLl9wcmVmZXJyZWRDYW1lcmE9Yi5wcmVmZXJyZWRDYW1lcmF8fGZ8fHRoaXMuX3ByZWZlcnJlZENhbWVyYTt0aGlzLl9sZWdhY3lDYW52YXNTaXplPVwibnVtYmVyXCI9PT10eXBlb2YgYz9jOlwibnVtYmVyXCI9PT10eXBlb2YgZD9kOnRoaXMuX2xlZ2FjeUNhbnZhc1NpemU7dGhpcy5fbWF4U2NhbnNQZXJTZWNvbmQ9Yi5tYXhTY2Fuc1BlclNlY29uZHx8dGhpcy5fbWF4U2NhbnNQZXJTZWNvbmQ7dGhpcy5fb25QbGF5PXRoaXMuX29uUGxheS5iaW5kKHRoaXMpO3RoaXMuX29uTG9hZGVkTWV0YURhdGE9XG50aGlzLl9vbkxvYWRlZE1ldGFEYXRhLmJpbmQodGhpcyk7dGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlPXRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZS5iaW5kKHRoaXMpO3RoaXMuX3VwZGF0ZU92ZXJsYXk9dGhpcy5fdXBkYXRlT3ZlcmxheS5iaW5kKHRoaXMpO2EuZGlzYWJsZVBpY3R1cmVJblBpY3R1cmU9ITA7YS5wbGF5c0lubGluZT0hMDthLm11dGVkPSEwO2xldCBoPSExO2EuaGlkZGVuJiYoYS5oaWRkZW49ITEsaD0hMCk7ZG9jdW1lbnQuYm9keS5jb250YWlucyhhKXx8KGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSksaD0hMCk7Yz1hLnBhcmVudEVsZW1lbnQ7aWYoYi5oaWdobGlnaHRTY2FuUmVnaW9ufHxiLmhpZ2hsaWdodENvZGVPdXRsaW5lKXtkPSEhYi5vdmVybGF5O3RoaXMuJG92ZXJsYXk9Yi5vdmVybGF5fHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2Y9dGhpcy4kb3ZlcmxheS5zdHlsZTtmLnBvc2l0aW9uPVwiYWJzb2x1dGVcIjtmLmRpc3BsYXk9XCJub25lXCI7XG5mLnBvaW50ZXJFdmVudHM9XCJub25lXCI7dGhpcy4kb3ZlcmxheS5jbGFzc0xpc3QuYWRkKFwic2Nhbi1yZWdpb24taGlnaGxpZ2h0XCIpO2lmKCFkJiZiLmhpZ2hsaWdodFNjYW5SZWdpb24pe3RoaXMuJG92ZXJsYXkuaW5uZXJIVE1MPSc8c3ZnIGNsYXNzPVwic2Nhbi1yZWdpb24taGlnaGxpZ2h0LXN2Z1wiIHZpZXdCb3g9XCIwIDAgMjM4IDIzOFwiIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2xlZnQ6MDt0b3A6MDtmaWxsOm5vbmU7c3Ryb2tlOiNlOWIyMTM7c3Ryb2tlLXdpZHRoOjQ7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kXCI+PHBhdGggZD1cIk0zMSAySDEwYTggOCAwIDAgMC04IDh2MjFNMjA3IDJoMjFhOCA4IDAgMCAxIDggOHYyMW0wIDE3NnYyMWE4IDggMCAwIDEtOCA4aC0yMW0tMTc2IDBIMTBhOCA4IDAgMCAxLTgtOHYtMjFcIi8+PC9zdmc+Jzt0cnl7dGhpcy4kb3ZlcmxheS5maXJzdEVsZW1lbnRDaGlsZC5hbmltYXRlKHt0cmFuc2Zvcm06W1wic2NhbGUoLjk4KVwiLFxuXCJzY2FsZSgxLjAxKVwiXX0se2R1cmF0aW9uOjQwMCxpdGVyYXRpb25zOkluZmluaXR5LGRpcmVjdGlvbjpcImFsdGVybmF0ZVwiLGVhc2luZzpcImVhc2UtaW4tb3V0XCJ9KX1jYXRjaChtKXt9Yy5pbnNlcnRCZWZvcmUodGhpcy4kb3ZlcmxheSx0aGlzLiR2aWRlby5uZXh0U2libGluZyl9Yi5oaWdobGlnaHRDb2RlT3V0bGluZSYmKHRoaXMuJG92ZXJsYXkuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsJzxzdmcgY2xhc3M9XCJjb2RlLW91dGxpbmUtaGlnaGxpZ2h0XCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2ZpbGw6bm9uZTtzdHJva2U6I2U5YjIxMztzdHJva2Utd2lkdGg6NTtzdHJva2UtZGFzaGFycmF5OjI1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZFwiPjxwb2x5Z29uLz48L3N2Zz4nKSx0aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodD10aGlzLiRvdmVybGF5Lmxhc3RFbGVtZW50Q2hpbGQpfXRoaXMuX3NjYW5SZWdpb249XG50aGlzLl9jYWxjdWxhdGVTY2FuUmVnaW9uKGEpO3JlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+e2xldCBtPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEpO1wibm9uZVwiPT09bS5kaXNwbGF5JiYoYS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIixcImJsb2NrXCIsXCJpbXBvcnRhbnRcIiksaD0hMCk7XCJ2aXNpYmxlXCIhPT1tLnZpc2liaWxpdHkmJihhLnN0eWxlLnNldFByb3BlcnR5KFwidmlzaWJpbGl0eVwiLFwidmlzaWJsZVwiLFwiaW1wb3J0YW50XCIpLGg9ITApO2gmJihjb25zb2xlLndhcm4oXCJRclNjYW5uZXIgaGFzIG92ZXJ3cml0dGVuIHRoZSB2aWRlbyBoaWRpbmcgc3R5bGUgdG8gYXZvaWQgU2FmYXJpIHN0b3BwaW5nIHRoZSBwbGF5YmFjay5cIiksYS5zdHlsZS5vcGFjaXR5PVwiMFwiLGEuc3R5bGUud2lkdGg9XCIwXCIsYS5zdHlsZS5oZWlnaHQ9XCIwXCIsdGhpcy4kb3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5wYXJlbnRFbGVtZW50JiZ0aGlzLiRvdmVybGF5LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy4kb3ZlcmxheSksXG5kZWxldGUgdGhpcy4kb3ZlcmxheSxkZWxldGUgdGhpcy4kY29kZU91dGxpbmVIaWdobGlnaHQpO3RoaXMuJG92ZXJsYXkmJnRoaXMuX3VwZGF0ZU92ZXJsYXkoKX0pO2EuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlcIix0aGlzLl9vblBsYXkpO2EuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsdGhpcy5fb25Mb2FkZWRNZXRhRGF0YSk7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIix0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5fdXBkYXRlT3ZlcmxheSk7dGhpcy5fcXJFbmdpbmVQcm9taXNlPWUuY3JlYXRlUXJFbmdpbmUoKX1zdGF0aWMgc2V0IFdPUktFUl9QQVRIKGEpe2NvbnNvbGUud2FybihcIlNldHRpbmcgUXJTY2FubmVyLldPUktFUl9QQVRIIGlzIG5vdCByZXF1aXJlZCBhbmQgbm90IHN1cHBvcnRlZCBhbnltb3JlLiBIYXZlIGEgbG9vayBhdCB0aGUgUkVBRE1FIGZvciBuZXcgc2V0dXAgaW5zdHJ1Y3Rpb25zLlwiKX1zdGF0aWMgYXN5bmMgaGFzQ2FtZXJhKCl7dHJ5e3JldHVybiEhKGF3YWl0IGUubGlzdENhbWVyYXMoITEpKS5sZW5ndGh9Y2F0Y2goYSl7cmV0dXJuITF9fXN0YXRpYyBhc3luYyBsaXN0Q2FtZXJhcyhhPVxuITEpe2lmKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKXJldHVybltdO2xldCBiPWFzeW5jKCk9Pihhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKSkuZmlsdGVyKGQ9PlwidmlkZW9pbnB1dFwiPT09ZC5raW5kKSxjO3RyeXthJiYoYXdhaXQgYigpKS5ldmVyeShkPT4hZC5sYWJlbCkmJihjPWF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHthdWRpbzohMSx2aWRlbzohMH0pKX1jYXRjaChkKXt9dHJ5e3JldHVybihhd2FpdCBiKCkpLm1hcCgoZCxmKT0+KHtpZDpkLmRldmljZUlkLGxhYmVsOmQubGFiZWx8fCgwPT09Zj9cIkRlZmF1bHQgQ2FtZXJhXCI6YENhbWVyYSAke2YrMX1gKX0pKX1maW5hbGx5e2MmJihjb25zb2xlLndhcm4oXCJDYWxsIGxpc3RDYW1lcmFzIGFmdGVyIHN1Y2Nlc3NmdWxseSBzdGFydGluZyBhIFFSIHNjYW5uZXIgdG8gYXZvaWQgY3JlYXRpbmcgYSB0ZW1wb3JhcnkgdmlkZW8gc3RyZWFtXCIpLGUuX3N0b3BWaWRlb1N0cmVhbShjKSl9fWFzeW5jIGhhc0ZsYXNoKCl7bGV0IGE7XG50cnl7aWYodGhpcy4kdmlkZW8uc3JjT2JqZWN0KXtpZighKHRoaXMuJHZpZGVvLnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSlyZXR1cm4hMTthPXRoaXMuJHZpZGVvLnNyY09iamVjdH1lbHNlIGE9KGF3YWl0IHRoaXMuX2dldENhbWVyYVN0cmVhbSgpKS5zdHJlYW07cmV0dXJuXCJ0b3JjaFwiaW4gYS5nZXRWaWRlb1RyYWNrcygpWzBdLmdldFNldHRpbmdzKCl9Y2F0Y2goYil7cmV0dXJuITF9ZmluYWxseXthJiZhIT09dGhpcy4kdmlkZW8uc3JjT2JqZWN0JiYoY29uc29sZS53YXJuKFwiQ2FsbCBoYXNGbGFzaCBhZnRlciBzdWNjZXNzZnVsbHkgc3RhcnRpbmcgdGhlIHNjYW5uZXIgdG8gYXZvaWQgY3JlYXRpbmcgYSB0ZW1wb3JhcnkgdmlkZW8gc3RyZWFtXCIpLGUuX3N0b3BWaWRlb1N0cmVhbShhKSl9fWlzRmxhc2hPbigpe3JldHVybiB0aGlzLl9mbGFzaE9ufWFzeW5jIHRvZ2dsZUZsYXNoKCl7dGhpcy5fZmxhc2hPbj9hd2FpdCB0aGlzLnR1cm5GbGFzaE9mZigpOmF3YWl0IHRoaXMudHVybkZsYXNoT24oKX1hc3luYyB0dXJuRmxhc2hPbigpe2lmKCF0aGlzLl9mbGFzaE9uJiZcbiF0aGlzLl9kZXN0cm95ZWQmJih0aGlzLl9mbGFzaE9uPSEwLHRoaXMuX2FjdGl2ZSYmIXRoaXMuX3BhdXNlZCkpdHJ5e2lmKCFhd2FpdCB0aGlzLmhhc0ZsYXNoKCkpdGhyb3dcIk5vIGZsYXNoIGF2YWlsYWJsZVwiO2F3YWl0IHRoaXMuJHZpZGVvLnNyY09iamVjdC5nZXRWaWRlb1RyYWNrcygpWzBdLmFwcGx5Q29uc3RyYWludHMoe2FkdmFuY2VkOlt7dG9yY2g6ITB9XX0pfWNhdGNoKGEpe3Rocm93IHRoaXMuX2ZsYXNoT249ITEsYTt9fWFzeW5jIHR1cm5GbGFzaE9mZigpe3RoaXMuX2ZsYXNoT24mJih0aGlzLl9mbGFzaE9uPSExLGF3YWl0IHRoaXMuX3Jlc3RhcnRWaWRlb1N0cmVhbSgpKX1kZXN0cm95KCl7dGhpcy4kdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsdGhpcy5fb25Mb2FkZWRNZXRhRGF0YSk7dGhpcy4kdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBsYXlcIix0aGlzLl9vblBsYXkpO2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsXG50aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UpO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5fdXBkYXRlT3ZlcmxheSk7dGhpcy5fZGVzdHJveWVkPSEwO3RoaXMuX2ZsYXNoT249ITE7dGhpcy5zdG9wKCk7ZS5fcG9zdFdvcmtlck1lc3NhZ2UodGhpcy5fcXJFbmdpbmVQcm9taXNlLFwiY2xvc2VcIil9YXN5bmMgc3RhcnQoKXtpZih0aGlzLl9kZXN0cm95ZWQpdGhyb3cgRXJyb3IoXCJUaGUgUVIgc2Nhbm5lciBjYW4gbm90IGJlIHN0YXJ0ZWQgYXMgaXQgaGFkIGJlZW4gZGVzdHJveWVkLlwiKTtpZighdGhpcy5fYWN0aXZlfHx0aGlzLl9wYXVzZWQpaWYoXCJodHRwczpcIiE9PXdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCYmY29uc29sZS53YXJuKFwiVGhlIGNhbWVyYSBzdHJlYW0gaXMgb25seSBhY2Nlc3NpYmxlIGlmIHRoZSBwYWdlIGlzIHRyYW5zZmVycmVkIHZpYSBodHRwcy5cIiksdGhpcy5fYWN0aXZlPSEwLCFkb2N1bWVudC5oaWRkZW4paWYodGhpcy5fcGF1c2VkPVxuITEsdGhpcy4kdmlkZW8uc3JjT2JqZWN0KWF3YWl0IHRoaXMuJHZpZGVvLnBsYXkoKTtlbHNlIHRyeXtsZXQge3N0cmVhbTphLGZhY2luZ01vZGU6Yn09YXdhaXQgdGhpcy5fZ2V0Q2FtZXJhU3RyZWFtKCk7IXRoaXMuX2FjdGl2ZXx8dGhpcy5fcGF1c2VkP2UuX3N0b3BWaWRlb1N0cmVhbShhKToodGhpcy5fc2V0VmlkZW9NaXJyb3IoYiksdGhpcy4kdmlkZW8uc3JjT2JqZWN0PWEsYXdhaXQgdGhpcy4kdmlkZW8ucGxheSgpLHRoaXMuX2ZsYXNoT24mJih0aGlzLl9mbGFzaE9uPSExLHRoaXMudHVybkZsYXNoT24oKS5jYXRjaCgoKT0+e30pKSl9Y2F0Y2goYSl7aWYoIXRoaXMuX3BhdXNlZCl0aHJvdyB0aGlzLl9hY3RpdmU9ITEsYTt9fXN0b3AoKXt0aGlzLnBhdXNlKCk7dGhpcy5fYWN0aXZlPSExfWFzeW5jIHBhdXNlKGE9ITEpe3RoaXMuX3BhdXNlZD0hMDtpZighdGhpcy5fYWN0aXZlKXJldHVybiEwO3RoaXMuJHZpZGVvLnBhdXNlKCk7dGhpcy4kb3ZlcmxheSYmKHRoaXMuJG92ZXJsYXkuc3R5bGUuZGlzcGxheT1cblwibm9uZVwiKTtsZXQgYj0oKT0+e3RoaXMuJHZpZGVvLnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtJiYoZS5fc3RvcFZpZGVvU3RyZWFtKHRoaXMuJHZpZGVvLnNyY09iamVjdCksdGhpcy4kdmlkZW8uc3JjT2JqZWN0PW51bGwpfTtpZihhKXJldHVybiBiKCksITA7YXdhaXQgbmV3IFByb21pc2UoYz0+c2V0VGltZW91dChjLDMwMCkpO2lmKCF0aGlzLl9wYXVzZWQpcmV0dXJuITE7YigpO3JldHVybiEwfWFzeW5jIHNldENhbWVyYShhKXthIT09dGhpcy5fcHJlZmVycmVkQ2FtZXJhJiYodGhpcy5fcHJlZmVycmVkQ2FtZXJhPWEsYXdhaXQgdGhpcy5fcmVzdGFydFZpZGVvU3RyZWFtKCkpfXN0YXRpYyBhc3luYyBzY2FuSW1hZ2UoYSxiLGMsZCxmPSExLGg9ITEpe2xldCBtLG49ITE7YiYmKFwic2NhblJlZ2lvblwiaW4gYnx8XCJxckVuZ2luZVwiaW4gYnx8XCJjYW52YXNcImluIGJ8fFwiZGlzYWxsb3dDYW52YXNSZXNpemluZ1wiaW4gYnx8XCJhbHNvVHJ5V2l0aG91dFNjYW5SZWdpb25cImluXG5ifHxcInJldHVybkRldGFpbGVkU2NhblJlc3VsdFwiaW4gYik/KG09Yi5zY2FuUmVnaW9uLGM9Yi5xckVuZ2luZSxkPWIuY2FudmFzLGY9Yi5kaXNhbGxvd0NhbnZhc1Jlc2l6aW5nfHwhMSxoPWIuYWxzb1RyeVdpdGhvdXRTY2FuUmVnaW9ufHwhMSxuPSEwKTpifHxjfHxkfHxmfHxoP2NvbnNvbGUud2FybihcIllvdSdyZSB1c2luZyBhIGRlcHJlY2F0ZWQgYXBpIGZvciBzY2FuSW1hZ2Ugd2hpY2ggd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXCIpOmNvbnNvbGUud2FybihcIk5vdGUgdGhhdCB0aGUgcmV0dXJuIHR5cGUgb2Ygc2NhbkltYWdlIHdpbGwgY2hhbmdlIGluIHRoZSBmdXR1cmUuIFRvIGFscmVhZHkgc3dpdGNoIHRvIHRoZSBuZXcgYXBpIHRvZGF5LCB5b3UgY2FuIHBhc3MgcmV0dXJuRGV0YWlsZWRTY2FuUmVzdWx0OiB0cnVlLlwiKTtiPSEhYzt0cnl7bGV0IHAsaztbYyxwXT1hd2FpdCBQcm9taXNlLmFsbChbY3x8ZS5jcmVhdGVRckVuZ2luZSgpLGUuX2xvYWRJbWFnZShhKV0pO1xuW2Qsa109ZS5fZHJhd1RvQ2FudmFzKHAsbSxkLGYpO2xldCBxO2lmKGMgaW5zdGFuY2VvZiBXb3JrZXIpe2xldCBnPWM7Ynx8ZS5fcG9zdFdvcmtlck1lc3NhZ2VTeW5jKGcsXCJpbnZlcnNpb25Nb2RlXCIsXCJib3RoXCIpO3E9YXdhaXQgbmV3IFByb21pc2UoKGwsdik9PntsZXQgdyx1LHIseT0tMTt1PXQ9Pnt0LmRhdGEuaWQ9PT15JiYoZy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHUpLGcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsciksY2xlYXJUaW1lb3V0KHcpLG51bGwhPT10LmRhdGEuZGF0YT9sKHtkYXRhOnQuZGF0YS5kYXRhLGNvcm5lclBvaW50czplLl9jb252ZXJ0UG9pbnRzKHQuZGF0YS5jb3JuZXJQb2ludHMsbSl9KTp2KGUuTk9fUVJfQ09ERV9GT1VORCkpfTtyPXQ9PntnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdSk7Zy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixyKTtjbGVhclRpbWVvdXQodyk7dihcIlNjYW5uZXIgZXJyb3I6IFwiKyh0P1xudC5tZXNzYWdlfHx0OlwiVW5rbm93biBFcnJvclwiKSl9O2cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix1KTtnLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLHIpO3c9c2V0VGltZW91dCgoKT0+cihcInRpbWVvdXRcIiksMUU0KTtsZXQgeD1rLmdldEltYWdlRGF0YSgwLDAsZC53aWR0aCxkLmhlaWdodCk7eT1lLl9wb3N0V29ya2VyTWVzc2FnZVN5bmMoZyxcImRlY29kZVwiLHgsW3guZGF0YS5idWZmZXJdKX0pfWVsc2UgcT1hd2FpdCBQcm9taXNlLnJhY2UoW25ldyBQcm9taXNlKChnLGwpPT53aW5kb3cuc2V0VGltZW91dCgoKT0+bChcIlNjYW5uZXIgZXJyb3I6IHRpbWVvdXRcIiksMUU0KSksKGFzeW5jKCk9Pnt0cnl7dmFyIFtnXT1hd2FpdCBjLmRldGVjdChkKTtpZighZyl0aHJvdyBlLk5PX1FSX0NPREVfRk9VTkQ7cmV0dXJue2RhdGE6Zy5yYXdWYWx1ZSxjb3JuZXJQb2ludHM6ZS5fY29udmVydFBvaW50cyhnLmNvcm5lclBvaW50cyxtKX19Y2F0Y2gobCl7Zz1sLm1lc3NhZ2V8fGw7XG5pZigvbm90IGltcGxlbWVudGVkfHNlcnZpY2UgdW5hdmFpbGFibGUvLnRlc3QoZykpcmV0dXJuIGUuX2Rpc2FibGVCYXJjb2RlRGV0ZWN0b3I9ITAsZS5zY2FuSW1hZ2UoYSx7c2NhblJlZ2lvbjptLGNhbnZhczpkLGRpc2FsbG93Q2FudmFzUmVzaXppbmc6ZixhbHNvVHJ5V2l0aG91dFNjYW5SZWdpb246aH0pO3Rocm93YFNjYW5uZXIgZXJyb3I6ICR7Z31gO319KSgpXSk7cmV0dXJuIG4/cTpxLmRhdGF9Y2F0Y2gocCl7aWYoIW18fCFoKXRocm93IHA7bGV0IGs9YXdhaXQgZS5zY2FuSW1hZ2UoYSx7cXJFbmdpbmU6YyxjYW52YXM6ZCxkaXNhbGxvd0NhbnZhc1Jlc2l6aW5nOmZ9KTtyZXR1cm4gbj9rOmsuZGF0YX1maW5hbGx5e2J8fGUuX3Bvc3RXb3JrZXJNZXNzYWdlKGMsXCJjbG9zZVwiKX19c2V0R3JheXNjYWxlV2VpZ2h0cyhhLGIsYyxkPSEwKXtlLl9wb3N0V29ya2VyTWVzc2FnZSh0aGlzLl9xckVuZ2luZVByb21pc2UsXCJncmF5c2NhbGVXZWlnaHRzXCIse3JlZDphLGdyZWVuOmIsXG5ibHVlOmMsdXNlSW50ZWdlckFwcHJveGltYXRpb246ZH0pfXNldEludmVyc2lvbk1vZGUoYSl7ZS5fcG9zdFdvcmtlck1lc3NhZ2UodGhpcy5fcXJFbmdpbmVQcm9taXNlLFwiaW52ZXJzaW9uTW9kZVwiLGEpfXN0YXRpYyBhc3luYyBjcmVhdGVRckVuZ2luZShhKXthJiZjb25zb2xlLndhcm4oXCJTcGVjaWZ5aW5nIGEgd29ya2VyIHBhdGggaXMgbm90IHJlcXVpcmVkIGFuZCBub3Qgc3VwcG9ydGVkIGFueW1vcmUuXCIpO2E9KCk9PmltcG9ydChcIi4vcXItc2Nhbm5lci13b3JrZXIubWluLmpzXCIpLnRoZW4oYz0+Yy5jcmVhdGVXb3JrZXIoKSk7aWYoISghZS5fZGlzYWJsZUJhcmNvZGVEZXRlY3RvciYmXCJCYXJjb2RlRGV0ZWN0b3JcImluIHdpbmRvdyYmQmFyY29kZURldGVjdG9yLmdldFN1cHBvcnRlZEZvcm1hdHMmJihhd2FpdCBCYXJjb2RlRGV0ZWN0b3IuZ2V0U3VwcG9ydGVkRm9ybWF0cygpKS5pbmNsdWRlcyhcInFyX2NvZGVcIikpKXJldHVybiBhKCk7bGV0IGI9bmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5yZXR1cm4gYiYmYi5icmFuZHMuc29tZSgoe2JyYW5kOmN9KT0+L0Nocm9taXVtL2kudGVzdChjKSkmJi9tYWMgP09TL2kudGVzdChiLnBsYXRmb3JtKSYmYXdhaXQgYi5nZXRIaWdoRW50cm9weVZhbHVlcyhbXCJhcmNoaXRlY3R1cmVcIixcInBsYXRmb3JtVmVyc2lvblwiXSkudGhlbigoe2FyY2hpdGVjdHVyZTpjLHBsYXRmb3JtVmVyc2lvbjpkfSk9Pi9hcm0vaS50ZXN0KGN8fFwiYXJtXCIpJiYxMzw9cGFyc2VJbnQoZHx8XCIxM1wiKSkuY2F0Y2goKCk9PiEwKT9hKCk6bmV3IEJhcmNvZGVEZXRlY3Rvcih7Zm9ybWF0czpbXCJxcl9jb2RlXCJdfSl9X29uUGxheSgpe3RoaXMuX3NjYW5SZWdpb249dGhpcy5fY2FsY3VsYXRlU2NhblJlZ2lvbih0aGlzLiR2aWRlbyk7dGhpcy5fdXBkYXRlT3ZlcmxheSgpO3RoaXMuJG92ZXJsYXkmJih0aGlzLiRvdmVybGF5LnN0eWxlLmRpc3BsYXk9XCJcIik7dGhpcy5fc2NhbkZyYW1lKCl9X29uTG9hZGVkTWV0YURhdGEoKXt0aGlzLl9zY2FuUmVnaW9uPXRoaXMuX2NhbGN1bGF0ZVNjYW5SZWdpb24odGhpcy4kdmlkZW8pO1xudGhpcy5fdXBkYXRlT3ZlcmxheSgpfV9vblZpc2liaWxpdHlDaGFuZ2UoKXtkb2N1bWVudC5oaWRkZW4/dGhpcy5wYXVzZSgpOnRoaXMuX2FjdGl2ZSYmdGhpcy5zdGFydCgpfV9jYWxjdWxhdGVTY2FuUmVnaW9uKGEpe2xldCBiPU1hdGgucm91bmQoMi8zKk1hdGgubWluKGEudmlkZW9XaWR0aCxhLnZpZGVvSGVpZ2h0KSk7cmV0dXJue3g6TWF0aC5yb3VuZCgoYS52aWRlb1dpZHRoLWIpLzIpLHk6TWF0aC5yb3VuZCgoYS52aWRlb0hlaWdodC1iKS8yKSx3aWR0aDpiLGhlaWdodDpiLGRvd25TY2FsZWRXaWR0aDp0aGlzLl9sZWdhY3lDYW52YXNTaXplLGRvd25TY2FsZWRIZWlnaHQ6dGhpcy5fbGVnYWN5Q2FudmFzU2l6ZX19X3VwZGF0ZU92ZXJsYXkoKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PntpZih0aGlzLiRvdmVybGF5KXt2YXIgYT10aGlzLiR2aWRlbyxiPWEudmlkZW9XaWR0aCxjPWEudmlkZW9IZWlnaHQsZD1hLm9mZnNldFdpZHRoLGY9YS5vZmZzZXRIZWlnaHQsaD1hLm9mZnNldExlZnQsXG5tPWEub2Zmc2V0VG9wLG49d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSkscD1uLm9iamVjdEZpdCxrPWIvYyxxPWQvZjtzd2l0Y2gocCl7Y2FzZSBcIm5vbmVcIjp2YXIgZz1iO3ZhciBsPWM7YnJlYWs7Y2FzZSBcImZpbGxcIjpnPWQ7bD1mO2JyZWFrO2RlZmF1bHQ6KFwiY292ZXJcIj09PXA/az5xOms8cSk/KGw9ZixnPWwqayk6KGc9ZCxsPWcvayksXCJzY2FsZS1kb3duXCI9PT1wJiYoZz1NYXRoLm1pbihnLGIpLGw9TWF0aC5taW4obCxjKSl9dmFyIFt2LHddPW4ub2JqZWN0UG9zaXRpb24uc3BsaXQoXCIgXCIpLm1hcCgocix5KT0+e2NvbnN0IHg9cGFyc2VGbG9hdChyKTtyZXR1cm4gci5lbmRzV2l0aChcIiVcIik/KHk/Zi1sOmQtZykqeC8xMDA6eH0pO249dGhpcy5fc2NhblJlZ2lvbi53aWR0aHx8YjtxPXRoaXMuX3NjYW5SZWdpb24uaGVpZ2h0fHxjO3A9dGhpcy5fc2NhblJlZ2lvbi54fHwwO3ZhciB1PXRoaXMuX3NjYW5SZWdpb24ueXx8MDtrPXRoaXMuJG92ZXJsYXkuc3R5bGU7ay53aWR0aD1cbmAke24vYipnfXB4YDtrLmhlaWdodD1gJHtxL2MqbH1weGA7ay50b3A9YCR7bSt3K3UvYypsfXB4YDtjPS9zY2FsZVhcXCgtMVxcKS8udGVzdChhLnN0eWxlLnRyYW5zZm9ybSk7ay5sZWZ0PWAke2grKGM/ZC12LWc6dikrKGM/Yi1wLW46cCkvYipnfXB4YDtrLnRyYW5zZm9ybT1hLnN0eWxlLnRyYW5zZm9ybX19KX1zdGF0aWMgX2NvbnZlcnRQb2ludHMoYSxiKXtpZighYilyZXR1cm4gYTtsZXQgYz1iLnh8fDAsZD1iLnl8fDAsZj1iLndpZHRoJiZiLmRvd25TY2FsZWRXaWR0aD9iLndpZHRoL2IuZG93blNjYWxlZFdpZHRoOjE7Yj1iLmhlaWdodCYmYi5kb3duU2NhbGVkSGVpZ2h0P2IuaGVpZ2h0L2IuZG93blNjYWxlZEhlaWdodDoxO2ZvcihsZXQgaCBvZiBhKWgueD1oLngqZitjLGgueT1oLnkqYitkO3JldHVybiBhfV9zY2FuRnJhbWUoKXshdGhpcy5fYWN0aXZlfHx0aGlzLiR2aWRlby5wYXVzZWR8fHRoaXMuJHZpZGVvLmVuZGVkfHwoXCJyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrXCJpblxudGhpcy4kdmlkZW8/dGhpcy4kdmlkZW8ucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjay5iaW5kKHRoaXMuJHZpZGVvKTpyZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKGFzeW5jKCk9PntpZighKDE+PXRoaXMuJHZpZGVvLnJlYWR5U3RhdGUpKXt2YXIgYT1EYXRlLm5vdygpLXRoaXMuX2xhc3RTY2FuVGltZXN0YW1wLGI9MUUzL3RoaXMuX21heFNjYW5zUGVyU2Vjb25kO2E8YiYmYXdhaXQgbmV3IFByb21pc2UoZD0+c2V0VGltZW91dChkLGItYSkpO3RoaXMuX2xhc3RTY2FuVGltZXN0YW1wPURhdGUubm93KCk7dHJ5e3ZhciBjPWF3YWl0IGUuc2NhbkltYWdlKHRoaXMuJHZpZGVvLHtzY2FuUmVnaW9uOnRoaXMuX3NjYW5SZWdpb24scXJFbmdpbmU6dGhpcy5fcXJFbmdpbmVQcm9taXNlLGNhbnZhczp0aGlzLiRjYW52YXN9KX1jYXRjaChkKXtpZighdGhpcy5fYWN0aXZlKXJldHVybjt0aGlzLl9vbkRlY29kZUVycm9yKGQpfSFlLl9kaXNhYmxlQmFyY29kZURldGVjdG9yfHxhd2FpdCB0aGlzLl9xckVuZ2luZVByb21pc2UgaW5zdGFuY2VvZlxuV29ya2VyfHwodGhpcy5fcXJFbmdpbmVQcm9taXNlPWUuY3JlYXRlUXJFbmdpbmUoKSk7Yz8odGhpcy5fb25EZWNvZGU/dGhpcy5fb25EZWNvZGUoYyk6dGhpcy5fbGVnYWN5T25EZWNvZGUmJnRoaXMuX2xlZ2FjeU9uRGVjb2RlKGMuZGF0YSksdGhpcy4kY29kZU91dGxpbmVIaWdobGlnaHQmJihjbGVhclRpbWVvdXQodGhpcy5fY29kZU91dGxpbmVIaWdobGlnaHRSZW1vdmFsVGltZW91dCksdGhpcy5fY29kZU91dGxpbmVIaWdobGlnaHRSZW1vdmFsVGltZW91dD12b2lkIDAsdGhpcy4kY29kZU91dGxpbmVIaWdobGlnaHQuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLGAke3RoaXMuX3NjYW5SZWdpb24ueHx8MH0gYCtgJHt0aGlzLl9zY2FuUmVnaW9uLnl8fDB9IGArYCR7dGhpcy5fc2NhblJlZ2lvbi53aWR0aHx8dGhpcy4kdmlkZW8udmlkZW9XaWR0aH0gYCtgJHt0aGlzLl9zY2FuUmVnaW9uLmhlaWdodHx8dGhpcy4kdmlkZW8udmlkZW9IZWlnaHR9YCksdGhpcy4kY29kZU91dGxpbmVIaWdobGlnaHQuZmlyc3RFbGVtZW50Q2hpbGQuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsXG5jLmNvcm5lclBvaW50cy5tYXAoKHt4OmQseTpmfSk9PmAke2R9LCR7Zn1gKS5qb2luKFwiIFwiKSksdGhpcy4kY29kZU91dGxpbmVIaWdobGlnaHQuc3R5bGUuZGlzcGxheT1cIlwiKSk6dGhpcy4kY29kZU91dGxpbmVIaWdobGlnaHQmJiF0aGlzLl9jb2RlT3V0bGluZUhpZ2hsaWdodFJlbW92YWxUaW1lb3V0JiYodGhpcy5fY29kZU91dGxpbmVIaWdobGlnaHRSZW1vdmFsVGltZW91dD1zZXRUaW1lb3V0KCgpPT50aGlzLiRjb2RlT3V0bGluZUhpZ2hsaWdodC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLDEwMCkpfXRoaXMuX3NjYW5GcmFtZSgpfSl9X29uRGVjb2RlRXJyb3IoYSl7YSE9PWUuTk9fUVJfQ09ERV9GT1VORCYmY29uc29sZS5sb2coYSl9YXN5bmMgX2dldENhbWVyYVN0cmVhbSgpe2lmKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKXRocm93XCJDYW1lcmEgbm90IGZvdW5kLlwiO2xldCBhPS9eKGVudmlyb25tZW50fHVzZXIpJC8udGVzdCh0aGlzLl9wcmVmZXJyZWRDYW1lcmEpP1wiZmFjaW5nTW9kZVwiOlxuXCJkZXZpY2VJZFwiLGI9W3t3aWR0aDp7bWluOjEwMjR9fSx7d2lkdGg6e21pbjo3Njh9fSx7fV0sYz1iLm1hcChkPT5PYmplY3QuYXNzaWduKHt9LGQse1thXTp7ZXhhY3Q6dGhpcy5fcHJlZmVycmVkQ2FtZXJhfX0pKTtmb3IobGV0IGQgb2ZbLi4uYywuLi5iXSl0cnl7bGV0IGY9YXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe3ZpZGVvOmQsYXVkaW86ITF9KSxoPXRoaXMuX2dldEZhY2luZ01vZGUoZil8fChkLmZhY2luZ01vZGU/dGhpcy5fcHJlZmVycmVkQ2FtZXJhOlwiZW52aXJvbm1lbnRcIj09PXRoaXMuX3ByZWZlcnJlZENhbWVyYT9cInVzZXJcIjpcImVudmlyb25tZW50XCIpO3JldHVybntzdHJlYW06ZixmYWNpbmdNb2RlOmh9fWNhdGNoKGYpe310aHJvd1wiQ2FtZXJhIG5vdCBmb3VuZC5cIjt9YXN5bmMgX3Jlc3RhcnRWaWRlb1N0cmVhbSgpe2xldCBhPXRoaXMuX3BhdXNlZDthd2FpdCB0aGlzLnBhdXNlKCEwKSYmIWEmJnRoaXMuX2FjdGl2ZSYmYXdhaXQgdGhpcy5zdGFydCgpfXN0YXRpYyBfc3RvcFZpZGVvU3RyZWFtKGEpe2ZvcihsZXQgYiBvZiBhLmdldFRyYWNrcygpKWIuc3RvcCgpLFxuYS5yZW1vdmVUcmFjayhiKX1fc2V0VmlkZW9NaXJyb3IoYSl7dGhpcy4kdmlkZW8uc3R5bGUudHJhbnNmb3JtPVwic2NhbGVYKFwiKyhcInVzZXJcIj09PWE/LTE6MSkrXCIpXCJ9X2dldEZhY2luZ01vZGUoYSl7cmV0dXJuKGE9YS5nZXRWaWRlb1RyYWNrcygpWzBdKT8vcmVhcnxiYWNrfGVudmlyb25tZW50L2kudGVzdChhLmxhYmVsKT9cImVudmlyb25tZW50XCI6L2Zyb250fHVzZXJ8ZmFjZS9pLnRlc3QoYS5sYWJlbCk/XCJ1c2VyXCI6bnVsbDpudWxsfXN0YXRpYyBfZHJhd1RvQ2FudmFzKGEsYixjLGQ9ITEpe2M9Y3x8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtsZXQgZj1iJiZiLng/Yi54OjAsaD1iJiZiLnk/Yi55OjAsbT1iJiZiLndpZHRoP2Iud2lkdGg6YS52aWRlb1dpZHRofHxhLndpZHRoLG49YiYmYi5oZWlnaHQ/Yi5oZWlnaHQ6YS52aWRlb0hlaWdodHx8YS5oZWlnaHQ7ZHx8KGQ9YiYmYi5kb3duU2NhbGVkV2lkdGg/Yi5kb3duU2NhbGVkV2lkdGg6bSxiPWImJmIuZG93blNjYWxlZEhlaWdodD9cbmIuZG93blNjYWxlZEhlaWdodDpuLGMud2lkdGghPT1kJiYoYy53aWR0aD1kKSxjLmhlaWdodCE9PWImJihjLmhlaWdodD1iKSk7Yj1jLmdldENvbnRleHQoXCIyZFwiLHthbHBoYTohMX0pO2IuaW1hZ2VTbW9vdGhpbmdFbmFibGVkPSExO2IuZHJhd0ltYWdlKGEsZixoLG0sbiwwLDAsYy53aWR0aCxjLmhlaWdodCk7cmV0dXJuW2MsYl19c3RhdGljIGFzeW5jIF9sb2FkSW1hZ2UoYSl7aWYoYSBpbnN0YW5jZW9mIEltYWdlKXJldHVybiBhd2FpdCBlLl9hd2FpdEltYWdlTG9hZChhKSxhO2lmKGEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50fHxhIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fGEgaW5zdGFuY2VvZiBTVkdJbWFnZUVsZW1lbnR8fFwiT2Zmc2NyZWVuQ2FudmFzXCJpbiB3aW5kb3cmJmEgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXN8fFwiSW1hZ2VCaXRtYXBcImluIHdpbmRvdyYmYSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKXJldHVybiBhO2lmKGEgaW5zdGFuY2VvZlxuRmlsZXx8YSBpbnN0YW5jZW9mIEJsb2J8fGEgaW5zdGFuY2VvZiBVUkx8fFwic3RyaW5nXCI9PT10eXBlb2YgYSl7bGV0IGI9bmV3IEltYWdlO2Iuc3JjPWEgaW5zdGFuY2VvZiBGaWxlfHxhIGluc3RhbmNlb2YgQmxvYj9VUkwuY3JlYXRlT2JqZWN0VVJMKGEpOmEudG9TdHJpbmcoKTt0cnl7cmV0dXJuIGF3YWl0IGUuX2F3YWl0SW1hZ2VMb2FkKGIpLGJ9ZmluYWxseXsoYSBpbnN0YW5jZW9mIEZpbGV8fGEgaW5zdGFuY2VvZiBCbG9iKSYmVVJMLnJldm9rZU9iamVjdFVSTChiLnNyYyl9fWVsc2UgdGhyb3dcIlVuc3VwcG9ydGVkIGltYWdlIHR5cGUuXCI7fXN0YXRpYyBhc3luYyBfYXdhaXRJbWFnZUxvYWQoYSl7YS5jb21wbGV0ZSYmMCE9PWEubmF0dXJhbFdpZHRofHxhd2FpdCBuZXcgUHJvbWlzZSgoYixjKT0+e2xldCBkPWY9PnthLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZCk7YS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixkKTtmIGluc3RhbmNlb2YgRXJyb3JFdmVudD9cbmMoXCJJbWFnZSBsb2FkIGVycm9yXCIpOmIoKX07YS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGQpO2EuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsZCl9KX1zdGF0aWMgYXN5bmMgX3Bvc3RXb3JrZXJNZXNzYWdlKGEsYixjLGQpe3JldHVybiBlLl9wb3N0V29ya2VyTWVzc2FnZVN5bmMoYXdhaXQgYSxiLGMsZCl9c3RhdGljIF9wb3N0V29ya2VyTWVzc2FnZVN5bmMoYSxiLGMsZCl7aWYoIShhIGluc3RhbmNlb2YgV29ya2VyKSlyZXR1cm4tMTtsZXQgZj1lLl93b3JrZXJNZXNzYWdlSWQrKzthLnBvc3RNZXNzYWdlKHtpZDpmLHR5cGU6YixkYXRhOmN9LGQpO3JldHVybiBmfX1lLkRFRkFVTFRfQ0FOVkFTX1NJWkU9NDAwO2UuTk9fUVJfQ09ERV9GT1VORD1cIk5vIFFSIGNvZGUgZm91bmRcIjtlLl9kaXNhYmxlQmFyY29kZURldGVjdG9yPSExO2UuX3dvcmtlck1lc3NhZ2VJZD0wO2V4cG9ydCBkZWZhdWx0IGVcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXFyLXNjYW5uZXIubWluLmpzLm1hcFxuIiwiaW1wb3J0IHsgd2ViVmlld0Vycm9yIH0gZnJvbSBcIi4vY29tbW9uXCI7XG5pbXBvcnQgUXJTY2FubmVyIGZyb20gJ3FyLXNjYW5uZXInO1xuaW1wb3J0IFFSQ29kZSBmcm9tICdxcmNvZGUnO1xubGV0IHFyU2Nhbm5lciA9IG51bGw7XG4vLyBTdGFydCB0aGUgUVIgU2Nhbm5lclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UVJTY2FubmVyKHNjYW5SZXN1bHRIYW5kbGVyKSB7XG4gICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FtZXJhLXZpZGVvJyk7XG4gICAgY29uc3QgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FtZXJhLW1vZGFsJyk7XG4gICAgaWYgKCF2aWRlbyB8fCAhbW9kYWwpIHtcbiAgICAgICAgd2ViVmlld0Vycm9yKCdDYW1lcmEgZWxlbWVudHMgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU2hvdyBtb2RhbCBmaXJzdFxuICAgIG1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgIC8vIENoZWNrIGluaXRpYWwgc3RhdGUgb2YgZmFsbGJhY2sgVUlcbiAgICBjb25zdCBmYWxsYmFjayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduby1jYW1lcmEtZmFsbGJhY2snKTtcbiAgICBpZiAoZmFsbGJhY2sgJiYgIWZhbGxiYWNrLmNsYXNzTGlzdC5jb250YWlucygnaGlkZGVuJykpIHtcbiAgICAgICAgaGlkZU5vQ2FtZXJhRmFsbGJhY2soKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ3JlYXRlIFFSIHNjYW5uZXIgLSB0aGlzIHdpbGwgZmFpbCBpZiBubyBjYW1lcmEgaXMgYXZhaWxhYmxlXG4gICAgICAgIHFyU2Nhbm5lciA9IG5ldyBRclNjYW5uZXIodmlkZW8sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHNjYW5SZXN1bHRIYW5kbGVyKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb25EZWNvZGVFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU2lsZW50bHkgaGFuZGxlIGRlY29kZSBlcnJvcnMgKG5vcm1hbCBkdXJpbmcgc2Nhbm5pbmcpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBxclNjYW5uZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdlYlZpZXdFcnJvcignRXJyb3Igc3RhcnRpbmcgUVIgc2Nhbm5lcjonLCBlcnJvcik7XG4gICAgICAgIHNob3dOb0NhbWVyYUZhbGxiYWNrKCk7XG4gICAgfVxufVxuLy8gU3RvcCB0aGUgUVIgc2Nhbm5lclxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BRUlNjYW5uZXIoZm9yY2VDbG9zZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FtZXJhLW1vZGFsJyk7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbm8tY2FtZXJhLWZhbGxiYWNrJyk7XG4gICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FtZXJhLXZpZGVvJyk7XG4gICAgaWYgKHFyU2Nhbm5lcikge1xuICAgICAgICBxclNjYW5uZXIuc3RvcCgpO1xuICAgICAgICBxclNjYW5uZXIuZGVzdHJveSgpO1xuICAgICAgICBxclNjYW5uZXIgPSBudWxsO1xuICAgIH1cbiAgICAvLyBQcm9wZXJseSBjbGVhbiB1cCB0aGUgdmlkZW8gZWxlbWVudCB0byBwcmV2ZW50IG1lZGlhIHBsYXllciBvdmVybGF5XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICAgIC8vIFN0b3AgYWxsIHZpZGVvIHRyYWNrc1xuICAgICAgICBpZiAodmlkZW8uc3JjT2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB2aWRlby5zcmNPYmplY3Q7XG4gICAgICAgICAgICBpZiAoc3RyZWFtICYmIHN0cmVhbS5nZXRUcmFja3MpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciB0aGUgdmlkZW8gc291cmNlXG4gICAgICAgIHZpZGVvLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgIHZpZGVvLnNyYyA9ICcnO1xuICAgICAgICB2aWRlby5sb2FkKCk7IC8vIFJlc2V0IHRoZSB2aWRlbyBlbGVtZW50XG4gICAgICAgIC8vIFBhdXNlIHRoZSB2aWRlb1xuICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgIH1cbiAgICAvLyBDbG9zZSBtb2RhbCBpZiBmb3JjZUNsb3NlIGlzIHRydWUgT1IgaWYgZmFsbGJhY2sgaXMgbm90IHZpc2libGVcbiAgICBpZiAobW9kYWwgJiYgKGZvcmNlQ2xvc2UgfHwgIWZhbGxiYWNrIHx8IGZhbGxiYWNrLmNsYXNzTGlzdC5jb250YWlucygnaGlkZGVuJykpKSB7XG4gICAgICAgIG1vZGFsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIH1cbn1cbi8vIFNob3cgbm8gY2FtZXJhIGZhbGxiYWNrIFVJXG5mdW5jdGlvbiBzaG93Tm9DYW1lcmFGYWxsYmFjaygpIHtcbiAgICBjb25zdCBmYWxsYmFjayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduby1jYW1lcmEtZmFsbGJhY2snKTtcbiAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW1lcmEtdmlkZW8nKTtcbiAgICBjb25zdCBzY2FuT3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zY2FuLW92ZXJsYXknKTtcbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgLy8gSGlkZSB2aWRlbyBhbmQgc2NhbiBvdmVybGF5XG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgICAgdmlkZW8uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbk92ZXJsYXkpIHtcbiAgICAgICAgICAgIHNjYW5PdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvdyBmYWxsYmFjayBVSVxuICAgICAgICBmYWxsYmFjay5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICB9XG59XG4vLyBIaWRlIG5vIGNhbWVyYSBmYWxsYmFjayBVSVxuZXhwb3J0IGZ1bmN0aW9uIGhpZGVOb0NhbWVyYUZhbGxiYWNrKCkge1xuICAgIGNvbnN0IGZhbGxiYWNrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vLWNhbWVyYS1mYWxsYmFjaycpO1xuICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbWVyYS12aWRlbycpO1xuICAgIGNvbnN0IHNjYW5PdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNjYW4tb3ZlcmxheScpO1xuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAvLyBIaWRlIGZhbGxiYWNrIFVJXG4gICAgICAgIGZhbGxiYWNrLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAvLyBSZXN0b3JlIHZpZGVvIGFuZCBzY2FuIG92ZXJsYXlcbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICB2aWRlby5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbk92ZXJsYXkpIHtcbiAgICAgICAgICAgIHNjYW5PdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gUmVuZGVyIHRoZSBRUiBjb2RlIGZvciBhbiBhZGRyZXNzXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVRUkNvZGUoYWRkcmVzcykge1xuICAgIGNvbnN0IHFyQ29kZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3FyLWNvZGUnKTtcbiAgICBxckNvZGVFbC5pbm5lckhUTUwgPSAnJztcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBxckNvZGVFbC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIFFSQ29kZS50b0NhbnZhcyhjYW52YXMsIGFkZHJlc3MsIHtcbiAgICAgICAgd2lkdGg6IDIwMCxcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgIGRhcms6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIGxpZ2h0OiAnI0ZGRkZGRidcbiAgICAgICAgfVxuICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdlYlZpZXdFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIFFSIGNvZGU6JywgZXJyb3IpO1xuICAgICAgICAgICAgcXJDb2RlRWwuaW5uZXJIVE1MID0gJzxwIHN0eWxlPVwiY29sb3I6ICNmZjZiNmI7XCI+UVIgQ29kZSBnZW5lcmF0aW9uIGZhaWxlZDwvcD4nO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBpc1ZhbGlkRUNhc2hBZGRyZXNzIH0gZnJvbSAnLi9hZGRyZXNzJztcbmltcG9ydCB7IHNhdHNUb1hlYyB9IGZyb20gJy4vYW1vdW50Jztcbi8qKlxuICogQ3JlYXRlIGEgQklQMjEgVVJJIGZyb20gYW4gYWRkcmVzcyBhbmQgb3B0aW9uYWwgYW1vdW50XG4gKlxuICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgZUNhc2ggYWRkcmVzcyAobWF5IGluY2x1ZGUgbmV0d29yayBwcmVmaXggbGlrZSBcImVjdGVzdDpcIiBvciBcImVjYXNoOlwiKVxuICogQHBhcmFtIGFtb3VudFNhdHMgLSBPcHRpb25hbCBhbW91bnQgaW4gc2F0b3NoaXMgKHdpbGwgYmUgY29udmVydGVkIHRvIFhFQyBpbiB0aGUgVVJJKVxuICogQHJldHVybnMgQSBCSVAyMSBVUkkgc3RyaW5nIChlLmcuLCBcImVjYXNoOmFkZHJlc3NcIiBvciBcImVjYXNoOmFkZHJlc3M/YW1vdW50PTEwMC4wMFwiKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmlwMjFVcmkoYWRkcmVzcywgYW1vdW50U2F0cykge1xuICAgIC8vIFN0cmlwIGFueSBleGlzdGluZyBwcmVmaXggdG8gZ2V0IHRoZSByYXcgYWRkcmVzc1xuICAgIGNvbnN0IHJhd0FkZHJlc3MgPSBhZGRyZXNzLmluY2x1ZGVzKCc6JykgPyBhZGRyZXNzLnNwbGl0KCc6JylbMV0gOiBhZGRyZXNzO1xuICAgIC8vIEJ1aWxkIEJJUDIxIFVSSSB3aXRoIGNvbmZpZyBwcmVmaXhcbiAgICBsZXQgYmlwMjFVcmkgPSBjb25maWcuYmlwMjFQcmVmaXggKyByYXdBZGRyZXNzO1xuICAgIC8vIEFkZCBhbW91bnQgcGFyYW1ldGVyIGlmIHByb3ZpZGVkIGFuZCBwb3NpdGl2ZVxuICAgIGlmIChhbW91bnRTYXRzICYmIGFtb3VudFNhdHMgPiAwKSB7XG4gICAgICAgIC8vIENvbnZlcnQgc2F0b3NoaXMgdG8gWEVDIHVzaW5nIHRoZSBzdGFuZGFyZCBjb252ZXJzaW9uIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IGFtb3VudFhlYyA9IHNhdHNUb1hlYyhhbW91bnRTYXRzKTtcbiAgICAgICAgLy8gRm9ybWF0IHdpdGggMiBkZWNpbWFsIHBsYWNlc1xuICAgICAgICBiaXAyMVVyaSArPSBgP2Ftb3VudD0ke2Ftb3VudFhlYy50b0ZpeGVkKDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBiaXAyMVVyaTtcbn1cbi8qKlxuICogUGFyc2UgYSBCSVAyMSBVUkkgc3RyaW5nXG4gKlxuICogU3VwcG9ydHMgc2ltcGxpZmllZCBCSVAyMSBmb3JtYXQgZm9yIGVDYXNoOlxuICogLSBhbHdheXMgc3RhcnRzIHdpdGggZWNhc2g6IGV2ZW4gZm9yIG90aGVyIHByZWZpeGVkIGFkZHJlc3Nlc1xuICogLSBPcHRpb25hbCBhbW91bnQgcGFyYW1ldGVyIChlLmcuLCA/YW1vdW50PTEwMC40MilcbiAqIC0gQWxsIG90aGVyIHF1ZXJ5IHBhcmFtZXRlcnMgYXJlIGlnbm9yZWRcbiAqXG4gKiBAcGFyYW0gdXJpIC0gVGhlIFVSSSBzdHJpbmcgdG8gcGFyc2UgKGUuZy4sIFwiZWNhc2g6cHJmaGNueXFubDVjZ3JubWxmbW1zNjc1dzkzbGQ3bXZ2cWQweThsejA3P2Ftb3VudD0xMDAuNDJcIilcbiAqIEByZXR1cm5zIFBhcnNlZCByZXN1bHQgd2l0aCBhZGRyZXNzIGFuZCBvcHRpb25hbCBhbW91bnQsIG9yIG51bGwgaWYgaW52YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCaXAyMVVyaSh1cmkpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBQYXJzZSB0aGUgVVJJIHVzaW5nIFVSTCBBUElcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh1cmkpO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm90b2NvbCBtYXRjaGVzIHRoZSBleHBlY3RlZCBCSVAyMSBwcmVmaXhcbiAgICAgICAgaWYgKHVybC5wcm90b2NvbCAhPT0gY29uZmlnLmJpcDIxUHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcGF0aG5hbWUgYWxyZWFkeSBoYXMgdGhlIGV4cGVjdGVkIHByZWZpeCAoZS5nLiwgXCJlY3Rlc3Q6YWRkcmVzc1wiKVxuICAgICAgICAvLyBJZiBub3QsIGFkZCB0aGUgY29uZmlndXJlZCBwcmVmaXhcbiAgICAgICAgbGV0IGFkZHJlc3NQYXJ0ID0gdXJsLnBhdGhuYW1lO1xuICAgICAgICBpZiAoIWFkZHJlc3NQYXJ0LnN0YXJ0c1dpdGgoY29uZmlnLmFkZHJlc3NQcmVmaXggKyAnOicpKSB7XG4gICAgICAgICAgICBhZGRyZXNzUGFydCA9IGNvbmZpZy5hZGRyZXNzUHJlZml4ICsgJzonICsgYWRkcmVzc1BhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGFkZHJlc3MgKHRoaXMgd2lsbCBjYXRjaCBpbnZhbGlkIGZvcm1hdHMgbGlrZSBlY2FzaDovL2FkZHJlc3Mgd2l0aCBsZWFkaW5nIHNsYXNoKVxuICAgICAgICBpZiAoIWlzVmFsaWRFQ2FzaEFkZHJlc3MoYWRkcmVzc1BhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzUGFydCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUGFyc2UgdGhlIGFtb3VudCBwYXJhbWV0ZXIgaWYgcHJlc2VudC4gVGhpcyBpcyB0aGUgb25seSBwYXJhbWV0ZXIgc3VwcG9ydGVkIGJ5IHRoaXMgd2FsbGV0LlxuICAgICAgICAvLyBBbW91bnQgaW4gQklQMjEgaXMgc3BlY2lmaWVkIGluIFhFQywgd2UgY29udmVydCB0byBzYXRvc2hpcyAoMSBYRUMgPSAxMDAgc2F0cylcbiAgICAgICAgY29uc3QgYW1vdW50UGFyYW0gPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgnYW1vdW50Jyk7XG4gICAgICAgIGlmIChhbW91bnRQYXJhbSkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYXMgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIChYRUMpXG4gICAgICAgICAgICBjb25zdCBhbW91bnRYZWMgPSBwYXJzZUZsb2F0KGFtb3VudFBhcmFtKTtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgaXQncyBhIHZhbGlkIG51bWJlciBhbmQgcG9zaXRpdmVcbiAgICAgICAgICAgIGlmICghaXNOYU4oYW1vdW50WGVjKSAmJiBhbW91bnRYZWMgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBYRUMgdG8gc2F0b3NoaXMgKDEgWEVDID0gMTAwIHNhdHMpIGFuZCBlbnN1cmUgaXQncyBhbiBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNhdHMgPSBNYXRoLnJvdW5kKGFtb3VudFhlYyAqIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9tYWluLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xub3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL21haW4uY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSU1QT1JUU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnZWNhc2gtd2FsbGV0JztcbmltcG9ydCB7IENocm9uaWtDbGllbnQgfSBmcm9tICdjaHJvbmlrLWNsaWVudCc7XG5pbXBvcnQgeyBERUZBVUxUX0RVU1RfU0FUUyB9IGZyb20gJ2VjYXNoLWxpYic7XG5pbXBvcnQgUHVsbFRvUmVmcmVzaCBmcm9tICdwdWxsdG9yZWZyZXNoanMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25IaXN0b3J5TWFuYWdlciB9IGZyb20gJy4vdHJhbnNhY3Rpb24taGlzdG9yeSc7XG5pbXBvcnQgeyBzZW5kTWVzc2FnZVRvQmFja2VuZCwgd2ViVmlld0xvZywgd2ViVmlld0Vycm9yIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgY2FsY3VsYXRlVHJhbnNhY3Rpb25BbW91bnRTYXRzLCBzYXRzVG9YZWMsIGNhbGN1bGF0ZU1heFNwZW5kYWJsZUFtb3VudCwgZXN0aW1hdGVUcmFuc2FjdGlvbkZlZSB9IGZyb20gJy4vYW1vdW50JztcbmltcG9ydCB7IGdldEFkZHJlc3MsIHNlbmRUcmFuc2FjdGlvbiB9IGZyb20gJy4vd2FsbGV0JztcbmltcG9ydCB7IGdldE1uZW1vbmljLCBzdG9yZU1uZW1vbmljLCBsb2FkTW5lbW9uaWMsIGdlbmVyYXRlTW5lbW9uaWMsIHZhbGlkYXRlTW5lbW9uaWMgfSBmcm9tICcuL21uZW1vbmljJztcbmltcG9ydCB7IGNvcHlBZGRyZXNzLCBpc1ZhbGlkRUNhc2hBZGRyZXNzIH0gZnJvbSAnLi9hZGRyZXNzJztcbmltcG9ydCB7IGdlbmVyYXRlUVJDb2RlLCBoaWRlTm9DYW1lcmFGYWxsYmFjaywgc3RvcFFSU2Nhbm5lciwgc3RhcnRRUlNjYW5uZXIgfSBmcm9tICcuL3FyY29kZSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBwYXJzZUJpcDIxVXJpLCBjcmVhdGVCaXAyMVVyaSB9IGZyb20gJy4vYmlwMjEnO1xuLy8gU3R5bGVzXG5pbXBvcnQgJy4vbWFpbi5jc3MnO1xuLy8gSWNvbnNcbmltcG9ydCBiYWNrQXJyb3dJY29uIGZyb20gJy4vYmFjay1hcnJvdy5zdmcnO1xuaW1wb3J0IGVjYXNoTG9nbyBmcm9tICcuL2VjYXNoLnN2Zyc7XG5pbXBvcnQgZWRpdEljb24gZnJvbSAnLi9lZGl0LnN2Zyc7XG5pbXBvcnQgaGlzdG9yeUljb24gZnJvbSAnLi9oaXN0b3J5LnN2Zyc7XG5pbXBvcnQgbm9DYW1lcmFJY29uIGZyb20gJy4vY2FtZXJhLnN2Zyc7XG5pbXBvcnQgcXJDb2RlSWNvbiBmcm9tICcuL3FyY29kZS5zdmcnO1xuaW1wb3J0IHNldHRpbmdzSWNvbiBmcm9tICcuL3NldHRpbmdzLnN2Zyc7XG4vLyBHZXQgRE9NIGVsZW1lbnRzXG5jb25zdCBtYWluU2NyZWVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW4tc2NyZWVuJyk7XG5jb25zdCBzZW5kU2NyZWVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbmQtc2NyZWVuJyk7XG5jb25zdCBzZXR0aW5nc1NjcmVlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1zY3JlZW4nKTtcbmNvbnN0IGhpc3RvcnlTY3JlZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGlzdG9yeS1zY3JlZW4nKTtcbi8vIFdhbGxldCBzdGF0ZVxubGV0IHdhbGxldCA9IG51bGw7XG5sZXQgZWNhc2hXYWxsZXQgPSBudWxsO1xubGV0IHdzRW5kcG9pbnQgPSBudWxsO1xubGV0IGNocm9uaWs7XG4vLyBCYWxhbmNlIHN0YXRlIC0gc2VwYXJhdGUgYXZhaWxhYmxlIGFuZCB0cmFuc2l0aW9uYWwgKG5vdCBmaW5hbGl6ZWQgeWV0KSBcbi8vIGJhbGFuY2VzIChpbiBzYXRvc2hpcylcbmxldCBhdmFpbGFibGVCYWxhbmNlU2F0cyA9IDA7IC8vIE9ubHkgZmluYWxpemVkIGFtb3VudHMgaW4gc2F0b3NoaXNcbmxldCB0cmFuc2l0aW9uYWxCYWxhbmNlU2F0cyA9IDA7IC8vIE9ubHkgbm9uIGZpbmFsaXplZCBhbW91bnRzIGluIHNhdG9zaGlzXG4vLyBQZW5kaW5nIHRyYW5zYWN0aW9ucyAtIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBub3QgeWV0IGZpbmFsaXplZFxubGV0IHBlbmRpbmdBbW91bnRzID0ge307XG4vLyBDcmVhdGUgZ2xvYmFsIGluc3RhbmNlIG9mIFRyYW5zYWN0aW9uSGlzdG9yeU1hbmFnZXJcbmxldCB0cmFuc2FjdGlvbkhpc3RvcnkgPSBudWxsO1xuLy8gU2V0dGluZ3Mgc3RhdGVcbmxldCByZXF1aXJlSG9sZFRvU2VuZCA9IHRydWU7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTRVRUSU5HUyBQRVJTSVNURU5DRVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gT25seSB1c2VkIGZvciBzZXR0aW5ncyB0aGF0IGRvbid0IHJlcXVpcmUgYW55IHNlY3VyaXR5IG9yIGVuY3J5cHRpb25cbmNvbnN0IFNFVFRJTkdTX1NUT1JBR0VfS0VZID0gJ2VjYXNod2FsbGV0LnNldHRpbmdzLjEnO1xuLy8gTG9hZCBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZVxuZnVuY3Rpb24gbG9hZFNldHRpbmdzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNFVFRJTkdTX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBKU09OLnBhcnNlKHN0b3JlZCk7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdlYlZpZXdFcnJvcignRmFpbGVkIHRvIGxvYWQgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gZGVmYXVsdHMgaWYgbm8gc2V0dGluZ3MgZm91bmRcbiAgICByZXR1cm4ge1xuICAgICAgICByZXF1aXJlSG9sZFRvU2VuZDogdHJ1ZSxcbiAgICB9O1xufVxuLy8gU2F2ZSBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2VcbmZ1bmN0aW9uIHNhdmVTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNFVFRJTkdTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICB3ZWJWaWV3TG9nKCdTZXR0aW5ncyBzYXZlZCB0byBsb2NhbFN0b3JhZ2UnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdlYlZpZXdFcnJvcignRmFpbGVkIHRvIHNhdmUgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBHRU5FUkFMIFVUSUxJVFkgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTaG93IGVycm9yIG1vZGFsIHdpdGggcHJvcGVyIHRpdGxlXG5mdW5jdGlvbiBzaG93RXJyb3JNb2RhbCh0aXRsZSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IGVycm9yTW9kYWxPdmVybGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yLW1vZGFsLW92ZXJsYXknKTtcbiAgICBjb25zdCBlcnJvck1vZGFsVGl0bGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXJyb3ItbW9kYWwtdGl0bGUnKTtcbiAgICBjb25zdCBlcnJvck1vZGFsTWVzc2FnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5lcnJvci1tb2RhbC1tZXNzYWdlJyk7XG4gICAgY29uc3QgZXJyb3JNb2RhbENsb3NlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yLW1vZGFsLWNsb3NlJyk7XG4gICAgZXJyb3JNb2RhbFRpdGxlLnRleHRDb250ZW50ID0gdGl0bGU7XG4gICAgZXJyb3JNb2RhbE1lc3NhZ2UudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgIGVycm9yTW9kYWxDbG9zZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgZXJyb3JNb2RhbE92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9KTtcbiAgICBlcnJvck1vZGFsT3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xufVxuZnVuY3Rpb24gc2hvd0xvYWRpbmdTY3JlZW4obWVzc2FnZSkge1xuICAgIGNvbnN0IGxvYWRpbmdFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nJyk7XG4gICAgaWYgKGxvYWRpbmdFbCkge1xuICAgICAgICBsb2FkaW5nRWwuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgY29uc3QgbG9hZGluZ1RleHQgPSBsb2FkaW5nRWwucXVlcnlTZWxlY3RvcignLmxvYWRpbmctdGV4dCcpO1xuICAgICAgICBpZiAobG9hZGluZ1RleHQpIHtcbiAgICAgICAgICAgIGxvYWRpbmdUZXh0LnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGhpZGVMb2FkaW5nU2NyZWVuKCkge1xuICAgIGNvbnN0IGxvYWRpbmdFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nJyk7XG4gICAgaWYgKGxvYWRpbmdFbCkge1xuICAgICAgICBsb2FkaW5nRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBOQVZJR0FUSU9OIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gc2hvd01haW5TY3JlZW4oKSB7XG4gICAgaWYgKG1haW5TY3JlZW4pIHtcbiAgICAgICAgbWFpblNjcmVlbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICB9XG4gICAgaWYgKHNlbmRTY3JlZW4pIHtcbiAgICAgICAgc2VuZFNjcmVlbi5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICB9XG4gICAgaWYgKHNldHRpbmdzU2NyZWVuKSB7XG4gICAgICAgIHNldHRpbmdzU2NyZWVuLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIH1cbiAgICBpZiAoaGlzdG9yeVNjcmVlbikge1xuICAgICAgICBoaXN0b3J5U2NyZWVuLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIH1cbiAgICAvLyBSZXNldCB0aGUgcmVjaXBpZW50IGFkZHJlc3MgZmllbGQgdG8gcmVhZG9ubHkgZm9yIFFSIHNjYW5zXG4gICAgY29uc3QgcmVjaXBpZW50QWRkcmVzc0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlY2lwaWVudC1hZGRyZXNzJyk7XG4gICAgaWYgKHJlY2lwaWVudEFkZHJlc3NJbnB1dCkge1xuICAgICAgICByZWNpcGllbnRBZGRyZXNzSW5wdXQuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICdyZWFkb25seScpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNob3dTZW5kU2NyZWVuKCkge1xuICAgIC8vIEFsd2F5cyByZWZyZXNoIHRoZSBhdmFpbGFibGUgdXR4b3MgYmVmb3JlIHNob3dpbmcgdGhlIHNlbmQgc2NyZWVuXG4gICAgYXdhaXQgc3luY1dhbGxldCgpO1xuICAgIGlmIChtYWluU2NyZWVuKSB7XG4gICAgICAgIG1haW5TY3JlZW4uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgfVxuICAgIGlmIChzZW5kU2NyZWVuKSB7XG4gICAgICAgIHNlbmRTY3JlZW4uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgfVxuICAgIC8vIFJlc2V0IGFsbCBmb3JtIGZpZWxkcyBhbmQgdmFsaWRhdGlvbiBzdGF0ZXNcbiAgICBjb25zdCByZWNpcGllbnRJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWNpcGllbnQtYWRkcmVzcycpO1xuICAgIGNvbnN0IHNlbmRBbW91bnRJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZW5kLWFtb3VudCcpO1xuICAgIGNvbnN0IGFtb3VudFNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbW91bnQtc2xpZGVyJyk7XG4gICAgY29uc3QgZmVlRGlzcGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmZWUtZGlzcGxheScpO1xuICAgIC8vIENsZWFyIHJlY2lwaWVudCBhZGRyZXNzIGZpZWxkIGFuZCB2YWxpZGF0aW9uIHN0YXRlc1xuICAgIGlmIChyZWNpcGllbnRJbnB1dCkge1xuICAgICAgICByZWNpcGllbnRJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICByZWNpcGllbnRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCd2YWxpZCcsICdpbnZhbGlkJyk7XG4gICAgICAgIHJlY2lwaWVudElucHV0LnJlbW92ZUF0dHJpYnV0ZSgncmVhZG9ubHknKTsgLy8gQWxsb3cgZWRpdGluZyBmb3IgbWFudWFsIGVudHJ5XG4gICAgfVxuICAgIC8vIFJlc2V0IGFtb3VudCBmaWVsZCBhbmQgdmFsaWRhdGlvbiBzdGF0ZXNcbiAgICBpZiAoc2VuZEFtb3VudElucHV0KSB7XG4gICAgICAgIHNlbmRBbW91bnRJbnB1dC52YWx1ZSA9ICc1LjQ2JzsgLy8gUHJlZmlsbCB3aXRoIG1pbmltdW0gdmFsaWQgYW1vdW50XG4gICAgICAgIHNlbmRBbW91bnRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCd2YWxpZCcsICdpbnZhbGlkJyk7XG4gICAgfVxuICAgIC8vIFJlc2V0IHNsaWRlclxuICAgIGlmIChhbW91bnRTbGlkZXIpIHtcbiAgICAgICAgYW1vdW50U2xpZGVyLnZhbHVlID0gJzUuNDYnO1xuICAgIH1cbiAgICAvLyBIaWRlIGZlZSBkaXNwbGF5XG4gICAgaWYgKGZlZURpc3BsYXkpIHtcbiAgICAgICAgZmVlRGlzcGxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICAvLyBSZS1zZXR1cCBzZW5kIGJ1dHRvbiBiZWhhdmlvciBiYXNlZCBvbiBjdXJyZW50IHNldHRpbmdcbiAgICBjb25zdCBjb25maXJtU2VuZEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25maXJtLXNlbmQnKTtcbiAgICBpZiAoY29uZmlybVNlbmRCdG4pIHtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYnkgY2xvbmluZyBhbmQgcmVwbGFjaW5nXG4gICAgICAgIGNvbnN0IG5ld0J1dHRvbiA9IGNvbmZpcm1TZW5kQnRuLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgY29uZmlybVNlbmRCdG4ucGFyZW50Tm9kZT8ucmVwbGFjZUNoaWxkKG5ld0J1dHRvbiwgY29uZmlybVNlbmRCdG4pO1xuICAgICAgICAvLyBTZXR1cCB3aXRoIGN1cnJlbnQgYmVoYXZpb3JcbiAgICAgICAgc2V0dXBIb2xkVG9TZW5kKG5ld0J1dHRvbik7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSBzZW5kIHNjcmVlbiBsaW1pdHMgYmFzZWQgb24gY3VycmVudCB3YWxsZXQgc3RhdGVcbiAgICB1cGRhdGVTZW5kU2NyZWVuTGltaXRzKCk7XG4gICAgLy8gVmFsaWRhdGUgYW1vdW50IGZpZWxkIGFmdGVyIHJlc2V0XG4gICAgdmFsaWRhdGVBbW91bnRGaWVsZCgpO1xuICAgIC8vIEluaXRpYWxpemUgc2xpZGVyIGFuZCBtYXJrc1xuICAgIHVwZGF0ZVNsaWRlckZyb21JbnB1dCgpO1xuICAgIGNvbnN0IG1heFNwZW5kYWJsZSA9IGNhbGN1bGF0ZU1heFNwZW5kYWJsZUFtb3VudChlY2FzaFdhbGxldCk7XG4gICAgdXBkYXRlU2xpZGVyTWFya3MoNS40NiwgbWF4U3BlbmRhYmxlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9wZW5TZW5kU2NyZWVuV2l0aEFkZHJlc3MoYWRkcmVzcywgc2F0cykge1xuICAgIC8vIEZpcnN0IHNob3cgdGhlIHNlbmQgc2NyZWVuICh0aGlzIHdpbGwgcmVzZXQgZXZlcnl0aGluZylcbiAgICBhd2FpdCBzaG93U2VuZFNjcmVlbigpO1xuICAgIC8vIFRoZW4gc2V0IHRoZSBhZGRyZXNzIGFuZCBtYWtlIGl0IHJlYWRvbmx5XG4gICAgY29uc3QgcmVjaXBpZW50QWRkcmVzc0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlY2lwaWVudC1hZGRyZXNzJyk7XG4gICAgaWYgKHJlY2lwaWVudEFkZHJlc3NJbnB1dCkge1xuICAgICAgICByZWNpcGllbnRBZGRyZXNzSW5wdXQudmFsdWUgPSBhZGRyZXNzO1xuICAgICAgICByZWNpcGllbnRBZGRyZXNzSW5wdXQuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICdyZWFkb25seScpO1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgYWRkcmVzcyBhZnRlciBzZXR0aW5nIGl0XG4gICAgICAgIHZhbGlkYXRlQWRkcmVzc0ZpZWxkKCk7XG4gICAgfVxuICAgIC8vIElmIGFuIGFtb3VudCB3YXMgcHJvdmlkZWQgKGluIHNhdG9zaGlzKSwgY29udmVydCB0byBYRUMgYW5kIHNldCBpdFxuICAgIGlmIChzYXRzICE9PSB1bmRlZmluZWQgJiYgc2F0cyA+IDApIHtcbiAgICAgICAgY29uc3Qgc2VuZEFtb3VudElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbmQtYW1vdW50Jyk7XG4gICAgICAgIGNvbnN0IGFtb3VudFNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbW91bnQtc2xpZGVyJyk7XG4gICAgICAgIC8vIENvbnZlcnQgc2F0b3NoaXMgdG8gWEVDIGZvciBkaXNwbGF5XG4gICAgICAgIGNvbnN0IGFtb3VudFhlYyA9IHNhdHNUb1hlYyhzYXRzKTtcbiAgICAgICAgaWYgKHNlbmRBbW91bnRJbnB1dCkge1xuICAgICAgICAgICAgLy8gRm9ybWF0IHRvIDIgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICAgIHNlbmRBbW91bnRJbnB1dC52YWx1ZSA9IGFtb3VudFhlYy50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGFtb3VudFxuICAgICAgICAgICAgdmFsaWRhdGVBbW91bnRGaWVsZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbW91bnRTbGlkZXIpIHtcbiAgICAgICAgICAgIGFtb3VudFNsaWRlci52YWx1ZSA9IGFtb3VudFhlYy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyaWdnZXIgZmVlIGNhbGN1bGF0aW9uIHNpbmNlIGFkZHJlc3MgaXMgbm93IHZhbGlkXG4gICAgdXBkYXRlRmVlRGlzcGxheSgpO1xufVxuYXN5bmMgZnVuY3Rpb24gb3BlblNlbmRTY3JlZW5Gb3JNYW51YWxFbnRyeSgpIHtcbiAgICBzdG9wUVJTY2FubmVyKHRydWUpOyAvLyBGb3JjZSBjbG9zZSB0aGUgbW9kYWxcbiAgICBoaWRlTm9DYW1lcmFGYWxsYmFjaygpO1xuICAgIC8vIEZpcnN0IHNob3cgdGhlIHNlbmQgc2NyZWVuICh0aGlzIHdpbGwgcmVzZXQgZXZlcnl0aGluZylcbiAgICBhd2FpdCBzaG93U2VuZFNjcmVlbigpO1xuICAgIC8vIFRoZSBmb3JtIGlzIGFscmVhZHkgcmVzZXQgYnkgc2hvd1NlbmRTY3JlZW4oKSwgbm8gYWRkaXRpb25hbCBhY3Rpb24gbmVlZGVkXG4gICAgLy8gVGhlIGFkZHJlc3MgZmllbGQgaXMgYWxyZWFkeSBjbGVhcmVkIGFuZCBlZGl0YWJsZVxufVxuLy8gT3BlbiB0cmFuc2FjdGlvbiBpbiBibG9jayBleHBsb3JlclxuZnVuY3Rpb24gb3BlblRyYW5zYWN0aW9uSW5FeHBsb3Jlcih0eGlkKSB7XG4gICAgY29uc3QgZXhwbG9yZXJVcmwgPSBjb25maWcuZXhwbG9yZXJVcmwgKyB0eGlkO1xuICAgIC8vIE9uIG1vYmlsZSAoaU9TL0FuZHJvaWQgV2ViVmlldyksIHNlbmQgbWVzc2FnZSB0byBuYXRpdmUgbGF5ZXIgdG8gb3BlbiBpbiBzeXN0ZW0gYnJvd3NlclxuICAgIC8vIE9uIHdlYiwgdXNlIHdpbmRvdy5vcGVuXG4gICAgaWYgKCFzZW5kTWVzc2FnZVRvQmFja2VuZCgnT1BFTl9VUkwnLCBleHBsb3JlclVybCkpIHtcbiAgICAgICAgd2luZG93Lm9wZW4oZXhwbG9yZXJVcmwsICdfYmxhbmsnKTtcbiAgICB9XG59XG4vLyBIaXN0b3J5IHNjcmVlbiBmdW5jdGlvbnNcbmZ1bmN0aW9uIHNob3dIaXN0b3J5U2NyZWVuKCkge1xuICAgIGlmIChtYWluU2NyZWVuKSB7XG4gICAgICAgIG1haW5TY3JlZW4uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgfVxuICAgIGlmIChzZW5kU2NyZWVuKSB7XG4gICAgICAgIHNlbmRTY3JlZW4uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgfVxuICAgIGlmIChzZXR0aW5nc1NjcmVlbikge1xuICAgICAgICBzZXR0aW5nc1NjcmVlbi5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICB9XG4gICAgaWYgKGhpc3RvcnlTY3JlZW4pIHtcbiAgICAgICAgaGlzdG9yeVNjcmVlbi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICB9XG4gICAgLy8gTG9hZCB0cmFuc2FjdGlvbiBoaXN0b3J5IHdoZW4gc2hvd2luZyB0aGUgc2NyZWVuIChyZXNldCB0byBmaXJzdCBwYWdlKVxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGVjYXNoV2FsbGV0KTtcbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICB0cmFuc2FjdGlvbkhpc3RvcnkubG9hZFRyYW5zYWN0aW9uSGlzdG9yeShjaHJvbmlrLCBhZGRyZXNzLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gU2V0dXAgc2Nyb2xsIGRldGVjdGlvbiBmb3IgaW5maW5pdGUgbG9hZGluZyBhbmQgY2xpY2sgaGFuZGxlcnMgZm9yIHRyYW5zYWN0aW9uIElEc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkxpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJhbnNhY3Rpb24tbGlzdCcpO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25MaXN0KSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkxpc3QuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4gdHJhbnNhY3Rpb25IaXN0b3J5LmhhbmRsZVNjcm9sbCgpKTtcbiAgICAgICAgICAgIC8vIEV2ZW50IGRlbGVnYXRpb24gZm9yIHRyYW5zYWN0aW9uIElEIGNsaWNrc1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25MaXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndHJhbnNhY3Rpb24tdHhpZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4aWQgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXR4aWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5UcmFuc2FjdGlvbkluRXhwbG9yZXIodHhpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIDEwMCk7IC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBET00gaXMgcmVhZHlcbn1cbi8vIFNldHRpbmdzIHNjcmVlbiBmdW5jdGlvbnNcbmZ1bmN0aW9uIHNob3dTZXR0aW5nc1NjcmVlbigpIHtcbiAgICBpZiAobWFpblNjcmVlbikge1xuICAgICAgICBtYWluU2NyZWVuLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIH1cbiAgICBpZiAoc2VuZFNjcmVlbikge1xuICAgICAgICBzZW5kU2NyZWVuLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIH1cbiAgICBpZiAoc2V0dGluZ3NTY3JlZW4pIHtcbiAgICAgICAgc2V0dGluZ3NTY3JlZW4uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgfVxuICAgIGlmIChoaXN0b3J5U2NyZWVuKSB7XG4gICAgICAgIGhpc3RvcnlTY3JlZW4uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgfVxuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG1uZW1vbmljIGRpc3BsYXkgd2hlbiBzaG93aW5nIHNldHRpbmdzXG4gICAgdXBkYXRlTW5lbW9uaWNEaXNwbGF5KCk7XG59XG4vLyBUaGVzZSBhcmUgcmVxdWlyZWQgZm9yIHRoZSB3ZWJ2aWV3IGh0bWwgYnV0dG9uIGJpbmRpbmdzXG53aW5kb3cub3Blbkhpc3RvcnkgPSBzaG93SGlzdG9yeVNjcmVlbjtcbndpbmRvdy5vcGVuU2V0dGluZ3MgPSBzaG93U2V0dGluZ3NTY3JlZW47XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTRU5EIFNDUkVFTiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFZhbGlkYXRlIGFkZHJlc3MgZmllbGQgYW5kIHVwZGF0ZSBVSVxuZnVuY3Rpb24gdmFsaWRhdGVBZGRyZXNzRmllbGQoKSB7XG4gICAgY29uc3QgcmVjaXBpZW50SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVjaXBpZW50LWFkZHJlc3MnKTtcbiAgICBpZiAoIXJlY2lwaWVudElucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWRkcmVzcyA9IHJlY2lwaWVudElucHV0LnZhbHVlLnRyaW0oKTtcbiAgICAvLyBDbGVhciBwcmV2aW91cyB2YWxpZGF0aW9uIHN0YXRlc1xuICAgIHJlY2lwaWVudElucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ2ludmFsaWQnKTtcbiAgICByZWNpcGllbnRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCd2YWxpZCcpO1xuICAgIGlmIChhZGRyZXNzID09PSAnJykge1xuICAgICAgICAvLyBFbXB0eSBmaWVsZCAtIG5vIHZhbGlkYXRpb24gc3RhdGVcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNWYWxpZEVDYXNoQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICByZWNpcGllbnRJbnB1dC5jbGFzc0xpc3QuYWRkKCd2YWxpZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVjaXBpZW50SW5wdXQuY2xhc3NMaXN0LmFkZCgnaW52YWxpZCcpO1xuICAgIH1cbn1cbi8vIFVwZGF0ZSBzZW5kIHNjcmVlbiB3aXRoIG1heGltdW0gc3BlbmRhYmxlIGFtb3VudFxuZnVuY3Rpb24gdXBkYXRlU2VuZFNjcmVlbkxpbWl0cygpIHtcbiAgICBjb25zdCBtYXhTcGVuZGFibGUgPSBjYWxjdWxhdGVNYXhTcGVuZGFibGVBbW91bnQoZWNhc2hXYWxsZXQpO1xuICAgIC8vIFVwZGF0ZSBhbW91bnQgaW5wdXQgbWF4IGF0dHJpYnV0ZVxuICAgIGNvbnN0IGFtb3VudElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbmQtYW1vdW50Jyk7XG4gICAgaWYgKGFtb3VudElucHV0KSB7XG4gICAgICAgIGFtb3VudElucHV0Lm1heCA9IG1heFNwZW5kYWJsZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgc2xpZGVyIG1heCB2YWx1ZSBhbmQgbGFiZWxcbiAgICBjb25zdCBhbW91bnRTbGlkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW1vdW50LXNsaWRlcicpO1xuICAgIGlmIChhbW91bnRTbGlkZXIpIHtcbiAgICAgICAgYW1vdW50U2xpZGVyLm1heCA9IG1heFNwZW5kYWJsZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgc2xpZGVyIG1heCBsYWJlbFxuICAgIGNvbnN0IHNsaWRlck1heExhYmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NsaWRlci1tYXgtbGFiZWwnKTtcbiAgICBpZiAoc2xpZGVyTWF4TGFiZWwpIHtcbiAgICAgICAgc2xpZGVyTWF4TGFiZWwudGV4dENvbnRlbnQgPSBgJHttYXhTcGVuZGFibGUudG9GaXhlZCgyKX0gJHtjb25maWcudGlja2VyfWA7XG4gICAgfVxufVxuLy8gVXBkYXRlIGZlZSBkaXNwbGF5XG5mdW5jdGlvbiB1cGRhdGVGZWVEaXNwbGF5KCkge1xuICAgIGNvbnN0IHJlY2lwaWVudElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlY2lwaWVudC1hZGRyZXNzJyk7XG4gICAgY29uc3QgYW1vdW50SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VuZC1hbW91bnQnKTtcbiAgICBjb25zdCBmZWVEaXNwbGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZlZS1kaXNwbGF5Jyk7XG4gICAgaWYgKCFyZWNpcGllbnRJbnB1dCB8fCAhYW1vdW50SW5wdXQgfHwgIWZlZURpc3BsYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWNpcGllbnRBZGRyZXNzID0gcmVjaXBpZW50SW5wdXQudmFsdWUudHJpbSgpO1xuICAgIGxldCBhbW91bnQgPSBwYXJzZUZsb2F0KGFtb3VudElucHV0LnZhbHVlKTtcbiAgICAvLyBIaWRlIGlmIGFkZHJlc3Mgb3IgYW1vdW50IGlzIGludmFsaWRcbiAgICBpZiAoIXJlY2lwaWVudEFkZHJlc3MgfHwgIWlzVmFsaWRFQ2FzaEFkZHJlc3MocmVjaXBpZW50QWRkcmVzcykgfHwgaXNOYU4oYW1vdW50KSB8fCBhbW91bnQgPD0gMCkge1xuICAgICAgICBmZWVEaXNwbGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IG51bGw7XG4gICAgLy8gQ2hlY2sgZm9yIGR1c3QgdGhyZXNob2xkXG4gICAgY29uc3QgZHVzdFhFQyA9IHNhdHNUb1hlYyhOdW1iZXIoREVGQVVMVF9EVVNUX1NBVFMpKTtcbiAgICBpZiAoYW1vdW50IDwgZHVzdFhFQykge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBgQW1vdW50IGlzIHRvbyBzbWFsbGA7XG4gICAgfVxuICAgIC8vIFRyeSB0byBlc3RpbWF0ZSBmZWUgZm9yIHRoZSByZXF1ZXN0ZWQgYW1vdW50XG4gICAgbGV0IGZlZUVzdGltYXRlID0gZXN0aW1hdGVUcmFuc2FjdGlvbkZlZShlY2FzaFdhbGxldCwgcmVjaXBpZW50QWRkcmVzcywgYW1vdW50KTtcbiAgICAvLyBJbnN1ZmZpY2llbnQgYmFsYW5jZSAtIGNhbGN1bGF0ZSBmb3IgbWF4IHNwZW5kYWJsZSBhbW91bnRcbiAgICBpZiAoIWZlZUVzdGltYXRlKSB7XG4gICAgICAgIGFtb3VudCA9IGNhbGN1bGF0ZU1heFNwZW5kYWJsZUFtb3VudChlY2FzaFdhbGxldCk7XG4gICAgICAgIGZlZUVzdGltYXRlID0gZXN0aW1hdGVUcmFuc2FjdGlvbkZlZShlY2FzaFdhbGxldCwgcmVjaXBpZW50QWRkcmVzcywgYW1vdW50KTtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gYEluc3VmZmljaWVudCBiYWxhbmNlYDtcbiAgICB9XG4gICAgLy8gQnVpbGQgdGhlIGh0bWwgZmVlIGJsb2NrIGhlYWRpbmcgZGVwZW5kaW5nIG9uIHRoZSBlcnJvciBjb25kaXRpb25cbiAgICBsZXQgZmVlQmxvY2tIZWFkaW5nID0gJ1RyYW5zYWN0aW9uIERldGFpbHMnO1xuICAgIGxldCBmZWVCbG9ja0hlYWRpbmdDbGFzc2VzID0gJ3RpdGxlJztcbiAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIGZlZURpc3BsYXkuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcbiAgICAgICAgZmVlQmxvY2tIZWFkaW5nID0gZXJyb3JNZXNzYWdlO1xuICAgICAgICBmZWVCbG9ja0hlYWRpbmdDbGFzc2VzICs9ICcgZXJyb3InO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmVlRGlzcGxheS5jbGFzc0xpc3QucmVtb3ZlKCdlcnJvcicpO1xuICAgIH1cbiAgICAvLyBCdWlsZCB0aGUgSFRNTCB3aXRoIGNvbmRpdGlvbmFsIHN0eWxpbmdcbiAgICBsZXQgaHRtbCA9IGA8ZGl2IGNsYXNzPVwiZmVlLWluZm9cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmZWUtaXRlbSAke2ZlZUJsb2NrSGVhZGluZ0NsYXNzZXN9XCI+XG4gICAgICAgICAgICAgICAgJHtmZWVCbG9ja0hlYWRpbmd9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmZWUtaXRlbVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmVlLWxhYmVsXCI+QW1vdW50Ojwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZlZS12YWx1ZVwiPiR7YW1vdW50LnRvRml4ZWQoMil9ICR7Y29uZmlnLnRpY2tlcn08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmZWUtaXRlbVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmVlLWxhYmVsXCI+TmV0d29yayBGZWU6PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmVlLXZhbHVlXCI+JHtmZWVFc3RpbWF0ZT8uZmVlWEVDLnRvRml4ZWQoMil9ICR7Y29uZmlnLnRpY2tlcn08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmZWUtaXRlbSB0b3RhbFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmVlLWxhYmVsXCI+VG90YWw6PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmVlLXZhbHVlXCI+JHtmZWVFc3RpbWF0ZT8udG90YWxYRUMudG9GaXhlZCgyKX0gJHtjb25maWcudGlja2VyfTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBgO1xuICAgIGZlZURpc3BsYXkuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBmZWVEaXNwbGF5LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xufVxuLy8gQW1vdW50IGlucHV0IGhhbmRsaW5nIHRvIHByZXZlbnQgbW9yZSB0aGFuIDIgZGVjaW1hbHNcbmZ1bmN0aW9uIGhhbmRsZUFtb3VudElucHV0KGV2ZW50KSB7XG4gICAgY29uc3QgaW5wdXQgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZTtcbiAgICAvLyBBbGxvdyBvbmx5IG51bWJlcnMgYW5kIG9uZSBkZWNpbWFsIHBvaW50XG4gICAgY29uc3QgY2xlYW5WYWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teMC05Ll0vZywgJycpO1xuICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgZGVjaW1hbCBwb2ludHNcbiAgICBjb25zdCBwYXJ0cyA9IGNsZWFuVmFsdWUuc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMikge1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHBhcnRzWzBdICsgJy4nICsgcGFydHMuc2xpY2UoMSkuam9pbignJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBhIGRlY2ltYWwgcG9pbnQsIGxpbWl0IHRvIDIgZGVjaW1hbCBwbGFjZXNcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAyICYmIHBhcnRzWzFdLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSBwYXJ0c1swXSArICcuJyArIHBhcnRzWzFdLnN1YnN0cmluZygwLCAyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdGhlIGlucHV0IHZhbHVlIGlmIGl0IHdhcyBjbGVhbmVkXG4gICAgaWYgKGNsZWFuVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gY2xlYW5WYWx1ZTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHNsaWRlciB0byBtYXRjaCBpbnB1dCB2YWx1ZVxuICAgIHVwZGF0ZVNsaWRlckZyb21JbnB1dCgpO1xuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFmdGVyIGlucHV0IGlzIHByb2Nlc3NlZFxuICAgIHZhbGlkYXRlQW1vdW50RmllbGQoKTtcbn1cbi8vIEhhbmRsZSBzbGlkZXIgaW5wdXRcbmZ1bmN0aW9uIGhhbmRsZVNsaWRlcklucHV0KGV2ZW50KSB7XG4gICAgY29uc3Qgc2xpZGVyID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdChzbGlkZXIudmFsdWUpO1xuICAgIC8vIFVwZGF0ZSB0aGUgYW1vdW50IGlucHV0IGZpZWxkIGltbWVkaWF0ZWx5IGZvciB2aXN1YWwgZmVlZGJhY2tcbiAgICBjb25zdCBzZW5kQW1vdW50SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VuZC1hbW91bnQnKTtcbiAgICBpZiAoc2VuZEFtb3VudElucHV0KSB7XG4gICAgICAgIHNlbmRBbW91bnRJbnB1dC52YWx1ZSA9IHZhbHVlLnRvRml4ZWQoMik7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIGltbWVkaWF0ZWx5IHdpdGhvdXQgdGhyb3R0bGluZ1xuICAgIHZhbGlkYXRlQW1vdW50RmllbGQoKTtcbn1cbi8vIFVwZGF0ZSBzbGlkZXIgZnJvbSBpbnB1dCBmaWVsZFxuZnVuY3Rpb24gdXBkYXRlU2xpZGVyRnJvbUlucHV0KCkge1xuICAgIGNvbnN0IHNlbmRBbW91bnRJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZW5kLWFtb3VudCcpO1xuICAgIGNvbnN0IGFtb3VudFNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbW91bnQtc2xpZGVyJyk7XG4gICAgaWYgKCFzZW5kQW1vdW50SW5wdXQgfHwgIWFtb3VudFNsaWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdChzZW5kQW1vdW50SW5wdXQudmFsdWUpO1xuICAgIGNvbnN0IG1pbkFtb3VudCA9IDUuNDY7XG4gICAgY29uc3QgbWF4QW1vdW50ID0gY2FsY3VsYXRlTWF4U3BlbmRhYmxlQW1vdW50KGVjYXNoV2FsbGV0KTtcbiAgICAvLyBDbGFtcCB2YWx1ZSB0byBzbGlkZXIgcmFuZ2VcbiAgICBjb25zdCBjbGFtcGVkVmFsdWUgPSBNYXRoLm1heChtaW5BbW91bnQsIE1hdGgubWluKHZhbHVlLCBtYXhBbW91bnQpKTtcbiAgICAvLyBVcGRhdGUgc2xpZGVyIHZhbHVlXG4gICAgYW1vdW50U2xpZGVyLnZhbHVlID0gY2xhbXBlZFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgLy8gVXBkYXRlIHNsaWRlciBtYXggaWYgYmFsYW5jZSBjaGFuZ2VkXG4gICAgaWYgKG1heEFtb3VudCAhPT0gcGFyc2VGbG9hdChhbW91bnRTbGlkZXIubWF4KSkge1xuICAgICAgICBhbW91bnRTbGlkZXIubWF4ID0gbWF4QW1vdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHNsaWRlck1heExhYmVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NsaWRlci1tYXgtbGFiZWwnKTtcbiAgICAgICAgaWYgKHNsaWRlck1heExhYmVsKSB7XG4gICAgICAgICAgICBzbGlkZXJNYXhMYWJlbC50ZXh0Q29udGVudCA9IGAke21heEFtb3VudC50b0ZpeGVkKDIpfSAke2NvbmZpZy50aWNrZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc2xpZGVyIG1hcmtzIGZvciBuZXcgcmFuZ2VcbiAgICAgICAgdXBkYXRlU2xpZGVyTWFya3MobWluQW1vdW50LCBtYXhBbW91bnQpO1xuICAgIH1cbn1cbi8vIFVwZGF0ZSBzbGlkZXIgbWFya3MgYmFzZWQgb24gY3VycmVudCByYW5nZVxuZnVuY3Rpb24gdXBkYXRlU2xpZGVyTWFya3MobWluQW1vdW50LCBtYXhBbW91bnQpIHtcbiAgICBjb25zdCBtYXJrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tYXJrJyk7XG4gICAgY29uc3QgcmFuZ2UgPSBtYXhBbW91bnQgLSBtaW5BbW91bnQ7XG4gICAgbWFya3MuZm9yRWFjaCgobWFyaywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9ICgoaW5kZXggKyAxKSAqIDEwKTsgLy8gMTAlLCAyMCUsIDMwJSwgZXRjLiAoc2tpcHBpbmcgMCUgYW5kIDEwMCUpXG4gICAgICAgIGNvbnN0IGFjdHVhbFZhbHVlID0gbWluQW1vdW50ICsgKHJhbmdlICogcGVyY2VudGFnZSAvIDEwMCk7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlWYWx1ZSA9IGFjdHVhbFZhbHVlLnRvRml4ZWQoMik7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFyaydzIGRhdGEgYXR0cmlidXRlIGZvciByZWZlcmVuY2VcbiAgICAgICAgbWFyay5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsdWUnLCBkaXNwbGF5VmFsdWUpO1xuICAgICAgICAvLyBBZGQgYSBzdWJ0bGUgdG9vbHRpcCBlZmZlY3Qgb24gaG92ZXJcbiAgICAgICAgbWFyay50aXRsZSA9IGAke2Rpc3BsYXlWYWx1ZX0gJHtjb25maWcudGlja2VyfWA7XG4gICAgfSk7XG59XG4vLyBBbW91bnQgdmFsaWRhdGlvbiBmdW5jdGlvbnNcbmZ1bmN0aW9uIHZhbGlkYXRlQW1vdW50RmllbGQoKSB7XG4gICAgY29uc3Qgc2VuZEFtb3VudElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbmQtYW1vdW50Jyk7XG4gICAgY29uc3QgY29uZmlybVNlbmRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uZmlybS1zZW5kJyk7XG4gICAgaWYgKCFzZW5kQW1vdW50SW5wdXQgfHwgIWNvbmZpcm1TZW5kQnRuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW1vdW50ID0gcGFyc2VGbG9hdChzZW5kQW1vdW50SW5wdXQudmFsdWUpO1xuICAgIGNvbnN0IG1pbkFtb3VudCA9IDUuNDY7XG4gICAgY29uc3QgbWF4QW1vdW50ID0gY2FsY3VsYXRlTWF4U3BlbmRhYmxlQW1vdW50KGVjYXNoV2FsbGV0KTtcbiAgICAvLyBDbGVhciBwcmV2aW91cyB2YWxpZGF0aW9uIHN0YXRlc1xuICAgIHNlbmRBbW91bnRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdpbnZhbGlkJyk7XG4gICAgc2VuZEFtb3VudElucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ3ZhbGlkJyk7XG4gICAgLy8gQ2hlY2sgaWYgYW1vdW50IGlzIHZhbGlkXG4gICAgaWYgKGlzTmFOKGFtb3VudCkgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgICAgc2VuZEFtb3VudElucHV0LmNsYXNzTGlzdC5hZGQoJ2ludmFsaWQnKTtcbiAgICAgICAgY29uZmlybVNlbmRCdG4uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBidG5TcGFuID0gY29uZmlybVNlbmRCdG4ucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICBpZiAoYnRuU3Bhbikge1xuICAgICAgICAgICAgYnRuU3Bhbi50ZXh0Q29udGVudCA9ICdFbnRlciBBbW91bnQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFtb3VudCA8IG1pbkFtb3VudCkge1xuICAgICAgICBzZW5kQW1vdW50SW5wdXQuY2xhc3NMaXN0LmFkZCgnaW52YWxpZCcpO1xuICAgICAgICBjb25maXJtU2VuZEJ0bi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGJ0blNwYW4gPSBjb25maXJtU2VuZEJ0bi5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgIGlmIChidG5TcGFuKSB7XG4gICAgICAgICAgICBidG5TcGFuLnRleHRDb250ZW50ID0gYE1pbjogJHttaW5BbW91bnR9ICR7Y29uZmlnLnRpY2tlcn1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFtb3VudCA+IG1heEFtb3VudCkge1xuICAgICAgICBzZW5kQW1vdW50SW5wdXQuY2xhc3NMaXN0LmFkZCgnaW52YWxpZCcpO1xuICAgICAgICBjb25maXJtU2VuZEJ0bi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGJ0blNwYW4gPSBjb25maXJtU2VuZEJ0bi5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgIGlmIChidG5TcGFuKSB7XG4gICAgICAgICAgICBidG5TcGFuLnRleHRDb250ZW50ID0gYE1heDogJHttYXhBbW91bnQudG9GaXhlZCgyKX0gJHtjb25maWcudGlja2VyfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBbW91bnQgaXMgdmFsaWRcbiAgICBzZW5kQW1vdW50SW5wdXQuY2xhc3NMaXN0LmFkZCgndmFsaWQnKTtcbiAgICBjb25maXJtU2VuZEJ0bi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGJ0blNwYW4gPSBjb25maXJtU2VuZEJ0bi5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgaWYgKGJ0blNwYW4pIHtcbiAgICAgICAgYnRuU3Bhbi50ZXh0Q29udGVudCA9IHJlcXVpcmVIb2xkVG9TZW5kID8gJ0hvbGQgdG8gc2VuZCcgOiAnU2VuZCc7XG4gICAgfVxufVxuLy8gU2VuZCBidXR0b24gc2V0dXAgLSBlaXRoZXIgaG9sZC10by1zZW5kIG9yIHNpbXBsZSBjbGljayBiYXNlZCBvbiBzZXR0aW5nc1xuZnVuY3Rpb24gc2V0dXBIb2xkVG9TZW5kKGJ1dHRvbikge1xuICAgIC8vIElmIGhvbGQtdG8tc2VuZCBpcyBkaXNhYmxlZCwgdXNlIHNpbXBsZSBjbGljayBiZWhhdmlvclxuICAgIGlmICghcmVxdWlyZUhvbGRUb1NlbmQpIHtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVBbmRTZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEhvbGQtdG8tc2VuZCBiZWhhdmlvciB3aXRoIHByb2dyZXNzaXZlIGhhcHRpYyBmZWVkYmFja1xuICAgIGxldCBob2xkVGltZXIgPSBudWxsO1xuICAgIGxldCBoYXB0aWNJbnRlcnZhbCA9IG51bGw7XG4gICAgbGV0IHN0YXJ0VGltZSA9IDA7XG4gICAgY29uc3QgSE9MRF9EVVJBVElPTiA9IDEwMDA7IC8vIDEgc2Vjb25kXG4gICAgY29uc3QgSEFQVElDX0lOVEVSVkFMID0gNTA7IC8vIEhhcHRpYyBldmVyeSA1MG1zIGZvciBzbW9vdGhlciBjb250aW51b3VzIGZlZWxcbiAgICAvLyBQcm9ncmVzc2l2ZSBoYXB0aWMgZmVlZGJhY2sgYmFzZWQgb24gZWxhcHNlZCB0aW1lXG4gICAgY29uc3QgdHJpZ2dlclByb2dyZXNzaXZlSGFwdGljID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gSE9MRF9EVVJBVElPTiwgMSk7XG4gICAgICAgIC8vIFVzZSBzZWxlY3Rpb24gaGFwdGljIGZvciBzbW9vdGhlciByYXBpZCBmZWVkYmFjaywgdHJhbnNpdGlvbmluZyB0byBpbXBhY3RzXG4gICAgICAgIGxldCBoYXB0aWNUeXBlID0gJ3NlbGVjdGlvbic7XG4gICAgICAgIGlmIChwcm9ncmVzcyA+IDAuOCkge1xuICAgICAgICAgICAgaGFwdGljVHlwZSA9ICdpbXBhY3RIZWF2eSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZ3Jlc3MgPiAwLjUpIHtcbiAgICAgICAgICAgIGhhcHRpY1R5cGUgPSAnaW1wYWN0TWVkaXVtJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9ncmVzcyA+IDAuMikge1xuICAgICAgICAgICAgaGFwdGljVHlwZSA9ICdpbXBhY3RMaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgc2VuZE1lc3NhZ2VUb0JhY2tlbmQoJ0hBUFRJQ19GRUVEQkFDSycsIGhhcHRpY1R5cGUpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhcnRIb2xkID0gKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBDaGVjayBpZiBidXR0b24gaXMgZGlzYWJsZWRcbiAgICAgICAgaWYgKGJ1dHRvbi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIGJlZm9yZSBzdGFydGluZyB0aGUgaG9sZCBhbmltYXRpb25cbiAgICAgICAgY29uc3Qgc2VuZEFtb3VudElucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbmQtYW1vdW50Jyk7XG4gICAgICAgIGNvbnN0IHJlY2lwaWVudEFkZHJlc3NJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWNpcGllbnQtYWRkcmVzcycpO1xuICAgICAgICBpZiAoIXNlbmRBbW91bnRJbnB1dCB8fCAhcmVjaXBpZW50QWRkcmVzc0lucHV0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW1vdW50ID0gcGFyc2VGbG9hdChzZW5kQW1vdW50SW5wdXQudmFsdWUpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gcmVjaXBpZW50QWRkcmVzc0lucHV0LnZhbHVlLnRyaW0oKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgYWRkcmVzc1xuICAgICAgICBpZiAoIWFkZHJlc3MgfHwgIWlzVmFsaWRFQ2FzaEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIC8vIFBsYXkgd2FybmluZyBoYXB0aWMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlVG9CYWNrZW5kKCdIQVBUSUNfRkVFREJBQ0snLCAnbm90aWZpY2F0aW9uV2FybmluZycpO1xuICAgICAgICAgICAgcmVjaXBpZW50QWRkcmVzc0lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgYW1vdW50XG4gICAgICAgIGlmIChpc05hTihhbW91bnQpIHx8IGFtb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAvLyBQbGF5IHdhcm5pbmcgaGFwdGljIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBzZW5kTWVzc2FnZVRvQmFja2VuZCgnSEFQVElDX0ZFRURCQUNLJywgJ25vdGlmaWNhdGlvbldhcm5pbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnaG9sZGluZycpO1xuICAgICAgICAvLyBUcmlnZ2VyIGluaXRpYWwgaGFwdGljXG4gICAgICAgIHRyaWdnZXJQcm9ncmVzc2l2ZUhhcHRpYygpO1xuICAgICAgICAvLyBTZXQgdXAgY29udGludW91cyBoYXB0aWMgZmVlZGJhY2sgZHVyaW5nIGhvbGRcbiAgICAgICAgaGFwdGljSW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdHJpZ2dlclByb2dyZXNzaXZlSGFwdGljKCk7XG4gICAgICAgIH0sIEhBUFRJQ19JTlRFUlZBTCk7XG4gICAgICAgIC8vIFNldCB0aW1lciBmb3Igc3VjY2Vzc2Z1bCBob2xkXG4gICAgICAgIGhvbGRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIFN1Y2Nlc3MgaGFwdGljXG4gICAgICAgICAgICBzZW5kTWVzc2FnZVRvQmFja2VuZCgnSEFQVElDX0ZFRURCQUNLJywgJ25vdGlmaWNhdGlvblN1Y2Nlc3MnKTtcbiAgICAgICAgICAgIGF3YWl0IHZhbGlkYXRlQW5kU2VuZCgpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9LCBIT0xEX0RVUkFUSU9OKTtcbiAgICB9O1xuICAgIGNvbnN0IGNhbmNlbEhvbGQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChob2xkVGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIC8vIEdpdmUgZmVlZGJhY2sgdGhhdCBob2xkIHdhcyBjYW5jZWxsZWRcbiAgICAgICAgY29uc3QgaG9sZER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgaWYgKGhvbGREdXJhdGlvbiA+IDMwMCkge1xuICAgICAgICAgICAgLy8gVXNlciBoZWxkIGZvciBhIGJpdCBidXQgcmVsZWFzZWQgZWFybHkgLSBnaXZlIHdhcm5pbmcgaGFwdGljXG4gICAgICAgICAgICBzZW5kTWVzc2FnZVRvQmFja2VuZCgnSEFQVElDX0ZFRURCQUNLJywgJ25vdGlmaWNhdGlvbldhcm5pbmcnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGhvbGRUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhvbGRUaW1lcik7XG4gICAgICAgICAgICBob2xkVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGhhcHRpYyBpbnRlcnZhbFxuICAgICAgICBpZiAoaGFwdGljSW50ZXJ2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaGFwdGljSW50ZXJ2YWwpO1xuICAgICAgICAgICAgaGFwdGljSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdob2xkaW5nJyk7XG4gICAgfTtcbiAgICAvLyBNb3VzZSBldmVudHNcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgc3RhcnRIb2xkKTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGNhbmNlbEhvbGQpO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgY2FuY2VsSG9sZCk7XG4gICAgLy8gVG91Y2ggZXZlbnRzIGZvciBtb2JpbGVcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHN0YXJ0SG9sZCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBjYW5jZWxIb2xkKTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBjYW5jZWxIb2xkKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQW5kU2VuZCgpIHtcbiAgICBjb25zdCBzZW5kQW1vdW50SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VuZC1hbW91bnQnKTtcbiAgICBjb25zdCByZWNpcGllbnRBZGRyZXNzSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVjaXBpZW50LWFkZHJlc3MnKTtcbiAgICBpZiAoIXNlbmRBbW91bnRJbnB1dCB8fCAhcmVjaXBpZW50QWRkcmVzc0lucHV0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW1vdW50ID0gcGFyc2VGbG9hdChzZW5kQW1vdW50SW5wdXQudmFsdWUpO1xuICAgIGNvbnN0IGFkZHJlc3MgPSByZWNpcGllbnRBZGRyZXNzSW5wdXQudmFsdWUudHJpbSgpO1xuICAgIC8vIFZhbGlkYXRlIGFkZHJlc3NcbiAgICBpZiAoIWFkZHJlc3MgfHwgIWlzVmFsaWRFQ2FzaEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgcmVjaXBpZW50QWRkcmVzc0lucHV0LmZvY3VzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgYW1vdW50XG4gICAgdmFsaWRhdGVBbW91bnRGaWVsZCgpO1xuICAgIGNvbnN0IGNvbmZpcm1TZW5kQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpcm0tc2VuZCcpO1xuICAgIGlmIChjb25maXJtU2VuZEJ0bi5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47IC8vIEFtb3VudCB2YWxpZGF0aW9uIGZhaWxlZFxuICAgIH1cbiAgICAvLyBBbGwgdmFsaWRhdGlvbnMgcGFzc2VkLCBwcm9jZWVkIHdpdGggc2VuZGluZ1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENvbnZlcnQgWEVDIHRvIHNhdG9zaGlzICgxIFhFQyA9IDEwMCBzYXRvc2hpcylcbiAgICAgICAgY29uc3Qgc2F0cyA9IE1hdGgucm91bmQoYW1vdW50ICogMTAwKTtcbiAgICAgICAgYXdhaXQgc2VuZFRyYW5zYWN0aW9uKGVjYXNoV2FsbGV0LCBhZGRyZXNzLCBzYXRzKTtcbiAgICAgICAgd2ViVmlld0xvZyhgU2VudCAke2Ftb3VudH0gJHtjb25maWcudGlja2VyfSB0byAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB3ZWJWaWV3RXJyb3IoJ0ZhaWxlZCB0byBzZW5kIHRyYW5zYWN0aW9uOicsIGVycm9yKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIC8vIFJldHVybiB0byBtYWluIHNjcmVlblxuICAgICAgICBzaG93TWFpblNjcmVlbigpO1xuICAgIH1cbn1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNFVFRJTkdTIFNDUkVFTiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1uZW1vbmljIG1hbmFnZW1lbnQgZnVuY3Rpb25zXG5mdW5jdGlvbiB1cGRhdGVNbmVtb25pY0Rpc3BsYXkoKSB7XG4gICAgY29uc3QgbW5lbW9uaWNUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21uZW1vbmljLXRleHQnKTtcbiAgICBjb25zdCB3YWxsZXRNbmVtb25pYyA9IGdldE1uZW1vbmljKHdhbGxldCk7XG4gICAgaWYgKG1uZW1vbmljVGV4dCAmJiB3YWxsZXRNbmVtb25pYykge1xuICAgICAgICAvLyBtbmVtb25pY1RleHQudmFsdWUgPSB3YWxsZXQubW5lbW9uaWM7XG4gICAgICAgIG1uZW1vbmljVGV4dC52YWx1ZSA9IHdhbGxldE1uZW1vbmljO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNob3dNbmVtb25pY0VkaXRNb2RhbCgpIHtcbiAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtbmVtb25pYy1lZGl0LW1vZGFsJyk7XG4gICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGNvbnN0IGVkaXRUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21uZW1vbmljLWVkaXQtdGV4dCcpO1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21uZW1vbmljLXZhbGlkYXRpb24nKTtcbiAgICAgICAgaWYgKGVkaXRUZXh0KSB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRNbmVtb25pYyA9IGdldE1uZW1vbmljKHdhbGxldCk7XG4gICAgICAgICAgICBlZGl0VGV4dC52YWx1ZSA9IHdhbGxldE1uZW1vbmljID8gd2FsbGV0TW5lbW9uaWMgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGlvbikge1xuICAgICAgICAgICAgdmFsaWRhdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgIG1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhpZGVNbmVtb25pY0VkaXRNb2RhbCgpIHtcbiAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtbmVtb25pYy1lZGl0LW1vZGFsJyk7XG4gICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIG1vZGFsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIG1vZGFsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNob3dWYWxpZGF0aW9uTWVzc2FnZShtZXNzYWdlLCBpc0Vycm9yID0gdHJ1ZSkge1xuICAgIGNvbnN0IHZhbGlkYXRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW5lbW9uaWMtdmFsaWRhdGlvbicpO1xuICAgIGlmICh2YWxpZGF0aW9uKSB7XG4gICAgICAgIHZhbGlkYXRpb24udGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgICAgICB2YWxpZGF0aW9uLmNsYXNzTmFtZSA9IGB2YWxpZGF0aW9uLW1lc3NhZ2UgJHtpc0Vycm9yID8gJ2Vycm9yJyA6ICdzdWNjZXNzJ31gO1xuICAgICAgICB2YWxpZGF0aW9uLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhpZGVWYWxpZGF0aW9uTWVzc2FnZSgpIHtcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21uZW1vbmljLXZhbGlkYXRpb24nKTtcbiAgICBpZiAodmFsaWRhdGlvbikge1xuICAgICAgICB2YWxpZGF0aW9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2F2ZU1uZW1vbmljKG5ld01uZW1vbmljKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIG1uZW1vbmljXG4gICAgICAgIGlmICghdmFsaWRhdGVNbmVtb25pYyhuZXdNbmVtb25pYykpIHtcbiAgICAgICAgICAgIHNob3dWYWxpZGF0aW9uTWVzc2FnZSgnSW52YWxpZCBtbmVtb25pYy4gUGxlYXNlIGVudGVyIGEgdmFsaWQgMTItd29yZCByZWNvdmVyeSBwaHJhc2UuJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIG5ldyBtbmVtb25pY1xuICAgICAgICBhd2FpdCBzdG9yZU1uZW1vbmljKG5ld01uZW1vbmljLnRyaW0oKSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgd2FsbGV0IHdpdGggdGhlIG5ldyBtbmVtb25pY1xuICAgICAgICBpZiAod2FsbGV0KSB7XG4gICAgICAgICAgICB3YWxsZXQubW5lbW9uaWMgPSBuZXdNbmVtb25pYy50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVsb2FkIHRoZSB3YWxsZXQgd2l0aCB0aGUgbmV3IG1uZW1vbmljXG4gICAgICAgIHdlYlZpZXdMb2coJ1JlbG9hZGluZyB3YWxsZXQgd2l0aCBuZXcgbW5lbW9uaWMuLi4nKTtcbiAgICAgICAgYXdhaXQgbG9hZFdhbGxldEZyb21NbmVtb25pYyh3YWxsZXQubW5lbW9uaWMpO1xuICAgICAgICAvLyBFbnN1cmUgbWFpbiBzY3JlZW4gaXMgdmlzaWJsZSBhbmQgd2FsbGV0IGlzIGRpc3BsYXllZFxuICAgICAgICBzaG93TWFpblNjcmVlbigpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGRpc3BsYXlcbiAgICAgICAgdXBkYXRlTW5lbW9uaWNEaXNwbGF5KCk7XG4gICAgICAgIC8vIFNob3cgc3VjY2VzcyBtZXNzYWdlXG4gICAgICAgIHNob3dWYWxpZGF0aW9uTWVzc2FnZSgnTW5lbW9uaWMgdXBkYXRlZCBzdWNjZXNzZnVsbHkhIFdhbGxldCByZWxvYWRlZC4nLCBmYWxzZSk7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIHNhdmUgYnV0dG9uXG4gICAgICAgIGNvbnN0IHNhdmVNbmVtb25pY0VkaXRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2F2ZS1tbmVtb25pYy1lZGl0Jyk7XG4gICAgICAgIGlmIChzYXZlTW5lbW9uaWNFZGl0QnRuKSB7XG4gICAgICAgICAgICBzYXZlTW5lbW9uaWNFZGl0QnRuLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIaWRlIG1vZGFsIGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBoaWRlTW5lbW9uaWNFZGl0TW9kYWwoKTtcbiAgICAgICAgICAgIGhpZGVWYWxpZGF0aW9uTWVzc2FnZSgpO1xuICAgICAgICAgICAgLy8gUmUtZW5hYmxlIHRoZSBzYXZlIGJ1dHRvblxuICAgICAgICAgICAgaWYgKHNhdmVNbmVtb25pY0VkaXRCdG4pIHtcbiAgICAgICAgICAgICAgICBzYXZlTW5lbW9uaWNFZGl0QnRuLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHdlYlZpZXdFcnJvcignRXJyb3Igc2F2aW5nIG1uZW1vbmljOicsIGVycm9yKTtcbiAgICAgICAgc2hvd1ZhbGlkYXRpb25NZXNzYWdlKCdGYWlsZWQgdG8gc2F2ZSBtbmVtb25pYy4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFdBTExFVCBNQU5BR0VNRU5UIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVXBkYXRlIE5GQyBhZGRyZXNzIGZvciB0YWcgZW11bGF0aW9uIChCSVAyMSBVUkkpXG4vLyBhbW91bnRTYXRzIGlzIG9wdGlvbmFsIC0gaWYgcHJvdmlkZWQsIGl0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIEJJUDIxIFVSSVxuZnVuY3Rpb24gdXBkYXRlTmZjQWRkcmVzcyhhbW91bnRTYXRzKSB7XG4gICAgaWYgKCFlY2FzaFdhbGxldCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGVjYXNoV2FsbGV0KTtcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgQklQMjEgVVJJIHVzaW5nIHRoZSBiaXAyMSBtb2R1bGVcbiAgICBjb25zdCBiaXAyMVVyaSA9IGNyZWF0ZUJpcDIxVXJpKGFkZHJlc3MsIGFtb3VudFNhdHMpO1xuICAgIC8vIFNlbmQgdGhlIGNvbXBsZXRlIEJJUDIxIFVSSSB0byBuYXRpdmUgYXBwIGZvciBORkMgSENFXG4gICAgc2VuZE1lc3NhZ2VUb0JhY2tlbmQoJ1NFVF9ORkNfVVJJJywgYmlwMjFVcmkpO1xufVxuLy8gTG9hZCBleGlzdGluZyB3YWxsZXQgZnJvbSBzdG9yZWQgbW5lbW9uaWNcbmFzeW5jIGZ1bmN0aW9uIGxvYWRXYWxsZXRGcm9tTW5lbW9uaWMobW5lbW9uaWMpIHtcbiAgICAvLyBDcmVhdGUgd2FsbGV0IHVzaW5nIGVjYXNoLXdhbGxldCBsaWJyYXJ5XG4gICAgZWNhc2hXYWxsZXQgPSBXYWxsZXQuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBjaHJvbmlrKTtcbiAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhlY2FzaFdhbGxldCk7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB3ZWJWaWV3RXJyb3IoJ0Nhbm5vdCBnZXQgYWRkcmVzcyBmcm9tIHdhbGxldCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHN5bmNXYWxsZXQoKTtcbiAgICAvLyBDcmVhdGUgd2FsbGV0IGRhdGEgb2JqZWN0IC0gYmFsYW5jZSBpbiBzYXRvc2hpc1xuICAgIHdhbGxldCA9IHtcbiAgICAgICAgbW5lbW9uaWM6IG1uZW1vbmljLFxuICAgIH07XG4gICAgLy8gVXBkYXRlIGRpc3BsYXlzXG4gICAgdXBkYXRlV2FsbGV0RGlzcGxheSgpO1xuICAgIHVwZGF0ZVRyYW5zaXRpb25hbEJhbGFuY2UoKTtcbiAgICBnZW5lcmF0ZVFSQ29kZShhZGRyZXNzKTtcbiAgICBzdWJzY3JpYmVUb0FkZHJlc3MoYWRkcmVzcyk7XG4gICAgdHJhbnNhY3Rpb25IaXN0b3J5ID0gbmV3IFRyYW5zYWN0aW9uSGlzdG9yeU1hbmFnZXIoZWNhc2hXYWxsZXQsIGNocm9uaWspO1xuICAgIC8vIFVwZGF0ZSBORkMgYWRkcmVzcyBmb3IgdGFnIGVtdWxhdGlvblxuICAgIHVwZGF0ZU5mY0FkZHJlc3MoKTtcbiAgICAvLyBTZW5kIGFkZHJlc3MgYW5kIEJJUDIxIHByZWZpeCB0byB3YXRjaFxuICAgIHNlbmRNZXNzYWdlVG9CYWNrZW5kKCdTRU5EX0FERFJFU1NfVE9fV0FUQ0gnLCB7XG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIGJpcDIxUHJlZml4OiBjb25maWcuYmlwMjFQcmVmaXhcbiAgICB9KTtcbiAgICAvLyBOb3RpZnkgUmVhY3QgTmF0aXZlIHRoYXQgd2FsbGV0IGlzIHJlYWR5IChmb3IgcGVuZGluZyBORkMgcGF5bWVudHMpXG4gICAgc2VuZE1lc3NhZ2VUb0JhY2tlbmQoJ1dBTExFVF9SRUFEWScsIHRydWUpO1xufVxuLy8gTG9hZCB0aGUgd2FsbGV0LiBVc2UgdGhlIG1uZW1vbmljIGZyb20gc3RvcmFnZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBjcmVhdGVcbi8vIGEgbmV3IHdhbGxldC5cbmFzeW5jIGZ1bmN0aW9uIGxvYWRXYWxsZXQoZm9yY2VSZWxvYWQgPSBmYWxzZSkge1xuICAgIC8vIFByZXZlbnQgZHVwbGljYXRlIHdhbGxldCBjcmVhdGlvbiB1bmxlc3MgZm9yY2UgcmVsb2FkIGlzIHJlcXVlc3RlZFxuICAgIGlmIChlY2FzaFdhbGxldCAmJiAhZm9yY2VSZWxvYWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiBmb3JjZSByZWxvYWRpbmcsIHJlc2V0IHRoZSBleGlzdGluZyB3YWxsZXRcbiAgICBpZiAoZm9yY2VSZWxvYWQgJiYgZWNhc2hXYWxsZXQpIHtcbiAgICAgICAgZWNhc2hXYWxsZXQgPSBudWxsO1xuICAgIH1cbiAgICB3ZWJWaWV3TG9nKCdMb2FkaW5nIHRoZSB3YWxsZXQuLi4nKTtcbiAgICBsZXQgbW5lbW9uaWMgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIExvYWQgZXhpc3RpbmcgbW5lbW9uaWMgZnJvbSBzdG9yYWdlXG4gICAgICAgIG1uZW1vbmljID0gYXdhaXQgbG9hZE1uZW1vbmljKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBXZSBmYWlsZWQgdG8gbG9hZCB0aGUgbW5lbW9uaWMsIG1vc3QgbGlrZWx5IGJlY2F1c2UgdGhlIHVzZXIgZGlkIG5vdFxuICAgICAgICAvLyBjb21wbGV0ZSB0aGUgYXV0aGVudGljYXRpb24uIENsb3NlIHRoZSBhcHAuXG4gICAgICAgIHdlYlZpZXdMb2coJ0ZhaWxlZCB0byBsb2FkIGV4aXN0aW5nIHdhbGxldDonLCBlcnJvcik7XG4gICAgICAgIHNlbmRNZXNzYWdlVG9CYWNrZW5kKCdDTE9TRV9BUFAnLCB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIExvYWRpbmcgdGhlIG1uZW1vbmljIHN1Y2NlZWRlZCwgYnV0IHRoZSBtbmVtb25pYyBpcyBudWxsLiBUaGlzIG1lYW5zIHRoYXRcbiAgICAvLyB0aGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgd2FsbGV0IHlldC4gQ3JlYXRlIGEgbmV3IHdhbGxldC5cbiAgICBpZiAoIW1uZW1vbmljKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWJWaWV3TG9nKCdTdGFydGluZyB3YWxsZXQgY3JlYXRpb24gKGZpcnN0IHJ1bikuLi4nKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGFuZCBzdG9yZSBhIG5ldyBtbmVtb25pYyBmb3IgZmlyc3QgcnVuXG4gICAgICAgICAgICBtbmVtb25pYyA9IGdlbmVyYXRlTW5lbW9uaWMoKTtcbiAgICAgICAgICAgIHN0b3JlTW5lbW9uaWMobW5lbW9uaWMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgd2ViVmlld0Vycm9yKCdGYWlsZWQgdG8gY3JlYXRlIG1uZW1vbmljOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBsb2FkV2FsbGV0RnJvbU1uZW1vbmljKG1uZW1vbmljKTtcbn1cbi8vIFVwZGF0ZSB3YWxsZXQgZGlzcGxheSAoYWRkcmVzcyBhbmQgYmFsYW5jZSlcbmZ1bmN0aW9uIHVwZGF0ZVdhbGxldERpc3BsYXkoKSB7XG4gICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgd2ViVmlld0Vycm9yKCdObyB3YWxsZXQgZGF0YSwgY2Fubm5vdCB1cGRhdGUgdGhlIGRpc3BsYXknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhlY2FzaFdhbGxldCk7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgIHdlYlZpZXdFcnJvcignTm8gYWRkcmVzcywgY2Fubm90IHVwZGF0ZSB0aGUgZGlzcGxheScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFkZHJlc3NFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZGRyZXNzJyk7XG4gICAgaWYgKGFkZHJlc3NFbCkge1xuICAgICAgICBhZGRyZXNzRWwudGV4dENvbnRlbnQgPSBhZGRyZXNzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2ViVmlld0Vycm9yKCdhZGRyZXNzRWwgbm90IGZvdW5kLCBjYW5ub3QgdXBkYXRlIGFkZHJlc3MgZGlzcGxheScpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgYmFsYW5jZSBkaXNwbGF5LCBubyBhbmltYXRpb25cbiAgICB1cGRhdGVBdmFpbGFibGVCYWxhbmNlRGlzcGxheShmYWxzZSk7XG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBCQUxBTkNFIEFORCBUUkFOU0FDVElPTiBNQU5BR0VNRU5UIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQWRkIHBlbmRpbmcgdHJhbnNhY3Rpb24gYW1vdW50XG5hc3luYyBmdW5jdGlvbiBhZGRQZW5kaW5nQW1vdW50KHR4aWQsIHN0YXRlKSB7XG4gICAgaWYgKHBlbmRpbmdBbW91bnRzW3R4aWRdKSB7XG4gICAgICAgIHdlYlZpZXdMb2coYFRyYW5zYWN0aW9uICR7dHhpZH0gYWxyZWFkeSBleGlzdHMgaW4gcGVuZGluZyBhbW91bnRzLCBpZ25vcmluZyBkdXBsaWNhdGVgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0eEFtb3VudFNhdHMgPSBhd2FpdCBjYWxjdWxhdGVUcmFuc2FjdGlvbkFtb3VudFNhdHMoZWNhc2hXYWxsZXQsIGNocm9uaWssIHR4aWQpO1xuICAgIGlmICh0eEFtb3VudFNhdHMgPT0gMCkge1xuICAgICAgICB3ZWJWaWV3TG9nKGBUcmFuc2FjdGlvbiAke3R4aWR9IGhhcyBubyBhbW91bnQsIGlnbm9yaW5nYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcGVuZGluZ0Ftb3VudHNbdHhpZF0gPSB7XG4gICAgICAgIGFtb3VudFNhdHM6IHR4QW1vdW50U2F0cyxcbiAgICAgICAgc3RhdGUsXG4gICAgfTtcbiAgICB3ZWJWaWV3TG9nKGBBZGRlZCBwZW5kaW5nIHRyYW5zYWN0aW9uICR7dHhpZH06ICR7c2F0c1RvWGVjKHR4QW1vdW50U2F0cyl9ICR7Y29uZmlnLnRpY2tlcn0gKCR7dHhBbW91bnRTYXRzfSBzYXRzLCBzdGF0ZTogJHtzdGF0ZX0pYCk7XG4gICAgcmV0dXJuIHBlbmRpbmdBbW91bnRzW3R4aWRdO1xufVxuZnVuY3Rpb24gZmluYWxpemVUcmFuc2FjdGlvbihhbW91bnRTYXRzKSB7XG4gICAgYXZhaWxhYmxlQmFsYW5jZVNhdHMgKz0gYW1vdW50U2F0cztcbiAgICB1cGRhdGVUcmFuc2l0aW9uYWxCYWxhbmNlKCk7XG4gICAgdXBkYXRlQXZhaWxhYmxlQmFsYW5jZURpc3BsYXkodHJ1ZSk7IC8vIEFuaW1hdGUgd2hlbiBmaW5hbGl6aW5nIHRyYW5zYWN0aW9uc1xuICAgIHRyaWdnZXJTaGFrZUFuaW1hdGlvbigpO1xuICAgIC8vIFRyaWdnZXIgaGFwdGljIGZlZWRiYWNrIGZvciB0cmFuc2FjdGlvbiBmaW5hbGl6YXRpb25cbiAgICBzZW5kTWVzc2FnZVRvQmFja2VuZCgnVFhfRklOQUxJWkVEJywgdW5kZWZpbmVkKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmFsaXplUHJlQ29uc2Vuc3VzKHR4aWQpIHtcbiAgICBsZXQgdHg7XG4gICAgaWYgKHBlbmRpbmdBbW91bnRzW3R4aWRdKSB7XG4gICAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSB0aGUgdHJhbnNhY3Rpb24gaW4gb3VyIHBlbmRpbmcgYW1vdW50cywgc28gd2UgY2FuXG4gICAgICAgIC8vIGp1c3QgdXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICB0eCA9IHBlbmRpbmdBbW91bnRzW3R4aWRdO1xuICAgICAgICB0eC5zdGF0ZSA9ICdmaW5hbGl6ZWQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcGVuZGluZ190eCA9IGF3YWl0IGFkZFBlbmRpbmdBbW91bnQodHhpZCwgJ2ZpbmFsaXplZCcpO1xuICAgICAgICBpZiAoIXBlbmRpbmdfdHgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0eCA9IHBlbmRpbmdfdHg7XG4gICAgfVxuICAgIGZpbmFsaXplVHJhbnNhY3Rpb24odHguYW1vdW50U2F0cyk7XG4gICAgd2ViVmlld0xvZyhgUHJlLWNvbnNlbnN1cyBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gJHt0eGlkfTogJHtzYXRzVG9YZWModHguYW1vdW50U2F0cyl9ICR7Y29uZmlnLnRpY2tlcn0gbW92ZWQgdG8gYXZhaWxhYmxlIGJhbGFuY2UsIHN0YXRlIHNldCB0byBmaW5hbGl6ZWRgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpbmFsaXplUG9zdENvbnNlbnN1cyh0eGlkKSB7XG4gICAgaWYgKCFwZW5kaW5nQW1vdW50c1t0eGlkXSkge1xuICAgICAgICAvLyBXZSdyZSBsb3N0LCBqdXN0IHJlc3luY1xuICAgICAgICB3ZWJWaWV3TG9nKGBQb3N0LWNvbnNlbnN1cyBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gJHt0eGlkfSBidXQgaXQncyBub3QgcGVuZGluZywgcmVzeW5jaW5nYCk7XG4gICAgICAgIGF3YWl0IHN5bmNXYWxsZXQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHBlbmRpbmdBbW91bnRzW3R4aWRdO1xuICAgIGlmICh0eC5zdGF0ZSA9PT0gJ3BlbmRpbmdfZmluYWxpemF0aW9uJykge1xuICAgICAgICBmaW5hbGl6ZVRyYW5zYWN0aW9uKHR4LmFtb3VudFNhdHMpO1xuICAgICAgICB3ZWJWaWV3TG9nKGBQb3N0LWNvbnNlbnN1cyBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gJHt0eGlkfSB3aGljaCBpcyBwZW5kaW5nIGZpbmFsaXphdGlvbiwgbW92aW5nIHRvIGF2YWlsYWJsZSBiYWxhbmNlYCk7XG4gICAgfVxuICAgIC8vIFdlIHdvbid0IGdldCBhbnkgbWVzc2FnZSBmb3IgdGhpcyB0cmFuc2FjdGlvbiBhbnltb3JlXG4gICAgZGVsZXRlIHBlbmRpbmdBbW91bnRzW3R4aWRdO1xufVxuLy8gVXBkYXRlIHRyYW5zaXRpb25hbCBiYWxhbmNlIGRpc3BsYXlcbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb25hbEJhbGFuY2UoKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHBlbmRpbmcgYW1vdW50c1xuICAgIHRyYW5zaXRpb25hbEJhbGFuY2VTYXRzID0gMDtcbiAgICBmb3IgKGNvbnN0IHR4IG9mIE9iamVjdC52YWx1ZXMocGVuZGluZ0Ftb3VudHMpLmZpbHRlcih0eCA9PiB0eC5zdGF0ZSA9PT0gJ3BlbmRpbmdfZmluYWxpemF0aW9uJykpIHtcbiAgICAgICAgLy8gQW1vdW50IHNpZ24gZGV0ZXJtaW5lcyB0eXBlOiBwb3NpdGl2ZSA9IHJlY2VpdmUsIG5lZ2F0aXZlID0gc2VuZCwgMCA9IHJlY2VpdmVcbiAgICAgICAgdHJhbnNpdGlvbmFsQmFsYW5jZVNhdHMgKz0gdHguYW1vdW50U2F0cztcbiAgICB9XG4gICAgd2ViVmlld0xvZygnVXBkYXRlZCB0cmFuc2l0aW9uYWwgYmFsYW5jZTonLCBzYXRzVG9YZWModHJhbnNpdGlvbmFsQmFsYW5jZVNhdHMpLCBjb25maWcudGlja2VyLCAnKCcsIHRyYW5zaXRpb25hbEJhbGFuY2VTYXRzLCAnc2F0cyknKTtcbiAgICAvLyBVcGRhdGUgdHJhbnNpdGlvbmFsIGJhbGFuY2UgZGlzcGxheVxuICAgIGNvbnN0IHRyYW5zaXRpb25hbEJhbGFuY2VFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFuc2l0aW9uYWwtYmFsYW5jZScpO1xuICAgIGlmICh0cmFuc2l0aW9uYWxCYWxhbmNlRWwpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25hbEJhbGFuY2VTYXRzICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduID0gdHJhbnNpdGlvbmFsQmFsYW5jZVNhdHMgPiAwID8gJysnIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHJhbnNpdGlvbmFsQmFsYW5jZVNhdHMgPiAwID8gJ3JlY2VpdmUnIDogJ3NwZW5kJztcbiAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlUZXh0ID0gYCR7c2lnbn0ke3NhdHNUb1hlYyh0cmFuc2l0aW9uYWxCYWxhbmNlU2F0cykudG9GaXhlZCgyKX0gJHtjb25maWcudGlja2VyfWA7XG4gICAgICAgICAgICB0cmFuc2l0aW9uYWxCYWxhbmNlRWwudGV4dENvbnRlbnQgPSBkaXNwbGF5VGV4dDtcbiAgICAgICAgICAgIHRyYW5zaXRpb25hbEJhbGFuY2VFbC5jbGFzc05hbWUgPSBgdHJhbnNpdGlvbmFsLWJhbGFuY2UgJHt0eXBlfWA7XG4gICAgICAgICAgICB0cmFuc2l0aW9uYWxCYWxhbmNlRWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uYWxCYWxhbmNlRWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdlYlZpZXdFcnJvcigndHJhbnNpdGlvbmFsQmFsYW5jZUVsIG5vdCBmb3VuZCwgY2Fubm90IHVwZGF0ZSB0cmFuc2l0aW9uYWwgYmFsYW5jZSBkaXNwbGF5Jyk7XG4gICAgfVxufVxuLy8gVXBkYXRlIGF2YWlsYWJsZSBiYWxhbmNlIGRpc3BsYXkgd2l0aCBvcHRpb25hbCBhbmltYXRpb25cbmZ1bmN0aW9uIHVwZGF0ZUF2YWlsYWJsZUJhbGFuY2VEaXNwbGF5KGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgY29uc3QgYmFsYW5jZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhbGFuY2UnKTtcbiAgICBpZiAoYmFsYW5jZUVsKSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2VYZWMgPSBzYXRzVG9YZWMoYXZhaWxhYmxlQmFsYW5jZVNhdHMpO1xuICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgICAgYW5pbWF0ZUJhbGFuY2VDaGFuZ2UoYmFsYW5jZUVsLCBiYWxhbmNlWGVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhbGFuY2VFbC50ZXh0Q29udGVudCA9IGAke2JhbGFuY2VYZWMudG9GaXhlZCgyKX0gJHtjb25maWcudGlja2VyfWA7XG4gICAgICAgIH1cbiAgICAgICAgd2ViVmlld0xvZygnQXZhaWxhYmxlIGJhbGFuY2UgdXBkYXRlZDonLCBiYWxhbmNlWGVjLCBjb25maWcudGlja2VyLCAnKCcsIGF2YWlsYWJsZUJhbGFuY2VTYXRzLCAnc2F0cyknKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdlYlZpZXdFcnJvcignYmFsYW5jZUVsIG5vdCBmb3VuZCwgY2Fubm90IHVwZGF0ZSBhdmFpbGFibGUgYmFsYW5jZSBkaXNwbGF5Jyk7XG4gICAgfVxufVxuLy8gQW5pbWF0ZSBiYWxhbmNlIGNoYW5nZSB3aXRoIGNvdW50aW5nIGVmZmVjdFxuZnVuY3Rpb24gYW5pbWF0ZUJhbGFuY2VDaGFuZ2UoYmFsYW5jZUVsLCB0YXJnZXRCYWxhbmNlKSB7XG4gICAgY29uc3Qgc3RhcnRCYWxhbmNlID0gcGFyc2VGbG9hdChiYWxhbmNlRWwudGV4dENvbnRlbnQ/LnJlcGxhY2UoYCAke2NvbmZpZy50aWNrZXJ9YCwgJycpIHx8ICcwJyk7XG4gICAgY29uc3QgZGlmZmVyZW5jZSA9IHRhcmdldEJhbGFuY2UgLSBzdGFydEJhbGFuY2U7XG4gICAgY29uc3QgZHVyYXRpb24gPSAxMDAwOyAvLyAxIHNlY29uZCBhbmltYXRpb25cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIC8vIEFkZCBoaWdobGlnaHQgZWZmZWN0IGZvciBiYWxhbmNlIGNoYW5nZXNcbiAgICBpZiAoTWF0aC5hYnMoZGlmZmVyZW5jZSkgPiAwLjAxKSB7IC8vIE9ubHkgaGlnaGxpZ2h0IGlmIHRoZXJlJ3MgYSBtZWFuaW5nZnVsIGNoYW5nZVxuICAgICAgICBiYWxhbmNlRWwuc3R5bGUudHJhbnNpdGlvbiA9ICdhbGwgMC4zcyBlYXNlJztcbiAgICAgICAgYmFsYW5jZUVsLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgxLjA1KSc7XG4gICAgICAgIGJhbGFuY2VFbC5zdHlsZS5jb2xvciA9IGRpZmZlcmVuY2UgPiAwID8gJyM0YWRlODAnIDogJyNmODcxNzEnOyAvLyBHcmVlbiBmb3IgaW5jcmVhc2UsIHJlZCBmb3IgZGVjcmVhc2VcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBiYWxhbmNlRWwuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICAgICAgICAgIGJhbGFuY2VFbC5zdHlsZS5jb2xvciA9ICcnO1xuICAgICAgICB9LCAzMDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVCYWxhbmNlKCkge1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gZHVyYXRpb24sIDEpO1xuICAgICAgICAvLyBVc2UgZWFzaW5nIGZ1bmN0aW9uIGZvciBzbW9vdGggYW5pbWF0aW9uXG4gICAgICAgIGNvbnN0IGVhc2VPdXRDdWJpYyA9IDEgLSBNYXRoLnBvdygxIC0gcHJvZ3Jlc3MsIDMpO1xuICAgICAgICBjb25zdCBjdXJyZW50QmFsYW5jZSA9IHN0YXJ0QmFsYW5jZSArIChkaWZmZXJlbmNlICogZWFzZU91dEN1YmljKTtcbiAgICAgICAgYmFsYW5jZUVsLnRleHRDb250ZW50ID0gYCR7Y3VycmVudEJhbGFuY2UudG9GaXhlZCgyKX0gJHtjb25maWcudGlja2VyfWA7XG4gICAgICAgIGlmIChwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVCYWxhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGNvbG9yIGFmdGVyIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJhbGFuY2VFbC5zdHlsZS5jb2xvciA9ICcnO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlQmFsYW5jZSk7XG59XG4vLyBUcmlnZ2VyIHNoYWtlIGFuaW1hdGlvblxuZnVuY3Rpb24gdHJpZ2dlclNoYWtlQW5pbWF0aW9uKCkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25hbEJhbGFuY2VFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFuc2l0aW9uYWwtYmFsYW5jZScpO1xuICAgIGlmICh0cmFuc2l0aW9uYWxCYWxhbmNlRWwpIHtcbiAgICAgICAgdHJhbnNpdGlvbmFsQmFsYW5jZUVsLmNsYXNzTGlzdC5hZGQoJ3NoYWtlJyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdHJhbnNpdGlvbmFsQmFsYW5jZUVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NoYWtlJyk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3ZWJWaWV3RXJyb3IoJ3RyYW5zaXRpb25hbEJhbGFuY2VFbCBub3QgZm91bmQsIGNhbm5vdCB0cmlnZ2VyIHNoYWtlIGFuaW1hdGlvbicpO1xuICAgIH1cbn1cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBtYWluIHNjcmVlbiBpcyB2aXNpYmxlXG5mdW5jdGlvbiBpc01haW5TY3JlZW5WaXNpYmxlKCkge1xuICAgIGNvbnN0IHNlbmRTY3JlZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VuZC1zY3JlZW4nKTtcbiAgICBjb25zdCBzZXR0aW5nc1NjcmVlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1zY3JlZW4nKTtcbiAgICAvLyBNYWluIHNjcmVlbiBpcyB2aXNpYmxlIGlmIGJvdGggc2VuZCBhbmQgc2V0dGluZ3Mgc2NyZWVucyBhcmUgaGlkZGVuXG4gICAgcmV0dXJuICghc2VuZFNjcmVlbiB8fCBzZW5kU2NyZWVuLmNsYXNzTGlzdC5jb250YWlucygnaGlkZGVuJykpICYmXG4gICAgICAgICghc2V0dGluZ3NTY3JlZW4gfHwgc2V0dGluZ3NTY3JlZW4uY2xhc3NMaXN0LmNvbnRhaW5zKCdoaWRkZW4nKSk7XG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQVUxMLVRPLVJFRlJFU0ggRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQdWxsLXRvLXJlZnJlc2ggZnVuY3Rpb25zIHVzaW5nIFB1bGxUb1JlZnJlc2guanMgbGlicmFyeVxuZnVuY3Rpb24gaW5pdFB1bGxUb1JlZnJlc2goKSB7XG4gICAgUHVsbFRvUmVmcmVzaC5pbml0KHtcbiAgICAgICAgbWFpbkVsZW1lbnQ6ICcuY29udGFpbmVyJyxcbiAgICAgICAgb25SZWZyZXNoOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHN5bmNXYWxsZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHdlYlZpZXdFcnJvcignRmFpbGVkIHB1bGwtdG8tcmVmcmVzaCBzeW5jOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkUHVsbFRvUmVmcmVzaDogKCkgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBhbGxvdyBwdWxsLXRvLXJlZnJlc2ggb24gdGhlIG1haW4gc2NyZWVuXG4gICAgICAgICAgICByZXR1cm4gaXNNYWluU2NyZWVuVmlzaWJsZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBRUiBTQ0FOTkVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gaGFuZGxlU2NhbkJ1dHRvbkNsaWNrKCkge1xuICAgIHN0b3BRUlNjYW5uZXIoKTtcbiAgICBzdGFydFFSU2Nhbm5lcihoYW5kbGVRUlNjYW5SZXN1bHQpO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xvc2VDYW1lcmEoKSB7XG4gICAgc3RvcFFSU2Nhbm5lcih0cnVlKTsgLy8gRm9yY2UgY2xvc2UgdGhlIG1vZGFsXG4gICAgaGlkZU5vQ2FtZXJhRmFsbGJhY2soKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVFSU2NhblJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyBGaXJzdCwgdHJ5IHRvIHBhcnNlIGFzIEJJUDIxIFVSSVxuICAgIGNvbnN0IGJpcDIxUmVzdWx0ID0gcGFyc2VCaXAyMVVyaShyZXN1bHQpO1xuICAgIGlmIChiaXAyMVJlc3VsdCkge1xuICAgICAgICB3ZWJWaWV3TG9nKCdCSVAyMSBVUkkgc2Nhbm5lZDonLCByZXN1bHQpO1xuICAgICAgICBzdG9wUVJTY2FubmVyKCk7XG4gICAgICAgIGF3YWl0IG9wZW5TZW5kU2NyZWVuV2l0aEFkZHJlc3MoYmlwMjFSZXN1bHQuYWRkcmVzcywgYmlwMjFSZXN1bHQuc2F0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2s6IHZhbGlkYXRlIGlmIHRoZSBzY2FubmVkIGRhdGEgaXMgYSBwbGFpbiB2YWxpZCBlQ2FzaCBhZGRyZXNzXG4gICAgaWYgKGlzVmFsaWRFQ2FzaEFkZHJlc3MocmVzdWx0KSkge1xuICAgICAgICB3ZWJWaWV3TG9nKCdlQ2FzaCBhZGRyZXNzIHNjYW5uZWQ6JywgcmVzdWx0KTtcbiAgICAgICAgc3RvcFFSU2Nhbm5lcigpO1xuICAgICAgICBhd2FpdCBvcGVuU2VuZFNjcmVlbldpdGhBZGRyZXNzKHJlc3VsdCk7XG4gICAgfVxufVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU1lOQyBBTkQgU1VCU0NSSVBUSU9OIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU3Vic2NyaWJlIHRvIGFkZHJlc3Mgbm90aWZpY2F0aW9ucyB2aWEgQ2hyb25payBXZWJTb2NrZXQuXG4vLyBUaGlzIGlzIHdoZXJlIHRoZSBtYWluIHdhbGxldCB1cGRhdGUgbG9naWMgaGFwcGVucy5cbmFzeW5jIGZ1bmN0aW9uIHN1YnNjcmliZVRvQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ2xvc2UgZXhpc3RpbmcgY29ubmVjdGlvbiBpZiBhbnlcbiAgICAgICAgdW5zdWJzY3JpYmVGcm9tQWRkcmVzcygpO1xuICAgICAgICAvLyBDcmVhdGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdXNpbmcgY2hyb25pay1jbGllbnRcbiAgICAgICAgd3NFbmRwb2ludCA9IGNocm9uaWsud3Moe1xuICAgICAgICAgICAgb25Db25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2ViVmlld0xvZygnQ2hyb25payBXZWJTb2NrZXQgY29ubmVjdGVkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNvbm5lY3Q6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgd2ViVmlld0xvZygnQ2hyb25payBXZWJTb2NrZXQgcmVjb25uZWN0aW5nOicsIGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTWVzc2FnZTogYXN5bmMgKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKCdtc2dUeXBlJyBpbiBtc2cpIHx8ICEoJ3R4aWQnIGluIG1zZykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2ViVmlld0Vycm9yKCdObyBtc2dUeXBlLCBza2lwcGluZyB3ZWJzb2NrZXQgbWVzc2FnZTonLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKCd0eGlkJyBpbiBtc2cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlYlZpZXdFcnJvcignTm8gdHhpZCwgc2tpcHBpbmcgd2Vic29ja2V0IG1lc3NhZ2U6JywgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0eGlkID0gbXNnLnR4aWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtc2cubXNnVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVFhfQURERURfVE9fTUVNUE9PTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRyYW5zYWN0aW9uIGlzIG5vdCBmaW5hbGl6ZWQgeWV0LCBzaG93IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIHRyYW5zaXRpb25hbCBiYWxhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBhd2FpdCBhZGRQZW5kaW5nQW1vdW50KHR4aWQsICdwZW5kaW5nX2ZpbmFsaXphdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViVmlld0Vycm9yKGBGYWlsZWQgdG8gYWRkIHBlbmRpbmcgbWVtcG9vbCB0cmFuc2FjdGlvbjogJHt0eGlkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVHJhbnNpdGlvbmFsQmFsYW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTaGFrZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYlZpZXdMb2coYEFkZGVkIHBlbmRpbmcgdHJhbnNhY3Rpb246ICR7c2F0c1RvWGVjKHR4LmFtb3VudFNhdHMpfSAke2NvbmZpZy50aWNrZXJ9IGZvciB0eCAke3R4aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdUWF9DT05GSVJNRUQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nQW1vdW50c1t0eGlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBzY2VuYXJpb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJWaWV3TG9nKGBDb25maXJtZWQgdHJhbnNhY3Rpb24gJHt0eGlkfSBpcyBhbHJlYWR5IHBlbmRpbmcgd2l0aCBzdGF0ZSAke3BlbmRpbmdBbW91bnRzW3R4aWRdLnN0YXRlfSwgc2tpcHBpbmdgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwZW5kaW5nIHRyYW5zYWN0aW9uIGRvZXNuJ3QgZXhpc3QsIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gZmlndXJlIG91dCBpZiBpdCdzIGJlZW4gZmluYWxpemVkIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByZS1jb25zZW5zdXMgb3Igbm90LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGZpbmFsIHdlIGhhdmUgbm8gd2F5IHRvIGtub3cgd2hldGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGFscmVhZHkgYmVlbiBhY2NvdW50ZWQgZm9yIG9yIG5vdCAoZS5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IG9wZW5lZCB0aGUgd2FsbGV0KS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIGRvIG5vdGhpbmcgYW5kIHdhaXQgZm9yIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibG9jayB0byBldmVudHVhbGx5IGZpbmFsaXplIHRvIHJlc3luYyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FsbGV0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHJvbmlrX3R4ID0gYXdhaXQgY2hyb25pay50eCh0eGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaHJvbmlrX3R4LmlzRmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgYWRkUGVuZGluZ0Ftb3VudCh0eGlkLCAncGVuZGluZ19maW5hbGl6YXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJWaWV3RXJyb3IoYEZhaWxlZCB0byBhZGQgcGVuZGluZyBjb25maXJtZWQgdHJhbnNhY3Rpb246ICR7dHhpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRyYW5zaXRpb25hbEJhbGFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTaGFrZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViVmlld0xvZyhgQWRkZWQgcGVuZGluZyBjb25maXJtZWQgdHJhbnNhY3Rpb246ICR7c2F0c1RvWGVjKHR4LmFtb3VudFNhdHMpfSAke2NvbmZpZy50aWNrZXJ9IGZvciB0eCAke3R4aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdUWF9GSU5BTElaRUQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobXNnLmZpbmFsaXphdGlvblJlYXNvblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVFhfRklOQUxJWkFUSU9OX1JFQVNPTl9QUkVfQ09OU0VOU1VTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplUHJlQ29uc2Vuc3VzKHR4aWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RYX0ZJTkFMSVpBVElPTl9SRUFTT05fUE9TVF9DT05TRU5TVVMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxpemVQb3N0Q29uc2Vuc3VzKHR4aWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJWaWV3RXJyb3IoYFVua25vd24gZmluYWxpemF0aW9uIHJlYXNvbiBmb3IgJHt0eGlkfTogYCwgbXNnLmZpbmFsaXphdGlvblJlYXNvblR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVFhfUkVNT1ZFRF9GUk9NX01FTVBPT0wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVFhfSU5WQUxJREFURUQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwZW5kaW5nQW1vdW50c1t0eGlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUcmFuc2l0aW9uYWxCYWxhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlclNoYWtlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViVmlld0xvZyhgUmVtb3ZlZCBwZW5kaW5nIHRyYW5zYWN0aW9uOiAke3R4aWR9LCByZWFzb246ICR7bXNnLm1zZ1R5cGV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYlZpZXdFcnJvcihgVW5rbm93biBtZXNzYWdlIHR5cGU6ICR7bXNnLm1zZ1R5cGV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlYlZpZXdFcnJvcignRmFpbGVkIHByb2Nlc3NpbmcgV2ViU29ja2V0IG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdhaXQgZm9yIFdlYlNvY2tldCB0byBiZSBjb25uZWN0ZWRcbiAgICAgICAgYXdhaXQgd3NFbmRwb2ludC53YWl0Rm9yT3BlbigpO1xuICAgICAgICB3c0VuZHBvaW50LnN1YnNjcmliZVRvQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgd2ViVmlld0xvZygnU3Vic2NyaWJlZCB0byBhZGRyZXNzIG5vdGlmaWNhdGlvbnMgZm9yOicsIGFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgd2ViVmlld0Vycm9yKCdGYWlsZWQgdG8gc3Vic2NyaWJlIHRvIGFkZHJlc3Mgbm90aWZpY2F0aW9uczonLCBlcnJvcik7XG4gICAgfVxufVxuLy8gVW5zdWJzY3JpYmUgZnJvbSBhZGRyZXNzIG5vdGlmaWNhdGlvbnNcbmZ1bmN0aW9uIHVuc3Vic2NyaWJlRnJvbUFkZHJlc3MoKSB7XG4gICAgLy8gQWN0dWFsbHkgdW5zdWJzY3JpYmUgZnJvbSBhbGxcbiAgICBpZiAod3NFbmRwb2ludCkge1xuICAgICAgICB3c0VuZHBvaW50LmNsb3NlKCk7XG4gICAgICAgIHdzRW5kcG9pbnQgPSBudWxsO1xuICAgICAgICB3ZWJWaWV3TG9nKCdVbnN1YnNjcmliZWQgZnJvbSBhZGRyZXNzIG5vdGlmaWNhdGlvbnMnKTtcbiAgICB9XG59XG4vLyBTeW5jIHdhbGxldCAod2l0aCBmaW5hbGl6YXRpb24gZm9yIG1hbnVhbCBzeW5jKVxuYXN5bmMgZnVuY3Rpb24gc3luY1dhbGxldCgpIHtcbiAgICB3ZWJWaWV3TG9nKCdTeW5jaW5nIHdhbGxldC4uLicpO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEFkZCB0aW1lb3V0IHRvIHByZXZlbnQgaGFuZ2luZ1xuICAgICAgICBjb25zdCBzeW5jUHJvbWlzZSA9IGVjYXNoV2FsbGV0LnN5bmMoKTtcbiAgICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ05ldHdvcmsgdGltZW91dCAtIHBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24nKSksIDMwMDAwKSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbc3luY1Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICAgIGNvbnN0IHNwZW5kYWJsZVV0eG9zID0gZWNhc2hXYWxsZXQuc3BlbmRhYmxlU2F0c09ubHlVdHhvcygpO1xuICAgICAgICBjb25zdCBmaW5hbFV0eG9zID0gc3BlbmRhYmxlVXR4b3MuZmlsdGVyKHV0eG8gPT4gdXR4by5pc0ZpbmFsKTtcbiAgICAgICAgYXZhaWxhYmxlQmFsYW5jZVNhdHMgPSBOdW1iZXIoZmluYWxVdHhvcy5yZWR1Y2UoKHN1bSwgdXR4bykgPT4gc3VtICsgdXR4by5zYXRzLCAwbikpO1xuICAgICAgICAvLyBDbGVhciBhbGwgcGVuZGluZyB0cmFuc2FjdGlvbnMuIFRoZXkgd2lsbCBiZSByZS1hZGRlZCBhcyBuZWVkZWQgaWYgd2VcbiAgICAgICAgLy8gZ2V0IGEgbWVzc2FnZSBmb3IgdGhlbS5cbiAgICAgICAgcGVuZGluZ0Ftb3VudHMgPSB7fTtcbiAgICAgICAgdHJhbnNpdGlvbmFsQmFsYW5jZVNhdHMgPSAwO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGRpc3BsYXlcbiAgICAgICAgdXBkYXRlQXZhaWxhYmxlQmFsYW5jZURpc3BsYXkoZmFsc2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgd2ViVmlld0Vycm9yKCdGYWlsZWQgdG8gc3luYyB3YWxsZXQ6JywgZXJyb3IpO1xuICAgICAgICAvLyBTaG93IHVzZXItZnJpZW5kbHkgZXJyb3IgbWVzc2FnZVxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygndGltZW91dCcpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ05ldHdvcmsnKSkge1xuICAgICAgICAgICAgd2ViVmlld0Vycm9yKCdObyBpbnRlcm5ldCBjb25uZWN0aW9uIC0gcGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBhbmQgdHJ5IGFnYWluJyk7XG4gICAgICAgICAgICBzaG93RXJyb3JNb2RhbCgnTmV0d29yayBFcnJvcicsICdObyBpbnRlcm5ldCBjb25uZWN0aW9uIC0gcGxlYXNlIGNoZWNrIHlvdXIgbmV0d29yayBhbmQgdHJ5IGFnYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2gnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCduZXR3b3JrJykpIHtcbiAgICAgICAgICAgIHdlYlZpZXdFcnJvcignTmV0d29yayBlcnJvciAtIHVuYWJsZSB0byBjb25uZWN0IHRvIGVDYXNoIG5ldHdvcmsnKTtcbiAgICAgICAgICAgIHNob3dFcnJvck1vZGFsKCdDb25uZWN0aW9uIEVycm9yJywgJ05ldHdvcmsgZXJyb3IgLSB1bmFibGUgdG8gY29ubmVjdCB0byBlQ2FzaCBuZXR3b3JrJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3ZWJWaWV3RXJyb3IoJ0ZhaWxlZCB0byBzeW5jIHdhbGxldCAtIHBsZWFzZSB0cnkgYWdhaW4nKTtcbiAgICAgICAgICAgIHNob3dFcnJvck1vZGFsKCdTeW5jIEVycm9yJywgJ0ZhaWxlZCB0byBzeW5jIHdhbGxldCAtIHBsZWFzZSB0cnkgYWdhaW4nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIElOSVRJQUxJWkFUSU9OIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSW5pdGlhbGl6ZSB0aGUgYXBwIHdoZW4gRE9NIGlzIHJlYWR5XG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplQXBwKCkge1xuICAgIHdlYlZpZXdMb2coJ0luaXRpYWxpemluZyBhcHAuLi4nKTtcbiAgICAvLyBMb2FkIHNhdmVkIHNldHRpbmdzXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBsb2FkU2V0dGluZ3MoKTtcbiAgICByZXF1aXJlSG9sZFRvU2VuZCA9IHNldHRpbmdzLnJlcXVpcmVIb2xkVG9TZW5kO1xuICAgIC8vIEluaXRpYWxpemUgdGlja2VyIHN5bWJvbHMgaW4gSFRNTFxuICAgIGNvbnN0IHRpY2tlckVsZW1lbnRzID0gW1xuICAgICAgICAndGlja2VyLWJhbGFuY2UnLFxuICAgICAgICAndGlja2VyLWxhYmVsJyxcbiAgICAgICAgJ3RpY2tlci1zbGlkZXItbWluJyxcbiAgICAgICAgJ3RpY2tlci1zbGlkZXItbWF4J1xuICAgIF07XG4gICAgZm9yIChjb25zdCBlbGVtZW50SWQgb2YgdGlja2VyRWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gY29uZmlnLnRpY2tlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgdGhlIGJhY2sgYXJyb3cgaWNvbnNcbiAgICBmb3IgKGNvbnN0IGljb25FbCBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYmFjay1hcnJvdy1pY29uJykpIHtcbiAgICAgICAgaWNvbkVsLnNyYyA9IGJhY2tBcnJvd0ljb247XG4gICAgfVxuICAgIC8vIFNldCB0aGUgZUNhc2ggbG9nbyBzb3VyY2VcbiAgICBjb25zdCBsb2dvRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWNhc2gtbG9nbycpO1xuICAgIGlmIChsb2dvRWwpIHtcbiAgICAgICAgbG9nb0VsLnNyYyA9IGVjYXNoTG9nbztcbiAgICB9XG4gICAgLy8gU2V0IHRoZSBlZGl0IGljb24gc291cmNlXG4gICAgY29uc3QgZWRpdEljb25FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0LWljb24nKTtcbiAgICBpZiAoZWRpdEljb25FbCkge1xuICAgICAgICBlZGl0SWNvbkVsLnNyYyA9IGVkaXRJY29uO1xuICAgIH1cbiAgICAvLyBTZXQgdGhlIGhpc3RvcnkgaWNvbiBzb3VyY2VcbiAgICBjb25zdCBoaXN0b3J5SWNvbkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hpc3RvcnktaWNvbicpO1xuICAgIGlmIChoaXN0b3J5SWNvbkVsKSB7XG4gICAgICAgIGhpc3RvcnlJY29uRWwuc3JjID0gaGlzdG9yeUljb247XG4gICAgfVxuICAgIC8vIFNldCB0aGUgbm8gY2FtZXJhIGljb24gc291cmNlXG4gICAgY29uc3Qgbm9DYW1lcmFJY29uRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbm8tY2FtZXJhLWljb24nKTtcbiAgICBpZiAobm9DYW1lcmFJY29uRWwpIHtcbiAgICAgICAgbm9DYW1lcmFJY29uRWwuc3JjID0gbm9DYW1lcmFJY29uO1xuICAgIH1cbiAgICAvLyBTZXQgdGhlIFFSIGNvZGUgaWNvbiBzb3VyY2VcbiAgICBjb25zdCBxckljb25FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdxci1pY29uJyk7XG4gICAgaWYgKHFySWNvbkVsKSB7XG4gICAgICAgIHFySWNvbkVsLnNyYyA9IHFyQ29kZUljb247XG4gICAgfVxuICAgIC8vIFNldCB0aGUgc2V0dGluZ3MgaWNvbiBzb3VyY2VcbiAgICBjb25zdCBzZXR0aW5nc0ljb25FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1pY29uJyk7XG4gICAgaWYgKHNldHRpbmdzSWNvbkVsKSB7XG4gICAgICAgIHNldHRpbmdzSWNvbkVsLnNyYyA9IHNldHRpbmdzSWNvbjtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBwdWxsLXRvLXJlZnJlc2hcbiAgICBpbml0UHVsbFRvUmVmcmVzaCgpO1xuICAgIC8vIEFsd2F5cyByZXF1aXJlIGF1dGhlbnRpY2F0aW9uIG9uIGFwcCBsYXVuY2ggKGZvciBzZWN1cml0eSlcbiAgICAvLyBTaG93IGxvYWRpbmcgc2NyZWVuIHdpdGggYW4gb3BhcXVlIGJhY2tncm91bmQgZm9yIGJldHRlciBwcml2YWN5OiB3ZSB3YW50XG4gICAgLy8gdG8gYXZvaWQgYW55Ym9keSBzZWVpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIHdhbGxldCBiZWZvcmUgdGhlXG4gICAgLy8gYXV0aGVudGljYXRpb24gaXMgY29tcGxldGUuXG4gICAgc2hvd0xvYWRpbmdTY3JlZW4oJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyk7XG4gICAgY2hyb25payA9IG5ldyBDaHJvbmlrQ2xpZW50KGNvbmZpZy5jaHJvbmlrVXJscyk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbG9hZFdhbGxldCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgd2ViVmlld0Vycm9yKCdGYWlsZWQgdG8gbG9hZCB0aGUgd2FsbGV0OicsIGVycm9yKTtcbiAgICAgICAgc2VuZE1lc3NhZ2VUb0JhY2tlbmQoJ0NMT1NFX0FQUCcsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSGlkZSBsb2FkaW5nIHNjcmVlbiBvbiBzdWNjZXNzXG4gICAgaGlkZUxvYWRpbmdTY3JlZW4oKTtcbiAgICAvLyBBZGQgY2xpY2sgbGlzdGVuZXIgdG8gYWRkcmVzcyBlbGVtZW50IGZvciBjb3B5aW5nXG4gICAgY29uc3QgYWRkcmVzc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZHJlc3MnKTtcbiAgICBpZiAoYWRkcmVzc0VsKSB7XG4gICAgICAgIGFkZHJlc3NFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGNvcHlBZGRyZXNzKGVjYXNoV2FsbGV0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3ZWJWaWV3TG9nKCdFcnJvcjogYWRkcmVzc0VsIG5vdCBmb3VuZCwgY2Fubm90IGFkZCBjbGljayBsaXN0ZW5lciBmb3IgY29weWluZyBhZGRyZXNzJyk7XG4gICAgfVxuICAgIC8vIEFkZCBjbGljayBsaXN0ZW5lcnMgZm9yIFFSIHNjYW5uZXJcbiAgICBjb25zdCBzY2FuQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NjYW4tYnRuJyk7XG4gICAgY29uc3QgY2xvc2VDYW1lcmFCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xvc2UtY2FtZXJhJyk7XG4gICAgaWYgKHNjYW5CdG4pIHtcbiAgICAgICAgc2NhbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVNjYW5CdXR0b25DbGljayk7XG4gICAgfVxuICAgIGlmIChjbG9zZUNhbWVyYUJ0bikge1xuICAgICAgICBjbG9zZUNhbWVyYUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsb3NlQ2FtZXJhKTtcbiAgICB9XG4gICAgLy8gQWRkIGNsaWNrIGxpc3RlbmVyIGZvciBtYW51YWwgZW50cnkgYnV0dG9uXG4gICAgY29uc3QgbWFudWFsRW50cnlCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFudWFsLWVudHJ5LWJ0bicpO1xuICAgIGlmIChtYW51YWxFbnRyeUJ0bikge1xuICAgICAgICBtYW51YWxFbnRyeUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHsgYXdhaXQgb3BlblNlbmRTY3JlZW5Gb3JNYW51YWxFbnRyeSgpOyB9KTtcbiAgICB9XG4gICAgLy8gQWRkIGNsaWNrIGxpc3RlbmVycyBmb3IgU2VuZCBzY3JlZW5cbiAgICBjb25zdCBiYWNrQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhY2stYnRuJyk7XG4gICAgY29uc3QgY2FuY2VsU2VuZEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW5jZWwtc2VuZCcpO1xuICAgIGNvbnN0IGNvbmZpcm1TZW5kQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpcm0tc2VuZCcpO1xuICAgIGlmIChiYWNrQnRuKSB7XG4gICAgICAgIGJhY2tCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaG93TWFpblNjcmVlbik7XG4gICAgfVxuICAgIGlmIChjYW5jZWxTZW5kQnRuKSB7XG4gICAgICAgIGNhbmNlbFNlbmRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaG93TWFpblNjcmVlbik7XG4gICAgfVxuICAgIGlmIChjb25maXJtU2VuZEJ0bikge1xuICAgICAgICBzZXR1cEhvbGRUb1NlbmQoY29uZmlybVNlbmRCdG4pO1xuICAgIH1cbiAgICAvLyBBZGQgY2xpY2sgbGlzdGVuZXJzIGZvciBIaXN0b3J5IHNjcmVlblxuICAgIGNvbnN0IGhpc3RvcnlCYWNrQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hpc3RvcnktYmFjay1idG4nKTtcbiAgICBpZiAoaGlzdG9yeUJhY2tCdG4pIHtcbiAgICAgICAgaGlzdG9yeUJhY2tCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaG93TWFpblNjcmVlbik7XG4gICAgfVxuICAgIC8vIEFkZCBjbGljayBsaXN0ZW5lcnMgZm9yIFNldHRpbmdzIHNjcmVlblxuICAgIGNvbnN0IHNldHRpbmdzQmFja0J0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1iYWNrLWJ0bicpO1xuICAgIGNvbnN0IGVkaXRNbmVtb25pY0J0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0LW1uZW1vbmljLWJ0bicpO1xuICAgIGNvbnN0IGNhbmNlbE1uZW1vbmljRWRpdEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW5jZWwtbW5lbW9uaWMtZWRpdCcpO1xuICAgIGNvbnN0IHNhdmVNbmVtb25pY0VkaXRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2F2ZS1tbmVtb25pYy1lZGl0Jyk7XG4gICAgY29uc3QgY2xvc2VNbmVtb25pY01vZGFsQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nsb3NlLW1uZW1vbmljLW1vZGFsJyk7XG4gICAgaWYgKHNldHRpbmdzQmFja0J0bikge1xuICAgICAgICBzZXR0aW5nc0JhY2tCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaG93TWFpblNjcmVlbik7XG4gICAgfVxuICAgIC8vIFNldHVwIGhvbGQtdG8tc2VuZCB0b2dnbGUgYW5kIGFwcGx5IHNhdmVkIHNldHRpbmdcbiAgICBjb25zdCBob2xkVG9TZW5kVG9nZ2xlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hvbGQtdG8tc2VuZC10b2dnbGUnKTtcbiAgICBpZiAoaG9sZFRvU2VuZFRvZ2dsZSkge1xuICAgICAgICAvLyBBcHBseSBzYXZlZCBzZXR0aW5nIHRvIHRvZ2dsZSBVSVxuICAgICAgICBob2xkVG9TZW5kVG9nZ2xlLmNoZWNrZWQgPSByZXF1aXJlSG9sZFRvU2VuZDtcbiAgICAgICAgLy8gQWRkIGNoYW5nZSBsaXN0ZW5lclxuICAgICAgICBob2xkVG9TZW5kVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHJlcXVpcmVIb2xkVG9TZW5kID0gaG9sZFRvU2VuZFRvZ2dsZS5jaGVja2VkO1xuICAgICAgICAgICAgd2ViVmlld0xvZyhgSG9sZCB0byBzZW5kICR7cmVxdWlyZUhvbGRUb1NlbmQgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfWApO1xuICAgICAgICAgICAgLy8gU2F2ZSBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2VcbiAgICAgICAgICAgIHNhdmVTZXR0aW5ncyh7XG4gICAgICAgICAgICAgICAgcmVxdWlyZUhvbGRUb1NlbmQ6IHJlcXVpcmVIb2xkVG9TZW5kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZWRpdE1uZW1vbmljQnRuKSB7XG4gICAgICAgIGVkaXRNbmVtb25pY0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNob3dNbmVtb25pY0VkaXRNb2RhbCk7XG4gICAgfVxuICAgIGlmIChjYW5jZWxNbmVtb25pY0VkaXRCdG4pIHtcbiAgICAgICAgY2FuY2VsTW5lbW9uaWNFZGl0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgaGlkZU1uZW1vbmljRWRpdE1vZGFsKCk7XG4gICAgICAgICAgICBoaWRlVmFsaWRhdGlvbk1lc3NhZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjbG9zZU1uZW1vbmljTW9kYWxCdG4pIHtcbiAgICAgICAgY2xvc2VNbmVtb25pY01vZGFsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgaGlkZU1uZW1vbmljRWRpdE1vZGFsKCk7XG4gICAgICAgICAgICBoaWRlVmFsaWRhdGlvbk1lc3NhZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzYXZlTW5lbW9uaWNFZGl0QnRuKSB7XG4gICAgICAgIHNhdmVNbmVtb25pY0VkaXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlZGl0VGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtbmVtb25pYy1lZGl0LXRleHQnKTtcbiAgICAgICAgICAgIGlmIChlZGl0VGV4dCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNhdmVNbmVtb25pYyhlZGl0VGV4dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBZGQgdmFsaWRhdGlvbiB0byBhbW91bnQgaW5wdXRcbiAgICBjb25zdCBzZW5kQW1vdW50SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VuZC1hbW91bnQnKTtcbiAgICBpZiAoc2VuZEFtb3VudElucHV0KSB7XG4gICAgICAgIHNlbmRBbW91bnRJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlQW1vdW50SW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgdXBkYXRlRmVlRGlzcGxheSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VuZEFtb3VudElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB2YWxpZGF0ZUFtb3VudEZpZWxkKTtcbiAgICB9XG4gICAgLy8gQWRkIHNsaWRlciBmdW5jdGlvbmFsaXR5XG4gICAgY29uc3QgYW1vdW50U2xpZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Ftb3VudC1zbGlkZXInKTtcbiAgICBpZiAoYW1vdW50U2xpZGVyKSB7XG4gICAgICAgIGFtb3VudFNsaWRlci5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlU2xpZGVySW5wdXQoZXZlbnQpO1xuICAgICAgICAgICAgdXBkYXRlRmVlRGlzcGxheSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWRkIHJlY2lwaWVudCBhZGRyZXNzIGlucHV0IGxpc3RlbmVyIGZvciBmZWUgdXBkYXRlcyBhbmQgdmFsaWRhdGlvblxuICAgIGNvbnN0IHJlY2lwaWVudEFkZHJlc3NJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWNpcGllbnQtYWRkcmVzcycpO1xuICAgIGlmIChyZWNpcGllbnRBZGRyZXNzSW5wdXQpIHtcbiAgICAgICAgcmVjaXBpZW50QWRkcmVzc0lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGVBZGRyZXNzRmllbGQoKTtcbiAgICAgICAgICAgIHVwZGF0ZUZlZURpc3BsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEVuc3VyZSBjYW1lcmEgbW9kYWwgc3RhcnRzIGhpZGRlblxuICAgIGNvbnN0IGNhbWVyYU1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbWVyYS1tb2RhbCcpO1xuICAgIGlmIChjYW1lcmFNb2RhbCkge1xuICAgICAgICBjYW1lcmFNb2RhbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgd2ViVmlld0xvZygnQ2FtZXJhIG1vZGFsIGluaXRpYWxpemVkIGFzIGhpZGRlbicpO1xuICAgIH1cbn1cbi8vIExpc3RlbiBmb3IgcGF5bWVudCByZXF1ZXN0cyBmcm9tIFJlYWN0IE5hdGl2ZVxuZnVuY3Rpb24gaGFuZGxlUGF5bWVudFJlcXVlc3QoZXZlbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSA9PT0gJ1BBWU1FTlRfUkVRVUVTVCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpcDIxVXJpID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIEJJUDIxIFVSSVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VCaXAyMVVyaShiaXAyMVVyaSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gT3BlbiBzZW5kIHNjcmVlbiB3aXRoIHByZWZpbGxlZCBhZGRyZXNzIGFuZCBhbW91bnRcbiAgICAgICAgICAgICAgICBvcGVuU2VuZFNjcmVlbldpdGhBZGRyZXNzKHBhcnNlZC5hZGRyZXNzLCBwYXJzZWQuc2F0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ZWJWaWV3RXJyb3IoJ0ludmFsaWQgQklQMjEgVVJJOicsIGJpcDIxVXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWdub3JlIHBhcnNlIGVycm9ycyBmcm9tIG5vbi1KU09OIG1lc3NhZ2VzXG4gICAgfVxufVxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVBheW1lbnRSZXF1ZXN0KTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlUGF5bWVudFJlcXVlc3QpO1xuLy8gQWRkIGNsaWNrIGxpc3RlbmVyIHRvIGFkZHJlc3MgZWxlbWVudFxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBpbml0aWFsaXplQXBwKTtcbn1cbmVsc2Uge1xuICAgIC8vIERPTSBpcyBhbHJlYWR5IHJlYWR5XG4gICAgaW5pdGlhbGl6ZUFwcCgpO1xufVxuLy8gQ2xlYW51cCBXZWJTb2NrZXQgY29ubmVjdGlvbiB3aGVuIHBhZ2UgaXMgdW5sb2FkZWRcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG4gICAgdW5zdWJzY3JpYmVGcm9tQWRkcmVzcygpO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8393\n\n}")},8570:module=>{eval("{module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7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QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcz9kYTVhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gTG9uZztcclxuXHJcbi8qKlxyXG4gKiB3YXNtIG9wdGltaXphdGlvbnMsIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxyXG4gKi9cclxudmFyIHdhc20gPSBudWxsO1xyXG5cclxudHJ5IHtcclxuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcclxuICBdKSksIHt9KS5leHBvcnRzO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICogQGV4cG9ydHMgTG9uZ1xyXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG59XHJcblxyXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuLy9cclxuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbi8vXHJcbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuLyoqXHJcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgIH1cclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICB2YXIgcDtcclxuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XHJcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuICcwJztcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgIHJlbSA9IHRoaXM7XHJcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMjRcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaGkgPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmXHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbMF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1syXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbM10gPDwgMjQsXHJcbiAgICAgICAgYnl0ZXNbNF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbN10gPDwgMjQsXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1s0XSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s3XSxcclxuICAgICAgICBieXRlc1swXSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1szXSxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8570\n\n}")},8583:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeBase58 = exports.encodeBase58 = void 0;\n/**\n * Base58 characters include numbers 123456789, uppercase\n * ABCDEFGHJKLMNPQRSTUVWXYZ and lowercase abcdefghijkmnopqrstuvwxyz.\n */\nconst BASE58_CHARS = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nconst BASE58_MAP = [\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, -1,\n    -1, -1, -1, -1, -1, -1, 9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18, 19, 20,\n    21, -1, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1, -1,\n    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46, 47, 48, 49, 50,\n    51, 52, 53, 54, 55, 56, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    -1, -1, -1, -1, -1, -1, -1,\n];\n/** Encode the input bytes as base58 string (modeled after base58.cpp) */\nfunction encodeBase58(input) {\n    // Skip & count leading zeroes.\n    let numZeroes = 0;\n    while (numZeroes < input.length && input[numZeroes] == 0) {\n        numZeroes++;\n    }\n    // Allocate enough space in big-endian base58 representation.\n    // log(256) / log(58), rounded up. Use | 0 to force integers\n    const size = ((((input.length - numZeroes) * 138) / 100) | 0) + 1;\n    const b58 = new Uint8Array(size);\n    // Process the bytes.\n    let length = 0;\n    for (let idx = numZeroes; idx < input.length; ++idx) {\n        let carry = input[idx];\n        let i = 0;\n        // Apply \"b58 = b58 * 256 + ch\".\n        let j = size - 1;\n        while ((carry != 0 || i < length) && j >= 0) {\n            carry += 256 * b58[j];\n            b58[j] = carry % 58;\n            carry = (carry / 58) | 0;\n            j--;\n            i++;\n        }\n        if (carry != 0) {\n            throw new Error('Carry should be zero at this point');\n        }\n        length = i;\n    }\n    // Skip leading zeroes in base58 result.\n    let startIdx = size - length;\n    while (startIdx < b58.length && b58[startIdx] == 0) {\n        startIdx++;\n    }\n    // Translate the result into a string.\n    const result = new Array(numZeroes + b58.length - startIdx);\n    for (let idx = 0; idx < numZeroes; ++idx) {\n        result[idx] = '1';\n    }\n    for (let idx = startIdx; idx < b58.length; ++idx) {\n        result[idx] = BASE58_CHARS[b58[idx]];\n    }\n    return result.join('');\n}\nexports.encodeBase58 = encodeBase58;\n/** Decode the input base58 string as bytes (modeled after base58.cpp) */\nfunction decodeBase58(input) {\n    // Skip leading spaces.\n    let idx = 0;\n    while (idx < input.length && isWhitespace(input.charAt(idx))) {\n        idx++;\n    }\n    // Skip and count leading '1's.\n    let numZeroes = 0;\n    while (input[idx] === '1') {\n        numZeroes++;\n        idx++;\n    }\n    // Allocate enough space in big-endian base256 representation.\n    // log(58) / log(256), rounded up. Use `| 0` to force integers.\n    const size = ((((input.length - idx) * 733) / 1000) | 0) + 1;\n    const b256 = new Uint8Array(size);\n    // Process the characters.\n    let length = 0;\n    while (idx < input.length && !isWhitespace(input.charAt(idx))) {\n        // Decode base58 character\n        let carry = BASE58_MAP[input.charCodeAt(idx)];\n        if (carry === -1) {\n            throw new Error('Invalid base58 character');\n        }\n        let i = 0;\n        let j = b256.length - 1;\n        while ((carry != 0 || i < length) && j >= 0) {\n            carry += 58 * b256[j];\n            b256[j] = carry % 256;\n            carry = (carry / 256) | 0;\n            j--;\n            i++;\n        }\n        if (carry != 0) {\n            throw new Error('Carry should be zero at this point');\n        }\n        length = i;\n        idx++;\n    }\n    while (idx < input.length && isWhitespace(input.charAt(idx))) {\n        idx++;\n    }\n    if (idx < input.length) {\n        throw new Error('Extra letters after whitespace');\n    }\n    // Skip leading zeroes in b256.\n    const startIdx = size - length;\n    // Copy result into output vector.\n    const result = new Uint8Array(numZeroes + b256.length - startIdx);\n    let writeIdx = numZeroes;\n    for (let idx = startIdx; idx < b256.length; ++idx) {\n        result[writeIdx] = b256[idx];\n        writeIdx++;\n    }\n    return result;\n}\nexports.decodeBase58 = decodeBase58;\nfunction isWhitespace(ch) {\n    return ' \\r\\f\\v\\n\\t'.indexOf(ch) > -1;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU4My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvYjU4LXRzL2Rpc3QvaW5kZXguanM/MzYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUJhc2U1OCA9IGV4cG9ydHMuZW5jb2RlQmFzZTU4ID0gdm9pZCAwO1xuLyoqXG4gKiBCYXNlNTggY2hhcmFjdGVycyBpbmNsdWRlIG51bWJlcnMgMTIzNDU2Nzg5LCB1cHBlcmNhc2VcbiAqIEFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWiBhbmQgbG93ZXJjYXNlIGFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXouXG4gKi9cbmNvbnN0IEJBU0U1OF9DSEFSUyA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6JztcbmNvbnN0IEJBU0U1OF9NQVAgPSBbXG4gICAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCAtMSxcbiAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgLTEsIDE3LCAxOCwgMTksIDIwLFxuICAgIDIxLCAtMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCwgNDEsIDQyLCA0MywgLTEsIDQ0LCA0NSwgNDYsIDQ3LCA0OCwgNDksIDUwLFxuICAgIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuXTtcbi8qKiBFbmNvZGUgdGhlIGlucHV0IGJ5dGVzIGFzIGJhc2U1OCBzdHJpbmcgKG1vZGVsZWQgYWZ0ZXIgYmFzZTU4LmNwcCkgKi9cbmZ1bmN0aW9uIGVuY29kZUJhc2U1OChpbnB1dCkge1xuICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICBsZXQgbnVtWmVyb2VzID0gMDtcbiAgICB3aGlsZSAobnVtWmVyb2VzIDwgaW5wdXQubGVuZ3RoICYmIGlucHV0W251bVplcm9lc10gPT0gMCkge1xuICAgICAgICBudW1aZXJvZXMrKztcbiAgICB9XG4gICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIC8vIGxvZygyNTYpIC8gbG9nKDU4KSwgcm91bmRlZCB1cC4gVXNlIHwgMCB0byBmb3JjZSBpbnRlZ2Vyc1xuICAgIGNvbnN0IHNpemUgPSAoKCgoaW5wdXQubGVuZ3RoIC0gbnVtWmVyb2VzKSAqIDEzOCkgLyAxMDApIHwgMCkgKyAxO1xuICAgIGNvbnN0IGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGlkeCA9IG51bVplcm9lczsgaWR4IDwgaW5wdXQubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICBsZXQgY2FycnkgPSBpbnB1dFtpZHhdO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgICAgbGV0IGogPSBzaXplIC0gMTtcbiAgICAgICAgd2hpbGUgKChjYXJyeSAhPSAwIHx8IGkgPCBsZW5ndGgpICYmIGogPj0gMCkge1xuICAgICAgICAgICAgY2FycnkgKz0gMjU2ICogYjU4W2pdO1xuICAgICAgICAgICAgYjU4W2pdID0gY2FycnkgJSA1ODtcbiAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gNTgpIHwgMDtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkgIT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXJyeSBzaG91bGQgYmUgemVybyBhdCB0aGlzIHBvaW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gaTtcbiAgICB9XG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIGxldCBzdGFydElkeCA9IHNpemUgLSBsZW5ndGg7XG4gICAgd2hpbGUgKHN0YXJ0SWR4IDwgYjU4Lmxlbmd0aCAmJiBiNThbc3RhcnRJZHhdID09IDApIHtcbiAgICAgICAgc3RhcnRJZHgrKztcbiAgICB9XG4gICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobnVtWmVyb2VzICsgYjU4Lmxlbmd0aCAtIHN0YXJ0SWR4KTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBudW1aZXJvZXM7ICsraWR4KSB7XG4gICAgICAgIHJlc3VsdFtpZHhdID0gJzEnO1xuICAgIH1cbiAgICBmb3IgKGxldCBpZHggPSBzdGFydElkeDsgaWR4IDwgYjU4Lmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgcmVzdWx0W2lkeF0gPSBCQVNFNThfQ0hBUlNbYjU4W2lkeF1dO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xufVxuZXhwb3J0cy5lbmNvZGVCYXNlNTggPSBlbmNvZGVCYXNlNTg7XG4vKiogRGVjb2RlIHRoZSBpbnB1dCBiYXNlNTggc3RyaW5nIGFzIGJ5dGVzIChtb2RlbGVkIGFmdGVyIGJhc2U1OC5jcHApICovXG5mdW5jdGlvbiBkZWNvZGVCYXNlNTgoaW5wdXQpIHtcbiAgICAvLyBTa2lwIGxlYWRpbmcgc3BhY2VzLlxuICAgIGxldCBpZHggPSAwO1xuICAgIHdoaWxlIChpZHggPCBpbnB1dC5sZW5ndGggJiYgaXNXaGl0ZXNwYWNlKGlucHV0LmNoYXJBdChpZHgpKSkge1xuICAgICAgICBpZHgrKztcbiAgICB9XG4gICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIGxldCBudW1aZXJvZXMgPSAwO1xuICAgIHdoaWxlIChpbnB1dFtpZHhdID09PSAnMScpIHtcbiAgICAgICAgbnVtWmVyb2VzKys7XG4gICAgICAgIGlkeCsrO1xuICAgIH1cbiAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC4gVXNlIGB8IDBgIHRvIGZvcmNlIGludGVnZXJzLlxuICAgIGNvbnN0IHNpemUgPSAoKCgoaW5wdXQubGVuZ3RoIC0gaWR4KSAqIDczMykgLyAxMDAwKSB8IDApICsgMTtcbiAgICBjb25zdCBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICB3aGlsZSAoaWR4IDwgaW5wdXQubGVuZ3RoICYmICFpc1doaXRlc3BhY2UoaW5wdXQuY2hhckF0KGlkeCkpKSB7XG4gICAgICAgIC8vIERlY29kZSBiYXNlNTggY2hhcmFjdGVyXG4gICAgICAgIGxldCBjYXJyeSA9IEJBU0U1OF9NQVBbaW5wdXQuY2hhckNvZGVBdChpZHgpXTtcbiAgICAgICAgaWYgKGNhcnJ5ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhc2U1OCBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBqID0gYjI1Ni5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoKGNhcnJ5ICE9IDAgfHwgaSA8IGxlbmd0aCkgJiYgaiA+PSAwKSB7XG4gICAgICAgICAgICBjYXJyeSArPSA1OCAqIGIyNTZbal07XG4gICAgICAgICAgICBiMjU2W2pdID0gY2FycnkgJSAyNTY7XG4gICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgfCAwO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJyeSAhPSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcnJ5IHNob3VsZCBiZSB6ZXJvIGF0IHRoaXMgcG9pbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBpO1xuICAgICAgICBpZHgrKztcbiAgICB9XG4gICAgd2hpbGUgKGlkeCA8IGlucHV0Lmxlbmd0aCAmJiBpc1doaXRlc3BhY2UoaW5wdXQuY2hhckF0KGlkeCkpKSB7XG4gICAgICAgIGlkeCsrO1xuICAgIH1cbiAgICBpZiAoaWR4IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0cmEgbGV0dGVycyBhZnRlciB3aGl0ZXNwYWNlJyk7XG4gICAgfVxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICBjb25zdCBzdGFydElkeCA9IHNpemUgLSBsZW5ndGg7XG4gICAgLy8gQ29weSByZXN1bHQgaW50byBvdXRwdXQgdmVjdG9yLlxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KG51bVplcm9lcyArIGIyNTYubGVuZ3RoIC0gc3RhcnRJZHgpO1xuICAgIGxldCB3cml0ZUlkeCA9IG51bVplcm9lcztcbiAgICBmb3IgKGxldCBpZHggPSBzdGFydElkeDsgaWR4IDwgYjI1Ni5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIHJlc3VsdFt3cml0ZUlkeF0gPSBiMjU2W2lkeF07XG4gICAgICAgIHdyaXRlSWR4Kys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlY29kZUJhc2U1OCA9IGRlY29kZUJhc2U1ODtcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjaCkge1xuICAgIHJldHVybiAnIFxcclxcZlxcdlxcblxcdCcuaW5kZXhPZihjaCkgPiAtMTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8583\n\n}")},8710:(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=int.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcxMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvaW8vaW50LmpzP2U0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8710\n\n}')},8737:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.slpAtoms = exports.slpBurn = exports.slpSend = exports.slpMintVault = exports.slpMint = exports.slpGenesis = exports.SLP_TOKEN_TYPE_NFT1_CHILD = exports.SLP_TOKEN_TYPE_NFT1_GROUP = exports.SLP_TOKEN_TYPE_MINT_VAULT = exports.SLP_TOKEN_TYPE_FUNGIBLE = exports.SLP_ATOMS_NUM_BYTES = exports.SLP_MAX_SEND_OUTPUTS = exports.SLP_MINT_VAULT_SCRIPTHASH_NUM_BYTES = exports.SLP_GENESIS_HASH_NUM_BYTES = exports.SLP_NFT1_GROUP = exports.SLP_NFT1_CHILD = exports.SLP_MINT_VAULT = exports.SLP_FUNGIBLE = exports.SLP_LOKAD_ID = exports.SLP_LOKAD_ID_STR = void 0;\nconst hex_js_1 = __webpack_require__(2938);\nconst str_js_1 = __webpack_require__(2392);\nconst op_js_1 = __webpack_require__(243);\nconst opcode_js_1 = __webpack_require__(2250);\nconst script_js_1 = __webpack_require__(6187);\nconst common_js_1 = __webpack_require__(5467);\n/** LOKAD ID for SLP */\nexports.SLP_LOKAD_ID_STR = 'SLP\\0';\n/** LOKAD ID for SLP */\nexports.SLP_LOKAD_ID = (0, str_js_1.strToBytes)(exports.SLP_LOKAD_ID_STR);\n/** SLP fungible token type number */\nexports.SLP_FUNGIBLE = 1;\n/** SLP MINT Vault token type number */\nexports.SLP_MINT_VAULT = 2;\n/** SLP NFT1 Child token type number */\nexports.SLP_NFT1_CHILD = 0x41;\n/** SLP NFT1 Group token type number */\nexports.SLP_NFT1_GROUP = 0x81;\n/** How many bytes the GENESIS `hash` field must have (or 0) */\nexports.SLP_GENESIS_HASH_NUM_BYTES = 32;\n/** How many bytes the GENESIS `mintVaultScripthash` field must have */\nexports.SLP_MINT_VAULT_SCRIPTHASH_NUM_BYTES = 20;\n/** How many outputs a SEND can specify at most */\nexports.SLP_MAX_SEND_OUTPUTS = 19;\n/** How many bytes every atoms amount has */\nexports.SLP_ATOMS_NUM_BYTES = 8;\nexports.SLP_TOKEN_TYPE_FUNGIBLE = {\n    protocol: 'SLP',\n    type: 'SLP_TOKEN_TYPE_FUNGIBLE',\n    number: exports.SLP_FUNGIBLE,\n};\nexports.SLP_TOKEN_TYPE_MINT_VAULT = {\n    protocol: 'SLP',\n    type: 'SLP_TOKEN_TYPE_MINT_VAULT',\n    number: exports.SLP_MINT_VAULT,\n};\nexports.SLP_TOKEN_TYPE_NFT1_GROUP = {\n    protocol: 'SLP',\n    type: 'SLP_TOKEN_TYPE_NFT1_GROUP',\n    number: exports.SLP_NFT1_GROUP,\n};\nexports.SLP_TOKEN_TYPE_NFT1_CHILD = {\n    protocol: 'SLP',\n    type: 'SLP_TOKEN_TYPE_NFT1_CHILD',\n    number: exports.SLP_NFT1_CHILD,\n};\n/** Build an SLP GENESIS OP_RETURN, creating a new SLP token */\nfunction slpGenesis(tokenType, genesisInfo, initialQuantity, mintBatonOutIdx) {\n    verifyTokenType(tokenType);\n    const data = [];\n    data.push(exports.SLP_LOKAD_ID);\n    data.push(new Uint8Array([tokenType]));\n    data.push(common_js_1.GENESIS);\n    data.push((0, str_js_1.strToBytes)(genesisInfo.tokenTicker ?? ''));\n    data.push((0, str_js_1.strToBytes)(genesisInfo.tokenName ?? ''));\n    data.push((0, str_js_1.strToBytes)(genesisInfo.url ?? ''));\n    data.push(genesisInfo.hash ? (0, hex_js_1.fromHex)(genesisInfo.hash) : new Uint8Array());\n    data.push(new Uint8Array([genesisInfo.decimals ?? 0]));\n    if (tokenType == exports.SLP_MINT_VAULT) {\n        if (genesisInfo.mintVaultScripthash === undefined) {\n            throw new Error('Must set mintVaultScripthash for MINT VAULT');\n        }\n        data.push((0, hex_js_1.fromHex)(genesisInfo.mintVaultScripthash));\n    }\n    else {\n        if (mintBatonOutIdx !== undefined) {\n            if (mintBatonOutIdx < 2) {\n                throw new Error('mintBatonOutIdx must be >= 2');\n            }\n            data.push(new Uint8Array([mintBatonOutIdx]));\n        }\n        else {\n            data.push(new Uint8Array());\n        }\n    }\n    data.push(slpAtoms(initialQuantity));\n    return script_js_1.Script.fromOps([opcode_js_1.OP_RETURN].concat(data.map(pushdataOpSlp)));\n}\nexports.slpGenesis = slpGenesis;\n/**\n * Build an SLP MINT pushdata section, creating new SLP tokens and mint batons\n * of the given token ID.\n **/\nfunction slpMint(tokenId, tokenType, additionalAtoms, mintBatonOutIdx) {\n    verifyTokenType(tokenType);\n    verifyTokenId(tokenId);\n    return script_js_1.Script.fromOps([\n        opcode_js_1.OP_RETURN,\n        pushdataOpSlp(exports.SLP_LOKAD_ID),\n        pushdataOpSlp(new Uint8Array([tokenType])),\n        pushdataOpSlp(common_js_1.MINT),\n        pushdataOpSlp((0, hex_js_1.fromHex)(tokenId)),\n        pushdataOpSlp(new Uint8Array(mintBatonOutIdx !== undefined ? [mintBatonOutIdx] : [])),\n        pushdataOpSlp(slpAtoms(additionalAtoms)),\n    ]);\n}\nexports.slpMint = slpMint;\n/**\n * Build an SLP MINT VAULT pushdata section, creating new SLP tokens and mint batons\n * of the given token ID.\n **/\nfunction slpMintVault(tokenId, additionalAtomsArray) {\n    verifyTokenId(tokenId);\n    verifySendAtomsArray(additionalAtomsArray);\n    return script_js_1.Script.fromOps([\n        opcode_js_1.OP_RETURN,\n        pushdataOpSlp(exports.SLP_LOKAD_ID),\n        pushdataOpSlp(new Uint8Array([exports.SLP_MINT_VAULT])),\n        pushdataOpSlp(common_js_1.MINT),\n        pushdataOpSlp((0, hex_js_1.fromHex)(tokenId)),\n    ].concat(additionalAtomsArray.map(atoms => pushdataOpSlp(slpAtoms(atoms)))));\n}\nexports.slpMintVault = slpMintVault;\n/**\n * Build an SLP SEND pushdata section, moving SLP tokens to different outputs\n **/\nfunction slpSend(tokenId, tokenType, sendAtomsArray) {\n    verifyTokenType(tokenType);\n    verifyTokenId(tokenId);\n    verifySendAtomsArray(sendAtomsArray);\n    return script_js_1.Script.fromOps([\n        opcode_js_1.OP_RETURN,\n        pushdataOpSlp(exports.SLP_LOKAD_ID),\n        pushdataOpSlp(new Uint8Array([tokenType])),\n        pushdataOpSlp(common_js_1.SEND),\n        pushdataOpSlp((0, hex_js_1.fromHex)(tokenId)),\n    ].concat(sendAtomsArray.map(atoms => pushdataOpSlp(slpAtoms(atoms)))));\n}\nexports.slpSend = slpSend;\n/**\n * Build an SLP BURN pushdata section, intentionally burning SLP tokens.\n * See https://github.com/badger-cash/slp-self-mint-protocol/blob/master/token-type1-burn.md\n **/\nfunction slpBurn(tokenId, tokenType, burnAtoms) {\n    verifyTokenType(tokenType);\n    verifyTokenId(tokenId);\n    return script_js_1.Script.fromOps([\n        opcode_js_1.OP_RETURN,\n        pushdataOpSlp(exports.SLP_LOKAD_ID),\n        pushdataOpSlp(new Uint8Array([tokenType])),\n        pushdataOpSlp(common_js_1.BURN),\n        pushdataOpSlp((0, hex_js_1.fromHex)(tokenId)),\n        pushdataOpSlp(slpAtoms(burnAtoms)),\n    ]);\n}\nexports.slpBurn = slpBurn;\nfunction verifyTokenType(tokenType) {\n    switch (tokenType) {\n        case exports.SLP_FUNGIBLE:\n        case exports.SLP_MINT_VAULT:\n        case exports.SLP_NFT1_GROUP:\n        case exports.SLP_NFT1_CHILD:\n            return;\n        default:\n            throw new Error(`Unknown token type ${tokenType}`);\n    }\n}\nfunction verifyTokenId(tokenId) {\n    if (tokenId.length != 64) {\n        throw new Error(`Token ID must be 64 hex characters in length, but got ${tokenId.length}`);\n    }\n}\nfunction verifySendAtomsArray(sendAtomsArray) {\n    if (sendAtomsArray.length == 0) {\n        throw new Error('sendAtomsArray cannot be empty');\n    }\n    if (sendAtomsArray.length > 19) {\n        throw new Error(`Cannot use more than 19 amounts, but got ${sendAtomsArray.length}`);\n    }\n}\nfunction pushdataOpSlp(pushdata) {\n    if (pushdata.length == 0) {\n        return {\n            opcode: opcode_js_1.OP_PUSHDATA1,\n            data: pushdata,\n        };\n    }\n    if (pushdata.length < opcode_js_1.OP_PUSHDATA1) {\n        return {\n            opcode: pushdata.length,\n            data: pushdata,\n        };\n    }\n    return (0, op_js_1.pushBytesOp)(pushdata);\n}\nfunction slpAtoms(atoms) {\n    if (atoms < 0n || atoms > 0xffffffffffffffffn) {\n        throw new Error(`Atoms out of range: ${atoms}`);\n    }\n    const atomsBytes = new Uint8Array(8);\n    const view = new DataView(atomsBytes.buffer, atomsBytes.byteOffset, atomsBytes.byteLength);\n    view.setBigUint64(0, atoms, /*little endian=*/ false);\n    return atomsBytes;\n}\nexports.slpAtoms = slpAtoms;\n//# sourceMappingURL=slp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODczNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLG9CQUFvQixHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxpQ0FBaUMsR0FBRyxpQ0FBaUMsR0FBRyxpQ0FBaUMsR0FBRywrQkFBK0IsR0FBRywyQkFBMkIsR0FBRyw0QkFBNEIsR0FBRywyQ0FBMkMsR0FBRyxrQ0FBa0MsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDcGlCLGlCQUFpQixtQkFBTyxDQUFDLElBQWM7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsSUFBYztBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFVO0FBQ2xDLG9CQUFvQixtQkFBTyxDQUFDLElBQWM7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsSUFBYztBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyxJQUFhO0FBQ3pDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixlQUFlO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHNCQUFzQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvZWNhc2gtbGliL2Rpc3QvdG9rZW4vc2xwLmpzPzlmY2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIDIwMjQgVGhlIEJpdGNvaW4gZGV2ZWxvcGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBDT1BZSU5HIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zbHBBdG9tcyA9IGV4cG9ydHMuc2xwQnVybiA9IGV4cG9ydHMuc2xwU2VuZCA9IGV4cG9ydHMuc2xwTWludFZhdWx0ID0gZXhwb3J0cy5zbHBNaW50ID0gZXhwb3J0cy5zbHBHZW5lc2lzID0gZXhwb3J0cy5TTFBfVE9LRU5fVFlQRV9ORlQxX0NISUxEID0gZXhwb3J0cy5TTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQID0gZXhwb3J0cy5TTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxUID0gZXhwb3J0cy5TTFBfVE9LRU5fVFlQRV9GVU5HSUJMRSA9IGV4cG9ydHMuU0xQX0FUT01TX05VTV9CWVRFUyA9IGV4cG9ydHMuU0xQX01BWF9TRU5EX09VVFBVVFMgPSBleHBvcnRzLlNMUF9NSU5UX1ZBVUxUX1NDUklQVEhBU0hfTlVNX0JZVEVTID0gZXhwb3J0cy5TTFBfR0VORVNJU19IQVNIX05VTV9CWVRFUyA9IGV4cG9ydHMuU0xQX05GVDFfR1JPVVAgPSBleHBvcnRzLlNMUF9ORlQxX0NISUxEID0gZXhwb3J0cy5TTFBfTUlOVF9WQVVMVCA9IGV4cG9ydHMuU0xQX0ZVTkdJQkxFID0gZXhwb3J0cy5TTFBfTE9LQURfSUQgPSBleHBvcnRzLlNMUF9MT0tBRF9JRF9TVFIgPSB2b2lkIDA7XG5jb25zdCBoZXhfanNfMSA9IHJlcXVpcmUoXCIuLi9pby9oZXguanNcIik7XG5jb25zdCBzdHJfanNfMSA9IHJlcXVpcmUoXCIuLi9pby9zdHIuanNcIik7XG5jb25zdCBvcF9qc18xID0gcmVxdWlyZShcIi4uL29wLmpzXCIpO1xuY29uc3Qgb3Bjb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vb3Bjb2RlLmpzXCIpO1xuY29uc3Qgc2NyaXB0X2pzXzEgPSByZXF1aXJlKFwiLi4vc2NyaXB0LmpzXCIpO1xuY29uc3QgY29tbW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG4vKiogTE9LQUQgSUQgZm9yIFNMUCAqL1xuZXhwb3J0cy5TTFBfTE9LQURfSURfU1RSID0gJ1NMUFxcMCc7XG4vKiogTE9LQUQgSUQgZm9yIFNMUCAqL1xuZXhwb3J0cy5TTFBfTE9LQURfSUQgPSAoMCwgc3RyX2pzXzEuc3RyVG9CeXRlcykoZXhwb3J0cy5TTFBfTE9LQURfSURfU1RSKTtcbi8qKiBTTFAgZnVuZ2libGUgdG9rZW4gdHlwZSBudW1iZXIgKi9cbmV4cG9ydHMuU0xQX0ZVTkdJQkxFID0gMTtcbi8qKiBTTFAgTUlOVCBWYXVsdCB0b2tlbiB0eXBlIG51bWJlciAqL1xuZXhwb3J0cy5TTFBfTUlOVF9WQVVMVCA9IDI7XG4vKiogU0xQIE5GVDEgQ2hpbGQgdG9rZW4gdHlwZSBudW1iZXIgKi9cbmV4cG9ydHMuU0xQX05GVDFfQ0hJTEQgPSAweDQxO1xuLyoqIFNMUCBORlQxIEdyb3VwIHRva2VuIHR5cGUgbnVtYmVyICovXG5leHBvcnRzLlNMUF9ORlQxX0dST1VQID0gMHg4MTtcbi8qKiBIb3cgbWFueSBieXRlcyB0aGUgR0VORVNJUyBgaGFzaGAgZmllbGQgbXVzdCBoYXZlIChvciAwKSAqL1xuZXhwb3J0cy5TTFBfR0VORVNJU19IQVNIX05VTV9CWVRFUyA9IDMyO1xuLyoqIEhvdyBtYW55IGJ5dGVzIHRoZSBHRU5FU0lTIGBtaW50VmF1bHRTY3JpcHRoYXNoYCBmaWVsZCBtdXN0IGhhdmUgKi9cbmV4cG9ydHMuU0xQX01JTlRfVkFVTFRfU0NSSVBUSEFTSF9OVU1fQllURVMgPSAyMDtcbi8qKiBIb3cgbWFueSBvdXRwdXRzIGEgU0VORCBjYW4gc3BlY2lmeSBhdCBtb3N0ICovXG5leHBvcnRzLlNMUF9NQVhfU0VORF9PVVRQVVRTID0gMTk7XG4vKiogSG93IG1hbnkgYnl0ZXMgZXZlcnkgYXRvbXMgYW1vdW50IGhhcyAqL1xuZXhwb3J0cy5TTFBfQVRPTVNfTlVNX0JZVEVTID0gODtcbmV4cG9ydHMuU0xQX1RPS0VOX1RZUEVfRlVOR0lCTEUgPSB7XG4gICAgcHJvdG9jb2w6ICdTTFAnLFxuICAgIHR5cGU6ICdTTFBfVE9LRU5fVFlQRV9GVU5HSUJMRScsXG4gICAgbnVtYmVyOiBleHBvcnRzLlNMUF9GVU5HSUJMRSxcbn07XG5leHBvcnRzLlNMUF9UT0tFTl9UWVBFX01JTlRfVkFVTFQgPSB7XG4gICAgcHJvdG9jb2w6ICdTTFAnLFxuICAgIHR5cGU6ICdTTFBfVE9LRU5fVFlQRV9NSU5UX1ZBVUxUJyxcbiAgICBudW1iZXI6IGV4cG9ydHMuU0xQX01JTlRfVkFVTFQsXG59O1xuZXhwb3J0cy5TTFBfVE9LRU5fVFlQRV9ORlQxX0dST1VQID0ge1xuICAgIHByb3RvY29sOiAnU0xQJyxcbiAgICB0eXBlOiAnU0xQX1RPS0VOX1RZUEVfTkZUMV9HUk9VUCcsXG4gICAgbnVtYmVyOiBleHBvcnRzLlNMUF9ORlQxX0dST1VQLFxufTtcbmV4cG9ydHMuU0xQX1RPS0VOX1RZUEVfTkZUMV9DSElMRCA9IHtcbiAgICBwcm90b2NvbDogJ1NMUCcsXG4gICAgdHlwZTogJ1NMUF9UT0tFTl9UWVBFX05GVDFfQ0hJTEQnLFxuICAgIG51bWJlcjogZXhwb3J0cy5TTFBfTkZUMV9DSElMRCxcbn07XG4vKiogQnVpbGQgYW4gU0xQIEdFTkVTSVMgT1BfUkVUVVJOLCBjcmVhdGluZyBhIG5ldyBTTFAgdG9rZW4gKi9cbmZ1bmN0aW9uIHNscEdlbmVzaXModG9rZW5UeXBlLCBnZW5lc2lzSW5mbywgaW5pdGlhbFF1YW50aXR5LCBtaW50QmF0b25PdXRJZHgpIHtcbiAgICB2ZXJpZnlUb2tlblR5cGUodG9rZW5UeXBlKTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZGF0YS5wdXNoKGV4cG9ydHMuU0xQX0xPS0FEX0lEKTtcbiAgICBkYXRhLnB1c2gobmV3IFVpbnQ4QXJyYXkoW3Rva2VuVHlwZV0pKTtcbiAgICBkYXRhLnB1c2goY29tbW9uX2pzXzEuR0VORVNJUyk7XG4gICAgZGF0YS5wdXNoKCgwLCBzdHJfanNfMS5zdHJUb0J5dGVzKShnZW5lc2lzSW5mby50b2tlblRpY2tlciA/PyAnJykpO1xuICAgIGRhdGEucHVzaCgoMCwgc3RyX2pzXzEuc3RyVG9CeXRlcykoZ2VuZXNpc0luZm8udG9rZW5OYW1lID8/ICcnKSk7XG4gICAgZGF0YS5wdXNoKCgwLCBzdHJfanNfMS5zdHJUb0J5dGVzKShnZW5lc2lzSW5mby51cmwgPz8gJycpKTtcbiAgICBkYXRhLnB1c2goZ2VuZXNpc0luZm8uaGFzaCA/ICgwLCBoZXhfanNfMS5mcm9tSGV4KShnZW5lc2lzSW5mby5oYXNoKSA6IG5ldyBVaW50OEFycmF5KCkpO1xuICAgIGRhdGEucHVzaChuZXcgVWludDhBcnJheShbZ2VuZXNpc0luZm8uZGVjaW1hbHMgPz8gMF0pKTtcbiAgICBpZiAodG9rZW5UeXBlID09IGV4cG9ydHMuU0xQX01JTlRfVkFVTFQpIHtcbiAgICAgICAgaWYgKGdlbmVzaXNJbmZvLm1pbnRWYXVsdFNjcmlwdGhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNldCBtaW50VmF1bHRTY3JpcHRoYXNoIGZvciBNSU5UIFZBVUxUJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdXNoKCgwLCBoZXhfanNfMS5mcm9tSGV4KShnZW5lc2lzSW5mby5taW50VmF1bHRTY3JpcHRoYXNoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWludEJhdG9uT3V0SWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtaW50QmF0b25PdXRJZHggPCAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW50QmF0b25PdXRJZHggbXVzdCBiZSA+PSAyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnB1c2gobmV3IFVpbnQ4QXJyYXkoW21pbnRCYXRvbk91dElkeF0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChuZXcgVWludDhBcnJheSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkYXRhLnB1c2goc2xwQXRvbXMoaW5pdGlhbFF1YW50aXR5KSk7XG4gICAgcmV0dXJuIHNjcmlwdF9qc18xLlNjcmlwdC5mcm9tT3BzKFtvcGNvZGVfanNfMS5PUF9SRVRVUk5dLmNvbmNhdChkYXRhLm1hcChwdXNoZGF0YU9wU2xwKSkpO1xufVxuZXhwb3J0cy5zbHBHZW5lc2lzID0gc2xwR2VuZXNpcztcbi8qKlxuICogQnVpbGQgYW4gU0xQIE1JTlQgcHVzaGRhdGEgc2VjdGlvbiwgY3JlYXRpbmcgbmV3IFNMUCB0b2tlbnMgYW5kIG1pbnQgYmF0b25zXG4gKiBvZiB0aGUgZ2l2ZW4gdG9rZW4gSUQuXG4gKiovXG5mdW5jdGlvbiBzbHBNaW50KHRva2VuSWQsIHRva2VuVHlwZSwgYWRkaXRpb25hbEF0b21zLCBtaW50QmF0b25PdXRJZHgpIHtcbiAgICB2ZXJpZnlUb2tlblR5cGUodG9rZW5UeXBlKTtcbiAgICB2ZXJpZnlUb2tlbklkKHRva2VuSWQpO1xuICAgIHJldHVybiBzY3JpcHRfanNfMS5TY3JpcHQuZnJvbU9wcyhbXG4gICAgICAgIG9wY29kZV9qc18xLk9QX1JFVFVSTixcbiAgICAgICAgcHVzaGRhdGFPcFNscChleHBvcnRzLlNMUF9MT0tBRF9JRCksXG4gICAgICAgIHB1c2hkYXRhT3BTbHAobmV3IFVpbnQ4QXJyYXkoW3Rva2VuVHlwZV0pKSxcbiAgICAgICAgcHVzaGRhdGFPcFNscChjb21tb25fanNfMS5NSU5UKSxcbiAgICAgICAgcHVzaGRhdGFPcFNscCgoMCwgaGV4X2pzXzEuZnJvbUhleCkodG9rZW5JZCkpLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKG5ldyBVaW50OEFycmF5KG1pbnRCYXRvbk91dElkeCAhPT0gdW5kZWZpbmVkID8gW21pbnRCYXRvbk91dElkeF0gOiBbXSkpLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKHNscEF0b21zKGFkZGl0aW9uYWxBdG9tcykpLFxuICAgIF0pO1xufVxuZXhwb3J0cy5zbHBNaW50ID0gc2xwTWludDtcbi8qKlxuICogQnVpbGQgYW4gU0xQIE1JTlQgVkFVTFQgcHVzaGRhdGEgc2VjdGlvbiwgY3JlYXRpbmcgbmV3IFNMUCB0b2tlbnMgYW5kIG1pbnQgYmF0b25zXG4gKiBvZiB0aGUgZ2l2ZW4gdG9rZW4gSUQuXG4gKiovXG5mdW5jdGlvbiBzbHBNaW50VmF1bHQodG9rZW5JZCwgYWRkaXRpb25hbEF0b21zQXJyYXkpIHtcbiAgICB2ZXJpZnlUb2tlbklkKHRva2VuSWQpO1xuICAgIHZlcmlmeVNlbmRBdG9tc0FycmF5KGFkZGl0aW9uYWxBdG9tc0FycmF5KTtcbiAgICByZXR1cm4gc2NyaXB0X2pzXzEuU2NyaXB0LmZyb21PcHMoW1xuICAgICAgICBvcGNvZGVfanNfMS5PUF9SRVRVUk4sXG4gICAgICAgIHB1c2hkYXRhT3BTbHAoZXhwb3J0cy5TTFBfTE9LQURfSUQpLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKG5ldyBVaW50OEFycmF5KFtleHBvcnRzLlNMUF9NSU5UX1ZBVUxUXSkpLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKGNvbW1vbl9qc18xLk1JTlQpLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKCgwLCBoZXhfanNfMS5mcm9tSGV4KSh0b2tlbklkKSksXG4gICAgXS5jb25jYXQoYWRkaXRpb25hbEF0b21zQXJyYXkubWFwKGF0b21zID0+IHB1c2hkYXRhT3BTbHAoc2xwQXRvbXMoYXRvbXMpKSkpKTtcbn1cbmV4cG9ydHMuc2xwTWludFZhdWx0ID0gc2xwTWludFZhdWx0O1xuLyoqXG4gKiBCdWlsZCBhbiBTTFAgU0VORCBwdXNoZGF0YSBzZWN0aW9uLCBtb3ZpbmcgU0xQIHRva2VucyB0byBkaWZmZXJlbnQgb3V0cHV0c1xuICoqL1xuZnVuY3Rpb24gc2xwU2VuZCh0b2tlbklkLCB0b2tlblR5cGUsIHNlbmRBdG9tc0FycmF5KSB7XG4gICAgdmVyaWZ5VG9rZW5UeXBlKHRva2VuVHlwZSk7XG4gICAgdmVyaWZ5VG9rZW5JZCh0b2tlbklkKTtcbiAgICB2ZXJpZnlTZW5kQXRvbXNBcnJheShzZW5kQXRvbXNBcnJheSk7XG4gICAgcmV0dXJuIHNjcmlwdF9qc18xLlNjcmlwdC5mcm9tT3BzKFtcbiAgICAgICAgb3Bjb2RlX2pzXzEuT1BfUkVUVVJOLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKGV4cG9ydHMuU0xQX0xPS0FEX0lEKSxcbiAgICAgICAgcHVzaGRhdGFPcFNscChuZXcgVWludDhBcnJheShbdG9rZW5UeXBlXSkpLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKGNvbW1vbl9qc18xLlNFTkQpLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKCgwLCBoZXhfanNfMS5mcm9tSGV4KSh0b2tlbklkKSksXG4gICAgXS5jb25jYXQoc2VuZEF0b21zQXJyYXkubWFwKGF0b21zID0+IHB1c2hkYXRhT3BTbHAoc2xwQXRvbXMoYXRvbXMpKSkpKTtcbn1cbmV4cG9ydHMuc2xwU2VuZCA9IHNscFNlbmQ7XG4vKipcbiAqIEJ1aWxkIGFuIFNMUCBCVVJOIHB1c2hkYXRhIHNlY3Rpb24sIGludGVudGlvbmFsbHkgYnVybmluZyBTTFAgdG9rZW5zLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWRnZXItY2FzaC9zbHAtc2VsZi1taW50LXByb3RvY29sL2Jsb2IvbWFzdGVyL3Rva2VuLXR5cGUxLWJ1cm4ubWRcbiAqKi9cbmZ1bmN0aW9uIHNscEJ1cm4odG9rZW5JZCwgdG9rZW5UeXBlLCBidXJuQXRvbXMpIHtcbiAgICB2ZXJpZnlUb2tlblR5cGUodG9rZW5UeXBlKTtcbiAgICB2ZXJpZnlUb2tlbklkKHRva2VuSWQpO1xuICAgIHJldHVybiBzY3JpcHRfanNfMS5TY3JpcHQuZnJvbU9wcyhbXG4gICAgICAgIG9wY29kZV9qc18xLk9QX1JFVFVSTixcbiAgICAgICAgcHVzaGRhdGFPcFNscChleHBvcnRzLlNMUF9MT0tBRF9JRCksXG4gICAgICAgIHB1c2hkYXRhT3BTbHAobmV3IFVpbnQ4QXJyYXkoW3Rva2VuVHlwZV0pKSxcbiAgICAgICAgcHVzaGRhdGFPcFNscChjb21tb25fanNfMS5CVVJOKSxcbiAgICAgICAgcHVzaGRhdGFPcFNscCgoMCwgaGV4X2pzXzEuZnJvbUhleCkodG9rZW5JZCkpLFxuICAgICAgICBwdXNoZGF0YU9wU2xwKHNscEF0b21zKGJ1cm5BdG9tcykpLFxuICAgIF0pO1xufVxuZXhwb3J0cy5zbHBCdXJuID0gc2xwQnVybjtcbmZ1bmN0aW9uIHZlcmlmeVRva2VuVHlwZSh0b2tlblR5cGUpIHtcbiAgICBzd2l0Y2ggKHRva2VuVHlwZSkge1xuICAgICAgICBjYXNlIGV4cG9ydHMuU0xQX0ZVTkdJQkxFOlxuICAgICAgICBjYXNlIGV4cG9ydHMuU0xQX01JTlRfVkFVTFQ6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5TTFBfTkZUMV9HUk9VUDpcbiAgICAgICAgY2FzZSBleHBvcnRzLlNMUF9ORlQxX0NISUxEOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRva2VuIHR5cGUgJHt0b2tlblR5cGV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmVyaWZ5VG9rZW5JZCh0b2tlbklkKSB7XG4gICAgaWYgKHRva2VuSWQubGVuZ3RoICE9IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gSUQgbXVzdCBiZSA2NCBoZXggY2hhcmFjdGVycyBpbiBsZW5ndGgsIGJ1dCBnb3QgJHt0b2tlbklkLmxlbmd0aH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlTZW5kQXRvbXNBcnJheShzZW5kQXRvbXNBcnJheSkge1xuICAgIGlmIChzZW5kQXRvbXNBcnJheS5sZW5ndGggPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlbmRBdG9tc0FycmF5IGNhbm5vdCBiZSBlbXB0eScpO1xuICAgIH1cbiAgICBpZiAoc2VuZEF0b21zQXJyYXkubGVuZ3RoID4gMTkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXNlIG1vcmUgdGhhbiAxOSBhbW91bnRzLCBidXQgZ290ICR7c2VuZEF0b21zQXJyYXkubGVuZ3RofWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1c2hkYXRhT3BTbHAocHVzaGRhdGEpIHtcbiAgICBpZiAocHVzaGRhdGEubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wY29kZTogb3Bjb2RlX2pzXzEuT1BfUFVTSERBVEExLFxuICAgICAgICAgICAgZGF0YTogcHVzaGRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwdXNoZGF0YS5sZW5ndGggPCBvcGNvZGVfanNfMS5PUF9QVVNIREFUQTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wY29kZTogcHVzaGRhdGEubGVuZ3RoLFxuICAgICAgICAgICAgZGF0YTogcHVzaGRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgb3BfanNfMS5wdXNoQnl0ZXNPcCkocHVzaGRhdGEpO1xufVxuZnVuY3Rpb24gc2xwQXRvbXMoYXRvbXMpIHtcbiAgICBpZiAoYXRvbXMgPCAwbiB8fCBhdG9tcyA+IDB4ZmZmZmZmZmZmZmZmZmZmZm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdG9tcyBvdXQgb2YgcmFuZ2U6ICR7YXRvbXN9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF0b21zQnl0ZXMgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGF0b21zQnl0ZXMuYnVmZmVyLCBhdG9tc0J5dGVzLmJ5dGVPZmZzZXQsIGF0b21zQnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgdmlldy5zZXRCaWdVaW50NjQoMCwgYXRvbXMsIC8qbGl0dGxlIGVuZGlhbj0qLyBmYWxzZSk7XG4gICAgcmV0dXJuIGF0b21zQnl0ZXM7XG59XG5leHBvcnRzLnNscEF0b21zID0gc2xwQXRvbXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbHAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8737\n\n}")},8816:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(6810), exports);\n__exportStar(__webpack_require__(7148), exports);\n//# sourceMappingURL=indexBrowser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODgxNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsSUFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsSUFBa0I7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL2VjYXNoLWxpYi9kaXN0L2luZGV4QnJvd3Nlci5qcz9hZjc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI0IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2luZGV4LmpzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbml0QnJvd3Nlci5qc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleEJyb3dzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8816\n\n}')},8820:module=>{eval("{/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix (size) {\n  if (!size || size < 1) {\n    throw new Error('BitMatrix size must be defined and greater than 0')\n  }\n\n  this.size = size\n  this.data = new Uint8Array(size * size)\n  this.reservedBit = new Uint8Array(size * size)\n}\n\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n  const index = row * this.size + col\n  this.data[index] = value\n  if (reserved) this.reservedBit[index] = true\n}\n\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n  return this.data[row * this.size + col]\n}\n\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n  this.data[row * this.size + col] ^= value\n}\n\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n  return this.reservedBit[row * this.size + col]\n}\n\nmodule.exports = BitMatrix\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODgyMC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvcXJjb2RlL2xpYi9jb3JlL2JpdC1tYXRyaXguanM/NTc3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlciBjbGFzcyB0byBoYW5kbGUgUVIgQ29kZSBzeW1ib2wgbW9kdWxlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIFN5bWJvbCBzaXplXG4gKi9cbmZ1bmN0aW9uIEJpdE1hdHJpeCAoc2l6ZSkge1xuICBpZiAoIXNpemUgfHwgc2l6ZSA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdE1hdHJpeCBzaXplIG11c3QgYmUgZGVmaW5lZCBhbmQgZ3JlYXRlciB0aGFuIDAnKVxuICB9XG5cbiAgdGhpcy5zaXplID0gc2l6ZVxuICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShzaXplICogc2l6ZSlcbiAgdGhpcy5yZXNlcnZlZEJpdCA9IG5ldyBVaW50OEFycmF5KHNpemUgKiBzaXplKVxufVxuXG4vKipcbiAqIFNldCBiaXQgdmFsdWUgYXQgc3BlY2lmaWVkIGxvY2F0aW9uXG4gKiBJZiByZXNlcnZlZCBmbGFnIGlzIHNldCwgdGhpcyBiaXQgd2lsbCBiZSBpZ25vcmVkIGR1cmluZyBtYXNraW5nIHByb2Nlc3NcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gIHJvd1xuICogQHBhcmFtIHtOdW1iZXJ9ICBjb2xcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzZXJ2ZWRcbiAqL1xuQml0TWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocm93LCBjb2wsIHZhbHVlLCByZXNlcnZlZCkge1xuICBjb25zdCBpbmRleCA9IHJvdyAqIHRoaXMuc2l6ZSArIGNvbFxuICB0aGlzLmRhdGFbaW5kZXhdID0gdmFsdWVcbiAgaWYgKHJlc2VydmVkKSB0aGlzLnJlc2VydmVkQml0W2luZGV4XSA9IHRydWVcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGJpdCB2YWx1ZSBhdCBzcGVjaWZpZWQgbG9jYXRpb25cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICByb3dcbiAqIEBwYXJhbSAge051bWJlcn0gIGNvbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuQml0TWF0cml4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtyb3cgKiB0aGlzLnNpemUgKyBjb2xdXG59XG5cbi8qKlxuICogQXBwbGllcyB4b3Igb3BlcmF0b3IgYXQgc3BlY2lmaWVkIGxvY2F0aW9uXG4gKiAodXNlZCBkdXJpbmcgbWFza2luZyBwcm9jZXNzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSAgcm93XG4gKiBAcGFyYW0ge051bWJlcn0gIGNvbFxuICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuICovXG5CaXRNYXRyaXgucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChyb3csIGNvbCwgdmFsdWUpIHtcbiAgdGhpcy5kYXRhW3JvdyAqIHRoaXMuc2l6ZSArIGNvbF0gXj0gdmFsdWVcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBiaXQgYXQgc3BlY2lmaWVkIGxvY2F0aW9uIGlzIHJlc2VydmVkXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9ICAgcm93XG4gKiBAcGFyYW0ge051bWJlcn0gICBjb2xcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkJpdE1hdHJpeC5wcm90b3R5cGUuaXNSZXNlcnZlZCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xuICByZXR1cm4gdGhpcy5yZXNlcnZlZEJpdFtyb3cgKiB0aGlzLnNpemUgKyBjb2xdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQml0TWF0cml4XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8820\n\n}")},8839:(__unused_webpack_module,exports)=>{"use strict";eval('{\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === "=")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join("");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = "invalid encoding";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODgzOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLDhCQUE4QixFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanM/NmU3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8839\n\n}')},8941:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pbkdf2 = pbkdf2;\nexports.pbkdf2Async = pbkdf2Async;\n/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\nconst hmac_ts_1 = __webpack_require__(9615);\n// prettier-ignore\nconst utils_ts_1 = __webpack_require__(9175);\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0, utils_ts_1.ahash)(hash);\n    const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0, utils_ts_1.anumber)(c);\n    (0, utils_ts_1.anumber)(dkLen);\n    (0, utils_ts_1.anumber)(asyncTick);\n    if (c < 1)\n        throw new Error('iterations (c) should be >= 1');\n    const password = (0, utils_ts_1.kdfInputToBytes)(_password);\n    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac_ts_1.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    (0, utils_ts_1.clean)(u);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_ts_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_ts_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk0MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsSUFBVztBQUNyQztBQUNBLG1CQUFtQixtQkFBTyxDQUFDLElBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBCQUEwQjtBQUN2RSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0Esb0RBQW9ELCtCQUErQjtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1QkFBdUI7QUFDMUU7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvcGJrZGYyLmpzPzA5MmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBia2RmMiA9IHBia2RmMjtcbmV4cG9ydHMucGJrZGYyQXN5bmMgPSBwYmtkZjJBc3luYztcbi8qKlxuICogUEJLREYgKFJGQyAyODk4KS4gQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEga2V5IGZyb20gcGFzc3dvcmQgYW5kIHNhbHQuXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IGhtYWNfdHNfMSA9IHJlcXVpcmUoXCIuL2htYWMuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIENvbW1vbiBwcm9sb2d1ZSBhbmQgZXBpbG9ndWUgZm9yIHN5bmMvYXN5bmMgZnVuY3Rpb25zXG5mdW5jdGlvbiBwYmtkZjJJbml0KGhhc2gsIF9wYXNzd29yZCwgX3NhbHQsIF9vcHRzKSB7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWhhc2gpKGhhc2gpO1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgdXRpbHNfdHNfMS5jaGVja09wdHMpKHsgZGtMZW46IDMyLCBhc3luY1RpY2s6IDEwIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2sgfSA9IG9wdHM7XG4gICAgKDAsIHV0aWxzX3RzXzEuYW51bWJlcikoYyk7XG4gICAgKDAsIHV0aWxzX3RzXzEuYW51bWJlcikoZGtMZW4pO1xuICAgICgwLCB1dGlsc190c18xLmFudW1iZXIpKGFzeW5jVGljayk7XG4gICAgaWYgKGMgPCAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdGlvbnMgKGMpIHNob3VsZCBiZSA+PSAxJyk7XG4gICAgY29uc3QgcGFzc3dvcmQgPSAoMCwgdXRpbHNfdHNfMS5rZGZJbnB1dFRvQnl0ZXMpKF9wYXNzd29yZCk7XG4gICAgY29uc3Qgc2FsdCA9ICgwLCB1dGlsc190c18xLmtkZklucHV0VG9CeXRlcykoX3NhbHQpO1xuICAgIC8vIERLID0gUEJLREYyKFBSRiwgUGFzc3dvcmQsIFNhbHQsIGMsIGRrTGVuKTtcbiAgICBjb25zdCBESyA9IG5ldyBVaW50OEFycmF5KGRrTGVuKTtcbiAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICBjb25zdCBQUkYgPSBobWFjX3RzXzEuaG1hYy5jcmVhdGUoaGFzaCwgcGFzc3dvcmQpO1xuICAgIGNvbnN0IFBSRlNhbHQgPSBQUkYuX2Nsb25lSW50bygpLnVwZGF0ZShzYWx0KTtcbiAgICByZXR1cm4geyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH07XG59XG5mdW5jdGlvbiBwYmtkZjJPdXRwdXQoUFJGLCBQUkZTYWx0LCBESywgcHJmVywgdSkge1xuICAgIFBSRi5kZXN0cm95KCk7XG4gICAgUFJGU2FsdC5kZXN0cm95KCk7XG4gICAgaWYgKHByZlcpXG4gICAgICAgIHByZlcuZGVzdHJveSgpO1xuICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh1KTtcbiAgICByZXR1cm4gREs7XG59XG4vKipcbiAqIFBCS0RGMi1ITUFDOiBSRkMgMjg5OCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIHBhc3N3b3JkIC0gcGFzc3dvcmQgZnJvbSB3aGljaCBhIGRlcml2ZWQga2V5IGlzIGdlbmVyYXRlZFxuICogQHBhcmFtIHNhbHQgLSBjcnlwdG9ncmFwaGljIHNhbHRcbiAqIEBwYXJhbSBvcHRzIC0ge2MsIGRrTGVufSB3aGVyZSBjIGlzIHdvcmsgZmFjdG9yIGFuZCBka0xlbiBpcyBvdXRwdXQgbWVzc2FnZSBzaXplXG4gKiBAZXhhbXBsZVxuICogY29uc3Qga2V5ID0gcGJrZGYyKHNoYTI1NiwgJ3Bhc3N3b3JkJywgJ3NhbHQnLCB7IGRrTGVuOiAzMiwgYzogTWF0aC5wb3coMiwgMTgpIH0pO1xuICovXG5mdW5jdGlvbiBwYmtkZjIoaGFzaCwgcGFzc3dvcmQsIHNhbHQsIG9wdHMpIHtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZVZpZXcpKGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgZm9yIChsZXQgdWkgPSAxOyB1aSA8IGM7IHVpKyspIHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uIEFzeW5jIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgcGJrZGYyQXN5bmMoc2hhMjU2LCAncGFzc3dvcmQnLCAnc2FsdCcsIHsgZGtMZW46IDMyLCBjOiA1MDBfMDAwIH0pO1xuICovXG5hc3luYyBmdW5jdGlvbiBwYmtkZjJBc3luYyhoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cykge1xuICAgIGNvbnN0IHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVWaWV3KShhcnIpO1xuICAgIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheShQUkYub3V0cHV0TGVuKTtcbiAgICAvLyBESyA9IFQxICsgVDIgKyDii68gKyBUZGtsZW4vaGxlblxuICAgIGZvciAobGV0IHRpID0gMSwgcG9zID0gMDsgcG9zIDwgZGtMZW47IHRpKyssIHBvcyArPSBQUkYub3V0cHV0TGVuKSB7XG4gICAgICAgIC8vIFRpID0gRihQYXNzd29yZCwgU2FsdCwgYywgaSlcbiAgICAgICAgY29uc3QgVGkgPSBESy5zdWJhcnJheShwb3MsIHBvcyArIFBSRi5vdXRwdXRMZW4pO1xuICAgICAgICB2aWV3LnNldEludDMyKDAsIHRpLCBmYWxzZSk7XG4gICAgICAgIC8vIEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpID0gVTEgXiBVMiBeIOKLryBeIFVjXG4gICAgICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgICAgICAocHJmVyA9IFBSRlNhbHQuX2Nsb25lSW50byhwcmZXKSkudXBkYXRlKGFycikuZGlnZXN0SW50byh1KTtcbiAgICAgICAgVGkuc2V0KHUuc3ViYXJyYXkoMCwgVGkubGVuZ3RoKSk7XG4gICAgICAgIGF3YWl0ICgwLCB1dGlsc190c18xLmFzeW5jTG9vcCkoYyAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8941\n\n}")},8950:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseAlp = void 0;\nconst hex_js_1 = __webpack_require__(2938);\nconst str_js_1 = __webpack_require__(2392);\nconst bytes_js_1 = __webpack_require__(1292);\nconst alp_js_1 = __webpack_require__(6519);\nconst common_js_1 = __webpack_require__(5467);\n/**\n * Parse the given ALP pushdata. eMPP allows multiple pushdata per OP_RETURN.\n *\n * For data that's clearly not ALP (i.e. doesn't start with LOKAD ID \"SLP2\"),\n * it will return `undefined`.\n *\n * For an unknown token type, it'll return AlpUnknown.\n *\n * For a known token type, it'll parse the remaining data, or throw an error if\n * the format is invalid or if there's an unknown tx type.\n *\n * This behavior mirrors that of Chronik for consistency.\n **/\nfunction parseAlp(pushdata) {\n    // Must have at least 4 bytes for the LOKAD ID\n    if (pushdata.length < alp_js_1.ALP_LOKAD_ID.length) {\n        return undefined;\n    }\n    const bytes = new bytes_js_1.Bytes(pushdata);\n    // If the pushdata doesn't start with \"SLP2\" (ALP's LOKAD ID), return undefined\n    const lokadId = (0, str_js_1.bytesToStr)(bytes.readBytes(alp_js_1.ALP_LOKAD_ID.length));\n    if (lokadId != (0, str_js_1.bytesToStr)(alp_js_1.ALP_LOKAD_ID)) {\n        return undefined;\n    }\n    // Return UNKNOWN for unknown token types (only \"STANDARD\" known so far)\n    const tokenType = readU8(bytes, 'tokenType');\n    if (tokenType != alp_js_1.ALP_STANDARD) {\n        return {\n            txType: 'UNKNOWN',\n            tokenType,\n        };\n    }\n    // Parse tx type (GENESIS, MINT, SEND, BURN)\n    const txType = (0, str_js_1.bytesToStr)(readVarBytes(bytes, 'txType'));\n    // Handle tx type specific parsing\n    switch (txType) {\n        case common_js_1.GENESIS_STR:\n            return readGenesis(bytes, tokenType);\n        case common_js_1.MINT_STR:\n            return readMint(bytes, tokenType);\n        case common_js_1.SEND_STR:\n            return readSend(bytes, tokenType);\n        case common_js_1.BURN_STR:\n            return readBurn(bytes, tokenType);\n        default:\n            throw new Error('Unknown txType');\n    }\n}\nexports.parseAlp = parseAlp;\nfunction readGenesis(bytes, tokenType) {\n    const tokenTicker = (0, str_js_1.bytesToStr)(readVarBytes(bytes, 'tokenTicker'));\n    const tokenName = (0, str_js_1.bytesToStr)(readVarBytes(bytes, 'tokenName'));\n    const url = (0, str_js_1.bytesToStr)(readVarBytes(bytes, 'url'));\n    const data = readVarBytes(bytes, 'data');\n    const authPubkey = readVarBytes(bytes, 'authPubkey');\n    const decimals = readU8(bytes, 'decimals');\n    const mintData = readMintData(bytes);\n    ensureEnd(bytes, 'GENESIS');\n    return {\n        txType: common_js_1.GENESIS_STR,\n        tokenType,\n        genesisInfo: {\n            tokenTicker,\n            tokenName,\n            url,\n            data: (0, hex_js_1.toHex)(data),\n            authPubkey: (0, hex_js_1.toHex)(authPubkey),\n            decimals,\n        },\n        mintData,\n    };\n}\nfunction readMint(bytes, tokenType) {\n    const tokenId = readTokenId(bytes);\n    const mintData = readMintData(bytes);\n    ensureEnd(bytes, 'MINT');\n    return {\n        txType: common_js_1.MINT_STR,\n        tokenType,\n        tokenId,\n        mintData,\n    };\n}\nfunction readSend(bytes, tokenType) {\n    const tokenId = readTokenId(bytes);\n    const sendAtomsArray = readAtomsArray(bytes, 'sendAtomsArray');\n    ensureEnd(bytes, 'SEND');\n    return {\n        txType: common_js_1.SEND_STR,\n        tokenType,\n        tokenId,\n        sendAtomsArray,\n    };\n}\nfunction readBurn(bytes, tokenType) {\n    const tokenId = readTokenId(bytes);\n    const burnAtoms = readU48(bytes, 'burnAtoms');\n    ensureEnd(bytes, 'BURN');\n    return {\n        txType: common_js_1.BURN_STR,\n        tokenType,\n        tokenId,\n        burnAtoms,\n    };\n}\nfunction readU8(bytes, name) {\n    if (bytes.idx >= bytes.data.length) {\n        throw new Error(`Missing ${name}`);\n    }\n    return bytes.readU8();\n}\nfunction readU48(bytes, name) {\n    if (bytes.idx >= bytes.data.length) {\n        throw new Error(`Missing ${name}`);\n    }\n    return bytes.readU48();\n}\nfunction readTokenId(bytes) {\n    // Note: ALP token ID endianness is little-endian (like in prevOut)\n    return (0, hex_js_1.toHexRev)(bytes.readBytes(common_js_1.TOKEN_ID_NUM_BYTES));\n}\nfunction readSize(bytes, name) {\n    const size = readU8(bytes, name);\n    if (size > alp_js_1.ALP_MAX_SIZE) {\n        throw new Error(`Size must be between 0 and ${alp_js_1.ALP_MAX_SIZE}`);\n    }\n    return size;\n}\nfunction readVarBytes(bytes, name) {\n    const numBytes = readSize(bytes, name);\n    return bytes.readBytes(numBytes);\n}\nfunction readAtomsArray(bytes, name) {\n    const numAtoms = readSize(bytes, name);\n    const atomsArray = [];\n    for (let i = 0; i < numAtoms; ++i) {\n        atomsArray.push(bytes.readU48());\n    }\n    return atomsArray;\n}\nfunction readMintData(bytes) {\n    const atomsArray = readAtomsArray(bytes, 'atomsArray');\n    const numBatons = readU8(bytes, 'numBatons');\n    if (numBatons > alp_js_1.ALP_MAX_SIZE) {\n        throw new Error(`numBatons must be between 0 and ${alp_js_1.ALP_MAX_SIZE}`);\n    }\n    return {\n        atomsArray,\n        numBatons,\n    };\n}\nfunction ensureEnd(bytes, txType) {\n    if (bytes.idx < bytes.data.length) {\n        throw new Error(`Superfluous ${txType} bytes`);\n    }\n}\n//# sourceMappingURL=alp.parse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk1MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsaUJBQWlCLG1CQUFPLENBQUMsSUFBYztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFjO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLElBQWdCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLElBQVU7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsSUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHNCQUFzQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC90b2tlbi9hbHAucGFyc2UuanM/MWRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNSBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlQWxwID0gdm9pZCAwO1xuY29uc3QgaGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vaW8vaGV4LmpzXCIpO1xuY29uc3Qgc3RyX2pzXzEgPSByZXF1aXJlKFwiLi4vaW8vc3RyLmpzXCIpO1xuY29uc3QgYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuLi9pby9ieXRlcy5qc1wiKTtcbmNvbnN0IGFscF9qc18xID0gcmVxdWlyZShcIi4vYWxwLmpzXCIpO1xuY29uc3QgY29tbW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBBTFAgcHVzaGRhdGEuIGVNUFAgYWxsb3dzIG11bHRpcGxlIHB1c2hkYXRhIHBlciBPUF9SRVRVUk4uXG4gKlxuICogRm9yIGRhdGEgdGhhdCdzIGNsZWFybHkgbm90IEFMUCAoaS5lLiBkb2Vzbid0IHN0YXJ0IHdpdGggTE9LQUQgSUQgXCJTTFAyXCIpLFxuICogaXQgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXG4gKlxuICogRm9yIGFuIHVua25vd24gdG9rZW4gdHlwZSwgaXQnbGwgcmV0dXJuIEFscFVua25vd24uXG4gKlxuICogRm9yIGEga25vd24gdG9rZW4gdHlwZSwgaXQnbGwgcGFyc2UgdGhlIHJlbWFpbmluZyBkYXRhLCBvciB0aHJvdyBhbiBlcnJvciBpZlxuICogdGhlIGZvcm1hdCBpcyBpbnZhbGlkIG9yIGlmIHRoZXJlJ3MgYW4gdW5rbm93biB0eCB0eXBlLlxuICpcbiAqIFRoaXMgYmVoYXZpb3IgbWlycm9ycyB0aGF0IG9mIENocm9uaWsgZm9yIGNvbnNpc3RlbmN5LlxuICoqL1xuZnVuY3Rpb24gcGFyc2VBbHAocHVzaGRhdGEpIHtcbiAgICAvLyBNdXN0IGhhdmUgYXQgbGVhc3QgNCBieXRlcyBmb3IgdGhlIExPS0FEIElEXG4gICAgaWYgKHB1c2hkYXRhLmxlbmd0aCA8IGFscF9qc18xLkFMUF9MT0tBRF9JRC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgYnl0ZXNfanNfMS5CeXRlcyhwdXNoZGF0YSk7XG4gICAgLy8gSWYgdGhlIHB1c2hkYXRhIGRvZXNuJ3Qgc3RhcnQgd2l0aCBcIlNMUDJcIiAoQUxQJ3MgTE9LQUQgSUQpLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgY29uc3QgbG9rYWRJZCA9ICgwLCBzdHJfanNfMS5ieXRlc1RvU3RyKShieXRlcy5yZWFkQnl0ZXMoYWxwX2pzXzEuQUxQX0xPS0FEX0lELmxlbmd0aCkpO1xuICAgIGlmIChsb2thZElkICE9ICgwLCBzdHJfanNfMS5ieXRlc1RvU3RyKShhbHBfanNfMS5BTFBfTE9LQURfSUQpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIFJldHVybiBVTktOT1dOIGZvciB1bmtub3duIHRva2VuIHR5cGVzIChvbmx5IFwiU1RBTkRBUkRcIiBrbm93biBzbyBmYXIpXG4gICAgY29uc3QgdG9rZW5UeXBlID0gcmVhZFU4KGJ5dGVzLCAndG9rZW5UeXBlJyk7XG4gICAgaWYgKHRva2VuVHlwZSAhPSBhbHBfanNfMS5BTFBfU1RBTkRBUkQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4VHlwZTogJ1VOS05PV04nLFxuICAgICAgICAgICAgdG9rZW5UeXBlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQYXJzZSB0eCB0eXBlIChHRU5FU0lTLCBNSU5ULCBTRU5ELCBCVVJOKVxuICAgIGNvbnN0IHR4VHlwZSA9ICgwLCBzdHJfanNfMS5ieXRlc1RvU3RyKShyZWFkVmFyQnl0ZXMoYnl0ZXMsICd0eFR5cGUnKSk7XG4gICAgLy8gSGFuZGxlIHR4IHR5cGUgc3BlY2lmaWMgcGFyc2luZ1xuICAgIHN3aXRjaCAodHhUeXBlKSB7XG4gICAgICAgIGNhc2UgY29tbW9uX2pzXzEuR0VORVNJU19TVFI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZEdlbmVzaXMoYnl0ZXMsIHRva2VuVHlwZSk7XG4gICAgICAgIGNhc2UgY29tbW9uX2pzXzEuTUlOVF9TVFI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZE1pbnQoYnl0ZXMsIHRva2VuVHlwZSk7XG4gICAgICAgIGNhc2UgY29tbW9uX2pzXzEuU0VORF9TVFI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZFNlbmQoYnl0ZXMsIHRva2VuVHlwZSk7XG4gICAgICAgIGNhc2UgY29tbW9uX2pzXzEuQlVSTl9TVFI6XG4gICAgICAgICAgICByZXR1cm4gcmVhZEJ1cm4oYnl0ZXMsIHRva2VuVHlwZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHhUeXBlJyk7XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZUFscCA9IHBhcnNlQWxwO1xuZnVuY3Rpb24gcmVhZEdlbmVzaXMoYnl0ZXMsIHRva2VuVHlwZSkge1xuICAgIGNvbnN0IHRva2VuVGlja2VyID0gKDAsIHN0cl9qc18xLmJ5dGVzVG9TdHIpKHJlYWRWYXJCeXRlcyhieXRlcywgJ3Rva2VuVGlja2VyJykpO1xuICAgIGNvbnN0IHRva2VuTmFtZSA9ICgwLCBzdHJfanNfMS5ieXRlc1RvU3RyKShyZWFkVmFyQnl0ZXMoYnl0ZXMsICd0b2tlbk5hbWUnKSk7XG4gICAgY29uc3QgdXJsID0gKDAsIHN0cl9qc18xLmJ5dGVzVG9TdHIpKHJlYWRWYXJCeXRlcyhieXRlcywgJ3VybCcpKTtcbiAgICBjb25zdCBkYXRhID0gcmVhZFZhckJ5dGVzKGJ5dGVzLCAnZGF0YScpO1xuICAgIGNvbnN0IGF1dGhQdWJrZXkgPSByZWFkVmFyQnl0ZXMoYnl0ZXMsICdhdXRoUHVia2V5Jyk7XG4gICAgY29uc3QgZGVjaW1hbHMgPSByZWFkVTgoYnl0ZXMsICdkZWNpbWFscycpO1xuICAgIGNvbnN0IG1pbnREYXRhID0gcmVhZE1pbnREYXRhKGJ5dGVzKTtcbiAgICBlbnN1cmVFbmQoYnl0ZXMsICdHRU5FU0lTJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhUeXBlOiBjb21tb25fanNfMS5HRU5FU0lTX1NUUixcbiAgICAgICAgdG9rZW5UeXBlLFxuICAgICAgICBnZW5lc2lzSW5mbzoge1xuICAgICAgICAgICAgdG9rZW5UaWNrZXIsXG4gICAgICAgICAgICB0b2tlbk5hbWUsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBkYXRhOiAoMCwgaGV4X2pzXzEudG9IZXgpKGRhdGEpLFxuICAgICAgICAgICAgYXV0aFB1YmtleTogKDAsIGhleF9qc18xLnRvSGV4KShhdXRoUHVia2V5KSxcbiAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICB9LFxuICAgICAgICBtaW50RGF0YSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZE1pbnQoYnl0ZXMsIHRva2VuVHlwZSkge1xuICAgIGNvbnN0IHRva2VuSWQgPSByZWFkVG9rZW5JZChieXRlcyk7XG4gICAgY29uc3QgbWludERhdGEgPSByZWFkTWludERhdGEoYnl0ZXMpO1xuICAgIGVuc3VyZUVuZChieXRlcywgJ01JTlQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eFR5cGU6IGNvbW1vbl9qc18xLk1JTlRfU1RSLFxuICAgICAgICB0b2tlblR5cGUsXG4gICAgICAgIHRva2VuSWQsXG4gICAgICAgIG1pbnREYXRhLFxuICAgIH07XG59XG5mdW5jdGlvbiByZWFkU2VuZChieXRlcywgdG9rZW5UeXBlKSB7XG4gICAgY29uc3QgdG9rZW5JZCA9IHJlYWRUb2tlbklkKGJ5dGVzKTtcbiAgICBjb25zdCBzZW5kQXRvbXNBcnJheSA9IHJlYWRBdG9tc0FycmF5KGJ5dGVzLCAnc2VuZEF0b21zQXJyYXknKTtcbiAgICBlbnN1cmVFbmQoYnl0ZXMsICdTRU5EJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhUeXBlOiBjb21tb25fanNfMS5TRU5EX1NUUixcbiAgICAgICAgdG9rZW5UeXBlLFxuICAgICAgICB0b2tlbklkLFxuICAgICAgICBzZW5kQXRvbXNBcnJheSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZEJ1cm4oYnl0ZXMsIHRva2VuVHlwZSkge1xuICAgIGNvbnN0IHRva2VuSWQgPSByZWFkVG9rZW5JZChieXRlcyk7XG4gICAgY29uc3QgYnVybkF0b21zID0gcmVhZFU0OChieXRlcywgJ2J1cm5BdG9tcycpO1xuICAgIGVuc3VyZUVuZChieXRlcywgJ0JVUk4nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eFR5cGU6IGNvbW1vbl9qc18xLkJVUk5fU1RSLFxuICAgICAgICB0b2tlblR5cGUsXG4gICAgICAgIHRva2VuSWQsXG4gICAgICAgIGJ1cm5BdG9tcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZFU4KGJ5dGVzLCBuYW1lKSB7XG4gICAgaWYgKGJ5dGVzLmlkeCA+PSBieXRlcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMucmVhZFU4KCk7XG59XG5mdW5jdGlvbiByZWFkVTQ4KGJ5dGVzLCBuYW1lKSB7XG4gICAgaWYgKGJ5dGVzLmlkeCA+PSBieXRlcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXMucmVhZFU0OCgpO1xufVxuZnVuY3Rpb24gcmVhZFRva2VuSWQoYnl0ZXMpIHtcbiAgICAvLyBOb3RlOiBBTFAgdG9rZW4gSUQgZW5kaWFubmVzcyBpcyBsaXR0bGUtZW5kaWFuIChsaWtlIGluIHByZXZPdXQpXG4gICAgcmV0dXJuICgwLCBoZXhfanNfMS50b0hleFJldikoYnl0ZXMucmVhZEJ5dGVzKGNvbW1vbl9qc18xLlRPS0VOX0lEX05VTV9CWVRFUykpO1xufVxuZnVuY3Rpb24gcmVhZFNpemUoYnl0ZXMsIG5hbWUpIHtcbiAgICBjb25zdCBzaXplID0gcmVhZFU4KGJ5dGVzLCBuYW1lKTtcbiAgICBpZiAoc2l6ZSA+IGFscF9qc18xLkFMUF9NQVhfU0laRSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kICR7YWxwX2pzXzEuQUxQX01BWF9TSVpFfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIHJlYWRWYXJCeXRlcyhieXRlcywgbmFtZSkge1xuICAgIGNvbnN0IG51bUJ5dGVzID0gcmVhZFNpemUoYnl0ZXMsIG5hbWUpO1xuICAgIHJldHVybiBieXRlcy5yZWFkQnl0ZXMobnVtQnl0ZXMpO1xufVxuZnVuY3Rpb24gcmVhZEF0b21zQXJyYXkoYnl0ZXMsIG5hbWUpIHtcbiAgICBjb25zdCBudW1BdG9tcyA9IHJlYWRTaXplKGJ5dGVzLCBuYW1lKTtcbiAgICBjb25zdCBhdG9tc0FycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BdG9tczsgKytpKSB7XG4gICAgICAgIGF0b21zQXJyYXkucHVzaChieXRlcy5yZWFkVTQ4KCkpO1xuICAgIH1cbiAgICByZXR1cm4gYXRvbXNBcnJheTtcbn1cbmZ1bmN0aW9uIHJlYWRNaW50RGF0YShieXRlcykge1xuICAgIGNvbnN0IGF0b21zQXJyYXkgPSByZWFkQXRvbXNBcnJheShieXRlcywgJ2F0b21zQXJyYXknKTtcbiAgICBjb25zdCBudW1CYXRvbnMgPSByZWFkVTgoYnl0ZXMsICdudW1CYXRvbnMnKTtcbiAgICBpZiAobnVtQmF0b25zID4gYWxwX2pzXzEuQUxQX01BWF9TSVpFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbnVtQmF0b25zIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAke2FscF9qc18xLkFMUF9NQVhfU0laRX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXRvbXNBcnJheSxcbiAgICAgICAgbnVtQmF0b25zLFxuICAgIH07XG59XG5mdW5jdGlvbiBlbnN1cmVFbmQoYnl0ZXMsIHR4VHlwZSkge1xuICAgIGlmIChieXRlcy5pZHggPCBieXRlcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1cGVyZmx1b3VzICR7dHhUeXBlfSBieXRlc2ApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFscC5wYXJzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8950\n\n}")},9003:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OID_EMAIL_ADDRESS = exports.OID_COMMON_NAME = exports.OID_ORGANIZATIONAL_UNIT_NAME = exports.OID_ORGANIZATION_NAME = exports.OID_LOCALITY_NAME = exports.OID_STATE_OR_PROVINCE_NAME = exports.OID_COUNTRY_NAME = exports.OID_SECP384R1 = exports.OID_PRIME256V1 = exports.OID_ANSIP256K1 = exports.OID_EC_PUBLIC_KEY = exports.OID_ECDSA_WITH_SHA384 = exports.OID_ECDSA_WITH_SHA256 = exports.OID_RSA_SHA512 = exports.OID_RSA_SHA384 = exports.OID_RSA_SHA256 = void 0;\nexports.OID_RSA_SHA256 = '1.2.840.113549.1.1.11';\nexports.OID_RSA_SHA384 = '1.2.840.113549.1.1.12';\nexports.OID_RSA_SHA512 = '1.2.840.113549.1.1.13';\nexports.OID_ECDSA_WITH_SHA256 = '1.2.840.10045.4.3.2';\nexports.OID_ECDSA_WITH_SHA384 = '1.2.840.10045.4.3.3';\nexports.OID_EC_PUBLIC_KEY = '1.2.840.10045.2.1';\nexports.OID_ANSIP256K1 = '1.3.132.0.10';\nexports.OID_PRIME256V1 = '1.2.840.10045.3.1.7';\nexports.OID_SECP384R1 = '1.3.132.0.34';\nexports.OID_COUNTRY_NAME = '2.5.4.6';\nexports.OID_STATE_OR_PROVINCE_NAME = '2.5.4.8';\nexports.OID_LOCALITY_NAME = '2.5.4.7';\nexports.OID_ORGANIZATION_NAME = '2.5.4.10';\nexports.OID_ORGANIZATIONAL_UNIT_NAME = '2.5.4.11';\nexports.OID_COMMON_NAME = '2.5.4.3';\nexports.OID_EMAIL_ADDRESS = '1.2.840.113549.1.9.1';\n//# sourceMappingURL=x509.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAwMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyx1QkFBdUIsR0FBRyxvQ0FBb0MsR0FBRyw2QkFBNkIsR0FBRyx5QkFBeUIsR0FBRyxrQ0FBa0MsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyx5QkFBeUIsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDdmMsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQyx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLG9DQUFvQztBQUNwQyx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9wYXltZW50L3g1MDkuanM/YzgzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNSBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9JRF9FTUFJTF9BRERSRVNTID0gZXhwb3J0cy5PSURfQ09NTU9OX05BTUUgPSBleHBvcnRzLk9JRF9PUkdBTklaQVRJT05BTF9VTklUX05BTUUgPSBleHBvcnRzLk9JRF9PUkdBTklaQVRJT05fTkFNRSA9IGV4cG9ydHMuT0lEX0xPQ0FMSVRZX05BTUUgPSBleHBvcnRzLk9JRF9TVEFURV9PUl9QUk9WSU5DRV9OQU1FID0gZXhwb3J0cy5PSURfQ09VTlRSWV9OQU1FID0gZXhwb3J0cy5PSURfU0VDUDM4NFIxID0gZXhwb3J0cy5PSURfUFJJTUUyNTZWMSA9IGV4cG9ydHMuT0lEX0FOU0lQMjU2SzEgPSBleHBvcnRzLk9JRF9FQ19QVUJMSUNfS0VZID0gZXhwb3J0cy5PSURfRUNEU0FfV0lUSF9TSEEzODQgPSBleHBvcnRzLk9JRF9FQ0RTQV9XSVRIX1NIQTI1NiA9IGV4cG9ydHMuT0lEX1JTQV9TSEE1MTIgPSBleHBvcnRzLk9JRF9SU0FfU0hBMzg0ID0gZXhwb3J0cy5PSURfUlNBX1NIQTI1NiA9IHZvaWQgMDtcbmV4cG9ydHMuT0lEX1JTQV9TSEEyNTYgPSAnMS4yLjg0MC4xMTM1NDkuMS4xLjExJztcbmV4cG9ydHMuT0lEX1JTQV9TSEEzODQgPSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEyJztcbmV4cG9ydHMuT0lEX1JTQV9TSEE1MTIgPSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEzJztcbmV4cG9ydHMuT0lEX0VDRFNBX1dJVEhfU0hBMjU2ID0gJzEuMi44NDAuMTAwNDUuNC4zLjInO1xuZXhwb3J0cy5PSURfRUNEU0FfV0lUSF9TSEEzODQgPSAnMS4yLjg0MC4xMDA0NS40LjMuMyc7XG5leHBvcnRzLk9JRF9FQ19QVUJMSUNfS0VZID0gJzEuMi44NDAuMTAwNDUuMi4xJztcbmV4cG9ydHMuT0lEX0FOU0lQMjU2SzEgPSAnMS4zLjEzMi4wLjEwJztcbmV4cG9ydHMuT0lEX1BSSU1FMjU2VjEgPSAnMS4yLjg0MC4xMDA0NS4zLjEuNyc7XG5leHBvcnRzLk9JRF9TRUNQMzg0UjEgPSAnMS4zLjEzMi4wLjM0JztcbmV4cG9ydHMuT0lEX0NPVU5UUllfTkFNRSA9ICcyLjUuNC42JztcbmV4cG9ydHMuT0lEX1NUQVRFX09SX1BST1ZJTkNFX05BTUUgPSAnMi41LjQuOCc7XG5leHBvcnRzLk9JRF9MT0NBTElUWV9OQU1FID0gJzIuNS40LjcnO1xuZXhwb3J0cy5PSURfT1JHQU5JWkFUSU9OX05BTUUgPSAnMi41LjQuMTAnO1xuZXhwb3J0cy5PSURfT1JHQU5JWkFUSU9OQUxfVU5JVF9OQU1FID0gJzIuNS40LjExJztcbmV4cG9ydHMuT0lEX0NPTU1PTl9OQU1FID0gJzIuNS40LjMnO1xuZXhwb3J0cy5PSURfRU1BSUxfQUREUkVTUyA9ICcxLjIuODQwLjExMzU0OS4xLjkuMSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14NTA5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9003\n\n}")},9175:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(5145);\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexports.swap8IfBE = exports.isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanM/NTMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5zd2FwMzJJZkJFID0gZXhwb3J0cy5ieXRlU3dhcElmQkUgPSBleHBvcnRzLnN3YXA4SWZCRSA9IGV4cG9ydHMuaXNMRSA9IHZvaWQgMDtcbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5leHBvcnRzLmFudW1iZXIgPSBhbnVtYmVyO1xuZXhwb3J0cy5hYnl0ZXMgPSBhYnl0ZXM7XG5leHBvcnRzLmFoYXNoID0gYWhhc2g7XG5leHBvcnRzLmFleGlzdHMgPSBhZXhpc3RzO1xuZXhwb3J0cy5hb3V0cHV0ID0gYW91dHB1dDtcbmV4cG9ydHMudTggPSB1ODtcbmV4cG9ydHMudTMyID0gdTMyO1xuZXhwb3J0cy5jbGVhbiA9IGNsZWFuO1xuZXhwb3J0cy5jcmVhdGVWaWV3ID0gY3JlYXRlVmlldztcbmV4cG9ydHMucm90ciA9IHJvdHI7XG5leHBvcnRzLnJvdGwgPSByb3RsO1xuZXhwb3J0cy5ieXRlU3dhcCA9IGJ5dGVTd2FwO1xuZXhwb3J0cy5ieXRlU3dhcDMyID0gYnl0ZVN3YXAzMjtcbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG5leHBvcnRzLmJ5dGVzVG9VdGY4ID0gYnl0ZXNUb1V0Zjg7XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuZXhwb3J0cy5rZGZJbnB1dFRvQnl0ZXMgPSBrZGZJbnB1dFRvQnl0ZXM7XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG5leHBvcnRzLmNoZWNrT3B0cyA9IGNoZWNrT3B0cztcbmV4cG9ydHMuY3JlYXRlSGFzaGVyID0gY3JlYXRlSGFzaGVyO1xuZXhwb3J0cy5jcmVhdGVPcHRIYXNoZXIgPSBjcmVhdGVPcHRIYXNoZXI7XG5leHBvcnRzLmNyZWF0ZVhPRmVyID0gY3JlYXRlWE9GZXI7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbi8qKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuIEJlIGNhcmVmdWw6IG5vZGVqcyBCdWZmZXIgd2lsbCByZXR1cm4gdHJ1ZS4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBwb3NpdGl2ZSBpbnRlZ2VyLiAqL1xuZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5mdW5jdGlvbiBhYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJyArIGxlbmd0aHMgKyAnLCBnb3QgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaCAqL1xuZnVuY3Rpb24gYWhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy5jcmVhdGVIYXNoZXInKTtcbiAgICBhbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBhbnVtYmVyKGguYmxvY2tMZW4pO1xufVxuLyoqIEFzc2VydHMgYSBoYXNoIGluc3RhbmNlIGhhcyBub3QgYmVlbiBkZXN0cm95ZWQgLyBmaW5pc2hlZCAqL1xuZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICcgKyBtaW4pO1xuICAgIH1cbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHU4LiAqL1xuZnVuY3Rpb24gdTgoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1MzIuICovXG5mdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmZ1bmN0aW9uIGNsZWFuKC4uLmFycmF5cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXS5maWxsKDApO1xuICAgIH1cbn1cbi8qKiBDcmVhdGUgRGF0YVZpZXcgb2YgYW4gYXJyYXkgZm9yIGVhc3kgYnl0ZS1sZXZlbCBtYW5pcHVsYXRpb24uICovXG5mdW5jdGlvbiBjcmVhdGVWaWV3KGFycikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZnVuY3Rpb24gcm90bCh3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xufVxuLyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuZXhwb3J0cy5pc0xFID0gKCgpID0+IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG4vKiogVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZnVuY3Rpb24gYnl0ZVN3YXAod29yZCkge1xuICAgIHJldHVybiAoKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAgICAgKCh3b3JkIDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAgICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpKTtcbn1cbi8qKiBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm0gKi9cbmV4cG9ydHMuc3dhcDhJZkJFID0gZXhwb3J0cy5pc0xFXG4gICAgPyAobikgPT4gblxuICAgIDogKG4pID0+IGJ5dGVTd2FwKG4pO1xuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnRzLmJ5dGVTd2FwSWZCRSA9IGV4cG9ydHMuc3dhcDhJZkJFO1xuLyoqIEluIHBsYWNlIGJ5dGUgc3dhcCBmb3IgVWludDMyQXJyYXkgKi9cbmZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMuc3dhcDMySWZCRSA9IGV4cG9ydHMuaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUhleChoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4gKiBDYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbiAqIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbiAqL1xuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pXG4gKi9cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgoVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZnVuY3Rpb24ga2RmSW5wdXRUb0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHt9LnRvU3RyaW5nLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlICovXG5jbGFzcyBIYXNoIHtcbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vKiogV3JhcHMgaGFzaCBmdW5jdGlvbiwgY3JlYXRpbmcgYW4gaW50ZXJmYWNlIG9uIHRvcCBvZiBpdCAqL1xuZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9wdEhhc2hlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVhPRmVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSBjcmVhdGVIYXNoZXI7XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlT3B0SGFzaGVyO1xuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZVhPRmVyO1xuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvICYmIHR5cGVvZiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvICYmIHR5cGVvZiBjcnlwdG9fMS5jcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjcnlwdG9fMS5jcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9175\n\n}")},9176:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.verifyMsg = exports.signMsg = exports.magicHash = void 0;\nconst hash_1 = __webpack_require__(5632);\nconst ecc_1 = __webpack_require__(3799);\nconst writerbytes_1 = __webpack_require__(8161);\nconst varsize_1 = __webpack_require__(1451);\nconst hex_1 = __webpack_require__(2938);\nconst address_1 = __webpack_require__(3085);\n/**\n * messages.ts\n *\n * Sign and verify messages\n */\nconst ECASH_MSG_SIGNING_PREFIX = \'\\x16eCash Signed Message:\\n\';\n/**\n * Messages are prepared in a standard way before signing and verifying\n *\n * - The raw message (e.g., "Hello, world!") is encoded as a UTF-8 byte array\n * - The prefixed message is constructed as:\n *\n *   [prefix][message_length][message]\n *\n *   where message_length is a variable-length integer (varint) encoding the\n *   byte length of the message\n *\n * We keep the "magicHash" name used in bitcoinjs-message as we do the same thing here\n * with eCash tools\n *\n * ref https://github.com/bitcoinjs/bitcoinjs-message/blob/master/index.js#L57\n */\nconst magicHash = (message, messagePrefix = ECASH_MSG_SIGNING_PREFIX) => {\n    const encoder = new TextEncoder();\n    // Convert prefix to Uint8Array\n    const prefixBytes = encoder.encode(messagePrefix);\n    // Convert message to Uint8Array\n    const messageBytes = encoder.encode(message);\n    // Calculate the maximum possible size of the varint for message length\n    const maxVarintSize = messageBytes.length <= 0xfc\n        ? 1\n        : messageBytes.length <= 0xffff\n            ? 3\n            : messageBytes.length <= 0xffffffff\n                ? 5\n                : 9;\n    // Create a WriterBytes instance with enough capacity\n    const writer = new writerbytes_1.WriterBytes(prefixBytes.length + maxVarintSize + messageBytes.length);\n    // Write the prefix\n    writer.putBytes(prefixBytes);\n    // Write the message length as a varint\n    (0, varsize_1.writeVarSize)(messageBytes.length, writer);\n    // Write the message\n    writer.putBytes(messageBytes);\n    // Return double SHA-256 hash\n    return (0, hash_1.sha256d)(writer.data);\n};\nexports.magicHash = magicHash;\n/**\n * Sign a message\n *\n * While there is not an official BIP or spec here, there is\n * a de facto standard\n *\n * See implementation in bitcoinjs-lib and electrum\n */\nconst signMsg = (msg, sk, prefix = ECASH_MSG_SIGNING_PREFIX) => {\n    const preparedMsg = (0, exports.magicHash)(msg, prefix);\n    const sig = new ecc_1.Ecc().signRecoverable(sk, preparedMsg);\n    // Convert Uint8Array to binary string and encode with btoa\n    const binaryString = String.fromCharCode(...sig);\n    return btoa(binaryString);\n};\nexports.signMsg = signMsg;\n/**\n * Verify that a given message and signature\n * came from a given address\n */\nconst verifyMsg = (msg, signature, address, prefix = ECASH_MSG_SIGNING_PREFIX) => {\n    try {\n        const preparedMsg = (0, exports.magicHash)(msg, prefix);\n        // Decode base64 signature to binary string and convert to Uint8Array\n        const binaryString = atob(signature);\n        const sig = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) {\n            sig[i] = binaryString.charCodeAt(i);\n        }\n        const recoveredPk = new ecc_1.Ecc().recoverSig(sig, preparedMsg);\n        // Get recovered hash as a hex string and compare to tested hash\n        const recoveredHash = (0, hex_1.toHex)((0, hash_1.shaRmd160)(recoveredPk));\n        const testedHash = address_1.Address.fromCashAddress(address).hash;\n        return recoveredHash === testedHash;\n    }\n    catch (err) {\n        console.error(`Error verifying signature`, err);\n        return false;\n    }\n};\nexports.verifyMsg = verifyMsg;\n//# sourceMappingURL=messages.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsaUJBQWlCO0FBQ3ZELGVBQWUsbUJBQU8sQ0FBQyxJQUFRO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxJQUFPO0FBQzdCLHNCQUFzQixtQkFBTyxDQUFDLElBQWtCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLElBQWM7QUFDeEMsY0FBYyxtQkFBTyxDQUFDLElBQVU7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsSUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9tZXNzYWdlcy5qcz9mZjI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI1IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyaWZ5TXNnID0gZXhwb3J0cy5zaWduTXNnID0gZXhwb3J0cy5tYWdpY0hhc2ggPSB2b2lkIDA7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuY29uc3QgZWNjXzEgPSByZXF1aXJlKFwiLi9lY2NcIik7XG5jb25zdCB3cml0ZXJieXRlc18xID0gcmVxdWlyZShcIi4vaW8vd3JpdGVyYnl0ZXNcIik7XG5jb25zdCB2YXJzaXplXzEgPSByZXF1aXJlKFwiLi9pby92YXJzaXplXCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9pby9oZXhcIik7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzL2FkZHJlc3NcIik7XG4vKipcbiAqIG1lc3NhZ2VzLnRzXG4gKlxuICogU2lnbiBhbmQgdmVyaWZ5IG1lc3NhZ2VzXG4gKi9cbmNvbnN0IEVDQVNIX01TR19TSUdOSU5HX1BSRUZJWCA9ICdcXHgxNmVDYXNoIFNpZ25lZCBNZXNzYWdlOlxcbic7XG4vKipcbiAqIE1lc3NhZ2VzIGFyZSBwcmVwYXJlZCBpbiBhIHN0YW5kYXJkIHdheSBiZWZvcmUgc2lnbmluZyBhbmQgdmVyaWZ5aW5nXG4gKlxuICogLSBUaGUgcmF3IG1lc3NhZ2UgKGUuZy4sIFwiSGVsbG8sIHdvcmxkIVwiKSBpcyBlbmNvZGVkIGFzIGEgVVRGLTggYnl0ZSBhcnJheVxuICogLSBUaGUgcHJlZml4ZWQgbWVzc2FnZSBpcyBjb25zdHJ1Y3RlZCBhczpcbiAqXG4gKiAgIFtwcmVmaXhdW21lc3NhZ2VfbGVuZ3RoXVttZXNzYWdlXVxuICpcbiAqICAgd2hlcmUgbWVzc2FnZV9sZW5ndGggaXMgYSB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciAodmFyaW50KSBlbmNvZGluZyB0aGVcbiAqICAgYnl0ZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2VcbiAqXG4gKiBXZSBrZWVwIHRoZSBcIm1hZ2ljSGFzaFwiIG5hbWUgdXNlZCBpbiBiaXRjb2luanMtbWVzc2FnZSBhcyB3ZSBkbyB0aGUgc2FtZSB0aGluZyBoZXJlXG4gKiB3aXRoIGVDYXNoIHRvb2xzXG4gKlxuICogcmVmIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYml0Y29pbmpzLW1lc3NhZ2UvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDU3XG4gKi9cbmNvbnN0IG1hZ2ljSGFzaCA9IChtZXNzYWdlLCBtZXNzYWdlUHJlZml4ID0gRUNBU0hfTVNHX1NJR05JTkdfUFJFRklYKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIC8vIENvbnZlcnQgcHJlZml4IHRvIFVpbnQ4QXJyYXlcbiAgICBjb25zdCBwcmVmaXhCeXRlcyA9IGVuY29kZXIuZW5jb2RlKG1lc3NhZ2VQcmVmaXgpO1xuICAgIC8vIENvbnZlcnQgbWVzc2FnZSB0byBVaW50OEFycmF5XG4gICAgY29uc3QgbWVzc2FnZUJ5dGVzID0gZW5jb2Rlci5lbmNvZGUobWVzc2FnZSk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIHBvc3NpYmxlIHNpemUgb2YgdGhlIHZhcmludCBmb3IgbWVzc2FnZSBsZW5ndGhcbiAgICBjb25zdCBtYXhWYXJpbnRTaXplID0gbWVzc2FnZUJ5dGVzLmxlbmd0aCA8PSAweGZjXG4gICAgICAgID8gMVxuICAgICAgICA6IG1lc3NhZ2VCeXRlcy5sZW5ndGggPD0gMHhmZmZmXG4gICAgICAgICAgICA/IDNcbiAgICAgICAgICAgIDogbWVzc2FnZUJ5dGVzLmxlbmd0aCA8PSAweGZmZmZmZmZmXG4gICAgICAgICAgICAgICAgPyA1XG4gICAgICAgICAgICAgICAgOiA5O1xuICAgIC8vIENyZWF0ZSBhIFdyaXRlckJ5dGVzIGluc3RhbmNlIHdpdGggZW5vdWdoIGNhcGFjaXR5XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IHdyaXRlcmJ5dGVzXzEuV3JpdGVyQnl0ZXMocHJlZml4Qnl0ZXMubGVuZ3RoICsgbWF4VmFyaW50U2l6ZSArIG1lc3NhZ2VCeXRlcy5sZW5ndGgpO1xuICAgIC8vIFdyaXRlIHRoZSBwcmVmaXhcbiAgICB3cml0ZXIucHV0Qnl0ZXMocHJlZml4Qnl0ZXMpO1xuICAgIC8vIFdyaXRlIHRoZSBtZXNzYWdlIGxlbmd0aCBhcyBhIHZhcmludFxuICAgICgwLCB2YXJzaXplXzEud3JpdGVWYXJTaXplKShtZXNzYWdlQnl0ZXMubGVuZ3RoLCB3cml0ZXIpO1xuICAgIC8vIFdyaXRlIHRoZSBtZXNzYWdlXG4gICAgd3JpdGVyLnB1dEJ5dGVzKG1lc3NhZ2VCeXRlcyk7XG4gICAgLy8gUmV0dXJuIGRvdWJsZSBTSEEtMjU2IGhhc2hcbiAgICByZXR1cm4gKDAsIGhhc2hfMS5zaGEyNTZkKSh3cml0ZXIuZGF0YSk7XG59O1xuZXhwb3J0cy5tYWdpY0hhc2ggPSBtYWdpY0hhc2g7XG4vKipcbiAqIFNpZ24gYSBtZXNzYWdlXG4gKlxuICogV2hpbGUgdGhlcmUgaXMgbm90IGFuIG9mZmljaWFsIEJJUCBvciBzcGVjIGhlcmUsIHRoZXJlIGlzXG4gKiBhIGRlIGZhY3RvIHN0YW5kYXJkXG4gKlxuICogU2VlIGltcGxlbWVudGF0aW9uIGluIGJpdGNvaW5qcy1saWIgYW5kIGVsZWN0cnVtXG4gKi9cbmNvbnN0IHNpZ25Nc2cgPSAobXNnLCBzaywgcHJlZml4ID0gRUNBU0hfTVNHX1NJR05JTkdfUFJFRklYKSA9PiB7XG4gICAgY29uc3QgcHJlcGFyZWRNc2cgPSAoMCwgZXhwb3J0cy5tYWdpY0hhc2gpKG1zZywgcHJlZml4KTtcbiAgICBjb25zdCBzaWcgPSBuZXcgZWNjXzEuRWNjKCkuc2lnblJlY292ZXJhYmxlKHNrLCBwcmVwYXJlZE1zZyk7XG4gICAgLy8gQ29udmVydCBVaW50OEFycmF5IHRvIGJpbmFyeSBzdHJpbmcgYW5kIGVuY29kZSB3aXRoIGJ0b2FcbiAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLnNpZyk7XG4gICAgcmV0dXJuIGJ0b2EoYmluYXJ5U3RyaW5nKTtcbn07XG5leHBvcnRzLnNpZ25Nc2cgPSBzaWduTXNnO1xuLyoqXG4gKiBWZXJpZnkgdGhhdCBhIGdpdmVuIG1lc3NhZ2UgYW5kIHNpZ25hdHVyZVxuICogY2FtZSBmcm9tIGEgZ2l2ZW4gYWRkcmVzc1xuICovXG5jb25zdCB2ZXJpZnlNc2cgPSAobXNnLCBzaWduYXR1cmUsIGFkZHJlc3MsIHByZWZpeCA9IEVDQVNIX01TR19TSUdOSU5HX1BSRUZJWCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkTXNnID0gKDAsIGV4cG9ydHMubWFnaWNIYXNoKShtc2csIHByZWZpeCk7XG4gICAgICAgIC8vIERlY29kZSBiYXNlNjQgc2lnbmF0dXJlIHRvIGJpbmFyeSBzdHJpbmcgYW5kIGNvbnZlcnQgdG8gVWludDhBcnJheVxuICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2lnW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjb3ZlcmVkUGsgPSBuZXcgZWNjXzEuRWNjKCkucmVjb3ZlclNpZyhzaWcsIHByZXBhcmVkTXNnKTtcbiAgICAgICAgLy8gR2V0IHJlY292ZXJlZCBoYXNoIGFzIGEgaGV4IHN0cmluZyBhbmQgY29tcGFyZSB0byB0ZXN0ZWQgaGFzaFxuICAgICAgICBjb25zdCByZWNvdmVyZWRIYXNoID0gKDAsIGhleF8xLnRvSGV4KSgoMCwgaGFzaF8xLnNoYVJtZDE2MCkocmVjb3ZlcmVkUGspKTtcbiAgICAgICAgY29uc3QgdGVzdGVkSGFzaCA9IGFkZHJlc3NfMS5BZGRyZXNzLmZyb21DYXNoQWRkcmVzcyhhZGRyZXNzKS5oYXNoO1xuICAgICAgICByZXR1cm4gcmVjb3ZlcmVkSGFzaCA9PT0gdGVzdGVkSGFzaDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB2ZXJpZnlpbmcgc2lnbmF0dXJlYCwgZXJyKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5leHBvcnRzLnZlcmlmeU1zZyA9IHZlcmlmeU1zZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2VzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9176\n\n}')},9390:module=>{"use strict";eval("{\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM5MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0EsVUFBVTtBQUNWLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanM/MDQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9390\n\n}")},9410:module=>{"use strict";eval('{\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== "undefined") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== "undefined") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQxMC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEtBQUs7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQztBQUN4RDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY2FzaC13YWxsZXQtd2ViLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzPzJiMDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeSk7XHJcblxyXG4vKipcclxuICogUmVhZHMgLyB3cml0ZXMgZmxvYXRzIC8gZG91YmxlcyBmcm9tIC8gdG8gYnVmZmVycy5cclxuICogQG5hbWUgdXRpbC5mbG9hdFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8vIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoZSBwdXJwb3NlIG9mIG5vZGUtYmFzZWQgdGVzdGluZyBpbiBtb2RpZmllZCBnbG9iYWwgZW52aXJvbm1lbnRzXHJcbmZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0cykge1xyXG5cclxuICAgIC8vIGZsb2F0OiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoWyAtMCBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjMyLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4YlszXSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfY3B5IDogd3JpdGVGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX3JldiA6IHdyaXRlRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAvLyBmbG9hdDogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfaWVlZTc1NCh3cml0ZVVpbnQsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQzMjg5MzQ0LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpIC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDEuMTc1NDk0MzUwODIyMjg3NWUtMzgpIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBNYXRoLnJvdW5kKHZhbCAvIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSkpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgdWludCA9IHJlYWRVaW50KGJ1ZiwgcG9zKSxcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAodWludCA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHVpbnQgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDI1NVxyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFKTtcclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8vIGRvdWJsZTogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KFstMF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmNjQuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzddID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzddO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9jcHkgOiByZWFkRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfcmV2IDogcmVhZERvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgIC8vIGRvdWJsZTogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KSB7IC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjE0NjQzNTA3MikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHsgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgbWFudGlzc2EgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMTAyNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgKiA0NTAzNTk5NjI3MzcwNDk2ID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGxvID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYwKSxcclxuICAgICAgICAgICAgICAgIGhpID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IGhpID4+PiAyMCAmIDIwNDcsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IDQyOTQ5NjcyOTYgKiAoaGkgJiAxMDQ4NTc1KSArIGxvO1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDdcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogNWUtMzI0ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG59XHJcblxyXG4vLyB1aW50IGhlbHBlcnNcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludExFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsID4+PiAyNDtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsICAgICAgICAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRMRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF1cclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50QkUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdIDw8IDI0XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10pID4+PiAwO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9410\n\n}')},9615:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hmac = exports.HMAC = void 0;\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nconst utils_ts_1 = __webpack_require__(9175);\nclass HMAC extends utils_ts_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, utils_ts_1.ahash)(hash);\n        const key = (0, utils_ts_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0, utils_ts_1.clean)(pad);\n    }\n    update(buf) {\n        (0, utils_ts_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYxNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLElBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VjYXNoLXdhbGxldC13ZWIvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzP2U2MzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhtYWMgPSBleHBvcnRzLkhNQUMgPSB2b2lkIDA7XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQG1vZHVsZVxuICovXG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jbGFzcyBITUFDIGV4dGVuZHMgdXRpbHNfdHNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWhhc2gpKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSAoMCwgdXRpbHNfdHNfMS50b0J5dGVzKShfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikocGFkKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hYnl0ZXMpKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuSE1BQyA9IEhNQUM7XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbiAqIGltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG4gKiBjb25zdCBtYWMxID0gaG1hYyhzaGEyNTYsICdrZXknLCAnbWVzc2FnZScpO1xuICovXG5jb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuZXhwb3J0cy5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9615\n\n}")},9693:(__unused_webpack_module,exports)=>{"use strict";eval("{\n// Copyright (c) 2025 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GENESIS_TOKEN_ID_PLACEHOLDER = void 0;\n/**\n * We do not yet know the tokenId of a token involved in a GenesisAction\n * We use a placeholder token to distinguish GENESIS PaymentTokenOutput[] from MINT\n * PaymentTokenOutput[]; see payment/output.ts\n */\nexports.GENESIS_TOKEN_ID_PLACEHOLDER = 'GENESIS_TOKEN_ID_PLACEHOLDER';\n//# sourceMappingURL=action.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY5My5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esb0NBQW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC9wYXltZW50L2FjdGlvbi5qcz9mMjMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSAyMDI1IFRoZSBCaXRjb2luIGRldmVsb3BlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgQ09QWUlORyBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR0VORVNJU19UT0tFTl9JRF9QTEFDRUhPTERFUiA9IHZvaWQgMDtcbi8qKlxuICogV2UgZG8gbm90IHlldCBrbm93IHRoZSB0b2tlbklkIG9mIGEgdG9rZW4gaW52b2x2ZWQgaW4gYSBHZW5lc2lzQWN0aW9uXG4gKiBXZSB1c2UgYSBwbGFjZWhvbGRlciB0b2tlbiB0byBkaXN0aW5ndWlzaCBHRU5FU0lTIFBheW1lbnRUb2tlbk91dHB1dFtdIGZyb20gTUlOVFxuICogUGF5bWVudFRva2VuT3V0cHV0W107IHNlZSBwYXltZW50L291dHB1dC50c1xuICovXG5leHBvcnRzLkdFTkVTSVNfVE9LRU5fSURfUExBQ0VIT0xERVIgPSAnR0VORVNJU19UT0tFTl9JRF9QTEFDRUhPTERFUic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9693\n\n}")},9801:(__unused_webpack_module,exports,__webpack_require__)=>{eval("{const Mode = __webpack_require__(208)\nconst NumericData = __webpack_require__(4357)\nconst AlphanumericData = __webpack_require__(1433)\nconst ByteData = __webpack_require__(5822)\nconst KanjiData = __webpack_require__(4861)\nconst Regex = __webpack_require__(7044)\nconst Utils = __webpack_require__(6886)\nconst dijkstra = __webpack_require__(6320)\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxhQUFhO0FBQ3pCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2NvcmUvc2VnbWVudHMuanM/YmVmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNb2RlID0gcmVxdWlyZSgnLi9tb2RlJylcbmNvbnN0IE51bWVyaWNEYXRhID0gcmVxdWlyZSgnLi9udW1lcmljLWRhdGEnKVxuY29uc3QgQWxwaGFudW1lcmljRGF0YSA9IHJlcXVpcmUoJy4vYWxwaGFudW1lcmljLWRhdGEnKVxuY29uc3QgQnl0ZURhdGEgPSByZXF1aXJlKCcuL2J5dGUtZGF0YScpXG5jb25zdCBLYW5qaURhdGEgPSByZXF1aXJlKCcuL2thbmppLWRhdGEnKVxuY29uc3QgUmVnZXggPSByZXF1aXJlKCcuL3JlZ2V4JylcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBkaWprc3RyYSA9IHJlcXVpcmUoJ2RpamtzdHJhanMnKVxuXG4vKipcbiAqIFJldHVybnMgVVRGOCBieXRlIGxlbmd0aFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyIElucHV0IHN0cmluZ1xuICogQHJldHVybiB7TnVtYmVyfSAgICAgTnVtYmVyIG9mIGJ5dGVcbiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nQnl0ZUxlbmd0aCAoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkubGVuZ3RoXG59XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBzZWdtZW50cyBvZiB0aGUgc3BlY2lmaWVkIG1vZGVcbiAqIGZyb20gYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gIHtNb2RlfSAgIG1vZGUgU2VnbWVudCBtb2RlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0ciAgU3RyaW5nIHRvIHByb2Nlc3NcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICBBcnJheSBvZiBvYmplY3Qgd2l0aCBzZWdtZW50cyBkYXRhXG4gKi9cbmZ1bmN0aW9uIGdldFNlZ21lbnRzIChyZWdleCwgbW9kZSwgc3RyKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gW11cbiAgbGV0IHJlc3VsdFxuXG4gIHdoaWxlICgocmVzdWx0ID0gcmVnZXguZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgZGF0YTogcmVzdWx0WzBdLFxuICAgICAgaW5kZXg6IHJlc3VsdC5pbmRleCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBsZW5ndGg6IHJlc3VsdFswXS5sZW5ndGhcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzXG59XG5cbi8qKlxuICogRXh0cmFjdHMgYSBzZXJpZXMgb2Ygc2VnbWVudHMgd2l0aCB0aGUgYXBwcm9wcmlhdGVcbiAqIG1vZGVzIGZyb20gYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGFTdHIgSW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgb2Ygb2JqZWN0IHdpdGggc2VnbWVudHMgZGF0YVxuICovXG5mdW5jdGlvbiBnZXRTZWdtZW50c0Zyb21TdHJpbmcgKGRhdGFTdHIpIHtcbiAgY29uc3QgbnVtU2VncyA9IGdldFNlZ21lbnRzKFJlZ2V4Lk5VTUVSSUMsIE1vZGUuTlVNRVJJQywgZGF0YVN0cilcbiAgY29uc3QgYWxwaGFOdW1TZWdzID0gZ2V0U2VnbWVudHMoUmVnZXguQUxQSEFOVU1FUklDLCBNb2RlLkFMUEhBTlVNRVJJQywgZGF0YVN0cilcbiAgbGV0IGJ5dGVTZWdzXG4gIGxldCBrYW5qaVNlZ3NcblxuICBpZiAoVXRpbHMuaXNLYW5qaU1vZGVFbmFibGVkKCkpIHtcbiAgICBieXRlU2VncyA9IGdldFNlZ21lbnRzKFJlZ2V4LkJZVEUsIE1vZGUuQllURSwgZGF0YVN0cilcbiAgICBrYW5qaVNlZ3MgPSBnZXRTZWdtZW50cyhSZWdleC5LQU5KSSwgTW9kZS5LQU5KSSwgZGF0YVN0cilcbiAgfSBlbHNlIHtcbiAgICBieXRlU2VncyA9IGdldFNlZ21lbnRzKFJlZ2V4LkJZVEVfS0FOSkksIE1vZGUuQllURSwgZGF0YVN0cilcbiAgICBrYW5qaVNlZ3MgPSBbXVxuICB9XG5cbiAgY29uc3Qgc2VncyA9IG51bVNlZ3MuY29uY2F0KGFscGhhTnVtU2VncywgYnl0ZVNlZ3MsIGthbmppU2VncylcblxuICByZXR1cm4gc2Vnc1xuICAgIC5zb3J0KGZ1bmN0aW9uIChzMSwgczIpIHtcbiAgICAgIHJldHVybiBzMS5pbmRleCAtIHMyLmluZGV4XG4gICAgfSlcbiAgICAubWFwKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG9iai5kYXRhLFxuICAgICAgICBtb2RlOiBvYmoubW9kZSxcbiAgICAgICAgbGVuZ3RoOiBvYmoubGVuZ3RoXG4gICAgICB9XG4gICAgfSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGhvdyBtYW55IGJpdHMgYXJlIG5lZWRlZCB0byBlbmNvZGUgYSBzdHJpbmcgb2ZcbiAqIHNwZWNpZmllZCBsZW5ndGggd2l0aCB0aGUgc3BlY2lmaWVkIG1vZGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGxlbmd0aCBTdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0gIHtNb2RlfSBtb2RlICAgICBTZWdtZW50IG1vZGVcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgIEJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gZ2V0U2VnbWVudEJpdHNMZW5ndGggKGxlbmd0aCwgbW9kZSkge1xuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIE1vZGUuTlVNRVJJQzpcbiAgICAgIHJldHVybiBOdW1lcmljRGF0YS5nZXRCaXRzTGVuZ3RoKGxlbmd0aClcbiAgICBjYXNlIE1vZGUuQUxQSEFOVU1FUklDOlxuICAgICAgcmV0dXJuIEFscGhhbnVtZXJpY0RhdGEuZ2V0Qml0c0xlbmd0aChsZW5ndGgpXG4gICAgY2FzZSBNb2RlLktBTkpJOlxuICAgICAgcmV0dXJuIEthbmppRGF0YS5nZXRCaXRzTGVuZ3RoKGxlbmd0aClcbiAgICBjYXNlIE1vZGUuQllURTpcbiAgICAgIHJldHVybiBCeXRlRGF0YS5nZXRCaXRzTGVuZ3RoKGxlbmd0aClcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlcyBhZGphY2VudCBzZWdtZW50cyB3aGljaCBoYXZlIHRoZSBzYW1lIG1vZGVcbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gc2VncyBBcnJheSBvZiBvYmplY3Qgd2l0aCBzZWdtZW50cyBkYXRhXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICBBcnJheSBvZiBvYmplY3Qgd2l0aCBzZWdtZW50cyBkYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU2VnbWVudHMgKHNlZ3MpIHtcbiAgcmV0dXJuIHNlZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHtcbiAgICBjb25zdCBwcmV2U2VnID0gYWNjLmxlbmd0aCAtIDEgPj0gMCA/IGFjY1thY2MubGVuZ3RoIC0gMV0gOiBudWxsXG4gICAgaWYgKHByZXZTZWcgJiYgcHJldlNlZy5tb2RlID09PSBjdXJyLm1vZGUpIHtcbiAgICAgIGFjY1thY2MubGVuZ3RoIC0gMV0uZGF0YSArPSBjdXJyLmRhdGFcbiAgICAgIHJldHVybiBhY2NcbiAgICB9XG5cbiAgICBhY2MucHVzaChjdXJyKVxuICAgIHJldHVybiBhY2NcbiAgfSwgW10pXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbGlzdCBvZiBhbGwgcG9zc2libGUgbm9kZXMgY29tYmluYXRpb24gd2hpY2hcbiAqIHdpbGwgYmUgdXNlZCB0byBidWlsZCBhIHNlZ21lbnRzIGdyYXBoLlxuICpcbiAqIE5vZGVzIGFyZSBkaXZpZGVkIGJ5IGdyb3Vwcy4gRWFjaCBncm91cCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIGFsbCB0aGUgbW9kZXNcbiAqIGluIHdoaWNoIGlzIHBvc3NpYmxlIHRvIGVuY29kZSB0aGUgZ2l2ZW4gdGV4dC5cbiAqXG4gKiBGb3IgZXhhbXBsZSB0aGUgdGV4dCAnMTIzNDUnIGNhbiBiZSBlbmNvZGVkIGFzIE51bWVyaWMsIEFscGhhbnVtZXJpYyBvciBCeXRlLlxuICogVGhlIGdyb3VwIGZvciAnMTIzNDUnIHdpbGwgY29udGFpbiB0aGVuIDMgb2JqZWN0cywgb25lIGZvciBlYWNoXG4gKiBwb3NzaWJsZSBlbmNvZGluZyBtb2RlLlxuICpcbiAqIEVhY2ggbm9kZSByZXByZXNlbnRzIGEgcG9zc2libGUgc2VnbWVudC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gc2VncyBBcnJheSBvZiBvYmplY3Qgd2l0aCBzZWdtZW50cyBkYXRhXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICBBcnJheSBvZiBvYmplY3Qgd2l0aCBzZWdtZW50cyBkYXRhXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTm9kZXMgKHNlZ3MpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWcgPSBzZWdzW2ldXG5cbiAgICBzd2l0Y2ggKHNlZy5tb2RlKSB7XG4gICAgICBjYXNlIE1vZGUuTlVNRVJJQzpcbiAgICAgICAgbm9kZXMucHVzaChbc2VnLFxuICAgICAgICAgIHsgZGF0YTogc2VnLmRhdGEsIG1vZGU6IE1vZGUuQUxQSEFOVU1FUklDLCBsZW5ndGg6IHNlZy5sZW5ndGggfSxcbiAgICAgICAgICB7IGRhdGE6IHNlZy5kYXRhLCBtb2RlOiBNb2RlLkJZVEUsIGxlbmd0aDogc2VnLmxlbmd0aCB9XG4gICAgICAgIF0pXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIE1vZGUuQUxQSEFOVU1FUklDOlxuICAgICAgICBub2Rlcy5wdXNoKFtzZWcsXG4gICAgICAgICAgeyBkYXRhOiBzZWcuZGF0YSwgbW9kZTogTW9kZS5CWVRFLCBsZW5ndGg6IHNlZy5sZW5ndGggfVxuICAgICAgICBdKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBNb2RlLktBTkpJOlxuICAgICAgICBub2Rlcy5wdXNoKFtzZWcsXG4gICAgICAgICAgeyBkYXRhOiBzZWcuZGF0YSwgbW9kZTogTW9kZS5CWVRFLCBsZW5ndGg6IGdldFN0cmluZ0J5dGVMZW5ndGgoc2VnLmRhdGEpIH1cbiAgICAgICAgXSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTW9kZS5CWVRFOlxuICAgICAgICBub2Rlcy5wdXNoKFtcbiAgICAgICAgICB7IGRhdGE6IHNlZy5kYXRhLCBtb2RlOiBNb2RlLkJZVEUsIGxlbmd0aDogZ2V0U3RyaW5nQnl0ZUxlbmd0aChzZWcuZGF0YSkgfVxuICAgICAgICBdKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2Rlc1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhIGdyYXBoIGZyb20gYSBsaXN0IG9mIG5vZGVzLlxuICogQWxsIHNlZ21lbnRzIGluIGVhY2ggbm9kZSBncm91cCB3aWxsIGJlIGNvbm5lY3RlZCB3aXRoIGFsbCB0aGUgc2VnbWVudHMgb2ZcbiAqIHRoZSBuZXh0IGdyb3VwIGFuZCBzbyBvbi5cbiAqXG4gKiBBdCBlYWNoIGNvbm5lY3Rpb24gd2lsbCBiZSBhc3NpZ25lZCBhIHdlaWdodCBkZXBlbmRpbmcgb24gdGhlXG4gKiBzZWdtZW50J3MgYnl0ZSBsZW5ndGguXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IG5vZGVzICAgIEFycmF5IG9mIG9iamVjdCB3aXRoIHNlZ21lbnRzIGRhdGFcbiAqIEBwYXJhbSAge051bWJlcn0gdmVyc2lvbiBRUiBDb2RlIHZlcnNpb25cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBHcmFwaCBvZiBhbGwgcG9zc2libGUgc2VnbWVudHNcbiAqL1xuZnVuY3Rpb24gYnVpbGRHcmFwaCAobm9kZXMsIHZlcnNpb24pIHtcbiAgY29uc3QgdGFibGUgPSB7fVxuICBjb25zdCBncmFwaCA9IHsgc3RhcnQ6IHt9IH1cbiAgbGV0IHByZXZOb2RlSWRzID0gWydzdGFydCddXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGVHcm91cCA9IG5vZGVzW2ldXG4gICAgY29uc3QgY3VycmVudE5vZGVJZHMgPSBbXVxuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlR3JvdXAubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2RlR3JvdXBbal1cbiAgICAgIGNvbnN0IGtleSA9ICcnICsgaSArIGpcblxuICAgICAgY3VycmVudE5vZGVJZHMucHVzaChrZXkpXG4gICAgICB0YWJsZVtrZXldID0geyBub2RlOiBub2RlLCBsYXN0Q291bnQ6IDAgfVxuICAgICAgZ3JhcGhba2V5XSA9IHt9XG5cbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgcHJldk5vZGVJZHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgY29uc3QgcHJldk5vZGVJZCA9IHByZXZOb2RlSWRzW25dXG5cbiAgICAgICAgaWYgKHRhYmxlW3ByZXZOb2RlSWRdICYmIHRhYmxlW3ByZXZOb2RlSWRdLm5vZGUubW9kZSA9PT0gbm9kZS5tb2RlKSB7XG4gICAgICAgICAgZ3JhcGhbcHJldk5vZGVJZF1ba2V5XSA9XG4gICAgICAgICAgICBnZXRTZWdtZW50Qml0c0xlbmd0aCh0YWJsZVtwcmV2Tm9kZUlkXS5sYXN0Q291bnQgKyBub2RlLmxlbmd0aCwgbm9kZS5tb2RlKSAtXG4gICAgICAgICAgICBnZXRTZWdtZW50Qml0c0xlbmd0aCh0YWJsZVtwcmV2Tm9kZUlkXS5sYXN0Q291bnQsIG5vZGUubW9kZSlcblxuICAgICAgICAgIHRhYmxlW3ByZXZOb2RlSWRdLmxhc3RDb3VudCArPSBub2RlLmxlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0YWJsZVtwcmV2Tm9kZUlkXSkgdGFibGVbcHJldk5vZGVJZF0ubGFzdENvdW50ID0gbm9kZS5sZW5ndGhcblxuICAgICAgICAgIGdyYXBoW3ByZXZOb2RlSWRdW2tleV0gPSBnZXRTZWdtZW50Qml0c0xlbmd0aChub2RlLmxlbmd0aCwgbm9kZS5tb2RlKSArXG4gICAgICAgICAgICA0ICsgTW9kZS5nZXRDaGFyQ291bnRJbmRpY2F0b3Iobm9kZS5tb2RlLCB2ZXJzaW9uKSAvLyBzd2l0Y2ggY29zdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldk5vZGVJZHMgPSBjdXJyZW50Tm9kZUlkc1xuICB9XG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBwcmV2Tm9kZUlkcy5sZW5ndGg7IG4rKykge1xuICAgIGdyYXBoW3ByZXZOb2RlSWRzW25dXS5lbmQgPSAwXG4gIH1cblxuICByZXR1cm4geyBtYXA6IGdyYXBoLCB0YWJsZTogdGFibGUgfVxufVxuXG4vKipcbiAqIEJ1aWxkcyBhIHNlZ21lbnQgZnJvbSBhIHNwZWNpZmllZCBkYXRhIGFuZCBtb2RlLlxuICogSWYgYSBtb2RlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtb3JlIHN1aXRhYmxlIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgICAgICAgICAgICAgSW5wdXQgZGF0YVxuICogQHBhcmFtICB7TW9kZSB8IFN0cmluZ30gbW9kZXNIaW50IERhdGEgbW9kZVxuICogQHJldHVybiB7U2VnbWVudH0gICAgICAgICAgICAgICAgIFNlZ21lbnRcbiAqL1xuZnVuY3Rpb24gYnVpbGRTaW5nbGVTZWdtZW50IChkYXRhLCBtb2Rlc0hpbnQpIHtcbiAgbGV0IG1vZGVcbiAgY29uc3QgYmVzdE1vZGUgPSBNb2RlLmdldEJlc3RNb2RlRm9yRGF0YShkYXRhKVxuXG4gIG1vZGUgPSBNb2RlLmZyb20obW9kZXNIaW50LCBiZXN0TW9kZSlcblxuICAvLyBNYWtlIHN1cmUgZGF0YSBjYW4gYmUgZW5jb2RlZFxuICBpZiAobW9kZSAhPT0gTW9kZS5CWVRFICYmIG1vZGUuYml0IDwgYmVzdE1vZGUuYml0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBkYXRhICsgJ1wiJyArXG4gICAgICAnIGNhbm5vdCBiZSBlbmNvZGVkIHdpdGggbW9kZSAnICsgTW9kZS50b1N0cmluZyhtb2RlKSArXG4gICAgICAnLlxcbiBTdWdnZXN0ZWQgbW9kZSBpczogJyArIE1vZGUudG9TdHJpbmcoYmVzdE1vZGUpKVxuICB9XG5cbiAgLy8gVXNlIE1vZGUuQllURSBpZiBLYW5qaSBzdXBwb3J0IGlzIGRpc2FibGVkXG4gIGlmIChtb2RlID09PSBNb2RlLktBTkpJICYmICFVdGlscy5pc0thbmppTW9kZUVuYWJsZWQoKSkge1xuICAgIG1vZGUgPSBNb2RlLkJZVEVcbiAgfVxuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgTW9kZS5OVU1FUklDOlxuICAgICAgcmV0dXJuIG5ldyBOdW1lcmljRGF0YShkYXRhKVxuXG4gICAgY2FzZSBNb2RlLkFMUEhBTlVNRVJJQzpcbiAgICAgIHJldHVybiBuZXcgQWxwaGFudW1lcmljRGF0YShkYXRhKVxuXG4gICAgY2FzZSBNb2RlLktBTkpJOlxuICAgICAgcmV0dXJuIG5ldyBLYW5qaURhdGEoZGF0YSlcblxuICAgIGNhc2UgTW9kZS5CWVRFOlxuICAgICAgcmV0dXJuIG5ldyBCeXRlRGF0YShkYXRhKVxuICB9XG59XG5cbi8qKlxuICogQnVpbGRzIGEgbGlzdCBvZiBzZWdtZW50cyBmcm9tIGFuIGFycmF5LlxuICogQXJyYXkgY2FuIGNvbnRhaW4gU3RyaW5ncyBvciBPYmplY3RzIHdpdGggc2VnbWVudCdzIGluZm8uXG4gKlxuICogRm9yIGVhY2ggaXRlbSB3aGljaCBpcyBhIHN0cmluZywgd2lsbCBiZSBnZW5lcmF0ZWQgYSBzZWdtZW50IHdpdGggdGhlIGdpdmVuXG4gKiBzdHJpbmcgYW5kIHRoZSBtb3JlIGFwcHJvcHJpYXRlIGVuY29kaW5nIG1vZGUuXG4gKlxuICogRm9yIGVhY2ggaXRlbSB3aGljaCBpcyBhbiBvYmplY3QsIHdpbGwgYmUgZ2VuZXJhdGVkIGEgc2VnbWVudCB3aXRoIHRoZSBnaXZlblxuICogZGF0YSBhbmQgbW9kZS5cbiAqIE9iamVjdHMgbXVzdCBjb250YWluIGF0IGxlYXN0IHRoZSBwcm9wZXJ0eSBcImRhdGFcIi5cbiAqIElmIHByb3BlcnR5IFwibW9kZVwiIGlzIG5vdCBwcmVzZW50LCB0aGUgbW9yZSBzdWl0YWJsZSBtb2RlIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyYXkgQXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHNlZ21lbnRzIGRhdGFcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICBBcnJheSBvZiBTZWdtZW50c1xuICovXG5leHBvcnRzLmZyb21BcnJheSA9IGZ1bmN0aW9uIGZyb21BcnJheSAoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAoYWNjLCBzZWcpIHtcbiAgICBpZiAodHlwZW9mIHNlZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFjYy5wdXNoKGJ1aWxkU2luZ2xlU2VnbWVudChzZWcsIG51bGwpKVxuICAgIH0gZWxzZSBpZiAoc2VnLmRhdGEpIHtcbiAgICAgIGFjYy5wdXNoKGJ1aWxkU2luZ2xlU2VnbWVudChzZWcuZGF0YSwgc2VnLm1vZGUpKVxuICAgIH1cblxuICAgIHJldHVybiBhY2NcbiAgfSwgW10pXG59XG5cbi8qKlxuICogQnVpbGRzIGFuIG9wdGltaXplZCBzZXF1ZW5jZSBvZiBzZWdtZW50cyBmcm9tIGEgc3RyaW5nLFxuICogd2hpY2ggd2lsbCBwcm9kdWNlIHRoZSBzaG9ydGVzdCBwb3NzaWJsZSBiaXRzdHJlYW0uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBkYXRhICAgIElucHV0IHN0cmluZ1xuICogQHBhcmFtICB7TnVtYmVyfSB2ZXJzaW9uIFFSIENvZGUgdmVyc2lvblxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgIEFycmF5IG9mIHNlZ21lbnRzXG4gKi9cbmV4cG9ydHMuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcgKGRhdGEsIHZlcnNpb24pIHtcbiAgY29uc3Qgc2VncyA9IGdldFNlZ21lbnRzRnJvbVN0cmluZyhkYXRhLCBVdGlscy5pc0thbmppTW9kZUVuYWJsZWQoKSlcblxuICBjb25zdCBub2RlcyA9IGJ1aWxkTm9kZXMoc2VncylcbiAgY29uc3QgZ3JhcGggPSBidWlsZEdyYXBoKG5vZGVzLCB2ZXJzaW9uKVxuICBjb25zdCBwYXRoID0gZGlqa3N0cmEuZmluZF9wYXRoKGdyYXBoLm1hcCwgJ3N0YXJ0JywgJ2VuZCcpXG5cbiAgY29uc3Qgb3B0aW1pemVkU2VncyA9IFtdXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBvcHRpbWl6ZWRTZWdzLnB1c2goZ3JhcGgudGFibGVbcGF0aFtpXV0ubm9kZSlcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmZyb21BcnJheShtZXJnZVNlZ21lbnRzKG9wdGltaXplZFNlZ3MpKVxufVxuXG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbiB2YXJpb3VzIHNlZ21lbnRzIHdpdGggdGhlIG1vZGVzIHdoaWNoXG4gKiBiZXN0IHJlcHJlc2VudCB0aGVpciBjb250ZW50LlxuICogVGhlIHByb2R1Y2VkIHNlZ21lbnRzIGFyZSBmYXIgZnJvbSBiZWluZyBvcHRpbWl6ZWQuXG4gKiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIHRvIGVzdGltYXRlIGEgUVIgQ29kZSB2ZXJzaW9uXG4gKiB3aGljaCBtYXkgY29udGFpbiB0aGUgZGF0YS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGRhdGEgSW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQXJyYXkgb2Ygc2VnbWVudHNcbiAqL1xuZXhwb3J0cy5yYXdTcGxpdCA9IGZ1bmN0aW9uIHJhd1NwbGl0IChkYXRhKSB7XG4gIHJldHVybiBleHBvcnRzLmZyb21BcnJheShcbiAgICBnZXRTZWdtZW50c0Zyb21TdHJpbmcoZGF0YSwgVXRpbHMuaXNLYW5qaU1vZGVFbmFibGVkKCkpXG4gIClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9801\n\n}")},9825:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n// Copyright (c) 2024 The Bitcoin developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.P2PKSignatory = exports.P2PKHSignatory = exports.signWithSigHash = exports.flagSignature = exports.calcTxFee = exports.TxBuilder = void 0;\nconst ecc_js_1 = __webpack_require__(3799);\nconst hash_js_1 = __webpack_require__(5632);\nconst writerbytes_js_1 = __webpack_require__(8161);\nconst op_js_1 = __webpack_require__(243);\nconst script_js_1 = __webpack_require__(6187);\nconst sigHashType_js_1 = __webpack_require__(1659);\nconst tx_js_1 = __webpack_require__(932);\nconst unsignedTx_js_1 = __webpack_require__(7151);\n/** Class that can be used to build and sign txs. */\nclass TxBuilder {\n    constructor(params) {\n        this.version = params?.version ?? tx_js_1.DEFAULT_TX_VERSION;\n        this.inputs = params?.inputs ?? [];\n        this.outputs = params?.outputs ?? [];\n        this.locktime = params?.locktime ?? 0;\n    }\n    /** Calculte sum of all sats coming in, or `undefined` if some unknown. */\n    inputSum() {\n        let inputSum = 0n;\n        for (const input of this.inputs) {\n            if (input.input.signData === undefined) {\n                return undefined;\n            }\n            inputSum += BigInt(input.input.signData.sats);\n        }\n        return inputSum;\n    }\n    prepareOutputs() {\n        let fixedOutputSum = 0n;\n        let leftoverIdx = undefined;\n        const outputs = new Array(this.outputs.length);\n        for (let idx = 0; idx < this.outputs.length; ++idx) {\n            const builderOutput = this.outputs[idx];\n            if ('bytecode' in builderOutput) {\n                // If builderOutput instanceof Script\n                // Note that the \"builderOutput instanceof Script\" check may fail due\n                // to discrepancies between nodejs and browser environments\n                if (leftoverIdx !== undefined) {\n                    throw 'Multiple leftover outputs, can at most use one';\n                }\n                leftoverIdx = idx;\n                outputs[idx] = {\n                    sats: 0n, // placeholder\n                    script: builderOutput.copy(),\n                };\n            }\n            else {\n                fixedOutputSum += BigInt(builderOutput.sats);\n                outputs[idx] = (0, tx_js_1.copyTxOutput)(builderOutput);\n            }\n        }\n        return { fixedOutputSum, leftoverIdx, outputs };\n    }\n    /** Sign the tx built by this builder and return a Tx */\n    sign(params) {\n        const ecc = params?.ecc ?? new ecc_js_1.Ecc();\n        const { fixedOutputSum, leftoverIdx, outputs } = this.prepareOutputs();\n        const inputs = this.inputs.map(input => (0, tx_js_1.copyTxInput)(input.input));\n        const updateSignatories = (ecc, unsignedTx) => {\n            for (let idx = 0; idx < this.inputs.length; ++idx) {\n                const signatory = this.inputs[idx].signatory;\n                const input = inputs[idx];\n                if (signatory !== undefined) {\n                    input.script = signatory(ecc, new unsignedTx_js_1.UnsignedTxInput({\n                        inputIdx: idx,\n                        unsignedTx,\n                    }));\n                }\n            }\n        };\n        if (leftoverIdx !== undefined) {\n            const inputSum = this.inputSum();\n            if (inputSum === undefined) {\n                throw new Error('Using a leftover output requires setting SignData.sats for all inputs');\n            }\n            if (params?.feePerKb === undefined) {\n                throw new Error('Using a leftover output requires setting feePerKb');\n            }\n            if (typeof params.feePerKb !== 'bigint') {\n                throw new Error('feePerKb must be a bigint');\n            }\n            if (params?.dustSats === undefined) {\n                throw new Error('Using a leftover output requires setting dustSats');\n            }\n            const dummyUnsignedTx = unsignedTx_js_1.UnsignedTx.dummyFromTx(new tx_js_1.Tx({\n                version: this.version,\n                inputs,\n                outputs,\n                locktime: this.locktime,\n            }));\n            // Must use dummy here because ECDSA sigs could be too small for fee calc\n            updateSignatories(new ecc_js_1.EccDummy(), dummyUnsignedTx);\n            let txSize = dummyUnsignedTx.tx.serSize();\n            let txFee = calcTxFee(txSize, params.feePerKb);\n            const leftoverSats = inputSum - (fixedOutputSum + txFee);\n            if (leftoverSats < params.dustSats) {\n                // inputs cannot pay for a dust leftover -> remove & recalc\n                outputs.splice(leftoverIdx, 1);\n                dummyUnsignedTx.tx.outputs = outputs;\n                // Must update signatories again as they might depend on outputs\n                updateSignatories(new ecc_js_1.EccDummy(), dummyUnsignedTx);\n                txSize = dummyUnsignedTx.tx.serSize();\n                txFee = calcTxFee(txSize, params.feePerKb);\n            }\n            else {\n                outputs[leftoverIdx].sats = leftoverSats;\n            }\n            if (inputSum < fixedOutputSum + txFee) {\n                throw new Error(`Insufficient input sats (${inputSum}): Can only pay for ${inputSum - fixedOutputSum} fees, but ${txFee} required`);\n            }\n        }\n        const unsignedTx = unsignedTx_js_1.UnsignedTx.fromTx(new tx_js_1.Tx({\n            version: this.version,\n            inputs,\n            outputs,\n            locktime: this.locktime,\n        }));\n        updateSignatories(ecc, unsignedTx);\n        return unsignedTx.tx;\n    }\n}\nexports.TxBuilder = TxBuilder;\n/** Calculate the required tx fee for the given txSize and feePerKb,\n *  rounding up */\nfunction calcTxFee(txSize, feePerKb) {\n    return (BigInt(txSize) * BigInt(feePerKb) + 999n) / 1000n;\n}\nexports.calcTxFee = calcTxFee;\n/** Append the sighash flags to the signature */\nfunction flagSignature(sig, sigHashFlags) {\n    const writer = new writerbytes_js_1.WriterBytes(sig.length + 1);\n    writer.putBytes(sig);\n    writer.putU8(sigHashFlags.toInt() & 0xff);\n    return writer.data;\n}\nexports.flagSignature = flagSignature;\n/**\n * Sign the sighash using Schnorr for BIP143 signatures and ECDSA for Legacy\n * signatures, and then flags the signature correctly\n **/\nfunction signWithSigHash(ecc, sk, sigHash, sigHashType) {\n    const sig = sigHashType.variant == sigHashType_js_1.SigHashTypeVariant.LEGACY\n        ? ecc.ecdsaSign(sk, sigHash)\n        : ecc.schnorrSign(sk, sigHash);\n    return flagSignature(sig, sigHashType);\n}\nexports.signWithSigHash = signWithSigHash;\n/** Signatory for a P2PKH input. Always uses Schnorr signatures */\nconst P2PKHSignatory = (sk, pk, sigHashType) => {\n    return (ecc, input) => {\n        const preimage = input.sigHashPreimage(sigHashType);\n        const sighash = (0, hash_js_1.sha256d)(preimage.bytes);\n        const sigFlagged = signWithSigHash(ecc, sk, sighash, sigHashType);\n        return script_js_1.Script.p2pkhSpend(pk, sigFlagged);\n    };\n};\nexports.P2PKHSignatory = P2PKHSignatory;\n/** Signatory for a P2PK input. Always uses Schnorr signatures */\nconst P2PKSignatory = (sk, sigHashType) => {\n    return (ecc, input) => {\n        const preimage = input.sigHashPreimage(sigHashType);\n        const sighash = (0, hash_js_1.sha256d)(preimage.bytes);\n        const sigFlagged = signWithSigHash(ecc, sk, sighash, sigHashType);\n        return script_js_1.Script.fromOps([(0, op_js_1.pushBytesOp)(sigFlagged)]);\n    };\n};\nexports.P2PKSignatory = P2PKSignatory;\n//# sourceMappingURL=txBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgyNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDeEksaUJBQWlCLG1CQUFPLENBQUMsSUFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxJQUFXO0FBQ3JDLHlCQUF5QixtQkFBTyxDQUFDLElBQXFCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLEdBQVM7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsSUFBYTtBQUN6Qyx5QkFBeUIsbUJBQU8sQ0FBQyxJQUFrQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLElBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFNBQVMsc0JBQXNCLDJCQUEyQixZQUFZLE9BQU87QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9lY2FzaC1saWIvZGlzdC90eEJ1aWxkZXIuanM/MTgzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgMjAyNCBUaGUgQml0Y29pbiBkZXZlbG9wZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIENPUFlJTkcgb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlAyUEtTaWduYXRvcnkgPSBleHBvcnRzLlAyUEtIU2lnbmF0b3J5ID0gZXhwb3J0cy5zaWduV2l0aFNpZ0hhc2ggPSBleHBvcnRzLmZsYWdTaWduYXR1cmUgPSBleHBvcnRzLmNhbGNUeEZlZSA9IGV4cG9ydHMuVHhCdWlsZGVyID0gdm9pZCAwO1xuY29uc3QgZWNjX2pzXzEgPSByZXF1aXJlKFwiLi9lY2MuanNcIik7XG5jb25zdCBoYXNoX2pzXzEgPSByZXF1aXJlKFwiLi9oYXNoLmpzXCIpO1xuY29uc3Qgd3JpdGVyYnl0ZXNfanNfMSA9IHJlcXVpcmUoXCIuL2lvL3dyaXRlcmJ5dGVzLmpzXCIpO1xuY29uc3Qgb3BfanNfMSA9IHJlcXVpcmUoXCIuL29wLmpzXCIpO1xuY29uc3Qgc2NyaXB0X2pzXzEgPSByZXF1aXJlKFwiLi9zY3JpcHQuanNcIik7XG5jb25zdCBzaWdIYXNoVHlwZV9qc18xID0gcmVxdWlyZShcIi4vc2lnSGFzaFR5cGUuanNcIik7XG5jb25zdCB0eF9qc18xID0gcmVxdWlyZShcIi4vdHguanNcIik7XG5jb25zdCB1bnNpZ25lZFR4X2pzXzEgPSByZXF1aXJlKFwiLi91bnNpZ25lZFR4LmpzXCIpO1xuLyoqIENsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gYnVpbGQgYW5kIHNpZ24gdHhzLiAqL1xuY2xhc3MgVHhCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gcGFyYW1zPy52ZXJzaW9uID8/IHR4X2pzXzEuREVGQVVMVF9UWF9WRVJTSU9OO1xuICAgICAgICB0aGlzLmlucHV0cyA9IHBhcmFtcz8uaW5wdXRzID8/IFtdO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBwYXJhbXM/Lm91dHB1dHMgPz8gW107XG4gICAgICAgIHRoaXMubG9ja3RpbWUgPSBwYXJhbXM/LmxvY2t0aW1lID8/IDA7XG4gICAgfVxuICAgIC8qKiBDYWxjdWx0ZSBzdW0gb2YgYWxsIHNhdHMgY29taW5nIGluLCBvciBgdW5kZWZpbmVkYCBpZiBzb21lIHVua25vd24uICovXG4gICAgaW5wdXRTdW0oKSB7XG4gICAgICAgIGxldCBpbnB1dFN1bSA9IDBuO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHRoaXMuaW5wdXRzKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaW5wdXQuc2lnbkRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFN1bSArPSBCaWdJbnQoaW5wdXQuaW5wdXQuc2lnbkRhdGEuc2F0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0U3VtO1xuICAgIH1cbiAgICBwcmVwYXJlT3V0cHV0cygpIHtcbiAgICAgICAgbGV0IGZpeGVkT3V0cHV0U3VtID0gMG47XG4gICAgICAgIGxldCBsZWZ0b3ZlcklkeCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IG5ldyBBcnJheSh0aGlzLm91dHB1dHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1aWxkZXJPdXRwdXQgPSB0aGlzLm91dHB1dHNbaWR4XTtcbiAgICAgICAgICAgIGlmICgnYnl0ZWNvZGUnIGluIGJ1aWxkZXJPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBidWlsZGVyT3V0cHV0IGluc3RhbmNlb2YgU2NyaXB0XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBcImJ1aWxkZXJPdXRwdXQgaW5zdGFuY2VvZiBTY3JpcHRcIiBjaGVjayBtYXkgZmFpbCBkdWVcbiAgICAgICAgICAgICAgICAvLyB0byBkaXNjcmVwYW5jaWVzIGJldHdlZW4gbm9kZWpzIGFuZCBicm93c2VyIGVudmlyb25tZW50c1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0b3ZlcklkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdNdWx0aXBsZSBsZWZ0b3ZlciBvdXRwdXRzLCBjYW4gYXQgbW9zdCB1c2Ugb25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdG92ZXJJZHggPSBpZHg7XG4gICAgICAgICAgICAgICAgb3V0cHV0c1tpZHhdID0ge1xuICAgICAgICAgICAgICAgICAgICBzYXRzOiAwbiwgLy8gcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0OiBidWlsZGVyT3V0cHV0LmNvcHkoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZml4ZWRPdXRwdXRTdW0gKz0gQmlnSW50KGJ1aWxkZXJPdXRwdXQuc2F0cyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0c1tpZHhdID0gKDAsIHR4X2pzXzEuY29weVR4T3V0cHV0KShidWlsZGVyT3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaXhlZE91dHB1dFN1bSwgbGVmdG92ZXJJZHgsIG91dHB1dHMgfTtcbiAgICB9XG4gICAgLyoqIFNpZ24gdGhlIHR4IGJ1aWx0IGJ5IHRoaXMgYnVpbGRlciBhbmQgcmV0dXJuIGEgVHggKi9cbiAgICBzaWduKHBhcmFtcykge1xuICAgICAgICBjb25zdCBlY2MgPSBwYXJhbXM/LmVjYyA/PyBuZXcgZWNjX2pzXzEuRWNjKCk7XG4gICAgICAgIGNvbnN0IHsgZml4ZWRPdXRwdXRTdW0sIGxlZnRvdmVySWR4LCBvdXRwdXRzIH0gPSB0aGlzLnByZXBhcmVPdXRwdXRzKCk7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IHRoaXMuaW5wdXRzLm1hcChpbnB1dCA9PiAoMCwgdHhfanNfMS5jb3B5VHhJbnB1dCkoaW5wdXQuaW5wdXQpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlU2lnbmF0b3JpZXMgPSAoZWNjLCB1bnNpZ25lZFR4KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0b3J5ID0gdGhpcy5pbnB1dHNbaWR4XS5zaWduYXRvcnk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dHNbaWR4XTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmF0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2NyaXB0ID0gc2lnbmF0b3J5KGVjYywgbmV3IHVuc2lnbmVkVHhfanNfMS5VbnNpZ25lZFR4SW5wdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRJZHg6IGlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc2lnbmVkVHgsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChsZWZ0b3ZlcklkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFN1bSA9IHRoaXMuaW5wdXRTdW0oKTtcbiAgICAgICAgICAgIGlmIChpbnB1dFN1bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2luZyBhIGxlZnRvdmVyIG91dHB1dCByZXF1aXJlcyBzZXR0aW5nIFNpZ25EYXRhLnNhdHMgZm9yIGFsbCBpbnB1dHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXM/LmZlZVBlcktiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIGEgbGVmdG92ZXIgb3V0cHV0IHJlcXVpcmVzIHNldHRpbmcgZmVlUGVyS2InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zLmZlZVBlcktiICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmVlUGVyS2IgbXVzdCBiZSBhIGJpZ2ludCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcz8uZHVzdFNhdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNpbmcgYSBsZWZ0b3ZlciBvdXRwdXQgcmVxdWlyZXMgc2V0dGluZyBkdXN0U2F0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHVtbXlVbnNpZ25lZFR4ID0gdW5zaWduZWRUeF9qc18xLlVuc2lnbmVkVHguZHVtbXlGcm9tVHgobmV3IHR4X2pzXzEuVHgoe1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgICAgICAgICBsb2NrdGltZTogdGhpcy5sb2NrdGltZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIE11c3QgdXNlIGR1bW15IGhlcmUgYmVjYXVzZSBFQ0RTQSBzaWdzIGNvdWxkIGJlIHRvbyBzbWFsbCBmb3IgZmVlIGNhbGNcbiAgICAgICAgICAgIHVwZGF0ZVNpZ25hdG9yaWVzKG5ldyBlY2NfanNfMS5FY2NEdW1teSgpLCBkdW1teVVuc2lnbmVkVHgpO1xuICAgICAgICAgICAgbGV0IHR4U2l6ZSA9IGR1bW15VW5zaWduZWRUeC50eC5zZXJTaXplKCk7XG4gICAgICAgICAgICBsZXQgdHhGZWUgPSBjYWxjVHhGZWUodHhTaXplLCBwYXJhbXMuZmVlUGVyS2IpO1xuICAgICAgICAgICAgY29uc3QgbGVmdG92ZXJTYXRzID0gaW5wdXRTdW0gLSAoZml4ZWRPdXRwdXRTdW0gKyB0eEZlZSk7XG4gICAgICAgICAgICBpZiAobGVmdG92ZXJTYXRzIDwgcGFyYW1zLmR1c3RTYXRzKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5wdXRzIGNhbm5vdCBwYXkgZm9yIGEgZHVzdCBsZWZ0b3ZlciAtPiByZW1vdmUgJiByZWNhbGNcbiAgICAgICAgICAgICAgICBvdXRwdXRzLnNwbGljZShsZWZ0b3ZlcklkeCwgMSk7XG4gICAgICAgICAgICAgICAgZHVtbXlVbnNpZ25lZFR4LnR4Lm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICAgICAgICAgIC8vIE11c3QgdXBkYXRlIHNpZ25hdG9yaWVzIGFnYWluIGFzIHRoZXkgbWlnaHQgZGVwZW5kIG9uIG91dHB1dHNcbiAgICAgICAgICAgICAgICB1cGRhdGVTaWduYXRvcmllcyhuZXcgZWNjX2pzXzEuRWNjRHVtbXkoKSwgZHVtbXlVbnNpZ25lZFR4KTtcbiAgICAgICAgICAgICAgICB0eFNpemUgPSBkdW1teVVuc2lnbmVkVHgudHguc2VyU2l6ZSgpO1xuICAgICAgICAgICAgICAgIHR4RmVlID0gY2FsY1R4RmVlKHR4U2l6ZSwgcGFyYW1zLmZlZVBlcktiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dHNbbGVmdG92ZXJJZHhdLnNhdHMgPSBsZWZ0b3ZlclNhdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5wdXRTdW0gPCBmaXhlZE91dHB1dFN1bSArIHR4RmVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgaW5wdXQgc2F0cyAoJHtpbnB1dFN1bX0pOiBDYW4gb25seSBwYXkgZm9yICR7aW5wdXRTdW0gLSBmaXhlZE91dHB1dFN1bX0gZmVlcywgYnV0ICR7dHhGZWV9IHJlcXVpcmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5zaWduZWRUeCA9IHVuc2lnbmVkVHhfanNfMS5VbnNpZ25lZFR4LmZyb21UeChuZXcgdHhfanNfMS5UeCh7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgICAgbG9ja3RpbWU6IHRoaXMubG9ja3RpbWUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgdXBkYXRlU2lnbmF0b3JpZXMoZWNjLCB1bnNpZ25lZFR4KTtcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkVHgudHg7XG4gICAgfVxufVxuZXhwb3J0cy5UeEJ1aWxkZXIgPSBUeEJ1aWxkZXI7XG4vKiogQ2FsY3VsYXRlIHRoZSByZXF1aXJlZCB0eCBmZWUgZm9yIHRoZSBnaXZlbiB0eFNpemUgYW5kIGZlZVBlcktiLFxuICogIHJvdW5kaW5nIHVwICovXG5mdW5jdGlvbiBjYWxjVHhGZWUodHhTaXplLCBmZWVQZXJLYikge1xuICAgIHJldHVybiAoQmlnSW50KHR4U2l6ZSkgKiBCaWdJbnQoZmVlUGVyS2IpICsgOTk5bikgLyAxMDAwbjtcbn1cbmV4cG9ydHMuY2FsY1R4RmVlID0gY2FsY1R4RmVlO1xuLyoqIEFwcGVuZCB0aGUgc2lnaGFzaCBmbGFncyB0byB0aGUgc2lnbmF0dXJlICovXG5mdW5jdGlvbiBmbGFnU2lnbmF0dXJlKHNpZywgc2lnSGFzaEZsYWdzKSB7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IHdyaXRlcmJ5dGVzX2pzXzEuV3JpdGVyQnl0ZXMoc2lnLmxlbmd0aCArIDEpO1xuICAgIHdyaXRlci5wdXRCeXRlcyhzaWcpO1xuICAgIHdyaXRlci5wdXRVOChzaWdIYXNoRmxhZ3MudG9JbnQoKSAmIDB4ZmYpO1xuICAgIHJldHVybiB3cml0ZXIuZGF0YTtcbn1cbmV4cG9ydHMuZmxhZ1NpZ25hdHVyZSA9IGZsYWdTaWduYXR1cmU7XG4vKipcbiAqIFNpZ24gdGhlIHNpZ2hhc2ggdXNpbmcgU2Nobm9yciBmb3IgQklQMTQzIHNpZ25hdHVyZXMgYW5kIEVDRFNBIGZvciBMZWdhY3lcbiAqIHNpZ25hdHVyZXMsIGFuZCB0aGVuIGZsYWdzIHRoZSBzaWduYXR1cmUgY29ycmVjdGx5XG4gKiovXG5mdW5jdGlvbiBzaWduV2l0aFNpZ0hhc2goZWNjLCBzaywgc2lnSGFzaCwgc2lnSGFzaFR5cGUpIHtcbiAgICBjb25zdCBzaWcgPSBzaWdIYXNoVHlwZS52YXJpYW50ID09IHNpZ0hhc2hUeXBlX2pzXzEuU2lnSGFzaFR5cGVWYXJpYW50LkxFR0FDWVxuICAgICAgICA/IGVjYy5lY2RzYVNpZ24oc2ssIHNpZ0hhc2gpXG4gICAgICAgIDogZWNjLnNjaG5vcnJTaWduKHNrLCBzaWdIYXNoKTtcbiAgICByZXR1cm4gZmxhZ1NpZ25hdHVyZShzaWcsIHNpZ0hhc2hUeXBlKTtcbn1cbmV4cG9ydHMuc2lnbldpdGhTaWdIYXNoID0gc2lnbldpdGhTaWdIYXNoO1xuLyoqIFNpZ25hdG9yeSBmb3IgYSBQMlBLSCBpbnB1dC4gQWx3YXlzIHVzZXMgU2Nobm9yciBzaWduYXR1cmVzICovXG5jb25zdCBQMlBLSFNpZ25hdG9yeSA9IChzaywgcGssIHNpZ0hhc2hUeXBlKSA9PiB7XG4gICAgcmV0dXJuIChlY2MsIGlucHV0KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZWltYWdlID0gaW5wdXQuc2lnSGFzaFByZWltYWdlKHNpZ0hhc2hUeXBlKTtcbiAgICAgICAgY29uc3Qgc2lnaGFzaCA9ICgwLCBoYXNoX2pzXzEuc2hhMjU2ZCkocHJlaW1hZ2UuYnl0ZXMpO1xuICAgICAgICBjb25zdCBzaWdGbGFnZ2VkID0gc2lnbldpdGhTaWdIYXNoKGVjYywgc2ssIHNpZ2hhc2gsIHNpZ0hhc2hUeXBlKTtcbiAgICAgICAgcmV0dXJuIHNjcmlwdF9qc18xLlNjcmlwdC5wMnBraFNwZW5kKHBrLCBzaWdGbGFnZ2VkKTtcbiAgICB9O1xufTtcbmV4cG9ydHMuUDJQS0hTaWduYXRvcnkgPSBQMlBLSFNpZ25hdG9yeTtcbi8qKiBTaWduYXRvcnkgZm9yIGEgUDJQSyBpbnB1dC4gQWx3YXlzIHVzZXMgU2Nobm9yciBzaWduYXR1cmVzICovXG5jb25zdCBQMlBLU2lnbmF0b3J5ID0gKHNrLCBzaWdIYXNoVHlwZSkgPT4ge1xuICAgIHJldHVybiAoZWNjLCBpbnB1dCkgPT4ge1xuICAgICAgICBjb25zdCBwcmVpbWFnZSA9IGlucHV0LnNpZ0hhc2hQcmVpbWFnZShzaWdIYXNoVHlwZSk7XG4gICAgICAgIGNvbnN0IHNpZ2hhc2ggPSAoMCwgaGFzaF9qc18xLnNoYTI1NmQpKHByZWltYWdlLmJ5dGVzKTtcbiAgICAgICAgY29uc3Qgc2lnRmxhZ2dlZCA9IHNpZ25XaXRoU2lnSGFzaChlY2MsIHNrLCBzaWdoYXNoLCBzaWdIYXNoVHlwZSk7XG4gICAgICAgIHJldHVybiBzY3JpcHRfanNfMS5TY3JpcHQuZnJvbU9wcyhbKDAsIG9wX2pzXzEucHVzaEJ5dGVzT3ApKHNpZ0ZsYWdnZWQpXSk7XG4gICAgfTtcbn07XG5leHBvcnRzLlAyUEtTaWduYXRvcnkgPSBQMlBLU2lnbmF0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHhCdWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9825\n\n}")},9899:module=>{eval("{function BitBuffer () {\n  this.buffer = []\n  this.length = 0\n}\n\nBitBuffer.prototype = {\n\n  get: function (index) {\n    const bufIndex = Math.floor(index / 8)\n    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1\n  },\n\n  put: function (num, length) {\n    for (let i = 0; i < length; i++) {\n      this.putBit(((num >>> (length - i - 1)) & 1) === 1)\n    }\n  },\n\n  getLengthInBits: function () {\n    return this.length\n  },\n\n  putBit: function (bit) {\n    const bufIndex = Math.floor(this.length / 8)\n    if (this.buffer.length <= bufIndex) {\n      this.buffer.push(0)\n    }\n\n    if (bit) {\n      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8))\n    }\n\n    this.length++\n  }\n}\n\nmodule.exports = BitBuffer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg5OS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2NvcmUvYml0LWJ1ZmZlci5qcz83YmEwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIEJpdEJ1ZmZlciAoKSB7XG4gIHRoaXMuYnVmZmVyID0gW11cbiAgdGhpcy5sZW5ndGggPSAwXG59XG5cbkJpdEJ1ZmZlci5wcm90b3R5cGUgPSB7XG5cbiAgZ2V0OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBjb25zdCBidWZJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyA4KVxuICAgIHJldHVybiAoKHRoaXMuYnVmZmVyW2J1ZkluZGV4XSA+Pj4gKDcgLSBpbmRleCAlIDgpKSAmIDEpID09PSAxXG4gIH0sXG5cbiAgcHV0OiBmdW5jdGlvbiAobnVtLCBsZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnB1dEJpdCgoKG51bSA+Pj4gKGxlbmd0aCAtIGkgLSAxKSkgJiAxKSA9PT0gMSlcbiAgICB9XG4gIH0sXG5cbiAgZ2V0TGVuZ3RoSW5CaXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoXG4gIH0sXG5cbiAgcHV0Qml0OiBmdW5jdGlvbiAoYml0KSB7XG4gICAgY29uc3QgYnVmSW5kZXggPSBNYXRoLmZsb29yKHRoaXMubGVuZ3RoIC8gOClcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDw9IGJ1ZkluZGV4KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKDApXG4gICAgfVxuXG4gICAgaWYgKGJpdCkge1xuICAgICAgdGhpcy5idWZmZXJbYnVmSW5kZXhdIHw9ICgweDgwID4+PiAodGhpcy5sZW5ndGggJSA4KSlcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCsrXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCaXRCdWZmZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9899\n\n}")},9953:(__unused_webpack_module,exports)=>{eval("{exports.L = { bit: 1 }\nexports.M = { bit: 0 }\nexports.Q = { bit: 3 }\nexports.H = { bit: 2 }\n\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'l':\n    case 'low':\n      return exports.L\n\n    case 'm':\n    case 'medium':\n      return exports.M\n\n    case 'q':\n    case 'quartile':\n      return exports.Q\n\n    case 'h':\n    case 'high':\n      return exports.H\n\n    default:\n      throw new Error('Unknown EC Level: ' + string)\n  }\n}\n\nexports.isValid = function isValid (level) {\n  return level && typeof level.bit !== 'undefined' &&\n    level.bit >= 0 && level.bit < 4\n}\n\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTk1My5qcyIsIm1hcHBpbmdzIjoiQUFBQSxTQUFTLEtBQUs7QUFDZCxTQUFTLEtBQUs7QUFDZCxTQUFTLEtBQUs7QUFDZCxTQUFTLEtBQUs7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNhc2gtd2FsbGV0LXdlYi8uL25vZGVfbW9kdWxlcy9xcmNvZGUvbGliL2NvcmUvZXJyb3ItY29ycmVjdGlvbi1sZXZlbC5qcz83YTQzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuTCA9IHsgYml0OiAxIH1cbmV4cG9ydHMuTSA9IHsgYml0OiAwIH1cbmV4cG9ydHMuUSA9IHsgYml0OiAzIH1cbmV4cG9ydHMuSCA9IHsgYml0OiAyIH1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyYW0gaXMgbm90IGEgc3RyaW5nJylcbiAgfVxuXG4gIGNvbnN0IGxjU3RyID0gc3RyaW5nLnRvTG93ZXJDYXNlKClcblxuICBzd2l0Y2ggKGxjU3RyKSB7XG4gICAgY2FzZSAnbCc6XG4gICAgY2FzZSAnbG93JzpcbiAgICAgIHJldHVybiBleHBvcnRzLkxcblxuICAgIGNhc2UgJ20nOlxuICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICByZXR1cm4gZXhwb3J0cy5NXG5cbiAgICBjYXNlICdxJzpcbiAgICBjYXNlICdxdWFydGlsZSc6XG4gICAgICByZXR1cm4gZXhwb3J0cy5RXG5cbiAgICBjYXNlICdoJzpcbiAgICBjYXNlICdoaWdoJzpcbiAgICAgIHJldHVybiBleHBvcnRzLkhcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gRUMgTGV2ZWw6ICcgKyBzdHJpbmcpXG4gIH1cbn1cblxuZXhwb3J0cy5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAobGV2ZWwpIHtcbiAgcmV0dXJuIGxldmVsICYmIHR5cGVvZiBsZXZlbC5iaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgbGV2ZWwuYml0ID49IDAgJiYgbGV2ZWwuYml0IDwgNFxufVxuXG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChleHBvcnRzLmlzVmFsaWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9953\n\n}")}},__webpack_module_cache__={},inProgress,dataWebpackPrefix;function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var n=__webpack_module_cache__[g]={id:g,exports:{}};return __webpack_modules__[g].call(n.exports,n,n.exports,__webpack_require__),n.exports}__webpack_require__.m=__webpack_modules__,__webpack_require__.n=g=>{var I=g&&g.__esModule?()=>g.default:()=>g;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(g,I)=>{for(var n in I)__webpack_require__.o(I,n)&&!__webpack_require__.o(g,n)&&Object.defineProperty(g,n,{enumerable:!0,get:I[n]})},__webpack_require__.f={},__webpack_require__.e=g=>Promise.all(Object.keys(__webpack_require__.f).reduce((I,n)=>(__webpack_require__.f[n](g,I),I),[])),__webpack_require__.u=g=>g+".bundle.js",__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}(),__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),inProgress={},dataWebpackPrefix="ecash-wallet-web:",__webpack_require__.l=(g,I,n,A)=>{if(inProgress[g])inProgress[g].push(I);else{var B,Q;if(void 0!==n)for(var C=document.getElementsByTagName("script"),t=0;t<C.length;t++){var e=C[t];if(e.getAttribute("src")==g||e.getAttribute("data-webpack")==dataWebpackPrefix+n){B=e;break}}B||(Q=!0,(B=document.createElement("script")).charset="utf-8",B.timeout=120,__webpack_require__.nc&&B.setAttribute("nonce",__webpack_require__.nc),B.setAttribute("data-webpack",dataWebpackPrefix+n),B.src=g),inProgress[g]=[I];var c=(I,n)=>{B.onerror=B.onload=null,clearTimeout(l);var A=inProgress[g];if(delete inProgress[g],B.parentNode&&B.parentNode.removeChild(B),A&&A.forEach(g=>g(n)),I)return I(n)},l=setTimeout(c.bind(null,void 0,{type:"timeout",target:B}),12e4);B.onerror=c.bind(null,B.onerror),B.onload=c.bind(null,B.onload),Q&&document.head.appendChild(B)}},__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},(()=>{var g;__webpack_require__.g.importScripts&&(g=__webpack_require__.g.location+"");var I=__webpack_require__.g.document;if(!g&&I&&(I.currentScript&&"SCRIPT"===I.currentScript.tagName.toUpperCase()&&(g=I.currentScript.src),!g)){var n=I.getElementsByTagName("script");if(n.length)for(var A=n.length-1;A>-1&&(!g||!/^http(s?):/.test(g));)g=n[A--].src}if(!g)throw new Error("Automatic publicPath is not supported in this browser");g=g.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=g})(),(()=>{__webpack_require__.b=document.baseURI||self.location.href;var g={792:0};__webpack_require__.f.j=(I,n)=>{var A=__webpack_require__.o(g,I)?g[I]:void 0;if(0!==A)if(A)n.push(A[2]);else{var B=new Promise((n,B)=>A=g[I]=[n,B]);n.push(A[2]=B);var Q=__webpack_require__.p+__webpack_require__.u(I),C=new Error;__webpack_require__.l(Q,n=>{if(__webpack_require__.o(g,I)&&(0!==(A=g[I])&&(g[I]=void 0),A)){var B=n&&("load"===n.type?"missing":n.type),Q=n&&n.target&&n.target.src;C.message="Loading chunk "+I+" failed.\n("+B+": "+Q+")",C.name="ChunkLoadError",C.type=B,C.request=Q,A[1](C)}},"chunk-"+I,I)}};var I=(I,n)=>{var A,B,[Q,C,t]=n,e=0;if(Q.some(I=>0!==g[I])){for(A in C)__webpack_require__.o(C,A)&&(__webpack_require__.m[A]=C[A]);t&&t(__webpack_require__)}for(I&&I(n);e<Q.length;e++)B=Q[e],__webpack_require__.o(g,B)&&g[B]&&g[B][0](),g[B]=0},n=self.webpackChunkecash_wallet_web=self.webpackChunkecash_wallet_web||[];n.forEach(I.bind(null,0)),n.push=I.bind(null,n.push.bind(n))})(),__webpack_require__.nc=void 0;var __webpack_exports__=__webpack_require__(8393)})();